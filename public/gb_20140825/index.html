<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Gb_20140825 - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Gb_20140825" />
<meta property="og:description" content="Constants Rob Pike 25 August 2014 Introduction Go is a statically typed language that does not permit operations that mix numeric types. You can’t add a float64 to an int, or even an int32 to an int. Yet it is legal to write 1e6*time.Second or math.Exp(1) or even 1&lt;&lt;(&#39; &#39;&#43;2.0). In Go, constants, unlike variables, behave pretty much like regular numbers. This post explains why that" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/gb_20140825/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-24T09:11:38+08:00" />
<meta property="article:modified_time" content="2022-10-29T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Gb_20140825"/>
<meta name="twitter:description" content="Constants Rob Pike 25 August 2014 Introduction Go is a statically typed language that does not permit operations that mix numeric types. You can’t add a float64 to an int, or even an int32 to an int. Yet it is legal to write 1e6*time.Second or math.Exp(1) or even 1&lt;&lt;(&#39; &#39;&#43;2.0). In Go, constants, unlike variables, behave pretty much like regular numbers. This post explains why that"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/gb_20140825/" /><link rel="prev" href="https://jefofrank.xyz/gb_20140820/" /><link rel="next" href="https://jefofrank.xyz/gb_20140926/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Gb_20140825",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/gb_20140825\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "go official blogs","wordcount":  4503 ,
        "url": "https:\/\/jefofrank.xyz\/gb_20140825\/","datePublished": "2022-10-24T09:11:38+08:00","dateModified": "2022-10-29T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Gb_20140825</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/2022/"><i class="far fa-folder fa-fw"></i>2022</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-10-24 09:11:38">2022-10-24 09:11:38</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4503 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#background-c">Background: C</a></li>
    <li><a href="#terminology">Terminology</a></li>
    <li><a href="#string-constants">String constants</a></li>
    <li><a href="#default-type">Default type</a></li>
    <li><a href="#default-type-determined-by-syntax">Default type determined by syntax</a></li>
    <li><a href="#booleans">Booleans</a></li>
    <li><a href="#floats">Floats</a></li>
    <li><a href="#complex-numbers">Complex numbers</a></li>
    <li><a href="#integers">Integers</a></li>
    <li><a href="#an-exercise-the-largest-unsigned-int">An exercise: The largest unsigned int</a></li>
    <li><a href="#numbers">Numbers</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="constants">Constants</h1>
<p>Rob Pike<br>
25 August 2014</p>
<h2 id="introduction">Introduction</h2>
<p>Go is a statically typed language that does not permit operations that mix numeric types. You can’t add a <code>float64</code> to an <code>int</code>, or even an <code>int32</code> to an <code>int</code>. Yet it is legal to write <code>1e6*time.Second</code> or <code>math.Exp(1)</code> or even <code>1&lt;&lt;(' '+2.0)</code>. In Go, constants, unlike variables, behave pretty much like regular numbers. This post explains why that is and what it means.</p>
<h2 id="background-c">Background: C</h2>
<p>In the early days of thinking about Go, we talked about a number of problems caused by the way C and its descendants let you mix and match numeric types. Many mysterious bugs, crashes, and portability problems are caused by expressions that combine integers of different sizes and “signedness”. Although to a seasoned C programmer the result of a calculation like</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">unsigned int u = 1e9;
long signed int i = -1;
... i + u ...
</code></pre></td></tr></table>
</div>
</div><p>may be familiar, it isn’t <em>a priori</em> obvious. How big is the result? What is its value? Is it signed or unsigned?</p>
<p>Nasty bugs lurk here.</p>
<p>C has a set of rules called “the usual arithmetic conversions” and it is an indicator of their subtlety that they have changed over the years (introducing yet more bugs, retroactively).</p>
<p>When designing Go, we decided to avoid this minefield by mandating that there is <em>no</em> mixing of numeric types. If you want to add <code>i</code> and <code>u</code>, you must be explicit about what you want the result to be. Given</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">var u uint
var i int
</code></pre></td></tr></table>
</div>
</div><p>you can write either <code>uint(i)+u</code> or <code>i+int(u)</code>, with both the meaning and type of the addition clearly expressed, but unlike in C you cannot write <code>i+u</code>. You can’t even mix <code>int</code> and <code>int32</code>, even when <code>int</code> is a 32-bit type.</p>
<p>This strictness eliminates a common cause of bugs and other failures. It is a vital property of Go. But it has a cost: it sometimes requires programmers to decorate their code with clumsy numeric conversions to express their meaning clearly.</p>
<p>And what about constants? Given the declarations above, what would make it legal to write <code>i</code> <code>=</code> <code>0</code> or <code>u</code> <code>=</code> <code>0</code>? What is the <em>type</em> of <code>0</code>? It would be unreasonable to require constants to have type conversions in simple contexts such as <code>i</code> <code>=</code> <code>int(0)</code>.</p>
<p>We soon realized the answer lay in making numeric constants work differently from how they behave in other C-like languages. After much thinking and experimentation, we came up with a design that we believe feels right almost always, freeing the programmer from converting constants all the time yet being able to write things like <code>math.Sqrt(2)</code> without being chided by the compiler.</p>
<p>In short, constants in Go just work, most of the time anyway. Let’s see how that happens.</p>
<h2 id="terminology">Terminology</h2>
<p>First, a quick definition. In Go, <code>const</code> is a keyword introducing a name for a scalar value such as <code>2</code> or <code>3.14159</code> or <code>&quot;scrumptious&quot;</code>. Such values, named or otherwise, are called <em>constants</em> in Go. Constants can also be created by expressions built from constants, such as <code>2+3</code> or <code>2+3i</code> or <code>math.Pi/2</code> or <code>(&quot;go&quot;+&quot;pher&quot;)</code>.</p>
<p>Some languages don’t have constants, and others have a more general definition of constant or application of the word <code>const</code>. In C and C++, for instance, <code>const</code> is a type qualifier that can codify more intricate properties of more intricate values.</p>
<p>But in Go, a constant is just a simple, unchanging value, and from here on we’re talking only about Go.</p>
<h2 id="string-constants">String constants</h2>
<p>There are many kinds of numeric constants—integers, floats, runes, signed, unsigned, imaginary, complex—so let’s start with a simpler form of constant: strings. String constants are easy to understand and provide a smaller space in which to explore the type issues of constants in Go.</p>
<p>A string constant encloses some text between double quotes. (Go also has raw string literals, enclosed by backquotes <code>``</code>, but for the purpose of this discussion they have all the same properties.) Here is a string constant:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">&#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>(For much more detail about the representation and interpretation of strings, see <a href="https://blog.golang.org/strings" target="_blank" rel="noopener noreffer">this blog post</a>.)</p>
<p>What type does this string constant have? The obvious answer is <code>string</code>, but that is <em>wrong</em>.</p>
<p>This is an <em>untyped string constant</em>, which is to say it is a constant textual value that does not yet have a fixed type. Yes, it’s a string, but it’s not a Go value of type <code>string</code>. It remains an untyped string constant even when given a name:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">const hello = &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>After this declaration, <code>hello</code> is also an untyped string constant. An untyped constant is just a value, one not yet given a defined type that would force it to obey the strict rules that prevent combining differently typed values.</p>
<p>It is this notion of an <em>untyped</em> constant that makes it possible for us to use constants in Go with great freedom.</p>
<p>So what, then, is a <em>typed</em> string constant? It’s one that’s been given a type, like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">const typedHello string = &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>Notice that the declaration of <code>typedHello</code> has an explicit <code>string</code> type before the equals sign. This means that <code>typedHello</code> has Go type <code>string</code>, and cannot be assigned to a Go variable of a different type. That is to say, this code works:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>const typedHello string = &ldquo;Hello, 世界&rdquo;</p>
<p>func main() {</p>
<pre><code>var s string
s = typedHello
fmt.Println(s)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>but this does not:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>const typedHello string = &ldquo;Hello, 世界&rdquo;</p>
<p>func main() {</p>
<pre><code>type MyString string
var m MyString
m = typedHello // Type error
fmt.Println(m)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The variable <code>m</code> has type <code>MyString</code> and cannot be assigned a value of a different type. It can only be assigned values of type <code>MyString</code>, like this:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>const typedHello string = &ldquo;Hello, 世界&rdquo;</p>
<p>func main() {
type MyString string
var m MyString</p>
<pre><code>const myStringHello MyString = &quot;Hello, 世界&quot;
m = myStringHello // OK
fmt.Println(m)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>or by forcing the issue with a conversion, like this:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>const typedHello string = &ldquo;Hello, 世界&rdquo;</p>
<p>func main() {
type MyString string
var m MyString</p>
<pre><code>m = MyString(typedHello)
fmt.Println(m)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>Returning to our <em>untyped</em> string constant, it has the helpful property that, since it has no type, assigning it to a typed variable does not cause a type error. That is, we can write</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">m = &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">m = hello
</code></pre></td></tr></table>
</div>
</div><p>because, unlike the typed constants <code>typedHello</code> and <code>myStringHello</code>, the untyped constants <code>&quot;Hello, 世界&quot;</code> and <code>hello</code> <em>have no type</em>. Assigning them to a variable of any type compatible with strings works without error.</p>
<p>These untyped string constants are strings, of course, so they can only be used where a string is allowed, but they do not have <em>type</em> <code>string</code>.</p>
<h2 id="default-type">Default type</h2>
<p>As a Go programmer, you have certainly seen many declarations like</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">str := &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>and by now you might be asking, “if the constant is untyped, how does <code>str</code> get a type in this variable declaration?” The answer is that an untyped constant has a default type, an implicit type that it transfers to a value if a type is needed where none is provided. For untyped string constants, that default type is obviously <code>string</code>, so</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">str := &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">var str = &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>means exactly the same as</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">var str string = &#34;Hello, 世界&#34;
</code></pre></td></tr></table>
</div>
</div><p>One way to think about untyped constants is that they live in a kind of ideal space of values, a space less restrictive than Go’s full type system. But to do anything with them, we need to assign them to variables, and when that happens the <em>variable</em> (not the constant itself) needs a type, and the constant can tell the variable what type it should have. In this example, <code>str</code> becomes a value of type <code>string</code> because the untyped string constant gives the declaration its default type, <code>string</code>.</p>
<p>In such a declaration, a variable is declared with a type and initial value. Sometimes when we use a constant, however, the destination of the value is not so clear. For instance consider this statement:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>fmt.Printf(&quot;%s&quot;, &quot;Hello, 世界&quot;)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The signature of <code>fmt.Printf</code> is</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func Printf(format string, a ...interface{}) (n int, err error)
</code></pre></td></tr></table>
</div>
</div><p>which is to say its arguments (after the format string) are interface values. What happens when <code>fmt.Printf</code> is called with an untyped constant is that an interface value is created to pass as an argument, and the concrete type stored for that argument is the default type of the constant. This process is analogous to what we saw earlier when declaring an initialized value using an untyped string constant.</p>
<p>You can see the result in this example, which uses the format <code>%v</code> to print the value and <code>%T</code> to print the type of the value being passed to <code>fmt.Printf</code>:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>const hello = &ldquo;Hello, 世界&rdquo;</p>
<p>func main() {</p>
<pre><code>fmt.Printf(&quot;%T: %v\\n&quot;, &quot;Hello, 世界&quot;, &quot;Hello, 世界&quot;)
fmt.Printf(&quot;%T: %v\\n&quot;, hello, hello)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>If the constant has a type, that goes into the interface, as this example shows:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>type MyString string</p>
<p>const myStringHello MyString = &ldquo;Hello, 世界&rdquo;</p>
<p>func main() {</p>
<pre><code>fmt.Printf(&quot;%T: %v\\n&quot;, myStringHello, myStringHello)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>(For more information about how interface values work, see the first sections of <a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="noopener noreffer">this blog post</a>.)</p>
<p>In summary, a typed constant obeys all the rules of typed values in Go. On the other hand, an untyped constant does not carry a Go type in the same way and can be mixed and matched more freely. It does, however, have a default type that is exposed when, and only when, no other type information is available.</p>
<h2 id="default-type-determined-by-syntax">Default type determined by syntax</h2>
<p>The default type of an untyped constant is determined by its syntax. For string constants, the only possible implicit type is <code>string</code>. For <a href="https://go.dev/ref/spec#Numeric_types" target="_blank" rel="noopener noreffer">numeric constants</a>, the implicit type has more variety. Integer constants default to <code>int</code>, floating-point constants <code>float64</code>, rune constants to <code>rune</code> (an alias for <code>int32</code>), and imaginary constants to <code>complex128</code>. Here’s our canonical print statement used repeatedly to show the default types in action:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>fmt.Printf(&quot;%T %v\\n&quot;, 0, 0)
fmt.Printf(&quot;%T %v\\n&quot;, 0.0, 0.0)
fmt.Printf(&quot;%T %v\\n&quot;, 'x', 'x')
fmt.Printf(&quot;%T %v\\n&quot;, 0i, 0i)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>(Exercise: Explain the result for <code>'x'</code>.)</p>
<h2 id="booleans">Booleans</h2>
<p>Everything we said about untyped string constants can be said for untyped boolean constants. The values <code>true</code> and <code>false</code> are untyped boolean constants that can be assigned to any boolean variable, but once given a type, boolean variables cannot be mixed:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>type MyBool bool
const True = true
const TypedTrue bool = true
var mb MyBool
mb = true      // OK
mb = True      // OK
mb = TypedTrue // Bad
fmt.Println(mb)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>Run the example and see what happens, then comment out the “Bad” line and run it again. The pattern here follows exactly that of string constants.</p>
<h2 id="floats">Floats</h2>
<p>Floating-point constants are just like boolean constants in most respects. Our standard example works as expected in translation:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>type MyFloat64 float64
const Zero = 0.0
const TypedZero float64 = 0.0
var mf MyFloat64
mf = 0.0       // OK
mf = Zero      // OK
mf = TypedZero // Bad
fmt.Println(mf)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>One wrinkle is that there are <em>two</em> floating-point types in Go: <code>float32</code> and <code>float64</code>. The default type for a floating-point constant is <code>float64</code>, although an untyped floating-point constant can be assigned to a <code>float32</code> value just fine:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {
const Zero = 0.0
const TypedZero float64 = 0.0</p>
<pre><code>var f32 float32
f32 = 0.0
f32 = Zero      // OK: Zero is untyped
f32 = TypedZero // Bad: TypedZero is float64 not float32.
fmt.Println(f32)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>Floating-point values are a good place to introduce the concept of overflow, or the range of values.</p>
<p>Numeric constants live in an arbitrary-precision numeric space; they are just regular numbers. But when they are assigned to a variable the value must be able to fit in the destination. We can declare a constant with a very large value:</p>
<pre><code>const Huge = 1e1000
</code></pre>
<p>—that’s just a number, after all—but we can’t assign it or even print it. This statement won’t even compile:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {
const Huge = 1e1000
// START OMIT</p>
<pre><code>fmt.Println(Huge)
</code></pre>
<p>// STOP OMIT
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The error is, “constant 1.00000e+1000 overflows float64”, which is true. But <code>Huge</code> might be useful: we can use it in expressions with other constants and use the value of those expressions if the result can be represented in the range of a <code>float64</code>. The statement,</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {
const Huge = 1e1000
// START OMIT</p>
<pre><code>fmt.Println(Huge / 1e999)
</code></pre>
<p>// STOP OMIT
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>prints <code>10</code>, as one would expect.</p>
<p>In a related way, floating-point constants may have very high precision, so that arithmetic involving them is more accurate. The constants defined in the <a href="https://go.dev/pkg/math" target="_blank" rel="noopener noreffer">math</a> package are given with many more digits than are available in a <code>float64</code>. Here is the definition of <code>math.Pi</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Pi  = 3.14159265358979323846264338327950288419716939937510582097494459
</code></pre></td></tr></table>
</div>
</div><p>When that value is assigned to a variable, some of the precision will be lost; the assignment will create the <code>float64</code> (or <code>float32</code>) value closest to the high-precision value. This snippet</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import (
&ldquo;fmt&rdquo;
&ldquo;math&rdquo;
)</p>
<p>func main() {</p>
<pre><code>pi := math.Pi
fmt.Println(pi)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>prints <code>3.141592653589793</code>.</p>
<p>Having so many digits available means that calculations like <code>Pi/2</code> or other more intricate evaluations can carry more precision until the result is assigned, making calculations involving constants easier to write without losing precision. It also means that there is no occasion in which the floating-point corner cases like infinities, soft underflows, and <code>NaNs</code> arise in constant expressions. (Division by a constant zero is a compile-time error, and when everything is a number there’s no such thing as “not a number”.)</p>
<h2 id="complex-numbers">Complex numbers</h2>
<p>Complex constants behave a lot like floating-point constants. Here’s a version of our now-familiar litany translated into complex numbers:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>type MyComplex128 complex128
const I = (0.0 + 1.0i)
const TypedI complex128 = (0.0 + 1.0i)
var mc MyComplex128
mc = (0.0 + 1.0i) // OK
mc = I            // OK
mc = TypedI       // Bad
fmt.Println(mc)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The default type of a complex number is <code>complex128</code>, the larger-precision version composed of two <code>float64</code> values.</p>
<p>For clarity in our example, we wrote out the full expression <code>(0.0+1.0i)</code>, but this value can be shortened to <code>0.0+1.0i</code>, <code>1.0i</code> or even <code>1i</code>.</p>
<p>Let’s play a trick. We know that in Go, a numeric constant is just a number. What if that number is a complex number with no imaginary part, that is, a real? Here’s one:</p>
<pre><code>const Two = 2.0 + 0i
</code></pre>
<p>That’s an untyped complex constant. Even though it has no imaginary part, the <em>syntax</em> of the expression defines it to have default type <code>complex128</code>. Therefore, if we use it to declare a variable, the default type will be <code>complex128</code>. The snippet</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {
const Two = 2.0 + 0i</p>
<pre><code>s := Two
fmt.Printf(&quot;%T: %v\\n&quot;, s, s)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>prints <code>complex128:</code> <code>(2+0i)</code>. But numerically, <code>Two</code> can be stored in a scalar floating-point number, a <code>float64</code> or <code>float32</code>, with no loss of information. Thus we can assign <code>Two</code> to a <code>float64</code>, either in an initialization or an assignment, without problems:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {
const Two = 2.0 + 0i</p>
<pre><code>var f float64
var g float64 = Two
f = Two
fmt.Println(f, &quot;and&quot;, g)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The output is <code>2</code> <code>and</code> <code>2</code>. Even though <code>Two</code> is a complex constant, it can be assigned to scalar floating-point variables. This ability for a constant to “cross” types like this will prove useful.</p>
<h2 id="integers">Integers</h2>
<p>At last we come to integers. They have more moving parts—<a href="https://go.dev/ref/spec#Numeric_types" target="_blank" rel="noopener noreffer">many sizes, signed or unsigned, and more</a>—but they play by the same rules. For the last time, here is our familiar example, using just <code>int</code> this time:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>type MyInt int
const Three = 3
const TypedThree int = 3
var mi MyInt
mi = 3          // OK
mi = Three      // OK
mi = TypedThree // Bad
fmt.Println(mi)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The same example could be built for any of the integer types, which are:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64
uintptr
</code></pre></td></tr></table>
</div>
</div><p>(plus the aliases <code>byte</code> for <code>uint8</code> and <code>rune</code> for <code>int32</code>). That’s a lot, but the pattern in the way constants work should be familiar enough by now that you can see how things will play out.</p>
<p>As mentioned above, integers come in a couple of forms and each form has its own default type: <code>int</code> for simple constants like <code>123</code> or <code>0xFF</code> or <code>-14</code> and <code>rune</code> for quoted characters like ‘a’, ‘世’ or ‘\r’.</p>
<p>No constant form has as its default type an unsigned integer type. However, the flexibility of untyped constants means we can initialize unsigned integer variables using simple constants as long as we are clear about the type. It’s analogous to how we can initialize a <code>float64</code> using a complex number with zero imaginary part. Here are several different ways to initialize a <code>uint</code>; all are equivalent, but all must mention the type explicitly for the result to be unsigned.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">var u uint = 17
var u = uint(17)
u := uint(17)
</code></pre></td></tr></table>
</div>
</div><p>Similarly to the range issue mentioned in the section on floating-point values, not all integer values can fit in all integer types. There are two problems that might arise: the value might be too large, or it might be a negative value being assigned to an unsigned integer type. For instance, <code>int8</code> has range -128 through 127, so constants outside of that range can never be assigned to a variable of type <code>int8</code>:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {
// START OMIT</p>
<pre><code>var i8 int8 = 128 // Error: too large.
</code></pre>
<p>// STOP OMIT
_ = i8
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>Similarly, <code>uint8</code>, also known as <code>byte</code>, has range 0 through 255, so a large or negative constant cannot be assigned to a <code>uint8</code>:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {
// START OMIT</p>
<pre><code>var u8 uint8 = -1 // Error: negative value.
</code></pre>
<p>// STOP OMIT
_ = u8
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>This type-checking can catch mistakes like this one:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {</p>
<pre><code>type Char byte
var c Char = '世' // Error: '世' has value 0x4e16, too large.
</code></pre>
<p>_ = c
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>If the compiler complains about your use of a constant, it’s likely a real bug like this.</p>
<h2 id="an-exercise-the-largest-unsigned-int">An exercise: The largest unsigned int</h2>
<p>Here is an informative little exercise. How do we express a constant representing the largest value that fits in a <code>uint</code>? If we were talking about <code>uint32</code> rather than <code>uint</code>, we could write</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">const MaxUint32 = 1&lt;&lt;32 - 1
</code></pre></td></tr></table>
</div>
</div><p>but we want <code>uint</code>, not <code>uint32</code>. The <code>int</code> and <code>uint</code> types have equal unspecified numbers of bits, either 32 or 64. Since the number of bits available depends on the architecture, we can’t just write down a single value.</p>
<p>Fans of <a href="http://en.wikipedia.org/wiki/Two%27s_complement" target="_blank" rel="noopener noreffer">two’s-complement arithmetic</a>, which Go’s integers are defined to use, know that the representation of <code>-1</code> has all its bits set to 1, so the bit pattern of <code>-1</code> is internally the same as that of the largest unsigned integer. We therefore might think we could write</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {
// START OMIT</p>
<pre><code>const MaxUint uint = -1 // Error: negative value
</code></pre>
<p>// STOP OMIT
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>but that is illegal because -1 cannot be represented by an unsigned variable; <code>-1</code> is not in the range of unsigned values. A conversion won’t help either, for the same reason:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {
// START OMIT</p>
<pre><code>const MaxUint uint = uint(-1) // Error: negative value
</code></pre>
<p>// STOP OMIT
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>Even though at run-time a value of -1 can be converted to an unsigned integer, the rules for constant <a href="https://go.dev/ref/spec#Conversions" target="_blank" rel="noopener noreffer">conversions</a> forbid this kind of coercion at compile time. That is to say, this works:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {</p>
<pre><code>var u uint
var v = -1
u = uint(v)
</code></pre>
<p>_ = u
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>but only because <code>v</code> is a variable; if we made <code>v</code> a constant, even an untyped constant, we’d be back in forbidden territory:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {</p>
<pre><code>var u uint
const v = -1
u = uint(v) // Error: negative value
</code></pre>
<p>_ = u
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>We return to our previous approach, but instead of <code>-1</code> we try <code>^0</code>, the bitwise negation of an arbitrary number of zero bits. But that fails too, for a similar reason: In the space of numeric values, <code>^0</code> represents an infinite number of ones, so we lose information if we assign that to any fixed-size integer:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>func main() {
// START OMIT</p>
<pre><code>const MaxUint uint = ^0 // Error: overflow
</code></pre>
<p>// STOP OMIT
}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>How then do we represent the largest unsigned integer as a constant?</p>
<p>The key is to constrain the operation to the number of bits in a <code>uint</code> and avoiding values, such as negative numbers, that are not representable in a <code>uint</code>. The simplest <code>uint</code> value is the typed constant <code>uint(0)</code>. If <code>uints</code> have 32 or 64 bits, <code>uint(0)</code> has 32 or 64 zero bits accordingly. If we invert each of those bits, we’ll get the correct number of one bits, which is the largest <code>uint</code> value.</p>
<p>Therefore we don’t flip the bits of the untyped constant <code>0</code>, we flip the bits of the typed constant <code>uint(0)</code>. Here, then, is our constant:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>const MaxUint = ^uint(0)
fmt.Printf(&quot;%x\\n&quot;, MaxUint)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>Whatever the number of bits it takes to represent a <code>uint</code> in the current execution environment (on the <a href="https://blog.golang.org/playground" target="_blank" rel="noopener noreffer">playground</a>, it’s 32), this constant correctly represents the largest value a variable of type <code>uint</code> can hold.</p>
<p>If you understand the analysis that got us to this result, you understand all the important points about constants in Go.</p>
<h2 id="numbers">Numbers</h2>
<p>The concept of untyped constants in Go means that all the numeric constants, whether integer, floating-point, complex, or even character values, live in a kind of unified space. It’s when we bring them to the computational world of variables, assignments, and operations that the actual types matter. But as long as we stay in the world of numeric constants, we can mix and match values as we like. All these constants have numeric value 1:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">1
1.000
1e3-99.0*10-9
&#39;\x01&#39;
&#39;\u0001&#39;
&#39;b&#39; - &#39;a&#39;
1.0+3i-3.0i
</code></pre></td></tr></table>
</div>
</div><p>Therefore, although they have different implicit default types, written as untyped constants they can be assigned to a variable of any numeric type:</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>var f float32 = 1
var i int = 1.000
var u uint32 = 1e3 - 99.0\*10.0 - 9
var c float64 = '\\x01'
var p uintptr = '\\u0001'
var r complex64 = 'b' - 'a'
var b byte = 1.0 + 3i - 3.0i

fmt.Println(f, i, u, c, p, r, b)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>The output from this snippet is: <code>1 1 1 1 1 (1+0i) 1</code>.</p>
<p>You can even do nutty stuff like</p>
<p>// +build OMIT</p>
<p>package main</p>
<p>import &ldquo;fmt&rdquo;</p>
<p>func main() {</p>
<pre><code>var f = 'a' \* 1.5
fmt.Println(f)
</code></pre>
<p>}</p>
<p>Run</p>
<p>RunKillClose</p>
<p>which yields 145.5, which is pointless except to prove a point.</p>
<p>But the real point of these rules is flexibility. That flexibility means that, despite the fact that in Go it is illegal in the same expression to mix floating-point and integer variables, or even <code>int</code> and <code>int32</code> variables, it is fine to write</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">sqrt2 := math.Sqrt(2)
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">const millisecond = time.Second/1e3
</code></pre></td></tr></table>
</div>
</div><p>or</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">bigBufferWithHeader := make([]byte, 512+1e6)
</code></pre></td></tr></table>
</div>
</div><p>and have the results mean what you expect.</p>
<p>Because in Go, numeric constants work as you expect: like numbers.</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-10-29 00:00:00</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/gb_20140825/" data-title="Gb_20140825" data-hashtags="go official blogs"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/gb_20140825/" data-hashtag="go official blogs"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/gb_20140825/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/gb_20140825/" data-title="Gb_20140825"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/gb_20140825/" data-title="Gb_20140825"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/gb_20140825/" data-title="Gb_20140825"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/go-official-blogs/">go official blogs</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/gb_20140820/" class="prev" rel="prev" title="Gb_20140820"><i class="fas fa-angle-left fa-fw"></i>Gb_20140820</a>
            <a href="/gb_20140926/" class="next" rel="next" title="Gb_20140926">Gb_20140926<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
