<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>DistributedSystem_HongweiDu_09 | Jefo</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="Qizheng的个人博客"><link rel="prev" href="https://qizhengzou.github.io/2021/name-services/" /><link rel="next" href="https://qizhengzou.github.io/2021/consistency-and-replication/" /><link rel="canonical" href="https://qizhengzou.github.io/2021/group-communication/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DistributedSystem_HongweiDu_09"/>
<meta name="twitter:description" content="Group Communication群组通信 Modes of communication： One-to-One Unicast 1&lt;&ndash;&gt;1 Point-to-point Anycast 1-&gt;nearest 1 of several identical nodes Introduced with IPv6; used with BGP routing protocol One-to-many Multicast 1-&gt;many Group communication Broadcast 1-&gt;all Groups: Groups allow us to deal with a collection of"/>
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "DistributedSystem_HongweiDu_09",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/qizhengzou.github.io\/2021\/group-communication\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/qizhengzou.github.io\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","keywords": "distributed_system","wordcount":  2516 ,
        "url": "https:\/\/qizhengzou.github.io\/2021\/group-communication\/","datePublished": "2021-12-03T14:36:23\u002b08:00","dateModified": "2022-01-01T00:00:00\u002b00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
                "@type": "Organization",
                "name": "qizheng",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/qizhengzou.github.io\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"description": ""
    }
    </script><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/lib/fontawesome-free/all.min.css"></head>
    <body><script>
            window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="https://qizhengzou.github.io">Jefo</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="https://qizhengzou.github.io/posts" title="">Posts</a><a class="menu-item" href="https://qizhengzou.github.io/tags" title="">Tags</a><a class="menu-item" href="https://qizhengzou.github.io/categories" title="">Categories</a><a class="menu-item" href="https://qizhengzou.github.io/about" title="">About</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    
        <div class="top-scroll-bar"></div>
    
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="https://qizhengzou.github.io">Jefo</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="https://qizhengzou.github.io/posts" title="">Posts</a><a class="menu-item" href="https://qizhengzou.github.io/tags" title="">Tags</a><a class="menu-item" href="https://qizhengzou.github.io/categories" title="">Categories</a><a class="menu-item" href="https://qizhengzou.github.io/about" title="">About</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a>
        </div>
    </div>
</nav><main class="main">
                <div class="container"><article class="page"><h1 class="post-title animated flipInX">DistributedSystem_HongweiDu_09</h1><div class="post-meta"><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2021-12-03>2021-12-03</time>&nbsp;
            <i class="fas fa-pencil-alt fa-fw"></i>about 2516 words&nbsp;<span class="post-category"><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href="https://qizhengzou.github.io/categories/school-courses/">School courses</a>&nbsp;</span></div><div class="post-toc" id="post-toc">
                <h2 class="post-toc-title">Contents</h2>
                <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#implementing-group-communication-mechanisms组播">Implementing Group Communication Mechanisms组播</a></li>
    <li><a href="#reliability-of-multicasts-组播可靠性">Reliability of multicasts 组播可靠性</a></li>
    <li><a href="#message-ordering-消息顺序">Message ordering 消息顺序</a></li>
    <li><a href="#ip-multicast-routing">IP multicast routing</a></li>
  </ul>
</nav></div>
            </div>
            <div class="post-toc-mobile" id="post-toc-mobile">
                <details>
                    <summary>
                        <div class="post-toc-title">
                            <span>Contents</span>
                            <span><i class="details icon fas fa-angle-down"></i></span>
                        </div>
                    </summary>
                    <div class="post-toc-content"><nav id="TableOfContentsMobile">
  <ul>
    <li><a href="#implementing-group-communication-mechanisms组播">Implementing Group Communication Mechanisms组播</a></li>
    <li><a href="#reliability-of-multicasts-组播可靠性">Reliability of multicasts 组播可靠性</a></li>
    <li><a href="#message-ordering-消息顺序">Message ordering 消息顺序</a></li>
    <li><a href="#ip-multicast-routing">IP multicast routing</a></li>
  </ul>
</nav></div>
                </details>
            </div><div class="post-content"><h1 id="group-communication群组通信">Group Communication群组通信</h1>
<p>Modes of communication：</p>
<ul>
<li>One-to-One
<ul>
<li>Unicast
<ul>
<li>1&lt;&ndash;&gt;1</li>
<li>Point-to-point</li>
</ul>
</li>
<li>Anycast
<ul>
<li>1-&gt;nearest 1 of several identical nodes</li>
<li>Introduced with IPv6; used with BGP routing protocol</li>
</ul>
</li>
</ul>
</li>
<li>One-to-many
<ul>
<li>Multicast
<ul>
<li>1-&gt;many</li>
<li><strong>Group communication</strong></li>
</ul>
</li>
<li>Broadcast
<ul>
<li>1-&gt;all</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Groups:</p>
<ul>
<li><strong>Groups allow us to deal with a collection of processes as one abstraction</strong></li>
<li>Send message to one entity
<ul>
<li>Deliver to entire group</li>
</ul>
</li>
<li>Groups are dynamic
<ul>
<li>Created and destroyed</li>
<li>Processes can join or leave
<ul>
<li>May belong to 0 or more groups</li>
</ul>
</li>
</ul>
</li>
<li>Primitives
<ul>
<li>join_group, leave_group,  send_to_group, query_membership(sometimes)</li>
</ul>
</li>
</ul>
<p>Design Issues:</p>
<ul>
<li>Closed vs. Open
<ul>
<li>Closed: only group members can sent messages</li>
</ul>
</li>
<li>Peer vs. Hierarchical
<ul>
<li>Peer: each member communicates with the entire group</li>
<li>Hierarchical: go through coordinator(s)
<ul>
<li><strong>Root coordinator</strong>: forwards message to appropriate subgroup coordinators</li>
</ul>
</li>
</ul>
</li>
<li>Managing membership &amp; group creation/deletion
<ul>
<li>Distributed vs. centralized</li>
</ul>
</li>
<li>Leaving &amp; joining must be synchronous</li>
<li>Fault tolerance (容错性）
<ul>
<li>Reliable message delivery? What about missing members?</li>
</ul>
</li>
</ul>
<p>Failure considerations:</p>
<ul>
<li>The same things bite us with unicast communication</li>
<li>Crash failure
<ul>
<li>Process stops communicating</li>
</ul>
</li>
<li>Omission failure (typically due to network)
<ul>
<li>Send omission: A process fails to send messages</li>
<li>Receive omission: A process fails to receive messages</li>
</ul>
</li>
<li>Byzantine failure
<ul>
<li>Some messages are faulty</li>
</ul>
</li>
<li>Partition failure
<ul>
<li>The network may get segmented, dividing the group into two or more unreachable sub-groups</li>
</ul>
</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101162357.png" alt="" class="lazyload"></figure></li>
</ul>
<a class="post-dummy-target" id="implementing-group-communication-mechanisms组播"></a><h2>Implementing Group Communication Mechanisms组播</h2>
<p>Hardware multicast:</p>
<ul>
<li>If we have hardware support for multicast
<ul>
<li>Group members listen on network address</li>
</ul>
</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101162524.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Broadcast:</p>
<ul>
<li>Diffusion group: send to all clients &amp; then filter
<ul>
<li>Software filters incoming multicast address</li>
<li>May use auxiliary address (not in the network address header) to identify group</li>
</ul>
</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101162629.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Hardware multicast &amp; broadcast:</p>
<ul>
<li>Ethernet supports both multicast &amp; broadcast</li>
<li>Limited to local area networks</li>
</ul>
<p>Software implementation: multiple unicasts:</p>
<ul>
<li>Sender knows group members</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101162709.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Software implementation: hierarchical：</p>
<ul>
<li>Multiple unicasts via group coordinator
<ul>
<li>Coordinator knows group members</li>
<li>Coordinator iterates through group members</li>
<li>May support a hierarchy of coordinators</li>
</ul>
</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101162744.png" alt="" class="lazyload"></figure></li>
</ul>
<a class="post-dummy-target" id="reliability-of-multicasts-组播可靠性"></a><h2>Reliability of multicasts 组播可靠性</h2>
<p>Atomic multicast：</p>
<ul>
<li>Atomicity （原子性）
<ul>
<li>Message sent to a group arrives at all group members</li>
<li>If it fails to arrive at any member, no member will process it</li>
</ul>
</li>
<li>Problems
<ul>
<li>Unreliable network</li>
<li>Each message should be acknowledged</li>
<li>Acknowledgements can be lost</li>
<li>Message sender might die</li>
</ul>
</li>
</ul>
<p>Achieving atomicity：</p>
<ul>
<li>General idea
<ul>
<li>Ensure that every recipient acknowledges receipt of the message</li>
<li>Only then allow the application to process the message</li>
<li>If we give up on a recipient
<ul>
<li>then no recipient can process that received message</li>
</ul>
</li>
</ul>
</li>
<li>Easier said than done!
<ul>
<li>What if a recipient dies after acknowledging the message?
<ul>
<li>Is it obligated to restart?</li>
<li>If it restarts, will it know to process the message?</li>
</ul>
</li>
<li>What if the sender (or coordinator) dies partway through the protocol?</li>
</ul>
</li>
</ul>
<p><strong>Achieving atomicity–example 1</strong>：</p>
<ul>
<li>Retry through network failures &amp; system downtime
<ul>
<li>Sender &amp; receivers maintain a persistent log</li>
<li>Each message has a unique ID so we can discard duplicates</li>
<li>Sender</li>
</ul>
</li>
<li>Send message to all group members
<ul>
<li>Write message to log</li>
<li>Wait for acknowledgement from each group member</li>
<li>Write acknowledgement to log</li>
<li>If timeout on waiting for an acknowledgement, retransmit to group member</li>
</ul>
</li>
<li>Receiver
<ul>
<li>Log received non-duplicate message to persistent log</li>
<li>Send acknowledgement</li>
</ul>
</li>
<li><strong>NEVER GIVE UP!</strong>
<ul>
<li>Assume that dead senders or receivers will be rebooted and will restart where they left off</li>
</ul>
</li>
</ul>
<p><strong>Achieving atomicity–example 2</strong>：</p>
<ul>
<li>Redefine the group
<ul>
<li>If some members failed to receive the message:
<ul>
<li>Remove the failed members from the group</li>
<li>Then allow existing members to process the message</li>
</ul>
</li>
<li>But still need to account for the death of the sender
<ul>
<li>Surviving group members may need to take over to ensure all current group members receive the message</li>
</ul>
</li>
<li>This is the approach used in virtual synchrony</li>
</ul>
</li>
</ul>
<p>Reliable multicast：</p>
<ul>
<li>All non-faulty group members will receive the message
<ul>
<li>Assume sender &amp; recipients will remain alive</li>
<li>Network may have glitches
<ul>
<li>Try to retransmit undelivered messages &hellip; but eventually give up</li>
</ul>
</li>
<li>It’s OK if some group members don’t get the message</li>
</ul>
</li>
<li>Acknowledgements
<ul>
<li>Send message to each group member</li>
<li>Wait for acknowledgement from each group member</li>
<li>Retransmit to non-responding members</li>
<li>Subject to feedback implosion</li>
</ul>
</li>
</ul>
<p>Optimizing Acknowledgements：</p>
<ul>
<li>Easiest thing is to wait for an ACK before sending the next message
<ul>
<li>But that incurs a round-trip delay</li>
</ul>
</li>
<li>Optimizations
<ul>
<li>Pipelining
<ul>
<li>Send multiple messages –receive ACKs asynchronously</li>
<li>Set timeout –retransmit message for missing ACKs</li>
</ul>
</li>
<li>Cumulative ACKs
<ul>
<li>Wait a little while before sending an ACK</li>
<li>If you receive others, then send one ACK for everything</li>
</ul>
</li>
<li>Piggybacked ACKs
<ul>
<li>Send an ACK along with a return message</li>
</ul>
</li>
<li>Negative ACKs
<ul>
<li>Use a sequence # on each message</li>
<li>Receiver requests retransmission of a missed message</li>
<li>More efficient but requires sender to buffer messages indefinitely</li>
<li>TCP does the first three of these&hellip;but now we have to do this for each recipient</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Unreliable multicast (best effort)：</p>
<ul>
<li>Basic multicast</li>
<li>Hope it gets there</li>
</ul>
<a class="post-dummy-target" id="message-ordering-消息顺序"></a><h2>Message ordering 消息顺序</h2>
<p>Good Ordering：</p>
<ul>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101163433.png" alt="" class="lazyload"></figure>
Bad Ordering：</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101163453.png" alt="" class="lazyload"></figure>
Good Ordering：</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101163514.png" alt="" class="lazyload"></figure>
Bad Ordering：</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101163534.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Sending vs. Receiving vs. Delivering：</p>
<ul>
<li>Multicast receiver algorithm decides when to deliver a message to the process.</li>
<li>A received message may be:
<ul>
<li>Delivered immediately
<ul>
<li>(put on a delivery queue that the process reads)</li>
</ul>
</li>
<li>Placed on a hold-back queue
<ul>
<li>(because we need to wait for an earlier message)</li>
</ul>
</li>
<li>Rejected/discarded
<ul>
<li>(duplicate or earlier message that we no longer want)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Sending, delivering, holding back：</p>
<ul>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101163638.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Global time ordering：</p>
<ul>
<li>All messages are delivered in exact order sent</li>
<li>Assumes two events never happen at the exact same time!</li>
<li>Difficult (impossible) to achieve</li>
<li>Not viable</li>
</ul>
<p>Total ordering （全序）：</p>
<ul>
<li>Consistent ordering at all receivers</li>
<li>All messages are delivered at all group members in the same order
<ul>
<li>They are sorted in the same order in the delivery queue</li>
</ul>
</li>
</ul>
<ol>
<li>If a process sends m before m' then any other process that delivers m' will have delivered m.</li>
<li>If a process delivers m' before m&quot; then every other process will have delivered m' before m&quot;.</li>
</ol>
<ul>
<li>Implementation:
<ul>
<li>Attach unique totally sequenced message ID</li>
<li>Receiver delivers a message to the application only if it has received all messages with a smaller ID</li>
</ul>
</li>
</ul>
<p>Causal ordering：</p>
<ul>
<li>Also known as partial ordering 偏序
<ul>
<li>Messages sequenced by Lamport or Vector timestamps</li>
</ul>
</li>
<li>If multicast(G, m)→multicast(G, m) then every process that delivers m' will have delivered m</li>
<li>If message m’ is causally dependent on message m, all processes must deliver m before m’.</li>
</ul>
<p>Causal ordering example：</p>
<ul>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164012.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Causal ordering –implementation：</p>
<ul>
<li>Implementation: Pa receives a message from Pb
<ul>
<li>Each process keeps a precedence vector(similar to vector timestamp)</li>
<li>Vector is updated on multicast send and receive events
<ul>
<li>Each entry = # of latest message from the corresponding group member that causally precedes the event</li>
</ul>
</li>
</ul>
</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164121.png" alt="" class="lazyload"></figure></li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164257.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Causal Ordering: Example：</p>
<ul>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164343.png" alt="" class="lazyload"></figure></li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164407.png" alt="" class="lazyload"></figure></li>
<li>P2 receives message m0 from P0 with V=(1,0,0)
<ul>
<li>(1) Is this in FIFO order from P0?
<ul>
<li>Compare current V on P2: V2=(0,0,0) with received V from P2, V2=(1,0,0)</li>
<li>Yes: V2[0] = 0, received V1[0] = 1 ⇒ sequential</li>
</ul>
</li>
<li>(2) Is V0[i] ≤ V2[i] for all other i?
<ul>
<li>Yes. (0 ≤ 0), (0 ≤ 0).</li>
</ul>
</li>
<li>Deliver m0. Update precedence vector from (0, 0, 0) to (1, 0, 0)</li>
<li>Now check hold-back queue. Can we deliver m1?</li>
</ul>
</li>
<li>(1) Is the held-back message m1 in FIFO order from P0?
<ul>
<li>Compare current V on P2: V2=(1,0,0) with held-back V from P0, V1=(1,1,0)</li>
<li>Yes: (current V2[1] = 0) vs. (received V1[1] = 1) ⇒ sequential</li>
</ul>
</li>
<li>(2) Is V0[i] ≤ V2[i] for all other i?
<ul>
<li>Now yes. (V0[0] = 1) ≤ (V2[0] = 1) and element 2: (V0[2] = 0) ≤ (V2[2] = 0)</li>
</ul>
</li>
<li>Deliver m1.
<ul>
<li>Causal ordering can be implemented more efficiently than total ordering:
<ul>
<li>No need for a global sequencer.</li>
<li>Expect reliable delivery but we may not need to send immediate acknowledgements.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Sync ordering：</p>
<ul>
<li>Messages can arrive in any order</li>
<li>Special message type
<ul>
<li>Synchronization primitive</li>
<li>Ensure all pending messages are delivered before any additional (post-sync) messages are accepted</li>
</ul>
</li>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164647.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Single Source FIFO (SSF) ordering：</p>
<ul>
<li>Messages from the same source are delivered in the order they were sent.</li>
<li>Message m must be delivered before message m’ iff m was sent before m’ from the same host</li>
<li><strong>If a process issues a multicast of m followed by m', then every process that delivers m' will have already delivered m.</strong></li>
</ul>
<p>Unordered multicast：</p>
<ul>
<li>Messages can be delivered in different order to different members</li>
<li>Order per-source does not matter.</li>
</ul>
<p>Multicasting considerations：</p>
<ul>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101164842.png" alt="" class="lazyload"></figure></li>
</ul>
<a class="post-dummy-target" id="ip-multicast-routing"></a><h2>IP multicast routing</h2>
<p>IP multicast routing：</p>
<ul>
<li>Deliver messages to a subset of nodes
<ul>
<li>Send to a multicast address</li>
</ul>
</li>
<li>How do we identify the recipients?
<ul>
<li>Enumerate them in the header?
<ul>
<li>What if we don’t know?</li>
<li>What if we have thousands of recipients?</li>
</ul>
</li>
</ul>
</li>
<li>Use a special address to identify a group of receivers
<ul>
<li>A copy of the packet is delivered to all receivers associated with that group</li>
<li>IPv4: Class D multicast IP address
<ul>
<li>32-bit address that starts with 1110</li>
<li>(224.0.0.0/4 = 224.0.0.0 – 239.255.255.255 )</li>
</ul>
</li>
<li>IPv6: 128-bit address with high-order bits 8 bits all 1</li>
<li><strong>Host group</strong> = set of machines listening to a particular multicast address
<ul>
<li>A copy of the message is delivered to all receivers associated with that group</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>IP multicasting：</p>
<ul>
<li>Can span multiple physical networks</li>
<li>Dynamic membership
<ul>
<li>Machine can join or leave at any time</li>
</ul>
</li>
<li>No restriction on number of hosts in a group</li>
<li>Machine does not need to be a member to send messages</li>
<li>Efficient: Packets are replicated only when necessary</li>
<li>Like IP, no delivery guarantees</li>
</ul>
<p>IP multicast addresses：</p>
<ul>
<li>Addresses chosen arbitrarily for an application</li>
<li>Well-known addresses assigned by IANA</li>
<li><strong>Internet Assigned Numbers Authority</strong></li>
<li>IPv4 addresses: <a href="http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml" target="_blank">http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml</a></li>
<li>IPv6 addresses: <a href="https://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml" target="_blank">https://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml</a>
<ul>
<li>Similar to ports – service-based allocation
<ul>
<li>For ports, we have:
<ul>
<li>FTP: port 21, SMTP: port 25, HTTP: port 80</li>
</ul>
</li>
<li>For multicast, we have:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">224.0.0.1:                all systems on this subnet
224.0.0.2:                all multicast routers on subnet 
224.0.23.173:          Philips Health
224.0.23.52:            Amex Market Data 
224.0.12.0-63:         Microsoft &amp; MSNBC 
FF02:0:0:0:0:0:0:9:    RIP routers
</code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
<p>IGMP 因特网组管理协议:</p>
<ul>
<li>Internet Group Management Protocol (IGMP)
<ul>
<li>Operates between a host and its attached router</li>
<li>Goal: allow a router to determine to which of its networks to forward IP multicast traffic</li>
<li>IP protocol (IP protocol number 2)</li>
</ul>
</li>
<li>Three message types
<ul>
<li>Membership_query
<ul>
<li>Sent by a router to all hosts on an interface to determine the set of all multicast groups that have been joined by the hosts on that interface</li>
</ul>
</li>
<li>Membership_report
<ul>
<li>Host response to a query or an initial join or a group</li>
</ul>
</li>
<li>Leave_group
<ul>
<li>Host indicates that it is no longer interested</li>
<li>Optional: router infers this if the host does not respond to a query</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Multicast Forwarding:</p>
<ul>
<li>IGMP allows a host to subscribe to receive a multicast stream</li>
<li>What about the source?
<ul>
<li>There is no protocol for the source!</li>
<li>It just sends one message to a class D address</li>
<li>Routers have to do the work</li>
</ul>
</li>
</ul>
<p>IGMP &amp; Wide-Area Multicast Routing:</p>
<ul>
<li><figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20220101165437.png" alt="" class="lazyload"></figure></li>
</ul>
<p>Multicast Forwarding:</p>
<ul>
<li>IGMP: Internet Group Management Protocol
<ul>
<li>Designed for routers to talk with hosts on directly connected networks</li>
</ul>
</li>
<li>PIM: Protocol Independent Multicast 独立组播协议
<ul>
<li>Multicast Routing Protocol for delivering packets across routers</li>
<li>Topology discovery is handled by other protocols</li>
<li>Two forms:
<ol>
<li>Dense Mode (PIM-DM) 密集模式</li>
<li>Sparse Mode (PIM-SM) 稀疏模式</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>Flooding: Dense Mode Multicast (PIM-DM):</p>
<ul>
<li>Relay multicast packet to all connected routers
<ul>
<li>Use a spanning tree and reverse path forwarding (RPF) to avoid loops</li>
<li>Feedback &amp; cut off if there are no interested receivers on a link
<ul>
<li>A router sends a prune message.</li>
<li>Periodically, routers send messages to refresh the prune state</li>
</ul>
</li>
<li><strong>Flooding is initiated by the sender’s router</strong></li>
</ul>
</li>
<li><strong>Reverse path forwarding (RPF)</strong>: avoid routing loops（逆向路径转发）
<ul>
<li>Packet is duplicated &amp; forwarded ONLY IF it was received via the link that is the shortest path to the sender</li>
<li>Shortest path is found by checking the router’s forwarding table to the source address</li>
</ul>
</li>
</ul>
<p>Flooding: Dense Mode Multicast:</p>
<ul>
<li>Advantage:
<ul>
<li>Simple</li>
<li>Good if the packet is desired in most locations</li>
</ul>
</li>
<li>Disadvantage:
<ul>
<li>wasteful on the network, wasteful extra state &amp; packet duplication on routers</li>
</ul>
</li>
</ul>
<p>Sparse Mode Multicast (PIM-SM):</p>
<ul>
<li>Initiated by the routers at each receiver</li>
<li>Each router needs to ask for a multicast feed with a PIM Join message
<ul>
<li>Initiated by a router at the destination that gets an IGMP join</li>
<li>Rendezvous Point: meeting place between receivers &amp; source
<ul>
<li>Join messages propagate to a defined rendezvous point (RP)</li>
<li>Sender transmits only to the rendezvous point</li>
<li>RP announcement messages inform edge routes of rendezvous points</li>
</ul>
</li>
<li>A Prune message stops a feed</li>
</ul>
</li>
<li>Advantage
<ul>
<li>Packets go only where needed</li>
<li>Creates extra state in routers only where needed</li>
</ul>
</li>
</ul>
<p>IP Multicast in use:</p>
<ul>
<li>Initially exciting:
<ul>
<li>Internet radio, NASA shuttle missions, collaborative gaming</li>
</ul>
</li>
<li>But:
<ul>
<li>Few ISPs enabled it</li>
<li>For the user, required tapping into existing streams(not good for on-demand content)</li>
<li>Industry embraced unicast instead</li>
</ul>
</li>
</ul>
<p>IP Multicast in use: IPTV:</p>
<ul>
<li>IPTV has emerged as the biggest user of IP multicast
<ul>
<li>Cable TV networks have migrated (or are migrating) to IP delivery</li>
</ul>
</li>
<li>Cable TV systems: aggregate bandwidth ~ 4.5 Gbps
<ul>
<li>Video streams: MPEG-2 or MPEG-4 (H.264)</li>
<li>MPEG-2 HD: ~30 Mbps ⇒ 150 channels = ~4.5 Gbps</li>
<li>MPEG-4 HD: ~6-9 Mbps; DVD quality: ~2 Mbps</li>
</ul>
</li>
<li>Multicast
<ul>
<li>Reduces the number of servers needed</li>
<li>Reduces the number of duplicate network streams</li>
</ul>
</li>
</ul>
<p>IP Multicast in use: IPTV:</p>
<ul>
<li>Multicast allows one stream of data to be sent to multiple subscribers using a single address</li>
<li>IGMP from the client
<ul>
<li>Subscribe to a TV channel</li>
<li>Change channels</li>
</ul>
</li>
<li>Use unicast for video on demand</li>
</ul>
</div><div class="post-copyright" id="post-footer">          
            <p class="copyright-item">
                <span>Author:&nbsp;</span>
                <span>qizheng</span>
            </p>

            <p class="copyright-item">
                <span>Updated on:&nbsp;</span>
                <span>2022-01-01</span>
            </p>

            <p class="copyright-item"></p>

            <p class="copyright-item"></p>

            <p class="copyright-item"></p>
        </div>
        <br>

        <div class="post-info-more">
            <section><span class="tag">
                            <a href="https://qizhengzou.github.io/tags/distributed_system/"><i class="fas fa-tag fa-fw"></i>&nbsp;distributed_system</a>&nbsp;
                        </span></section>
            <section>
                <span><a href="javascript:window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="https://qizhengzou.github.io">Home</a></span>
            </section>
        </div>
        
        <div class="post-nav"><a href="https://qizhengzou.github.io/2021/name-services/" class="prev" rel="prev" title="DistributedSystem_HongweiDu_08"><i class="fas fa-angle-left fa-fw"></i>DistributedSystem_HongweiDu_08</a>
                <a href="https://qizhengzou.github.io/2021/consistency-and-replication/" class="next" rel="next" title="DistributedSystem_HongweiDu_10">DistributedSystem_HongweiDu_10<i class="fas fa-angle-right fa-fw"></i></a></div><div class="post-comment"></div>
    </article></div>
            </main><footer class="footer">
    <div class="copyright">
        <div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://qizhengzou.github.io/about/" target="_blank">qizheng</a> | </span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> & <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt</a></div>
    </div>
</footer></div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/js/lib/jquery/jquery.slim.min.js"></script><script src="/js/lib/lazysizes/lazysizes.min.js"></script><script src="/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><link rel="stylesheet" href="/css/lib/katex/katex.min.css"><script src="/js/lib/katex/katex.min.js"></script><script defer src="/js/lib/katex/auto-render.min.js"></script><link rel="stylesheet" href="/css/lib/katex/copy-tex.min.css"><script defer src="/js/lib/katex/copy-tex.min.js"></script><script defer src="/js/lib/katex/mhchem.min.js"></script><script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "\\(", right: "\\)", display: false },
                    { left: "\\[", right: "\\]", display: true },{ left: "$", right: "$", display: false },]
            });
        });
    </script><script src="/js/blog.min.js"></script></body>
</html>