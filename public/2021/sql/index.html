<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Mysql_base_03 | Jefo</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="robots" content="noodp" />
<meta name="Description" content="Qizheng的个人博客"><link rel="prev" href="https://qizhengzou.github.io/2021/hdfs/" /><link rel="next" href="https://qizhengzou.github.io/2021/database-management-and-maintenance/" /><link rel="canonical" href="https://qizhengzou.github.io/2021/sql/" />
<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Mysql_base_03"/>
<meta name="twitter:description" content="sql语言 SQL语言概述 SQL语言提出和发展 1974年，由Boyce和Chamber提出 1975-1979年，在System R上首次实现，由"/>
<script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Mysql_base_03",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/qizhengzou.github.io\/2021\/sql\/"
        },"image": {
                "@type": "ImageObject",
                "url": "https:\/\/qizhengzou.github.io\/cover.png",
                "width":  800 ,
                "height":  600 
            },"genre": "posts","keywords": "mysql","wordcount":  4807 ,
        "url": "https:\/\/qizhengzou.github.io\/2021\/sql\/","datePublished": "2021-11-09T11:17:06\u002b08:00","dateModified": "2021-11-10T00:00:00\u002b00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
                "@type": "Organization",
                "name": "qizheng",
                "logo": {
                "@type": "ImageObject",
                "url": "https:\/\/qizhengzou.github.io\/logo.png",
                "width":  127 ,
                "height":  40 
                }
            },"description": ""
    }
    </script><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/lib/fontawesome-free/all.min.css"></head>
    <body><script>
            window.isDark = (window.localStorage && window.localStorage.getItem('theme')) === 'dark';
            window.isDark && document.body.classList.add('dark-theme');
        </script><div class="wrapper"><nav class="navbar">
    
        <div class="top-scroll-bar"></div>
    
    <div class="navbar-container">
        <div class="navbar-header animated bounceIn">
            <a href="https://qizhengzou.github.io">Jefo</a>
        </div>
        <div class="navbar-menu"><a class="menu-item" href="https://qizhengzou.github.io/posts" title="">Posts</a><a class="menu-item" href="https://qizhengzou.github.io/tags" title="">Tags</a><a class="menu-item" href="https://qizhengzou.github.io/categories" title="">Categories</a><a class="menu-item" href="https://qizhengzou.github.io/about" title="">About</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a>
        </div>
    </div>
</nav><nav class="navbar-mobile">
    
        <div class="top-scroll-bar"></div>
    
    <div class="navbar-container">
        <div class="navbar-header">
            <div class="navbar-header-title animated bounceIn">
                <a href="https://qizhengzou.github.io">Jefo</a>
            </div>
            <div class="menu-toggle" id="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="navbar-menu" id="mobile-menu"><a class="menu-item" href="https://qizhengzou.github.io/posts" title="">Posts</a><a class="menu-item" href="https://qizhengzou.github.io/tags" title="">Tags</a><a class="menu-item" href="https://qizhengzou.github.io/categories" title="">Categories</a><a class="menu-item" href="https://qizhengzou.github.io/about" title="">About</a><a href="javascript:void(0);" class="theme-switch"><i class="fas fa-adjust fa-rotate-180 fa-fw" title="Switch Theme"></i></a>
        </div>
    </div>
</nav><main class="main">
                <div class="container"><article class="page"><h1 class="post-title animated flipInX">Mysql_base_03</h1><div class="post-meta"><i class="far fa-calendar-alt fa-fw"></i>published on&nbsp;<time datetime=2021-11-09>2021-11-09</time>&nbsp;
            <i class="fas fa-pencil-alt fa-fw"></i>about 4807 words&nbsp;<span class="post-category"><i class="far fa-folder fa-fw"></i>included in&nbsp;<a href="https://qizhengzou.github.io/categories/school-courses/">School courses</a>&nbsp;</span></div><div class="post-toc" id="post-toc">
                <h2 class="post-toc-title">Contents</h2>
                <div class="post-toc-content"><nav id="TableOfContents">
  <ul>
    <li><a href="#sql语言概述">SQL语言概述</a>
      <ul>
        <li><a href="#sql语言提出和发展">SQL语言提出和发展</a></li>
        <li><a href="#sql语言概览">SQL语言概览</a></li>
      </ul>
    </li>
    <li><a href="#简单的sql-ddldml-创建数据库">简单的SQL-DDL/DML: 创建数据库</a></li>
    <li><a href="#sql-dml之查询select">SQL-DML之查询Select</a>
      <ul>
        <li><a href="#基本的检索操作">基本的检索操作</a></li>
        <li><a href="#多表联合检索">多表联合检索</a></li>
        <li><a href="#子查询">子查询</a></li>
        <li><a href="#结果计算与聚集函数">结果计算与聚集函数</a></li>
        <li><a href="#分组查询与分组过滤">分组查询与分组过滤</a></li>
        <li><a href="#并交差的处理">并、交、差的处理</a></li>
        <li><a href="#空值处理">空值处理</a></li>
        <li><a href="#内连接外连接">内连接、外连接</a></li>
        <li><a href="#sql的完整语法">SQL的完整语法</a></li>
      </ul>
    </li>
    <li><a href="#sql-dml之更新insertupdatedelete">SQL-DML之更新Insert/Update/Delete</a></li>
    <li><a href="#sql-视图及ddl的进一步介绍">SQL-视图及DDL的进一步介绍</a>
      <ul>
        <li><a href="#视图的定义与使用">视图的定义与使用</a></li>
        <li><a href="#视图更新问题">视图更新问题</a></li>
        <li><a href="#sql-ddl的进一步介绍-撤消语句的使用">SQL-DDL的进一步介绍: 撤消语句的使用</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div>
            <div class="post-toc-mobile" id="post-toc-mobile">
                <details>
                    <summary>
                        <div class="post-toc-title">
                            <span>Contents</span>
                            <span><i class="details icon fas fa-angle-down"></i></span>
                        </div>
                    </summary>
                    <div class="post-toc-content"><nav id="TableOfContentsMobile">
  <ul>
    <li><a href="#sql语言概述">SQL语言概述</a>
      <ul>
        <li><a href="#sql语言提出和发展">SQL语言提出和发展</a></li>
        <li><a href="#sql语言概览">SQL语言概览</a></li>
      </ul>
    </li>
    <li><a href="#简单的sql-ddldml-创建数据库">简单的SQL-DDL/DML: 创建数据库</a></li>
    <li><a href="#sql-dml之查询select">SQL-DML之查询Select</a>
      <ul>
        <li><a href="#基本的检索操作">基本的检索操作</a></li>
        <li><a href="#多表联合检索">多表联合检索</a></li>
        <li><a href="#子查询">子查询</a></li>
        <li><a href="#结果计算与聚集函数">结果计算与聚集函数</a></li>
        <li><a href="#分组查询与分组过滤">分组查询与分组过滤</a></li>
        <li><a href="#并交差的处理">并、交、差的处理</a></li>
        <li><a href="#空值处理">空值处理</a></li>
        <li><a href="#内连接外连接">内连接、外连接</a></li>
        <li><a href="#sql的完整语法">SQL的完整语法</a></li>
      </ul>
    </li>
    <li><a href="#sql-dml之更新insertupdatedelete">SQL-DML之更新Insert/Update/Delete</a></li>
    <li><a href="#sql-视图及ddl的进一步介绍">SQL-视图及DDL的进一步介绍</a>
      <ul>
        <li><a href="#视图的定义与使用">视图的定义与使用</a></li>
        <li><a href="#视图更新问题">视图更新问题</a></li>
        <li><a href="#sql-ddl的进一步介绍-撤消语句的使用">SQL-DDL的进一步介绍: 撤消语句的使用</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                </details>
            </div><div class="post-content"><h1 id="sql语言">sql语言</h1>
<a class="post-dummy-target" id="sql语言概述"></a><h2>SQL语言概述</h2>
<a class="post-dummy-target" id="sql语言提出和发展"></a><h3>SQL语言提出和发展</h3>
<ul>
<li>1974年，由Boyce和Chamber提出</li>
<li>1975-1979年，在System R上首次实现，由IBM的San Jose研究室研制，
称为Sequel(Structured English QUEry Language)</li>
<li>1986年推出了SQL标准：SQL-86，
“数据库语言SQL: Structured Query
Language”</li>
<li>1989年ANSI / ISO推出了SQL标准: SQL-89, 数据库语言SQL的标准集合</li>
<li>1992年进一步推出了SQL标准：SQL-92，也称为SQL2
<ul>
<li>是SQL-89的超集</li>
<li>增加了许多新特性，如新数据类型，更丰富数据操作，更强完整性支持等</li>
<li>原SQL-89被称为entry-SQL, 扩展的被称为Intermediate级和Full级</li>
</ul>
</li>
<li>1999年进一步推出了SQL标准： SQL-99，也称为SQL3
<ul>
<li>对面向对象的一些特征予以支持，支持抽象数据类型，支持行对象和列对象等</li>
<li>对递归、触发等复杂操作也予以规范化定义</li>
<li>有些特征，现有数据库厂商尚不能做到完全支持</li>
<li>废弃了SQL2的分级，但定义了core-SQL及扩展的SQL</li>
</ul>
</li>
<li>SQL 2003； SQL 2006； SQL 2008</li>
<li>SQL还有一个标准是X/Open标准，主要强调各厂商产品的可移植性，只包含被各厂商广泛认可的操作</li>
</ul>
<a class="post-dummy-target" id="sql语言概览"></a><h3>SQL语言概览</h3>
<ul>
<li>SQL语言是集DDL、DML和DCL于一体的数据库语言</li>
<li>SQL语言主要由以下9个单词引导的操作语句来构成，但每一种语句都能
表达复杂的操作请求
<ul>
<li>DDL语句引导词：Create(建立), Alter (修改), Drop(撤消)
<ul>
<li>模式的定义和删除，包括定义Database, Table, View,Index,完整性约束条件等，也包括定义对象(RowType行对象, Type列对象)</li>
</ul>
</li>
<li>DML语句引导词：Insert, Update, Delete, Select
<ul>
<li>各种方式的更新与检索操作，如直接输入记录，从其他Table(由SubQuery建立)输入,各种复杂条件的检索，如连接查找，模糊查找，分组查找，嵌套查找等</li>
<li>各种聚集操作，求平均、求和、…等，分组聚集，分组过滤等</li>
</ul>
</li>
<li>DCL语句引导词：Grant, Revoke
<ul>
<li>安全性控制：授权和撤消授权</li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="post-dummy-target" id="简单的sql-ddldml-创建数据库"></a><h2>简单的SQL-DDL/DML: 创建数据库</h2>
<p>create database 数据库名;<br>
create table 表名( 列名 数据类型 [Primary key |UNIQUE] [not null][, 列名 数据类型 [not null] , … ]) ;</p>
<p>在表中追加元组的值要使用DML（Data Manipulation Language）</p>
<ul>
<li>向Table中追加新的元组：Insert</li>
<li>修改Table中某些元组中的某些属性的值: Update</li>
<li>删除Table中的某些元组: Delete</li>
<li>对Table中的数据进行各种条件的检索: Select</li>
</ul>
<a class="post-dummy-target" id="sql-dml之查询select"></a><h2>SQL-DML之查询Select</h2>
<a class="post-dummy-target" id="基本的检索操作"></a><h3>基本的检索操作</h3>
<p>Select 的简单语法形式为：
Select 列名 [[, 列名] … ]
From 表名
[ Where 检索条件 ] ;<br>
基本检索操作：</p>
<ul>
<li>结果唯一性问题：尽管关系模型要求无重复元组出现在数据库中，但现实DBMS操作中，是允许检索结果出现重复元组的，但也允许无重复元组</li>
<li>结果排序问题：DBMS可以对检索结果进行排序，可以升序排列，也可以
降序排列。order by 列名 [asc | desc]</li>
<li>模糊查询问题：
<ul>
<li>含有like运算符的表达式
<ul>
<li>列名 [not ] like “字符串”</li>
</ul>
</li>
<li>找出匹配给定字符串的字符串。其中给定字符串中可以出现%, _等匹配符</li>
<li>匹配规则
<ul>
<li>% 0个或多个字符</li>
<li>_ 任意单个字符</li>
<li>\ 转义字符，用于去掉一些特殊字符的特定含义</li>
</ul>
</li>
<li>举例：Select S#, Sname From StudentWhere Sname Like ‘张%’</li>
</ul>
</li>
</ul>
<a class="post-dummy-target" id="多表联合检索"></a><h3>多表联合检索</h3>
<p>连接运算涉及到重名的问题，如两个表中的属性重名，连接的两个表重名
(同一表的连接)等，因此需要使用别名以便区分<br>
select中采用别名的方式（as可省略）：
Select 列名 as 列别名 [ [, 列名 as 列别名] … ]
From 表名1 as 表别名1, 表名2 as 表别名2, …
Where 检索条件</p>
<a class="post-dummy-target" id="子查询"></a><h3>子查询</h3>
<p>出现在Where子句中的Select语句被称为子查询(subquery) , 子查询返回了一个集合，可以通过与这个集合的比较来确定另一个查询集合。<br>
子查询类型：</p>
<ul>
<li>in谓词:表达式 [not ] in (子查询)
<ul>
<li>非相关子查询： 内层查询独立进行，没有涉及任何外层查询相关信息的子查询被称为非相关子查询。</li>
<li>相关子查询：内层查询需要依靠外层查询的某些参量作为限定条件才能进行，这样的子查询称为相关子查询。外层向内层传递的参量需要使用外层的表名或表别名来限定</li>
</ul>
</li>
<li>*some / *all谓词（*为&lt; , &gt; , &gt;=, &lt;=）：后接子查询
<ul>
<li>语义：将表达式的值与子查询的结果进行比较：
<ul>
<li>如果表达式的值至少与子查询结果的某一个值相比较满足* 关系，则“表达式 * some (子查询)”的结果便为真；</li>
<li>如果表达式的值与子查询结果的所有值相比较都满足* 关系，则“表达式 * all (子查询)”的结果便为真；</li>
</ul>
</li>
<li>表达式 = some (子查询)和表达式 in (子查询)等价；表达式 not in (子查询)与表达式 &lt;&gt; all (子查询)等价</li>
</ul>
</li>
<li>Exists谓词：[not] Exists (子查询)，不加not形式的Exists谓词可以不用。</li>
</ul>
<a class="post-dummy-target" id="结果计算与聚集函数"></a><h3>结果计算与聚集函数</h3>
<p>前面介绍的select-from-where语句中，select子句后面不仅可以是列名，而且可以是一些计算表达式或聚集函数，表明在选择和投影的同时直接进行一些运算，如下所示：<br>
Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]
From 表名1 [, 表名2 … ]
[ Where 检索条件];<br>
计算表达式可以是常量、列名或由常量、列名、特殊函数及算术运算符构
成的算术运算式。特殊函数的使用需结合各自DBMS的说明书。<br>
例如，有计算表达式投影列的示例:求有差额(差额&gt;0)的任意两位教师的薪水差额</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select T1.Tname as TR1, T2.Tname as TR2, T1.Salary – T2.Salary
From Teacher T1, Teacher T2
Where T1.Salary &gt; T2.Salary;
</code></pre></td></tr></table>
</div>
</div><ul>
<li>SQL提供了五个作用在简单列值集合上的内置聚集函数agfunc, 分别是：COUNT、SUM、AVG、MAX、MIN</li>
<li>SQL聚集函数的参数类型、结果类型与作用如下：
<figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211109234009.png" alt="" class="lazyload"></figure></li>
<li>eg:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select Sum(Salary) From Teacher;
Select AVG(Score) From Course C, SC
Where C.Cname = ‘数据库’ and C.C# = SC.C;
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="分组查询与分组过滤"></a><h3>分组查询与分组过滤</h3>
<p>为解决同时求解若干个集合的聚集运算问题，引出了分组的概念。SQL可
以将检索到的元组按照某一条件进行分类，具有相同条件值的元组划到一个组或一个集合中，这一过程就是分组过程。<br>
Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]
From 表名1 [, 表名2 … ]
[ Where 检索条件 ]
[ Group by 分组条件(列名) ];
<figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211109234447.png" alt="" class="lazyload"></figure></p>
<p>若要对集合(即分组)进行条件过滤，可使用Having子句<br>
Having子句，又称为分组过滤子句。需要有Group by子句支持，换句话说，没有Group by子句，便不能有Having子句。<br>
Select 列名 | expr | agfunc(列名) [[, 列名 | expr | agfunc(列名) ] … ]
From 表名1 [, 表名2 … ]
[ Where 检索条件 ]
[ Group by 分组条件 [ Having 分组过滤条件] ];<br>
例如</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select S# From SC
Where Score &lt; 60
Group by S# Having Count(*)&gt;2;
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select C# From SC
Where Score &lt; 60
Group by C# Having Count(*)&gt;10;
</code></pre></td></tr></table>
</div>
</div><p>分组查询仍需要注意语义问题:<br>
例如求有两门以上不及格课程的同学的学号及其平均成绩:<br>
错误写法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select S#, Avg(Score) From SC
Where Score &lt; 60
Group by S# Having Count(*)&gt;2;
</code></pre></td></tr></table>
</div>
</div><p>前述写法是不正确的，它求出的是那两门不及格课程的平均成绩，而不是
该同学所有课程的平均成绩，后者是题目要求的。因此正确写法为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select S#, AVG(Score) From SC
Where S# in
( Select S# From SC
Where Score &lt; 60
Group by S# Having Count(*)&gt;2 )
Group by S#;
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="并交差的处理"></a><h3>并、交、差的处理</h3>
<p>SQL语言中为并运算提供了运算符UNION, 为交运算提供了运算符
INTERSECT, 为差运算提供了运算符EXCEPT，其基本语法形式为：<br>
子查询 { Union [ALL] | Intersect [ALL] | Except [ALL] 子查询    <br>
通常情况下是自动删除重复元组。但有时为了保留重复的元
组，则需使用ALL保留字，ALL保留字是允许重复元组出现，具体使用如下：<br>
假设子查询1的一个元组出现m次，子查询2的一个元组出现n次，则
该元组在：</p>
<ul>
<li>子查询1 Union ALL 子查询2 ，出现m + n次</li>
<li>子查询1 Intersect ALL 子查询2 ，出现min(m,n)次</li>
<li>子查询1 Except ALL 子查询2 ，出现max(0, m – n)次</li>
</ul>
<p>示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select S# From SC Where C# = ‘002’
UNION
Select S# From SC Where C# =&#39;003&#39;;
</code></pre></td></tr></table>
</div>
</div><p>交运算符Intersect并没有增强SQL的表达能力，没有Intersect， SQL也
可以用其他方式表达同样的查询需求，如上例所述。只是有了Intersect更容易表达一些，但增加了SQL语言的不唯一性。</p>
<p>它们都是Core-SQL99的一部分，但有些DBMS并不支持这些运算，使用时要注意。</p>
<a class="post-dummy-target" id="空值处理"></a><h3>空值处理</h3>
<p>空值是其值不知道、不确定、不存在的值<br>
数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等<br>
在SQL标准中和许多现流行的DBMS中，空值被用一种特殊的符号Null来
标记，使用特殊的空值检测函数来获得某列的值是否为空值
eg:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Select Sname From Student
Where Sage is null ;
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="内连接外连接"></a><h3>内连接、外连接</h3>
<p>关系代数运算中，有连接运算，又分为连接和外连接<br>
在SQL的高级语法中引入了内连接与外连接运算，具体形式如下：<br>
Select 列名 [ [, 列名] … ]
From 表名1 [NATURAL]
[ INNER | { LEFT | RIGHT | FULL} [OUTER]] JOIN 表名2
{ ON 连接条件 | Using (Colname {, Colname …}) }
[ Where 检索条件 ] …<br>
连接运算由两部分构成：连接类型和连接条件 <br>
<figure><img src="/svg/loading.min.svg" data-sizes="auto" data-src="https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211110000120.png" alt="" class="lazyload"></figure></p>
<ul>
<li>Inner Join: 即关系代数中的-连接运算</li>
<li>Left Outer Join, Right Outer Join, Full Outer Join: 即关系代数中的外连接运算
<ul>
<li>如“表1 Left Outer Join 表2”，则连接后，表1的任何元组t都会出现在结果表中，如表2中有满足连接条件的元组s, 则t与s连接；否则t与空值元组连接；</li>
<li>如“表1 Right Outer Join 表2”，则连接后，表2的任何元组s都会出现在结果表中，如表1中有满足连接条件的元组t, 则t与s连接；否则s与空值元组连接；</li>
<li>如“表1 Full Outer Join 表2”，是前两者的并。</li>
</ul>
</li>
<li>连接中使用 natural
<ul>
<li>出现在结果关系中的两个连接关系的元组在公共属性上取值相等，且公共属性只出现一次</li>
</ul>
</li>
<li>连接中使用 on &lt;连接条件&gt;
<ul>
<li>出现在结果关系中的两个连接关系的元组取值满足连接条件，且公共属性出现两次</li>
</ul>
</li>
<li>连接中使用 using (Col1, Col2, &hellip;, Coln)
<ul>
<li>(Col1, Col2, &hellip;, Coln)是两个连接关系的公共属性的子集，元组在(Col1,Col2, &hellip;, Coln)上取值相等，且(Col1, Col2, &hellip;, Coln)只出现一次</li>
</ul>
</li>
</ul>
<a class="post-dummy-target" id="sql的完整语法"></a><h3>SQL的完整语法</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Subquery ::==
SELECT [ ALL | DISTINCT ] { * | expr [[AS] c_alias] {, … } }
FROM tableref {, … }
[WHERE search_condition]
[GROUP BY column {, … }]
[HAVING search_condition]
| subquery [UNION [ALL] | INTERSECT [ALL] | EXCEPT [ALL]]
[CORRESPONDING [BY] (colname {, … })] subquery;
Tableref ::== tablename [corr_name]
Select statement ::==
Subquery [ORDER BY result_column[ASC | DESC] { , … }]
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="sql-dml之更新insertupdatedelete"></a><h2>SQL-DML之更新Insert/Update/Delete</h2>
<p>元组新增Insert命令有两种形式</p>
<ul>
<li>单一元组新增命令形式：插入一条指定元组值的元组insert into 表名 [(列名[，列名]…)]values (值 [，值]…)；</li>
<li>批数据新增命令形式：插入子查询结果中的若干条元组。待插入的元 组由子查询给出。insert into 表名 [(列名[，列名]…)]子查询;
<ul>
<li>eg:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Insert Into St (S#, Sname, avgScore) Select S#, Sname, Avg(Score) From Student, SC Where Student.S# = SC.S# Group by Student.S#
</code></pre></td></tr></table>
</div>
</div></li>
<li>当有元组新增操作时，DBMS会检查用户定义的完整性约束条件等，如不符合完整性约束条件，则将不会执行新增动作（同删除操作）。</li>
</ul>
<p>SQL-DML之元组更新Update</p>
<ul>
<li>元组更新Update命令: 用指定要求的值更新指定表中满足指定条
件的元组的指定的列的值
Update 表名
Set 列名 = 表达式 | (子查询)
[ [ , 列名 = 表达式 | (子查询) ] … ]
[ Where 条件表达式] ;</li>
<li>如果Where条件省略，则更新所有的元组。</li>
</ul>
<a class="post-dummy-target" id="sql-视图及ddl的进一步介绍"></a><h2>SQL-视图及DDL的进一步介绍</h2>
<a class="post-dummy-target" id="视图的定义与使用"></a><h3>视图的定义与使用</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Create View CompStud AS
( Select * From Student
Where D# in ( Select D# From Dept
Where Dname = ‘计算机’ );
</code></pre></td></tr></table>
</div>
</div><a class="post-dummy-target" id="视图更新问题"></a><h3>视图更新问题</h3>
<p>SQL视图更新操作受到很大的约束，很多情况是不能进行视图
更新的:</p>
<ul>
<li>如果视图的select目标列包含聚集函数，则不能更新</li>
<li>如果视图的select子句使用了unique或distinct，则不能更新</li>
<li>如果视图中包括了group by子句，则不能更新</li>
<li>如果视图中包括经算术表达式计算出来的列，则不能更新</li>
<li>如果视图是由单个表的列构成，但并没有包括主键，则不能更新</li>
</ul>
<p>对于由单一Table子集构成的视图，即如果视图是从单个基本表使用选
择、投影操作导出的，并且包含了基本表的主键，则可以更新</p>
<a class="post-dummy-target" id="sql-ddl的进一步介绍-撤消语句的使用"></a><h3>SQL-DDL的进一步介绍: 撤消语句的使用</h3>
<p>不仅视图可以撤消，基本表、数据库等都可以撤消<br>
撤消基本表：drop table 表名<br>
<strong>注意</strong>，SQL-delete语句只是删除表中的元组, 而撤消基本表drop table的
操作是撤消包含表格式、表中所有元组、由该表导出的视图、等相关的所有内容，所以使用要特别注意。当表定义完成后，通常不是撤消表，而可能要修正表的定义，此时可使用Alter table语句修正基本表的定义：<br>
alter table tablename<br>
[add {colname datatype}]<br>
[drop {完整性约束名}]<br>
[modify {colname datatype, …}]<br>
指定当前数据库
use 数据库名;
关闭当前数据库
close 数据库;</p>
</div><div class="post-copyright" id="post-footer">          
            <p class="copyright-item">
                <span>Author:&nbsp;</span>
                <span>qizheng</span>
            </p>

            <p class="copyright-item">
                <span>Updated on:&nbsp;</span>
                <span>2021-11-10</span>
            </p>

            <p class="copyright-item"></p>

            <p class="copyright-item"></p>

            <p class="copyright-item"></p>
        </div>
        <br>

        <div class="post-info-more">
            <section><span class="tag">
                            <a href="https://qizhengzou.github.io/tags/mysql/"><i class="fas fa-tag fa-fw"></i>&nbsp;mysql</a>&nbsp;
                        </span></section>
            <section>
                <span><a href="javascript:window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="https://qizhengzou.github.io">Home</a></span>
            </section>
        </div>
        
        <div class="post-nav"><a href="https://qizhengzou.github.io/2021/hdfs/" class="prev" rel="prev" title="BigData_base_03"><i class="fas fa-angle-left fa-fw"></i>BigData_base_03</a>
                <a href="https://qizhengzou.github.io/2021/database-management-and-maintenance/" class="next" rel="next" title="Mysql_base_04">Mysql_base_04<i class="fas fa-angle-right fa-fw"></i></a></div><div class="post-comment"></div>
    </article></div>
            </main><footer class="footer">
    <div class="copyright">
        <div class="copyright-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://qizhengzou.github.io/about/" target="_blank">qizheng</a> | </span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a> & <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="external nofollow noopener noreffer">LoveIt</a></div>
    </div>
</footer></div><a href="#" class="dynamic-to-top" id="dynamic-to-top" data-scroll>
            <span>&nbsp;</span>
        </a><script src="/js/lib/jquery/jquery.slim.min.js"></script><script src="/js/lib/lazysizes/lazysizes.min.js"></script><script src="/js/lib/smooth-scroll/smooth-scroll.polyfills.min.js"></script><script>window.scroll = new SmoothScroll('[data-scroll]', {speed: 300, speedAsDuration: true});</script><link rel="stylesheet" href="/css/lib/katex/katex.min.css"><script src="/js/lib/katex/katex.min.js"></script><script defer src="/js/lib/katex/auto-render.min.js"></script><link rel="stylesheet" href="/css/lib/katex/copy-tex.min.css"><script defer src="/js/lib/katex/copy-tex.min.js"></script><script defer src="/js/lib/katex/mhchem.min.js"></script><script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "\\(", right: "\\)", display: false },
                    { left: "\\[", right: "\\]", display: true },{ left: "$", right: "$", display: false },]
            });
        });
    </script><script src="/js/blog.min.js"></script></body>
</html>