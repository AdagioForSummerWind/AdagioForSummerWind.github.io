# DistributedSystem_base_02

# 系统模型
## 简介
- 物理模型是描述系统的-个最显式的方法，它从计算机(和其他设备，例如移动电话)及其互联的网络方面考虑系统的硬件组成。
- 体系结构模型从系统的计算元素执行的计算和通信任务方面来描述系统。
- 基础模型采用抽象的观点描述分布式系统的某个方面。本章介绍考察分布式系统三个重要方面的基础模型:
    - 交互模型，它考虑在系统元素之间通信的结构和顺序;
    - 故障模型，它考虑一个系统可能不能正确操作的方式;
    - 安全模型，它考虑如何保护系统使其不受到正确操作的干扰或不被窃取数据。

## 物理模型
物理模型是从计算机和所用网络技术的特定细节中抽象出来的分布式系统底层硬件元素的表示。
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211117091203.png)

## 体系结构模型
本节采取一种三阶段方法:
- 首先，描述支撑现代分布式系统的核心基本体系结构元素，重点展示现在已有方法的不同;
- 考察能在开发复杂分布式系统解决方案中单独使用或组合使用的复合体系结构模式;
- 最后，对于以上体系结构风格中出现的不同编程风格，考虑可用于支持它们的中间件平台。

注意，有许多与本章中介绍的体系结构模型相关的权衡，其中涉及采用的系统体系结构元素、所采用的模式和(在合适的地方)使用的中间件，它们会影响结果系统的性能和有效性。理解这样的权衡可以说是分布式系统设计中的关键技能。

### 体系结构元素
- 通信实体：从系统的观点，回答通常是非常清楚的,这是因为在一个分布式系统中通信的实体通常是进程，这导致普遍地把分布式系统看成是带有恰当进程间通信范型的多个进程(如在第4章中讨论的)，有两个注意事项:
    - 在一些原始环境中，例如传感器网络,基本的操作系统可能不支持进程抽象(或甚至任何形式的隔离)，因此在这些系统中通信的实体是结点。
    - 在大多数分布式系统环境中，用线程补充进程，所以，严格说来，通信的末端是线程。
- 对象：对象已被引人以便在分布式系统中使用面向对象的方法(包括面向对象的设计和面向对象的编程语言)。在分布式面向对象的方法中，-个计算由若千交互的对象组成，这些对象代表分解给定问题领域的自然单元。对象通过接口被访问，用一个相关的接口定义语言(IDL) 提供定义在一个对象上的方法的规约。分布式对象已经成为分布式系统研究的一个主要领域，第5章和第8章将进一步讨论这个话题。
- 组件:因为对象的引入，许多重要的问题已被认为与分布式对象有关，组件技术的出现及使用是对这些弱点的一个直接响应。组件类似于对象，因为它们为构造分布式系统提供面向问题的抽象，也是通过接口被访问。关键的区别在于组件不仅指定其(提供的)接口而且给出关于其他组件/接口的假设，其他组件/接口是组件完成它的功能必须有的。换句话说,组件使得所有依赖显式化，为系统的构造提供一个更完整的合约。这个合约化的方法鼓励和促进第三方开发组件，也通过去除隐含的依赖
提升了一个更纯粹的组合化方法来构造分布式系统。基于组件的中间件经常对关键领域如部署和服务器方编程支持提供额外的支持[ Heineman and Councill 2001]。关于基于组件方法的进一步细节请参见第8章。
- Web服务: Web 服务代表开发分布式系统的第三种重要的范型[Alonso et al. 2004]。Web 服务与对象和组件紧密相关，也是采取基于行为封装和通过接口访问的方法。但是，相比而言，通过利用Web标准表示和发现服务，Web 服务本质上是被集成到万维网(即W3C)的。W3C ( World WideWeb)联盟把Web服务定义成：   一个软件应用，通过URI被辨识，它的接口和绑定能作为XML制品被定义描述和发现。一个Web服务通过在基于互联网的协议上利用基于XML的消息交换支持与其他软件代理的直接交互。   
- 换句话说，Web服务采用的基于Web的技术在-定程度上定义了Web服务。另一个重要的区别来源于技术使用的风格。对象和组件经常在一个组织内部使用，用于开发紧耦合的应用，但Web服务本身通常被看成完整的服务，它们可以组合起来获得增值服务，它们经常跨组织边界，因此可以实现业
务到业务的集成。Web服务可以由不同的提供商用不同的底层技术实现。Web服务将在第9章做进一步的探讨。
- 通信范型我们现在转向在分 布式系统中实体如何通信,考虑三种通信范型:
    - 进程间通信;
    - 远程调用;
    - 间接通信。

    - 进程间通信指的是用于分布式系统进程之间通信的相对底层的支持，包括消息传递原语、直接访问由互联网协议提供的API (套接字编程)和对多播通信的支持。第4章将详细讨论这样的服务。
    - 远程调用代表分布式系统中最常见的通信范型，覆盖一系列分布式系统中通信实体之间基于双向交换的技术，包括调用远程操作、过程或方法。进一步的定义参见下面内容(详细讨论见第5章):
    - 请求-应答协议是一个有效的模式，它加在一个底层消息传递服务之上，用于支持客户-服务器计算。特别的，这样的协议通常涉及一对消息的交换，消息从客户到服务器，接着从服务器返回客户，第一个消息包含在服务器端执行的操作的编码，然后是保存相关参数的字节数组，第二个消息包含操作的结果，它也被编码成字节数组。这种范型相对原始，实际上仅被用于嵌人式系统，对嵌人式系统来说性能是至关重要的。这个方法也被用在5.2节描述的HTTP协议中。正如下面讨论的，大多数分布式系统将选择使用远程过程调用或者远程方法调用，但注意底层的请求-应答交换支持两种方法。
    - 远程过程调用( Remote Procedure Call, RPC)的概念，最初由Birell 和Nelson [1984] 提出，代表了分布式计算中的一个主要突破。在RPC中,远程计算机上进程中的过程能被调用，好像它们是在本地地址空间中的过程一样。底层RPC系统隐藏了分布的重要方面，包括参数和结果的编码和解码、消息的传递和保持过程调用所要求的语义。这个方法直接而且得体地支持了客户-服务器计算，其中,服务器通过一个服务接口提供一套操作, 当这些操作本地可用时客户直接调用这些操作。因此，RPC系统(在最低程度上)提供访问和位置透明性。
    - 远程方法调用( Remote Method Invocation, RMI) 非常类似于远程过程调用，但它应用于分布式对象的环境。用这种方法，-个发起调用的对象能调用一个远程对象中的方法。与RPC一样，底层的细节都对用户隐藏。不过，通过支持对象标识和在远程调用中传递对象标识符作为参数，RMI 实现做得更多。它们也从与面向对象语言(见第5章相关讨论)的紧密集成中获得更多的好处。
    - 上述技术具有一个共同点:通信代表发送者和接收者之间的双向关系，其中，发送者显式地把消息/调用送往相关的接收者。接收者通常了解发送者的标识，在大多数情况下，双方必须在同时存在。相比而言，已经出现若千技术，这些技术支持间接通信,通过第三个实体，允许在发送者和接收者之间的深度解耦合。尤其是:
        - 发送者不需要知道他们正在发送给谁(空间解耦合)。
        - 发送者和接收者不需要同时存在(时间解耦合)。

    第6章将详细讨论间接通信。

    间接通信的关键技术包括:

    - 组通信:组通信涉及消息传递给若干接收者，因此是支持一对多通信的多方通信范型。组通信依赖组抽象，-一个组在系统中用-一个组标识符表示。接收方通过加人组，就能选择性接收发送到组的消息。发送者通过组标识符发送消息给组，因此，不需要知道消息的接收者。组通常也要维护组成员,具有处理组成员故障的机制。
    - 发布-订阅系统:许多系统，例如第1章中金融贸易的例子，被归类于信息分发系统，其中，大量生产者(或发布者)为大量的消费者(或订阅者)发布他们感兴趣的信息项(事件)。采用前述的任-核心通信范型来实现这个需求是复杂且低效的，因此，出现了发布-订阅系统(有时也叫分布式基于事件的系统)用于满足此项重要需求[ Muhl et al. 2006]。发布-订阅系统共享同一个关键的特征，即提供-一个中间服务,有效确保由生产者生成的信息被路由到需要这个信息的消费者。
    - 消息队列:虽然发布-订阅系统提供一种一对多风格的通信,但消息队列提供了点对点服务,其中生产者进程能发送消息到一个指定的队列，消费者进程能从队列中接收消息，或被通知队列里有新消息到达。因此，队列是生产者和消费者进程的中介。
    - 元组空间:元组空间提供了进-步的间接通信服务，并支持这样的模型一进程 能把任意的结构化数据项( 称为元组)放到一个持久元组空间，其他进程可以指定感兴趣的模式，从而可以在元组空间读或者删除元组。因为元组空间是持久的，读操作者和写操作者不需要同时存在。这种风格的编程，也被称为生成通信，由Gelemter [ 1985]作为一种并行编程范型引人。已经开发了不少分布式实现，采用了客户-服务器-风格的实现或采用了更分散的对等方法。
    - 分布式共享内存:分布式共享内存(Distributed Shared Memory, DSM)系统提供一种抽象，用于支持在不共享物理(内存的进程之间共享数据。提供给程序员的是-套熟悉的读或写(共享)数据结构的抽象，就好像这些数据在程序员自已本地的地址空间一样,从而提供了高层的分布透明性。基本的基础设施必须确保以及时的方式提供副本，也必须处理与数据同步和一致性相关的问题。分布式共享内存的概述在第6章中介绍。
- 到目前为止讨论的体系结构  
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211117094255.png)

- 角色和责任，在一个分布式系统中, 进程，或者说，对象、组件、服务，包括Web服务(为简单起见，我们在本节中使用术语“进程”)相互交互完成一个有用的活动，例如支持一次聊天会话。在这样做的时候，进程扮演给定的角色，在建立所采用的整体体系结构时，这些角色是基本的。本节我们考察两种起源于单个进程角色的体系结构风格:客户-服务器风格和对等风格。
    - 客户-服务器:这是讨论分布式系统时最常引用的体系结构。它是历史上最重要的体系结构，现在仍被广泛地使用。图2-3 给出了一个简单的结构，其中，进程扮演服务器和客户的角色。特别是,为了访问服务器管理的共享资源，客户进程可以与不同主机上的服务器进程交互。![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211117094742.png)如图2-3所示，一台服务器也可以是其他服务器的客户。例如，Web服务器通常是管理存储Web页面文件的本地文件服务器的客户。Web 服务器和大多数其他互联网服务是DNS服务的客户，DNS服务用于将互联网域名翻译成网络地址。另一个与Web相关的例子是搜索引擎,搜索引擎能让用户通过互联网查看Web页面上可用的信息汇总。这些信息汇总通过称为“Web 抓取”的程序形成，该程序在搜索引擎站点以后台方式运行，利用HTTP请求访问互联网上的Web服务器。因此，搜索引擎既是服务器又是客户:它回答来自浏览器客户的查询，并且运行作为其他Web服务器客户的Web抓取程序。在这个例子中，服务器任务(对用户查询的回答)和Web抓取的任务( 向其他Web服务器发送请求)是完全独立的，很少需要同步它们，它们可以并行运行。事实上,一个典型的搜索引擎正常情况下包含许多并发执行的线程，一些线程为它的客户服务，另一些线程运行Web抓取程序。
    - 对等体系结构:在这种体系结构中,涉及一项任务或活动的所有进程扮演相同的角色，作为对等方进行协作交互，不区分客户和服务器或运行它们的计算机。在实践中，所有的参与进程运行相同的程序并且相互之间提供相同的接口集合。虽然客户-服务器模型为数据和其他资源的共享提供了一个直接和相对简单的方法，但客户-服务器模型的伸缩性比较差。将一个服 务放在单个地址中意味着集中化地提供服务和管理，它的伸缩性不会超过提供服务的计算机的能力和该计算机所在网络连接的带宽。
- 放置：最后要考虑的问题是诸如对象或服务这样的实体是怎样映射到底层的物理分布式基础设施上的，物理分布式基础设施由大量的机器组成，这些机器通过一个任意复杂的网络互联。
    - 从决定分布式系统特性的角度而言，放置是关键的，这些特性大多数与性能相关，也包括其他特性如可靠性和安全性。   
    - 从机器和机器内部进程的角度看，在哪里放置-一个给定客户或服务器的问题是需要仔细设计的。放置需要考虑实体间的通信模式、给定机器的可靠性和它们当前的负载、不同机器之间的通信质量等。必须用有说服力的应用知识来确定放置,有些通用的指导方针可以用来获得一个优化的解决方案。因此，我们主要关注下列放置策略,它们能显著地改变-一个给定设计的特征(我们在2.3.2节又回到关于物理基础设施映射的关键问题，那里，我们主要考察层次化的体系结构):
        - 将服务映射到多个服务器;
        - 缓存;
        - 移动代码;
        - 移动代理。
    - 将服务映射到多个服务器:服务可实现成在-个单独主机上的几个服务器进程，在必要时进行交互以便为客户进程提供服务(参见图2-4b)。服务器可以将服务所基于的对象集分区，然后将这些分区分布到各个服务器上;或者服务器可以在几个主机上维护复制的对象集。
    - 缓存:缓存用于存储最近使用的数据对象，这些被存储的数据对象比对象本身更靠近一个客户或特定的一组客户。当服务器接收-一个新对象时,就将它存入缓存,必要的时候会替换缓存中已存在的对象。当客户进程需要一个对象时，缓存服务首先检查缓存，如果缓存中有最新的拷贝可用就提供缓存中的对象;如果缓存没有可用的对象，才去取一个最新的拷贝。每个客户都可以配置缓存或者将缓存放置在由几个客户共享的代理服务器上。
    - 移动代码:第1章介绍了移动代码。applet 是一个众所周知的并被广泛使用的移动代码例子，即运行浏览器的用户选择了一个到applet的链接，applet 的代码存储在Web服务器上，将applet的代码下载到浏览器并在浏览器端运行。在本地运行下载的代码的好处是能够提供良好的交互响应，因为它不受与网络通信相关的延迟或带宽变化的影响。
    - 移动代理:移动代理是一个运行的程序(包括代码和数据)，它从一台计算机移动到网络上的另一台计算机，代表某人完成诸如信息搜集之类的任务，最后返回结果。-一个移动代理可能多次调用所访问地点的本地资源一例如， 访问-一个数据库条目。如果将这种体系结构与对某些资源进行远程调用的静态客户相比，那么后者可能会传输大量的数据，前者通过用本地调用替换远程调用而降低了通信开销和时间。

### 体系结构模式
我们给出分布式系统中几个关键的体系结构模型，包括分层体系结构( layering architecture)、层次化体系结构( tiered ar-chitecture)和瘦客户相关的概念(包括虚拟网络计算的特定机制)。我们也把Web服务当做一个体系结构模式进行了考察，给出了其他可以应用在分布式系统中的模式。
- 分层，分层的概念是-一个熟悉的概念，与抽象紧密相关。在分层方法中，一个复杂的系统被分成若干层，每层利用下层提供的服务。因此，一个给定的层提供-一个软件抽象，更高的层不清楚实现细节，或不清楚在它下面的其他层。就分布式系统而言，这等同于把服务垂直组织成服务层。一个分布式服务可由一个或多个服务器进程提供，这些进程相互交互，并与客户进程交互，维护服务中的资源在系统范围内的-致视图。
- 层次化体系结构层次化体系结构 与分层体系结构是互补的。分层将服务垂直组织成抽象层，而层次化是一项组织给定层功能的技术，它把这个功能放在合适的服务器上，或者作为第二选择放在物理结点上。
- AJAX的作用:在1.6节中，我们介绍了AJAX ( Asynchronous Javascript And XML)是Web所使用的标准客户-服务器交互方式的扩展。AJAX满足了Javascript 前端程序( 运行在Web浏览器中)和基于服务器的后端程序(拥有描述应用状态的数据)之间的细粒度通信的需要。概括而言，在标准的Web交互方式中，浏览器发送HTTP请求给服务器，请求给定URL的页面、图像或其他资源。服务器发送整个页面作为应答，这个页面或者从服务器上的-一个文件中读取，或者由一个程序生成，取决于
URL中可识别的资源类型。当客户收到内容时，浏览器根据其MIME类型( text/html、image/jpg 等)相关的显示方式呈现它。虽然Web页面由不同类型的内容项组成，但是整个页面以它在html页面定义中指定的方式由浏览器组合并呈现。
- 瘦客户，分布式计算的趋势是将复杂性从最终用户设备移向互联网服务。这点在向云计算(见第1章)发展的趋势中最明显，在上面讨论的层次化体系结构中也能看到。这个趋势导致了对瘦客户概念的兴趣，它使得能以很少的对客户设备的假设或需求，获得对复杂网络化服务的访问，这些服务可以通过云解决方案提供。更具体来说，术语瘦客户指的是一个软件层，在执行一个应用程序或访问远程计算机上的服务时，由该软件层提供一个基于窗口的本地用户界面。
- 其他经常出现的模式：
    - 代理
        - 代理(proxy) 模式是分布式系统中经常出现的模式，其主要用于支持远程过程调用或远程方法调用的位置透明性。用这种方法，一个代理在本地地址空间中被创建，用于代表远程对象。这个代理提供与远程对象-样的接口，程序员调用这个代理对象，因此无须了解交互的分布式特性。在RPC和RMI中，代理支持位置透明性的作用将在第5章做进一步的讨论。 注意代理也被用于封装其他的功能( 诸如复制或缓存的放置策略等)。

    - web服务中的业务代理
        - Web服务中的业务代理(brokerage)的使用能被看成是一个在可能很复杂的分布式基础设施中支持互操作性的体系结构模式。特别地，这个模式是由服务提供商、服务请求者和服务代理(提供与请求的服务-致的服务)三部分组成，如图2-11所示。这个业务代理模式在分布式系统的多个领域被多次应用，例如Java RMI中的注册服务、CORBA中的名字服务( 分别参见第5章和第8章的讨论)。

    - 反射
        - 反射( reflection)模式在分布式系统中作为支持内省(系统的动态发现的特性)和从中调停(动态修改结构或行为的能力)的手段而被持续地使用。.例如，Java的内省能力被用于RMI的实现中，提供通用的分发(参见5.4.2节的讨论)。在一个反射系统中，标准的服务接口在基础层可供使.用，但元层接口也可以提供对涉及服务实现的组件及组件参数的访问。许多技术在元层可用，包括截获到达的消息或调用、动态发现由给定对象提供的接口、发现和适应系统底层体系结构的能力。反射被应用于分布式系统中的多个领域，特别是反射中间件领域，例如，可以用于支持更多的可配置及重配置中间件体系结构[Kon et al. 2001]。与分布式系统相关的体系结构模式更多的例子可以在Bushmann等人[2007] 的著作中找到。.
### 相关的中间件解决方案
第1章引入了中间件，在2.3.2节讨论分层体系结构时又重温了中间件。中间件的任务是为分布式系统的开发提供-一个高层的编程抽象，并且通过分层，对底层基础设施中的异构性提供抽象，从而提升互操作性和可移植性。中间件解决方案是基于2. 3. 1节引人的体系结构模型，也支持更复杂的体系结构模式。本节我们简要回顾一下现在存在的中间件类别，为在本书的其他部分进-步研究这 些解决方案做好准备。
- 中间件的类别
    - 远程过程调用包, (如Sun RPC,第5章)和组通信(如ISIS,第6章和第18章)属于最早的中间件实例。从那以后，出现了大量不同风格的中间件，大部分都基于上面介绍的体系结构模型。我们在图2-12中给出了中间件平台的分类，其中交叉引用了其他章,那些章更详细地讨论了不同种类的中间件。需要强调的是分类并不精确，现代中间件平台试图提供混合的解决方案。例如，许多分布式对象平台提供分布式事件服务，来补充传统的对远程方法调用的支持。类似地，出于互操作性的原因,许多基于组件的平台(和平台的其他分类)也支持Web服务和标准。从中间件标准和今天可用的技术的角度来看,还应该强调这个分类并不完整，其目的在于给出中间件的主要类别。其他(未给出的)解决方案是比较特定的，例如，特定于提供某-通信范型，如消息传递、远程过程调用、分布式共享内存、元组空间或组通信。
- 图2-12中的中间件的顶层分类是根据通信实体和相关通信范型而确定的，遵循五个主要的体系结构模型:分布式对象、分布式组件、发布-订阅系统、消息队列和Web服务。对等系统是这些类别的补充，基于2.3. 1节讨论的协作方法，对等系统是中间件-一个相当独立的分支。应用服务器，显示为分布式组件的子类，也提供对三层体系结构的直接支持。特别地，应用服务器提供了结构以支持应用逻辑和数据存储的分离，以及对其他特性( 如安全性和可靠性)的支持。详细细节将延后到第8章讨论。
- 除了编程抽象之外，中间件也能提供分布式系统的基础设施服务,供应用程序或其他服务使用。这些基础设施服务与中间件提供的分布式编程模式是紧密绑定的。例如，CORBA (第8章)提供给应用一系列的CORBA服务，包括对程序安全和可靠的支持。如上所述和在第8章中的进-一步讨论，应用服务器也提供对这些服务的内在支持。
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211201085724.png)
- 中间件的限制
    - 许多分布式应用完全依赖中间件提供的服务来支持应用的通信和数据共享需求。例如，一个适合客户-服务器模型的应用，如一个名字和地址的数据库，可以依赖只提供远程方法调用的中间件。
    - 通过依靠中间件支持的开发，能大大简化分布式系统的编程，但系统可依赖性的一些方面要求应用层面的支持。
    - 考虑从发送者的邮件主机传递大量的电子邮件消息到接收者的邮件主机。乍一看，这是一个TCP数据传输协议的简单应用( 见第3章的相关讨论)。但考虑这样的问题:用户试图在一个可能不可靠的网络上传递非常大的文件。TCP提供一些错误检测和更正， 但它不能从严重的网络中断中恢复。因此，邮件传递服务增加了另一层次的容错，维护一个进展记录，如果原来的TCP连接断开了，用一个新的TCP连接继续传递。
    - Saltzer、Reed 和Clarke的一篇经典论文[Saltzer et al. 1984]对分布式系统的设计给出了类似的、有价值的观点，他们称之为“端到端争论”。可将他们的陈述表述为:
        - 一些与通信相关的功能，可以只依靠通信系统终点(end point)的应用的知识和帮助，即可完整、可靠地实现。因此，将这些功能作为通信系统的特征不总是明智的(虽然由通信系统提供一个不完全版本的功能有时对性能提高是有用的)。可以看出他们的论点与通过引人适当的中间件层将所有通信活动从应用编程中抽象出来的观点是相反的。
    - 争论的关键是分布式程序正确的行为在很多层面上依赖检查、错误校正机制和安全手段，其中有些要求访问应用的地址空间的数据。任何企图在通信系统中单独完成的检查将只能保证部分正确性。因此，可能在应用程序中重复同样的任务,降低了编程效率,更重要的是增加了不必要的复杂性并要执行冗余的计算。
    - 这里不进一步介绍他们的争论细节,强烈推荐读者阅读前面提到的那篇论文一那里有许多说明的实例。原文作者之一最近指出:争论给互联网设计带来的实质性好处最近面临着为满足当前应用需求而转向网络服务专门化的危险[ www. reed. com]。
    - 这个争论给中间件设计者带来一个实际的两难困境，而且给定当代分布式系统中种类繁多的应用(和相关的环境条件) (见第1章)，这些困难与日俱增。本质上，底层中间件行为与一个给定应用或应用集的需求和相关环境上下文(如底层网络的状态和风格)有关。这个看法推动了对上下文感知和中间件自适应解决方案的兴趣，见Kon等人的讨论[2002] 。


## 基础模型
上面的各种系统模型完全不同，但具有一些基本特性。特别是，所有的模型都由若干进程组成,这些进程通过在计算机网络上发送消息而相互通信，所有的模型都共享下列设计需求:实现进程及网络的性能和可靠性特征，确保系统中资源的安全性。本节给出基于基本特性的模型，利用这些模型，我们能更详细地描述系统可能展示的特征、故障和安全风险。

通常，为了理解和推理系统行为的某些方面，一个基础模型应该仅包含我们要考虑的实质性成分。这样一个模型的目的是:
- 显式地表示有关我们正在建模的系统的假设。
- 给定这些假设，就什么是可能的、什么是不可能的给出结论。结论以通用算法或要确保的特性
的形式给出。特性成立的保证依赖于逻辑分析和(适当时候的)数学证明。

了解设计依赖什么、不依赖什么，我们就能从中获益。如果在一个特定系统中实现-个设计，这个设计能否运作，我们只需询向在那个系统中假设是否成立。通过清晰、显式地给出我们的假设，就能利用数学技巧证明系统的特征，这些特征对任何满足假设的系统都成立。最后，通过从细节(如硬件)中抽象系统的基本实体和特性，我们就能阐明对系统的理解。

我们希望在我们的基本模型中提取的分布式系统情况能解决下列问题:
- 交互:计算在进程中发生，进程通过传递消息交互，并引发进程之间的通信(信息流)和协调(活动的同步和排序)。在分布式系统的分析和设计中,我们特别关注这些交互。交互模型必须反映通信带来的延迟，这些延迟的持续时间会比较长，交互模型必须反映独立进程相互配合的准确性受限于这些延迟，受限于在分布式系统中很难跨所有计算机维护同一时间概念。
- 故障:只要分布式系统运行的任-计算机上出现故障(包括软件故障)或连接它们的网络出现故障，分布式系统的正确操作就会受到威胁。我们的模型将对这些故障进行定义和分类。这为分析它们潜在效果以及设计能容忍每种类型故障的系统奠定了基础。
- 安全:分布式系统的模块特性和开放性将其暴露在外部代理和内部代理的攻击下。我们的安全模型对发生这种攻击的形式给出了定义并进行了分类，为分析对系统的威胁以及设计能抵御这些威胁的系统奠定了基础。为了帮助讨论和推理，我们对本章介绍的模型进行了必要的简化，省略了许多真实系统中的细节。
它们与真实系统的关系，以及在模型帮助下揭示的问题环境中的解决方案是本书讨论的主题。

### 交互模型
体系结构模型对系统体系结构的讨论表明分布式系统由多个以复杂方式进行交互的进程组成。例如:
- 多个服务器进程能相互协作提供服务，前面提到的例子有域名服务(它将数据分区并复制到互联网中的服务器上)和Sun的网络信息服务(它在局域网的几个服务器上保存口令文件的复制版本)。
- 对等进程能相互协作获得一个共同的目标。例如，一个语音会议系统，它以类似的方式分布音频数据流，但它有严格的实时限制。

大多数程序员非常熟悉算法的概念一采取一系列步骤以执行期望的计算。简单的程序由算法控制，算法中的每一步都有严格的顺序。由算法决定程序的行为和程序变量的状态。这样的程序作为一个进程执行。由多个上面所说的进程组成的分布式系统是很复杂的。它们的行为和状态能用分布式算法描述一分布式算法定 义了组成系统的每个进程所采取的步骤，包括它们之间消息的传递。消息在进程之间传递以便在它们之间传递信息并协调它们的活动。每个进程执行的速率和进程之间消息传递的时限通常是不能预测的。要描述分布式算法的所有状态也非常困难，因为它必须处理所涉及的一个或多个进程的故障或消息传递的故障。

进程交互完成了分布式系统中所有的活动。每个进程有它自已的状态，该状态由进程能访问和更新的数据集组成，包括程序中的变量。属于每个进程的状态完全是私有的一也就是说， 它不能被其他进程访向或更新。

本节讨论分布式系统中影响进程交互的两个重要因素:
- 通信性能经常是一个限制特性。
- 不可能维护-个全局时间概念。

通信通道的性能。在我们的模型中， 通信通道在分布式系统中可用许多方法实现，例如，通过计算机网络上的流或简单消息传递来实现。计算机网络上的通信有下列与延迟(lateney)、 带宽( band-widh)和抖动(itter) 有关的性能特征:
- 从一个进程开始发送消息到另--个进程开始接收消息之间的间隔时间称为延迟。延迟包括:
    - 第一串比特通过网络传递到目的地所花费的时间。例如，通过卫星链接传递消息的延迟是无线电信号到达卫星并返回的时间。
    - 访问网络的延迟，当网络负载很重时，延迟增长很快。例如，对以太网传送而言，发送站点要等待网络空闲。
    - 操作系统通信服务在发送进程和接收进程上所花费的时间，这个时间会随操作系统当前的负载的变化而变化。
- 计算机网络的带寬是指在给定时间内网络能传递的信息总量。当大量通信通道使用同-一个网络时，它们就不得不共享可用的带宽。
- 抖动是传递一系列消息所花费的时间的变化值。抖动与多媒体数据有关。例如，如果音频数据
的连续采样在不同的时间间隔内播放，那么声音将严重失真。

计算机时钟和时序事件。分布式系统中的每台计算机有自己的内部时钟,本地进程用这个时钟获得当前时间值。因此，在不同计算机上运行的两个进程能将时间戳与它们的事件关联起来。但是，即使两个进程在同时读它们的时钟,它们各自的本地时钟也会提供不同的时间值。这是因为计算机时钟和绝对时间之间有偏移，更重要的是，它们的漂移率互不相同。术语时钟漂移率( clock drit rate)指的是计算机时钟偏离绝对参考时钟的比率。即使分布式系统中所有计算机的时钟在初始情况下都设置成相同的时间，它们的时钟最后也会相差巨大，除非进行校正。
- 有几种校正计算机时钟的时间的方法。例如，计算机可使用无线电接收器从全球定位系统( GPS)以大约1μs的精度接收时间读数。但GPS接收器不能在建筑物内工作，同时，为每一台计算机增加GPS在费用上也不合理。相反，具有精确时间源(如GPS)的计算机可发送时序消息给网络中的其他计算机。在两个本地时钟时间之间进行协商当然会受消息延迟的影响。有关时钟漂移和时钟同步的更详细的讨论见第14章。

交互模型的两个变体。在分布式系统中，很难对进程执行、消息传递或时钟漂移所花的时间设置时间限制。两种截然相反的观点提供了一对简单模型:第一个模型对时间有严格的假设，第二个模型对时间没有假设。
- 同步分布式系统: Hadzilacos 和Toueg [1994] 定义了一个同步分布式系统，它满足下列约束:
    - 进程执行每一步的时间有一个上限和下限。
    - 通过通道传递的每个消息在一个已知的时间范围内接收到。
    - 每个进程有一个本地时钟，它与实际时间的偏移率在一个已知的范围内。
- 对于分布式系统，建议给出合适的关于进程执行时间、消息延迟和时钟漂移率的上界和下界是可能的。但是达到实际值并对所选值提供保证是比较困难的。除非能保证上界和下界的值，否则任何基于所选值的设计都不可靠。但是，按同步系统构造算法，可以对算法在实际分布式系统的行为提供一些想法。例如，在同步系统中，可以使用超时来检测进程的故障，参见下面的2.4.2节。
- 同步分布式系統是能够被构造出来的。所要求的是进程用已知的资源需求完成任务，这些资源需求保证有足够的处理器周期和网络能力;还有要为进程提供漂移率在一定范围内的时钟。
- 异步分布式系统:许多分布式系统，例如互联网，是非常有用的，但它们不具备同步系统的资格。

因此我们需要另一个模型。异步分布式系统是对下列因素没有限制的系统:
- 进程执行速度 例如， 进程的一步可能只花费亿万分之一秒，而进程的另一步要花费一个世纪的时间，也就是说，每一步能花费任意长的时间。
- 消息传递延迟 例如， 从进程A到进程B传递一个消息的时间可能快得可以忽略，也可能要花费几年时间。换句话说，消息可在任意长时间后接收到。
- 时钟漂移率 时钟漂移率可以是任意的。

异步模型对执行的时间间隔没有任何假设。这正好与互联网一致，在互联网中,服务器或网络负载没有内在的约束，对像用FTP传输文件要花费多长时间也没有限制。有时电子邮件消息要花几天时间才能到达。下面的“Pepperland协定”部分说明在异步分布式系统中达成协定的困难性。即使有这些假设，有些设计问题也能得到解决。例如，虽然Web并不总能在一个合理的时间限制内提供特定的响应，但浏览器的设计可以做到让用户在等待时做其他事情。对异步分布式系统有效的任何解决方案对同步系统同样有效。

实际的分布式系统经常是异步的，因为进程需要共享处理器，而通信通道需要共享网络。例如，如果有太多特性未知的进程共享一个处理器，那么任何一个进程的性能都不能保证。但是，有许多不能在异步系统中解决的设计问题,在使用时间的某些特征后就能解决。在最终期限之前传递多媒体数据流的每个元素就是这样-个问题。对这样的问题，可使用同步模型。

事件排序。在许多情况下， 我们有兴趣知道一个进程中的一个事件(发送或接收一个消息)是发生在另一个进程中的另一个事件之前、之后或同时。尽管缺乏精确的时钟，但系统的执行仍能用事件和它们的顺序来描述。
### 故障模型
在分布式系统中，进程和通信通道都有可能出故障，即它们可能偏离被认为是正确或所期望的行为。故障模型定义了故障可能发生的方式，以便理解故障所产生的影响。Hadzilacos 和Toueg [ 1994]提供了一种分类法，用于区分进程故障和通信通道故障。这些故障将分别在下面的“ 遗漏故障”、“随机故障”和“时序故障”部分介绍。

本书将贯穿使用故障模型。例如:
- 第4章给出数据报和流通信的Java接口，它们分别提供不同程度的可靠性。
- 第5章给出支持RMI的请求-应答协议。它的故障特征取决于进程和通信通道两者的故障特征。该协议能用数据报或流通信实现。可根据实现的简单性、性能和可靠性作出决定。
- 第17章给出事务的两阶段的提交协议。它用于在面对进程和通信通道的确定性故障时完成事务。

遗漏故障。遗漏故障类错误指的是进程或通信通道不能完成它应该做的动作。
- 进程遗漏故障:进程主要的遗漏故障是崩溃。当我们说进程崩溃了，意为进程停止了，将不再执行程序的任何步骤。能在故障面前存活的服务,如果假设该服务所依赖的服务能干净利落地崩溃，即进程仍能正确运行或者停止运行,那么它的设计能被简化。其他进程通过下列事实能检测到这种进程崩溃:这个进程一再地不能对调用消息进行应答。然而，这种崩溃检测的方法依赖超时的使用，即进程用一段固定时间等待某个事件的发生。在异步系统中，超时只能表明进程没有响应一它 可能是崩溃了，也可能是执行速度慢，或者是消息还没有到达。如果其他进程能确切检测到进程已经崩溃，那么这个进程崩溃称为故障-停止。在同步系统中,
如果确保消息已被传递，而其他进程又没有响应时，进程使用超时来检测，那么就会产生故障--停止
行为。
- 通信遗漏故障:考虑通信原语send和re-ceive。进程p通过将消息m插人到它的外发消息缓冲区来执行send。通信通道将m传输到q的接收消息缓冲区。进程q通过将m从它的接收消息缓冲区取走并完成传递来执行receive ( 见图2-14)。通常由操作系统提供外发消息缓冲区和接收消息缓冲区。![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211201103811.png)
- 随机故障术语随机故障或拜占庭故障用于描述可能出现的最坏的故障，此时可能发生任何类型的错误。
- 时序故障时序故障适用于同步分布式系统。在这样的系统中，对进程执行时间、消息传递时间和时钟漂移率均有限制。时序故障见图2-16的列表。这些故障中的任何一个均可导致在指定时间间隔内对客户没有响应。![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211201103954.png)
- 故障屏蔽分布式系统中的每个组件通常是基于其他一组组件构造的。利用存在故障的组件构造可靠的服务是可能的。例如，保存有数据副本的多个服务器在其中一个服务器崩溃时能继续提供服务。
- 一对一通信的可靠性虽然基本的通信通道可能出现前面描述的遗漏故障，但用它来构造一个能屏蔽某些故障的通信服务是可能的。
    - 术语可靠通信可从下列有效性和完整性的角度来定义:
        - 有效性:外发消息缓冲区中的任何消息最终能传递到接收消息缓冲区。
        - 完整性:接收到的消息与发送的消息一致，没有消息被传递两次。
    - 对完整性的威胁来自两个方面:
        - 任何重发消息但不拒绝到达两次的消息的协议。要检测消息是否到达了两次，可以在协议中给消息附加序号。
        - 心怀恶意的用户，他们可能插人伪造的消息、重放旧的消息或篡改消息。在面对这种攻击时为维护完整性要采取相应的安全措施。
### 安全模型
在第1章中，我们识别出资源共享是分布式系统的一个激发因素。 在2.3节中，我们用进程来描述分布式系统的体系结构，其中可能封装了如对象、组件或服务等的高层抽象，而且，我们通过与其他进程的交互来访问系统。那个体系结构模型为我们的安全模型提供了基础:
- 通过保证进程和用于进程交互的通道的安全以及保护所封装的对象免遭未授权访问可实现分布式系统的安全。

保护对象。用户运行客户程序，由客户程序向服务器发送调用以完成在对象上的操作。服务器完成每个调用指定的操作并将结果发给客户。

保护进程和它们的交互进程通过发送消息进行交互。消息易于受到攻击，因为它们所使用的网络和通信服务是开放的，以使得任一对进程可以进行交互。服务器和对等进程暴露它们的接口，使得任何其他进程能给它们发送调用。

敌人。为了给安全威胁建模，我们假定敌人(有时也称为对手)能给任何进程发送任何消息，并读取或复制一对进程之间的任何消息，如图2-18所示。这种攻击能很简单地实现，它利用连接在网上的计算机运行一个程序读取那些发送给网络上其他计算机的网络消息，或是运行一个程序生成假的服务请求消息并声称来自授权的用户。攻击可能来自合法连接到网络的计算机或以非授权方式连接到网络的计算机。![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211201104558.png)

来自一个潜在敌人的威胁包括对进程的威胁和对通信通道的威胁。
- 对进程的威胁:在分布式系统中,一个用于处理到达的请求的进程可以接收来自其他进程的消息，但它未必能确定发送方的身份。通信协议(如IP)确实在每个消息中包括了源计算机的地址，但对一个敌人而言，用一个假的源地址生成一个消息并不困难。缺乏消息源的可靠的知识对服务器和客户的正确工作而言是一个威胁，具体解释如下:
    - 服务器:因为服务器能接收来自许多不同客户的调用，所以它未必能确定进行调用的主体的身份。即使服务器要求在每个调用中加入主体的身份，敌人也可能用假的身份生成一个调用。在没有关于发送方身份的可靠知识时，服务器不能断定应执行操作还是拒绝执行操作。例如，邮件服务器不知道从指定邮箱中请求一个邮件的用户是否有权限这样做，或者它是否为来自一个敌人的请求。
    - 客户:当客户接收到服务器的调用结果时，它未必能区分结果消息来自预期的服务器还是来自一个“哄骗”邮件服务器的敌人。因此，客户可能接收到一个与原始调用无关的结果，如一个假的邮件(不在用户邮箱中的邮件)。
- 对通信通道的威胁:一个敌人在网络和网关上行进时能复制、改变或插人消息。当信息在网络上传递时，这种攻击会对信息的私密性和完整性构成威胁，对系统的完整性也会构成威胁。例如，包含用户邮件的结果消息可能泄露给另-一个用户或者可能被改变成完全不同的东西。另一种形式的攻击是试图保存消息的拷贝并在以后重放这个消息，这使得反复重用同一消息成为可能。例如，有些人通过重发请求从一个银行账户转账到另一个银行账户的调用消息而受益。利用安全通道可解除这些威胁，安全通道是基于密码学和认证的，详细内容见下面的描述。

解除安全威胁。下面将介绍安全系统所基于的主要技术。 第11章将详细讨论安全的分布式系统的设计和实现。
- 密码学和共享秘密:假设一对进程(例如某个客户和某个服务器)共享一个秘密，即它们两个知道秘密但分布式系统中的其他进程不知道这个秘密。如果由一对进程交换的消息包括证明发送方共享秘密的信息，那么接收方就能确认发送方是一对进程中的另一个进程。当然，必须小心以确保共享的秘密不泄露给敌人。
- 密码学是保证消息安全的科学,加密是将消息编码以隐藏其内容的过程。现代密码学基于使用密钥(很难猜测的大数)的加密算法来传输数据，这些数据只能用相应的解密密钥恢复。
- 认证:共享秘密和加密的使用为消息的认证(证明由发送方提供的身份)奠定了基础。基本的认证技术是在消息中包含加密部分，该部分中包含足够的消息内容以保证它的真实性。对文件服务器的一个读取部分文件的请求，其认证部分可能包括请求的主体身份的表示、文件的标识、请求的日期和时间，所有内容都用一个在文件服务器和请求的进程之间共享的密钥加密。服务器能解密这个请求并检查它是否与请求中指定的未加密细节相对应。
- 安全通道:加密和认证用于构造安全通道，安全通道作为已有的通信服务层之上的服务层。安全通道是连接一对进程的通信通道，每个进程代表一个主体行事，如图2- 19所示。- 一个安全通道有下列特性:
    - 每个进程确切知道其他正在执行的进程所代表的主体身份。因此，如果客户和服务器通过安全通道通信，那么服务器要知道发起调用的主体身份，并能在执行操作之前检查它们的访向权限。这使得服务器能正确地保护它的对象，以便客户相信它是从真实的服务器上接收到的结果。
    - 安全通道确保在其上传送的数据的私密性和完整性(防止篡改)。
    - 每个消息包括一个物理的或逻辑的时间戳以防消息被重放或重排序。
    - ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211201105007.png)

其他可能的来自敌人的威胁。1.5.3 节简要介绍了两个安全威胁一拒绝服 务攻击和移动代码的部署。作为敌人破坏进程活动的可能的机会，我们要再介绍一下这两个安全威胁。
- 拒绝服务:在这种攻击形式下，敌人通过超量地、无意义地调用服务或在网络上进行消息传送，干扰授权用户的活动，导致物理资源( 网络带宽、服务器处理能力)的过载。这种攻击通常意在延迟或阻碍其他用户的动作。例如，建筑物中的电子门锁可能由于受到对计算机控制的电子锁的过多非法请求而失效。
- 移动代码:如果进程接收和执行来自其他地方的程序代码(如1. 5.3节提到的邮件附件)，那么这些移动代码就会带来新的、有趣的安全问题。这样的代码很容易扮演特洛伊木马的角色，声称完成的是无害的事情但事实上包括了访问或修改资源的代码，这些资源对宿主进程是合法可用的但对代码的编写者是不合法的。实现这种攻击有多种不同的方法，因此必须非常小心地构造宿主环境以避免攻击。其中的大多数问题已在Java和其他移动代码系统中解决了，但从最近的一段历史看，移动代码问题暴露了一些让人窘迫的弱点。这-点也很好地说明了所有安全系统的设计都需要严格的分析。

安全模型的使用。有人认为, 在分布式系统中获得安全是件简单的事，即根据预定义的访问权限控制对象的访问以及通信的安全通道的使用，但是通常却不是这样。安全技术(如加密)和访问控制的使用会产生实质性的处理和管理开销。前面概述的安全模型提供了分析和设计安全系统的基础，其中这些开销保持最少,但对分布式系统的威胁会在许多地方出现，需要对系统网络环境、物理环境和人际环境中所有可能引发的威胁进行仔细的分析。这种分析涉及构造威胁模型，由它列出系统会遭遇
的各种形式的攻击、风险评估和每个威胁所造成的后果。要在抵御威胁所需的安全技术的有效性和开销之间做出权衡。
## 小结        
如2.2节所展示的，从底层物理特性角度，例如，系统的规模、系统内在的异构性、从特性角度(如安全)提供端到端解决方案的实际需求等，分布式系统的复杂性正在增加。这使得从模型角度理解和探讨分布式系统显得更加重要。本章考虑了底层物理模型，并深度考察了支撑分布式系统的体系结构模型和基础模型。

本章从所包含的体系结构模型角度给出了描述分布式系统的方法，明晰了这个设计空间的内涵，包括查看什么在通信以及这些实体如何通信等核心问题，以及基于给定物理基础设施，考虑每个元素可以扮演的角色与合适的放置策略，并把它们补充到设计中去。

本章还介绍了体系结构模式在由底层核心元素(例如上述的客户-服务器模型)构造复杂设计中发挥的关键作用,给出了支持分布式系统的中间件解决方案的主要类型，包括基于分布式对象、组件、Web服务和分布式事件的解决方案。从体系结构模型角度看，客户-服务器方法是一种常见的体系结构模型一 Web 和其他互联网服务(如FIP、新闻和邮件以及Web服务和DNS)均基于这个模型，文件归档和其他本地服务也是如此。像DNS这种有大量的用户并管理大量信息的服务是基于多个服务器的，并使用数据分区和复制来提高可用性和容错能力。客户和代理服务器上的缓存得到广泛使用以提高服务的性能。不过，现在有许多方法对分布式系统进行建模，包括各种可替代的观点，如对等计算和更多的面向问题的抽象(如对象、组件或服务)。

基础棋型补充了体系结构模型，它们帮助从诸如性能、可靠性和安全角度对分布式系统的特性进行推理。特别地，我们给出了交互模型、故障模型和安全模型。它们识别出构造分布式系统的基本组件的共同特征。交互模型关注进程和通信通道的性能以及全局时钟的缺乏。它将同步系统看成在进程执行时间、消息传递时间和时钟漂移上有已知范围的系统，将异步系统看成在进程执行时间、消息传递时间和时钟漂移上没有限制的系统一这是对互联网行为的描述。

故障模型将分布式系统中的进程故障和基本的通信通道故障进行了分类。屏蔽是一项技术，依靠它，可将不太可靠的服务中的故障加以屏蔽，并基于此构造出较可靠的服务。特别是，通过屏蔽基本的通信通道的故障，可从基本的通信通道构造出可靠的通信服务。例如，遗漏故障可通过重传丢失的消息加以屏蔽。完整性是可靠通信的一个性质一它要求接收到的消息 与发送的消息一致，并且没有消息被发送两次。有效性是可靠通信的另一个性质一它要求发送消息缓冲区中的任何消息最终都能传递到接收消息缓冲区。

安全模型可识别出在一个开放的分布式系统中对进程和通信通道可能的威胁。有些威胁与完整性有关:恶意用户可能篡改消息或重放消息。其他的威胁则会损害私密性。另一个安全问题是发送消息所代表的主体(用户或服务器)的认证。安全通道使用密码技术来确保消息的完整性和私密性，并使得相互通信的主体可以进行验证。




