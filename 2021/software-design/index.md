# SEK_base_04

# 软件设计
## 软件工程开发方法与软件设计
### 软件工程开发方法
#### 传统开发方法
- **功能分解法**
    - 以系统需要提供的功能为中心来组织系统
        1. 首先定义各种功能，然后把功能分解为子功能
        2. 对较大的子功能进一步分解，直到可给出明确的定义
        3. 设计功能/子功能所需要的数据结构
        4. 定义功能/子功能之间的接口
    - 作为一种早期的建模方法，没有明确地区分分析与设计
    - 功能分解法的优缺点:
        - 直接地反映用户的需求所以工作很容易开始
        - 不能直接地映射问题域很难检验结
        - 果的正确性
        - 对需求变化的适应能力很差
        - 局部的错误和修改很容易产生全局性的影响
    - 功能分解法得到的系统模型：由模块及其接口构成
- **结构化方法：使用结构化编程、结构化分析和结构化设计技术的系统开发方法**
    - 结构化分析
        - 结构化分析又称数据流法，其基本策略是跟踪数据流，即研究问题域中数据如何流动，以及在各个环节上进行何种处理，从而发现数据流和加工。得到的分析模型是数据流图，主要模型元素是数据流、加工、文件及端点，外加处理说明和数据字典。
    - 结构化设计
        - 与功能分解法基本相同，基于模块的概念建立设计模型，分为概要设计和详细设计
        - 从功能的观点设计系统
        - 自顶向下，逐步分解和细化
        - 将大系统分解为若干模块，主程序调用这些模块实现完整的系统功能
    - 结构化编程
        - 具有一个开始和一个结束的程序或程序模块，并且在程序执行中的每一步都由三个部分之一组成：顺序、选择或循环结构
    - 结构化需求分析方法通常需建立以下模型：
        - 数据流图(Data Flow Diagram, DFD)
            - 描述系统由哪些部分组成、各部分之间有什么联系等
        - 数据字典(Data Dictionary, DD)
            - 定义了数据流图中每一个数据元素
        - 结构化语言(Structured Language)
        - 判定表或判定树(Decision Table/Tree)
            - 详细描述数据流图中不能被再分解的每一个加工的内部处理逻辑
        - 实体联系图(Entity-Relationship Diagram, E-R)
        - 状态转换图(State Transition Diagram, STD)
    - 结构化方法的常见问题
        -  需求的错误
            - 不完整、不一致、不明确
            - 开发人员和用户无法以同样的方式说明需求
            - 需求分析方法与设计方法不一致，分析的结果不能平滑过渡到设计
        - 需求的变化
            - 需求在整个项目过程中始终发生变化
            - 系统功能不断变化
            - 许多变化出现在项目后期
            - 维护过程中发生许多变化
        - 系统结构的崩溃
            - 系统在不断的变化中最终变得不可用
    - 造成上述问题的根本原因：
        - 结构化方法以功能分解和数据流为核心，但是系统功能和数据表示极有可能发生变化；
        -  以ATM银行系统为例：帐户的可选项、利率的不同计算方式、ATM的不同界面
- **信息建模法**
    - 由实体-关系法（E-R方法）发展而来，核心概念是实体和关系。实体描述问题域中的事物，关系描述事物之间在数据方面的联系，都可以带有属性。发展之后的方法也把实体称为对象，并使用类型和子类型的概念，作为实体（对象）的抽象描述。
    - 信息建模法已经很接近面向对象方法，因此有的文献也把它称为一种面向对象方法，但有以下差别：
        1. 强调的重点是信息建模和状态建模，而不是对象建模
        2. 实体中只有属性没有操作
        3. 只有属性的继承，不支持操作的继承
        4. 没有采用消息通讯

#### 面向对象方法
软件工程方法：
- 结构化
    - 复杂世界－>复杂处理过程（事情的发生发展）
    - 设计一系列功能（或算法）以解决某一问题
    - 寻找适当的方法存储数据
- 面向对象
    - 任何系统都是由能够完成一组相关任务的对象构成
    - 如果对象依赖于一个不属于它负责的任务，那么就需要访问负责此任务的另一个
    对象（调用其他对象的方法）
    - 一个对象不能直接操作另一个对象内部的数据，它也不能使其它对象直接访问自
    己的数据
    - 所有的交流都必须通过方法调用

举例：五子棋游戏
- 面向过程（事件）的设计思路就是首先分析问题的步骤：
1. 开始游戏，初始化画面
2. 黑子走，绘制画面，
3. 判断输赢，如分出输赢，跳至步骤6
4. 白子走，绘制画面，
5. 判断输赢，如未分出输赢，返回步骤2，
6. 输出最后结果。
-  面向对象的设计思路是分析与问题有关的实体：
1. 玩家：黑白双方，这两方的行为是一模一样的，
2. 棋盘：负责绘制画面
3. 规则：负责判定诸如犯规、输赢等。

举例：电话安装业务系统：
- 结构化分析-数据流和加工
    - ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211221215208.png)
- 面向对象方法—对象及其关系
    - ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211221215308.png)

- 什么情况下使用结构化的分析方法？
- 什么情况下使用面向对象的分析方法？

面向对象的程序开发：
- 软件设计应尽可能去描述那些极少发生变化的稳定要素：对象
- 银行客户、帐户
- 在结构化程序开发模式中优先考虑的是过程抽象，在面向对象开发模式中优先考虑的是实体(问题域的对象)；
- 主要考虑对象的行为而不是必须执行的一系列动作；
    - 对象是数据抽象与过程抽象的综合；
    - 算法被分布到各种实体中；
    - 消息从一个对象传送到另一个对象；
    - 控制流包含在各个对象的操作内；
    - 系统的状态保存在各个对象所定义的数据抽象中；

**二者本质区别**：
- 面向过程的结构化系统 = 功能 + 数据
- 面向对象的系统 = 对象 + 消息

面向对象方法的优势：
- 面向对象模型更接近于问题域(尽可能模拟人类习惯的思维方式)
    - 以问题域中的对象为基础建模
    - 以对象、属性和操作对问题进行建模
- 反复细化高层模型直到可以实现的程度
    - 努力避免在开发过程中出现大的概念跳变
- 将模型组织成对象的集合
    - 真实世界中的具体事物
        - 售货员、商品、仓库、顾客
        - 飞机、机场等
    - 逻辑概念
        - 商品目录、生产计划、销售
        - 操作系统中的分时策略、军事训练中的冲突解决规则等

把系统看做是一起工作来完成某项任务的相互作用的对象的集合
- 面向对象分析
    - 分析和理解问题域，找出描述问题域和系统责任所需的类及对象，分析它们的内部构成和外部关系，建立OOA 模型。
- 面向对象设计
    - 将OOA 模型细化，描述对象间交互，变成OOD 模型，并且补充与一些实现有关的部分，如人机界面、数据存储、操作细节等。
- 面向对象编程
    - 用一种面向对象的编程语言将OOD 模型中的各个成分编写成程序，由于从OOA→OOD→OOP实现了无缝连接和平滑过渡，因此提高了开发工作的效率和质量。

**OOA/D**:
- 分析：强调的是对问题和需求的调查研究，而不是解决方案
    - 面向对象分析过程中，强调的是在问题领域内发现和描述对象
- 设计：强调的是满足需求的概念上的解决方案（在软件方面和硬件方面），而不是其实现。
    - 面向对象设计过程中，强调的是定义软件对象以及它们如何协作以实现需求。
- 有价值的分析和设计可以概括为：做正确的事（分析）和正确地做事（设计）

**面向对象的基本概念：**
- 对象(Object)
- 类(Class)
- 继承(Inheritance)
- 多态(Polymorphism)
- 消息(Message)

对象（具体。有意义的个体）：
- 对象(Object)：具有责任的实体。一个特殊的，自成一体的容器，对象的数据对于外部对象是受保护的。
- 特性：标识符（区别其他对象）、属性（状态）和操作（ 行为）。
    - 属性(Attribute)：与对象关联的数据，描述对象静态特性；
    - 操作(Operation)：与对象关联的函数，描述对象动态特性；
- 示例
    - 学生：王洪波
    - 属性：姓名，性别，年级，院系；年级 = “2013”
    - 操作：选课、撤销、支付
- 对象是类的实例
- 对象与其他对象之间发生关联关系
- 但这个关联关系要定义为类之间的关系注意将属性划归正确的类

类：
- 具有相同性质、行为、对象关系、语义的对象集合
- 具有相同属性和操作的一组对象的抽象，它为属于该类的全部对象提供了统一的抽象描述
    - 类是概念定义，抽象了同类对象共同的属性和操作
    - 对象是类的一个实例

类与对象的比较
- “同类对象具有相同的属性和操作”是指它们的定义形式相同，而不是说每个对象的属性值都相同。
- 类是静态的，类的存在、语义和关系在程序执行前就已经定义好了。
- 对象是动态的，对象在程序执行时可以被创建和删除。

类的属性的“可见性”(Visibility)分类：
- 公有属性(public) +
- 私有属性(private) -
- 保护属性(protected) #

封装(Encapsulation)：把对象的属性和操作结合成一个独立的单元，并尽可能对外界隐藏数据的实现过程，隐藏实现细节；

**封装的重要意义**：
- 保护对象，避免用户误用；
- 保护客户端(调用程序)，其实现过程的改变 不会影响到相应客户端的改变。

封装带来的问题：
- 编程的麻烦
- 执行效率的损失

解决办法：
- 不强调严格封装，
- 实行可见性控制。

**消息(Message)：**
- 消息传递是对象间通信的手段
    - 通过消息请求/提供服务
- 一个对象向另一个对象发送消息来请求其服务
    - 消息描述：接收对象名、操作名和参数
- 消息类型
    - 同步消息，请求者需要等待响应者返回
    - 异步消息，请求者发出消息后继续自己工作，无需等待响应者返回
    - **消息是实现对象间交互和协同的方法**

泛化（Generalization）/继承（Inheritance）：
- 泛化关系是类元的一般描述和具体描述之间的关系，具体描述建立在一般描述的基础之上，并对其进行了扩展。
- 在共享祖先所定义的成分的前提下允许它自身定义增加的描述，这被称作继承。
    - 表示类与类之间的一般与特殊关系
    - 子 (特殊)类可以继承共享父 (一般)类的属性和操作
        - 单一继承：一个子类只有唯一的一个父类
        - 多重继承：一个子类有一个以上的父类
            - Java不支持多重继承
    - 继承可形成层次化的类结构

**多态(Polymorphism)**：
- 同一个操作作用于不同的对象上可以有不同的解释，并产生不同的执行结果。
    - 接口定义形式相同，但是实现形态不一样
    - 相同的消息发送给不同的对象时，每个对象将根据自己所属类中定义的这个操作去执行，从而产生不同的结果
- 多态支持对外接口统一化，但实现方式多样化
### 软件设计
#### 设计的概念
设计=天才+创造力

良好的软件设计的三个特征
- 目标：设计必须是实现所有包含在分析模型中的明确需求、以及客户期望的所有隐含需求
- 形态：对开发、测试和维护人员来说，设计必须是可读的、可理解的、可操作的指南
- 内容：设计必须提供软件的全貌，从实现的角度去说明功能、数据、行为等各个方面

“软件设计”的定义：
- 设计：为问题域的外部可见行为的规约增添实际的计算机系统实现所需的细节，包括关于人机交互、任务管理和数据管理的细节。 ——Coad/Yourdon

**软件设计在SE中所处的位置**：
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228091547.png)

设计的目标：质量
- “设计阶段”是软件工程中形成质量的关键阶段，其后所有阶段的活动都要依赖于设计的结果。
- “编写一段能工作的灵巧的代码是一回事，而设计能支持某个长久业务的东西则完全是另一回事。”

**软件质量**
- 外部质量：面向最终用户
    - 如易用性、效率、可靠性、正确性、完整性等
- 内部质量：面向软件工程师，技术的角度
    - 如可维护性、灵活性、可重用性、可测试性等
 
#### 设计的原则
软件设计的原则
- 设计原则是系统分解和模块设计的基本标准，应用这些原则可以使代码更加灵活、易于维护和扩展。

**抽象**：
- 抽象是关注事物中与问题相关部分而忽略其他无关部分的一种思考方法

**封装**：
- 封装和信息隐藏是指每个软件单元对其他所有单元都隐藏自己的设计决策， 各个单元的特性通过其外部可见的接口来描述。
- 要求：应将单元接口设计得尽可能简单，并将单元对于环境的假设和要求降至最低。

**模块化**：
- 模块化是在逻辑和物理上将整个系统分解成多个更小的部分，其实质是“分而治之”，即将一个复杂问题分解成若干个简单问题，然后逐个解决。

**系统分解原则：**
- 系统分解的目标：高内聚、低耦合
- 内聚性尽量将同一个功能的模块彼此之间的通信都能放在模块内部封装起来。
    - 如果一个模块或子系统含有许多彼此相关的元素，并且它们执行类似任务，那么其内聚性比较高；如果一个模块或子系统含有许多彼此不相关的元素，其内聚性就比较低。
- 耦合性两个模块或子系统之间依赖关系的强度。
    - 如果两个模块或子系统是松散耦合的，二者相互独立，那么当其中一个发生变化时对另一个产生的影响就很小；如果两个模块或子系统是紧密耦合的，其中一个发生变化就可能对另一个产生较大影响。

**层次化**：
- 分层（Layering）
    - 每一层可以访问下层，不能访问上层 
    - 封闭式结构：每一层只能访问与其相邻的下一层 
    - 开放式结构：每一层还可以访问下面更低的层次 
    - 层次数目不应超过7±2层

**复用**：
- 复用（Reuse）是利用某些已开发的、对建立新系统有用的软件元素来生成新的软件系统，其好处在于提高生产效率，提高软件质量。
- 源代码复用：对构件库中的源代码构件进行复用
- 软件体系结构复用：对已有的软件体系结构进行复用
- 框架复用：对特定领域中存在的一个公共体系结构及其构件进行复用
- 设计模式：通过为对象协作提供思想和范例来强调方法的复用



## 体系结构设计
### 软件体系结构要素
随着软件系统的规模和复杂性不断增加，对系统的全局结构设计和规划变得比算法的选择和数据结构的设计明显重要得多。
#### 软件体系结构概念

软件体系结构（Software Architecture）包括
- 构成系统的设计元素的描述
- 设计元素之间的交互
- 设计元素的组合模式以及在这些模式中的约束。
- **软件体系结构 = 构件 + 连接件 + 约束**

构件(Component)：
- 构件是具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素和数据存储。
- 构件是一个抽象的概念，任何在系统运行中承担一定功能、发挥一定作用的软件体都可看作是构件。
- 构件特点
    - 可分离：一个或数个可独立部署执行代码文件
    - 可替换：构件实例可被其他任何实现了相同接口的另一构件
    实例所替换
    - 可配置：外界可通过规范化的配置机制修改构件配置数据，
    进而影响（或称“定制”）构件的对外服务的功能或行为
    - 可复用：构件可不经源代码修改，无需重新编译，即可应用
    于多个软件项目或软件产品
- 构件组成
    - 接口
        - 构件接口是构件间的契约
        - 一个接口提供一种服务，完成某种逻辑行为
        - **构件作为一个封装的实体，只能通过其接口(Interface)与外部环境交互，表示了构件和外部环境的交互点，内部具体实现则被隐藏起来(Black-box)；**
    - 实现（功能）
        - 构件接口服务的实现
        - 构件核心逻辑实现
        - 构件内部所实现的功能以方法、操作(functions、behaviors)的形式体现出来，并通过接口向外发布，进而产生与其它构件之间的关联。
    - 构件接口与其内部实现应严格分开


连接：
- 连接(Connection)：构件间建立和维护行为关联与信息传递的途径；
- 机制：过程调用、中断、I/O、事件、进程、线程、共享、同步、并发、消息、远程调用、动态连接、API 等等
- 协议(Protocol)（是连接的规约(Specification)，连接的规约是建立在物理层之上的有意义信息形式的表达规定）：
    - 对过程调用来说：参数的个数和类型、参数排列次序
    - 对消息传送来说：消息的格式
    - 目的：使双方能够互相理解对方所发来的信息的语义。
- 除了连接机制/协议的实现难易之外，影响连接实现复杂性的因素之一是“有无连接的返回信息和返回的时间”，分为：
    - 同步 (Synchronous)
    - 异步 (Asynchronous)

**约束**：
- 高层次的软件元素可以向低层次软件元素发出请求，低层次软件元素完成计算后向高层次发送服务应答，反之不行
- 每个软件元素根据其职责位于适当的层次，不可错置，如核心层不能包含界面输入接收职责
- 每个层次都是可替换的，一个层次可以被实现了同样的对外服务接口的层次所替代

#### 软件体系结构的目标
- 软件体系结构关注的是：
    - 如何将复杂的软件系统划分为模块、如何规范模块的构成和性能、以及如何将这些模块组织为完整的系统。
- 主要目标：
    - 建立一个一致的系统及其视图集，并表达为最终用户和软件设计者需要的结构形式，支持用户和设计者之间的交流与理解。
### 软件体系结构风格
定义：
- 描述特定领域中软件系统家族的组织方式的惯用模式，反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效地组织成一个完整的系统。
#### 数据流风格
管道-过滤器风格：
- 把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤
的输出是下一个步骤的输入。
- 每个过滤器独立于其上游和下游的构件而工作，过滤器的设计要针对某种形式的数据
输入，并且产生某种特定形式的数据输出（到下一个过滤器）。过滤器没有必要了解
与之相邻的其他过滤器的工作。
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228095013.png)
- 把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接，一个步骤
的输出是下一个步骤的输入。
- 每个过滤器独立于其上游和下游的构件而工作，过滤器的设计要针对某种形式的数据
输入，并且产生某种特定形式的数据输出（到下一个过滤器）。过滤器没有必要了解
与之相邻的其他过滤器的工作。
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228095043.png)
- **在管道过滤器风格中构件具有良好的隐藏性和高内聚、低耦合的特点，可以很好地支持软件的重用和扩展但是这种结构不适合交互应用的情况，如果管道过长或者过滤器过于复杂的话系统的性能就会大大降低**

#### 以数据为中心的风格（仓库）
例：剪贴板 (Clipboard)
- 剪贴板是一个用来进行短时间的数据存储并在文档/应用之间进行数据传递和交换的软件程序
- 用来存储待传递和交换信息的公共区域(形成共享数据仓库)；
- 访问剪贴板的方式：copy & paste.
- 不同的应用程序通过该区域交换格式化的信息；
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228095240.png)

以数据为中心的体系结构风格(也称仓库风格)
- 数据存储位于这种体系结构的中心，其他构件会经常访问该数据存储，并对存储中的数据进行更新、增加、删除或者修改。

示例：注册表

只要仓库的定义良好就可以很方便地增添功能模块，从而实现向系统添加新的服务，但是这种系统的主要问题在于每个功能模块和仓库之间的耦合非常高，集中式的仓库很有可能成为系统性能的瓶颈


#### **调用和返回体系结构的风格**
主程序-子过程：
- 该风格是结构化程序设计的一种典型风格，从功能的观点设计系统，通过逐步分解和逐步细化，得到系统体系结构。
- 构件：主程序、子程序
- 连接器：调用-返回机制
- 拓扑结构：层次化结构

本质：**将大系统分解为若干模块(模块化)，主程序调用这些模块实现完整的系统功能**。
#### 面向对象体系结构风格
- 系统被看作对象的集合，每个对象都有一个它自己的功能集合
- 数据及作用在数据上的操作被封装成抽象数据类型 (AbstractData Type)
- 只通过接口与外界交互，内部的设计决策则被封装起来
    - 构件：类 
    - 连接件：类之间通过函数调用、消息传递实现交互
#### 层次体系结构风格
- 层次化已经成为一种复杂系统设计的普遍性原则
- 在层次系统中，系统被组织成若干个层次，每个层次由一系列构件组成；
- 层次之间存在接口，通过接口形成call/return的关系
    - 在外层，构件完成建立用户界面的操作
    - 在内层，构件完成建立操作系统接口的操作
    - 在中层，提供各种实用工具服务和应用软件功能
- 很多复杂软件的设计从操作系统到网络系统再到一般的应用几乎都是以层次结构来建立的
- 下层构件向上层构件提供服务，上层构件被看作是下层构件的客户端
- 层次系统的优点
    - 这种风格支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。
    - 由于每一层最多只影响两层，同时只要给相邻层提供相同的接口，允许每层用不同的方法实现，同样为软件复用提供了强大的支持。
- 不同的层次处于不同的抽象级别：
    - 越靠近底层，抽象级别越高；
    - 越靠近顶层，抽象级别越低；

严格分层和松散分层 
- 严格分层系统要求严格遵循分层原则，限制一层中的构件只能与对等实体以及与它紧邻的下面一层进行交互 
    - 优点：修改时的简单性 
    - 缺点：效率低下
- 松散的分层应用程序放宽了此限制，它允许构件与位于它下面的任意层中的组件进行交互 
    - 优点：效率高 
    - 缺点：修改时困难

**层次体系结构风格：**
- 客户机-服务器（C/S）
    - 客户机/服务器(Client/Server, C/S)：一个应用系统被分为两个逻辑上分离的部分，每一部分充当不同的角色、完成不同的功能，多台计算机共同完成统一的任务。
        - 客户机(前端，front-end)：用户交互、业务逻辑、与服务器通讯的接口；
        - 服务器(后端，back-end)：与客户机通讯的接口、业务逻辑、数据管理。
    - 一般的，客户机为完成特定的工作向服务器发出请求；服务器处理客户机的请求并返回结果。
    - 三层客户机/服务器(Client/Server, C/S)体系结构：在客户端与数据库服务器之间增加了一个中间层
        - 表示层：用户界面—界面设计
        - 业务逻辑层：业务处理—程序设计
        - 数据层：数据存储—数据库设计
    - 胖客户端与瘦客户端：在客户端多一些还是在服务器端多一些？
        - 胖客户端：客户端执行大部分的数据处理操作
        - 瘦客户端：客户端具有很少或没有业务逻辑
- 浏览器-服务器（B/S）
    - 浏览器/服务器(Browser/Server)是四层C/S风格的一种实现方式 。
        - 表现层：浏览器
        - 逻辑层：
            - Web服务器
            - 应用服务器
        - 数据层：数据库服务器
    - 示例：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228100738.png)
    - 浏览器/服务器(Browser/Server)：基于B/S体系结构的软件，系统安装、修改和维护全在服务器端解决，系统维护成本低：
        - 客户端无任何业务逻辑，用户在使用系统时，仅仅需要一个浏览器就可运行全部的模块，真正达到了“零客户端”的功能，很容易在运行时自动升级。
        - 良好的灵活性和可扩展性：对于环境和应用条件经常变动的情况，只要对业务逻辑层实施相应的改变，就能够达到目的。
    - B/S成为真正意义上的“瘦客户端”，从而具备了很高的稳定性、延展性和执行效率。
    - B/S将服务集中在一起管理，统一服务于客户端，从而具备了良好的容错能力和负载平衡能力。
- C/S,B/S混合模式
    - C/S+B/S混合模式：为了克服C/S与B/S各自的缺点，发挥各自的优点，在实际应用中，通常将二者结合起来
    - **遵循“内外有别”的原则**：
        - 企业内部用户通过局域网直接访问数据库服务器
            - C/S结构；
            - 交互性增强；
            - 数据查询与修改的响应速度高；
        - 企业外部用户通过Internet访问Web 服务器/应用服务器
            - B/S结构；
            - 用户不直接访问数据，数据安全；

## 类/数据建模与设计
### CRC卡片分拣法-面向对象方法
识别类的方法
- 使用CRC寻找类。
    - CRC是类 (Class) 、责任 (Responsibility) 和协作(Collaboration)的简称，CRC分析法根据类所要扮演的职责来确定类。
    - 根据边界类、控制类和实体类的划分来帮助发现系统中的类
    - 对领域进行分析，或利用已有的领域分析结果得到类
    - 参考分析、设计模式来确定类

Blackjack游戏：
- 通过名词过滤识别出的对象类
- 类筛选
- 确定初始类
- 识别类的功能职责
### **DFD-结构化方法**
结构化需求分析方法通常需建立以下模型：
- 数据流图(Data Flow Diagram, DFD)
    - 描述系统由哪些部分组成、各部分之间有什么联系等
- 数据字典(Data Dictionary, DD)
    - 定义了数据流图中每一个数据元素
- 结构化语言(Structured Language)
- 判定表或判定树(Decision Table/Tree)
    - 详细描述数据流图中不能被再分解的每一个加工的内部处理逻辑
- 实体联系图(Entity-Relationship Diagram, E-R)
- 状态转换图(State Transition Diagram, STD)

数据流图(Data Flow Diagram, DFD)：结构化系统分析的基本工具
- 描绘数据在系统中各逻辑功能模块之间的流动和处理过程，是一种功能模型
- 主要刻画“功能的输入和输出数据”、“数据的源头和目的地”

DFD的主要元素：
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228102944.png)
- 加工(又称数据处理，data processing)：对数据流进行某些操作或变换。
    - 收集、排序、选择、聚集、分析等
    - 加工要有名字，通常是动词短语，简明地描述完成什么事情
    - 在分层的数据流图中，加工还应编号
    - 三种类型：计算机自动加工、手工加工、人机协作的加工
- 数据存储(data storage，也称文件)：需要在外存储器上保存的数据，它可以是数据库文件或任何形式的数据组织。
    - 以名词命名
- 外部实体(external entity)：本系统外部环境中的实体(包括人员、组织或其他软件系统)
    - 也称为“数据源点/数据终点”，表示产生数据的源头或消费数据的终点
    - 以名词短语命名
    - 不能直接访问数据存储
- 数据流(data flow)：数据在系统内传播的路径
    - 由一组成分固定的数据组成。
    - 由于数据流是流动中的数据，所以必须有流向
    - 应用名词或名词短语命名
    - 可能是纸张上的数据、电子数据、通过网络传输的数据等
    - 可能存在于：
        - 外部实体与加工之间；
        - 加工与加工之间；
        - 加工与数据存储之间

**简单练习**：
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228103410.png)

DFD的层次性：自顶向下的分解(top-down)
- DFD的两种类型：
    - 环境关联DFD图(Context-level DFD，或Context Diagram)：也称顶层DFD图，描述了系统与外部环境之间的数据输入/输出关系；
    - 系统内部DFD图(Inner-level DFD)：描述系统内部各功能模块之间的数据流动关系
        - 0-层DFD图
        - 1-层DFD图
        - …
        - N层DFD图

顶层DFD图(关联图)
- 通过系统和外部世界之间的联系来描述系统的范围
- 确定了通过某一接口与系统相连的外部实体，同时也确定了外部实体和系统之间的数据流
- **只包含一个加工**，用以表示被开发的系统，然后考虑该系统有哪些输入数据、输出数据流
- 加工编号：0
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228103722.png)

0层DFD:
- 将顶层DFD图中的系统分解为若干个子系统，决定每个子系统间的数据接口和活动关系，得到0层DFD图；
- 加工编号：1、2、…、n
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228103809.png)

底层DFD:
- 针对0层DFD中的每一个子系统，对其继续分解得到细化的加工，进而逐渐向下构造得到1层DFD、2层DFD、…、n层DFD，一直到不能或不需再分解为止。
- 最底层DFD中的加工称为“基本加工”。
- 编号：
    - 1层DFD：1.1、1.2、…、1.n
    - 2层DFD：1.1.1、1.1.2、…、1.1.n
    - …
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228104011.png)

数据流的分解：
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228104046.png)

绘制DFD的一些基本原则：
- **把数据存储放在0层数据流图或更低层子图上，不要放在顶层的关联图上**
- 使用数据流图时，不要试图让数据流图反映处理的顺序，忽略系统的运行时的时间特性
- 加工通过数据存储进行通讯，而尽量避免从一个过程直接流到另一过程
- **数据不能直接由一个数据存储直接流到另一个数据存储**
- **数据不能直接从一个外部实体直接流到一个数据存储**
- **数据不能直接从一个数据存储直接流到一个外部实体**
- **数据不能直接在外部实体之间流动**
- 数据流是单向的
- 任何加工必须有输入和输出数据流
- 对现有加工进行持续的分解和组合，直到所有加工之间达到较高的聚合度；
- **尽量将每一张DFD上的所有元素数目控制在7-12个**。

**错误示例**：
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228104243.png)
## 行为建模与设计
### 状态图（Statechart Diagram)
**状态图(Statechart Diagram)描述了一个特定对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转移。**

- UML的状态图
    - 主要用于建立类的一个对象在其生存期间的动态行为，表现一个对象所经历的状态序列，引起状态转移的事件(Event),以及因状态转移而伴随的动作(Action)。
- 状态图适合于描述跨越多个用例的单个对象的行为，而不适合描述多个对象之间的行为协作，因此，常常将状态图与其它技术组合使用。

“状态”建模
- 所有的对象都有“状态”
    - 对象存在或者不存在
        - 对象不存在也是一种状态
    - 如果对象存在，则具有相应表示其属性的值
    - 每一种状态表示一种可能的状态赋值
- 例如：栈
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228104610.png)

**状态空间**：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211229204632.png)

模型建立的过程——状态空间的分解
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228104718.png)

状态图建模 
- 建模元素 
    - 状态 
        - 一个对象在生命期中满足某些条件、执行一些行为或者等待一个事件时的存在条件。
        - 实体对象都具有状态，状态是对象执行了一系列活动的结果。当某个事件发生后，对象的状态将发生变化
    - 状态转移 
    - 事件 
- 特殊的状态 
    - 初始状态、结束状态 
        - 一个状态图只能有一个初始状态，一个状态图可以有多个结束状态
    - 组合状态 
    - 历史状态 
- 状态图的绘制

状态种类：
- 组合状态：可以通过状态嵌套的方式简化图表
    - 一个组合状态可以包含一个或多个状态
    - 组合状态可以实现从不同抽象层次去体现状态图
    - 嵌套在另外一个状态中的状态称之为子状态（sub-state）,一个含有子状态的状态被称作组合状态（Compound States）
    - 【Check PIN】是组合状态，【Enter PIN】是子状态。
    - ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228105249.png)
- 历史状态
    - 使用历史状态，可以记住从组合状态中退出时所处的子状态，当再次进入组合状态时，可直接进入到这个子状态，而不是再次从组合状态的初态开始。
    - H和H*的区别：
        - H只记住最外层的组合状态的历史。
        - H*可记住任何深度的组合状态的历史。
    - 例：这里的H只记录Backing Up的状态

状态活动：
- 状态相关的活动类型
    - do/activity
        - 只要处于这个状态，某个活动就会一直执行，直到离开这个状态
    - entry/action and exit/action
        - 当进入（/离开）某个状态时执行的动作
    - include/stateDiagramName
        - 调用另一个状态图，形成嵌套的状态图

状态迁移(Transitions)
- **迁移包括五部分（源状态、目标状态、触发事件、警戒条件、触发事件、动作）：**
    - 转换是状态图的一个组成部分，表示一个状态到另一个状态的移动。
    - 状态之间的转移通常是由事件触发的，此时应在转移上标出触发转移的事件表达式。如果转移上未标明事件，则表示在源状态的内部活动执行完毕后自动触发。
    - 警戒条件:
        - 一个true或false测试表明是否需要进行转换
        - **当事件发生时，只有在保护条件（警戒条件）为真时才发生转换**
    - 对于给定的状态，最终只能产生一个迁移，因此从相同的状态出来的、 事件相同的几个迁移之间的条件应该是互斥的。

状态中的事件(Event):
- UML中事件分为四类
    - Call Event (调用某个操作)
    - Change Event：when (temperature > 120)
    - Signal event (触发事件)
    - Time event：after 5 seconds

状态图建模风格
- 建模风格1：把初态放置在左上角；把终态放置在右下角
- 建模风格2：用过去式命名转移事件
- 建模风格3：警戒条件不要重叠
- 建模风格4：不要把警戒条件置于初始转移上

状态图的检查表
- 绘图风格
    - 每个状态的命名应该是唯一的，意义明确的
    - 只对行为复杂的状态使用组合状态建模
    - 不要在一个图中包含太多细节
    - 使用警戒条件时要特殊注意不要引入二义性
        - 状态图应该具有确定性（除非特殊原因）
- **下述情况不适宜使用状态图：**
    - 当大部分的状态转移为“当这个状态完成时”
    - 有很多来自对象自身发出的触发事件

### 顺序图（Sequence Diagram）
顺序图
- 顺序图是强调消息时间顺序的交互图
- 顺序图描述了对象之间传送消息的时间顺序，表示用例中的行为顺序
- 顺序图将交互关系表示为一个二维图。其中，纵轴是时间轴，时间沿竖线向下延伸。横轴代表了在协作中各独立的对象
- 顺序图用来刻画系统实现某个功能的必要步骤

**顺序图的组成**
- 对象（Object）：类的实例，以某种角色参与交互，可以是人，物，其他系统或者子系统
    - 对象可以是系统的参与者或者任何有效的系统对象。对象是类的实例，它使用包围名称的矩形框来标记。名称带下划线。顺序图中对象的标记符如下
    - ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228111552.png)
    - 对象的创建与撤销
        - 如果对象位于顺序图的顶部，说明在交互开始之前该对象已经存在了。如果对象是在交互的过程中创建的，新建的对象在图中的位置较低。
        - 对象在创建消息发生之后才能存在，对象的生命线也是在创建消息之后才存在的。
        - 如果要撤销一个对象，只要在其生命线终止点放置一个“X”符号即可，该点通常是对删除或取消消息的回应。
- 生命线（Lifeline）：表示对象存在的时间
    - 生命线在顺序图中表示为从对象图标向下延伸的一条虚线，表示对象存在的时间
- 激活（Activation） ：表示对象进行操作的时间片段
    - 控制焦点/激活期(Focus of Control/Activation)表示对象进行操作的时间片段
        - 激活表示该对象被占用以完成某个任务，去激活指的则是对象处于空闲状态、在等待消息。
        - 在UML中，为了表示对象是激活的，可以将该对象的生命线拓宽成为矩形。其中的矩形称为激活条或控 制期，对象就是在激活条的顶部被激活的，对象在完成自己的工作后被去激活
    - 控制焦点/激活期(Focus of Control/Activation)的嵌套
        - 嵌套的FOC可以更精确地说明消息的开始和结束位置
        - 嵌套的FOC可以表示递归
    - 顺序图中时间约束的表示
        - 用约束(constraint)来表示

        
- 消息（Message）：
    - 消息(Message)用于描述对象间的交互操作和值传递过程，在UML中，消息使用箭头来表示，箭头的类型表示了消息的类型。
        - 对象之间的消息只能单路通信、消息用箭头表示
    - **消息类型**
        - Synchronous 同步消息（调用消息）
        - Asynchronous 异步消息
        - Return 返回消息
        - Time-out 超时等待
        - Self-message 自关联消息
    - 同步消息（调用消息）
        - 把调用的消息发给接受者、等待接受者放弃或者返回信息、接受者返回信息之前不能发送任何别的消息、并且工作流程被中断
    - 异步消息
        - 简单的说就是把消息发给接受者、不用等待接受者的反馈、可以给别的对象发消息异步消息可以并发工作
        - 用户登陆电影可视化系统，输入用户名和密码，发出登陆请求是同步消息还是异步消息？
        - 微信公众号向用户推送一篇文章，推送是同步消息还是异步消息
        - 我去银行办理业务，可能会有两种方式：
            1. 选择排队等候
            2. 另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了
    - 返回消息
        - 发送给对象的异步消息或调用消息、对象给的反馈、称作返回消息
        - 如果是过程调用的返回、返回消息是隐含的、所以返回消息可以不用画
        出来
        - 如果是非过程的、返回消息要明确的表示出来！
    - 超时消息
        - 接受者在指定时间内无法接受此消息、则发送者放弃这个消息
    - 自关联消息
        - 消息发送者给自己发消息

复合片段
- 一个复杂的顺序图可以划分为几个小块，每一个小块称为一个复合片段。每个复合片段由一个大方框包围，其名称显示在方框左上角的间隔区内，表示该顺序图的信息。
    - alt:多条路径，条件为真时执行。if/else -> (alt)[condition] 通过水平虚线分割不同情形。
    - opt:任选，仅当条件为真时执行。If -> (opt)[condition]
    - par:并行，每一片段都并发执行
    - loop:循环，片段可多次执行
- 例子：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228113410.png)


绘制顺序图步骤
1. 在顺序图顶端绘制矩形框，定义参与交互的类实例（对象）名；
2. 在每个对象下面绘制竖直虚线，表示该对象的生命线；
3. 在对象间添加箭头表示各种类型的消息，跟踪对象间的控制流；
4. 生命线加竖直矩形定义对象激活期，表明对象正在执行某操作；
5. 根据需要添加框的组合与关联，表示复杂的控制结构。

**例子：银行系统的交易验证：**
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228113452.png)

顺序图建模意义
- 通过顺序图描述算法逻辑
- 高质量的顺序图是代码的抽象
- 顺序图是与语言无关的表示方式
- 可以绘制顺序图来描述业务逻辑
- 可以通过团队协作完成顺序图的绘制
- 可以在同一页浏览多个对象和类的行为
### 协作图（Collaboration Diagram）
协作图
- 协作图是交互图的另一种表现形式，它强调参加交互的各对象的组织。主要用于描述一组相互合作的对象间的交互和链接。
- 协作图只对相互间有交互作用的对象和这些对象间的关系建模，而忽略了其他对象和关联。
- 时序图主要描述对象间消息发送的时间顺序，而协作图侧重于描述交互对象之间的链接关系，而不专门突出这些消息发送的时间顺序。
- 协作图不像时序图一样具备时间维，为了表示消息的时间顺序，通常要为消息加一个数字前缀。
- **协作图由对象、链接和消息组成。**
    - --使用实线表示两个对象间的链接
    - --消息由标记在连接上方的带有标记的箭头表示
- 例子：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228113655.png)

时序图与协作图比较：
- 时序图和协作图都属于交互图，都用于描述系统中对象之间的动态关系。两者可以相互转换，但两者强调的重点不同。
- --当对象及其连接有利于理解对象之间的交互时,选择协作图；
- --当强调消息发送的时间顺序时,选择时序图。
- --时序图中有对象生命线和控制焦点，协作图中没有；协作图中有路径，并且协作图中的消息必须要有顺序号，但时序图中没有这两个特征。
- 实际应用中，一般采用时序图。

对比例子：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228113759.png)
### 活动图（Activity Diagram）
活动图（Activity Diagram）
- 一般学习过c语言或别的程序设计语言的同学一定接触过流程图，因为流程图清晰的表达了程序的每一个步骤序列、过程、判定点和分支。
- 在UML里，**活动图本质上就是流程图**，描述系统的活动、判定点、分支等，可用于对系统的业务需求建模，因此它对于开发人员来说是一种重要的工具。
- UML活动图记录了单个操作或方法的逻辑，单个用户案例或者单个业务流程的逻辑。
- 也可以说，活动图是用图形化的方式描述事件流
- (即描述用例图中某个用例的逻辑流程)

活动图的基本概念和组成
- 从系统内部视角来看，活动图反映的是系统功能所要完成的动作过程。它定义了工作流从何时开始、哪里开始、按什么顺序发生、最终在哪结束。
- 活动图由起始状态、终止状态、活动、状态转移、决策、守护条件、同步棒和泳道组成。
- 活动图的起始状态和终止状态的表示同状态图。
- 活动图中的活动用圆角四边形表示，内部文字说明采取的动作。动作间的转移用带有箭头的实线表示。
- 守护条件：用来约束转移，守护条件为真时转移才可以开始。
- 决策：活动图中的决策用一个菱形表示。分支表示一个触发事件在不同的触发条件下引起多个不同的转移。
- 分支可以有一个进入转移和两个或多个输出转移。在每条输出转移上都有守护条件（即一个布尔表达式）保护，当且仅当守护条件的值为真时，该输出路径才有效。
- 同步棒：在建模过程中，可能会遇到对象在运行时存在两个或多个并发运行的控制流。所有的并行转移在合并前必须被执行。
- 在UML中，一条粗黑线表示将转移分解成两个或多个并发流，同样用粗黑线表示分支的合并。粗黑线称为同步棒。
- 泳道：
    - 活动图告诉你发生了什么，但没有告诉你该项活动由谁来完成。在程序设计中，这意味着活动图没有描述出各个活动由哪个类来完成。泳道解决了这一问题。
    - 泳道：用矩形框来表示，属于某个泳道的活动放在该矩形框内，将对象名放在矩形框的顶部，表示泳道中的活动由该对象负责。
    - 泳道可以提高活动图的可读性,可用于建模某些复杂的活动图。
    - ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228114310.png)

**例子：“记录学生分数”的活动图：**
- ![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228114056.png)
- 注:活动图与状态图的标记符非常相似，有时会让人混淆。其实, 
- 活动图是用来建模不同区域的工作如何彼此交互的；而状态图用
来表示单个的对象，以及对象的行为如何改变其状态。

例子：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228114155.png)

**活动图的优缺点：**
- 活动图最适合支持描述并行行为，这使之成为支持工作流建模的最好工具
- 但活动图最大的缺点是很难清楚地描述动作与对象之间的关系。

活动图的用途
- 活动图用于对系统的动态行为建模。活动图描述了从活动到活动的流。
- 在对一个系统建模时，通常有两种使用活动图的方式：
- (1)为工作流建模
- 对工作流建模强调与系统进行交互的对象所观察到的活动。用于可视化、详述、构造和文档化开发系统所涉及的业务流程。
- (2)为对象的操作建模
- 活动图本质上就是流程图，他描述系统的活动、判定点、分支等部分。因此，在UML中，可以把活动图作为流程图来使用，用于对系统的操作建模。

活动图的适用范围
- 对于以下情况可以使用活动图
- (1)分析用例，即用图形化的方式描述用例的事件流；
- (2)理解牵涉多个用例的工作流，即描述系统的业务流程；
- (3)处理多线程应用。
## 物理建模与设计
### 组件图
**组件图是对面向对象系统的物理方面建模时使用的两种图之一，另一种图是配置图**。目前，演示意义大于实际意义。

组件图和配置图统称系统的实现图。其中组件图显示代码本身的逻辑结构；配置图显示系统运行前的结构。

组件图描述软件组件以及组件之间的关系。**组件是代码的软件模块，组件图则显示了代码的结构**。

组件图画在组件视图(Component View)下面。

组件图显示了组件以及它们之间的管理信息

组件
- 组件是代码的软件模块，一般来说，就是一个实际文件。
- **组件包括以下类型**：
- --源代码组件
- --二进制组件
- --可执行组件
- **组件的特点**：
    - 组件是物理的
    - 组件是可替代的
    - 组件是系统的一部分

组件图的作用
- 每个组件体现了系统设计中特定类的实现。良好定义的组件不直接依赖于其他组件而依赖于组件所支持的接口
- 每个组件实现一些接口，并使用另一些接口。
- 组件图的用途是显示系统中的组件之间的依赖关系，以及组件的接口和调用关系。

