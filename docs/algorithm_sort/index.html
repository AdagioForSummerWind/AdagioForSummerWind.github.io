<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Algorithm_sort - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Algorithm_sort" />
<meta property="og:description" content="排序算法 冒泡 选择 插入 希尔 归并 优先队列及堆 快速 内置库使用快排的原因 堆排序 https://segmentfault.com/a/1190000039668324 https://www.cnblogs.com/onepixel/p/7674659.html 排序算法 稳定性概念 定义：能保证两个相等的数，经过排序之后，其在序列" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/algorithm_sort/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-20T19:52:01+08:00" />
<meta property="article:modified_time" content="2022-11-21T11:22:01+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Algorithm_sort"/>
<meta name="twitter:description" content="排序算法 冒泡 选择 插入 希尔 归并 优先队列及堆 快速 内置库使用快排的原因 堆排序 https://segmentfault.com/a/1190000039668324 https://www.cnblogs.com/onepixel/p/7674659.html 排序算法 稳定性概念 定义：能保证两个相等的数，经过排序之后，其在序列"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/algorithm_sort/" /><link rel="prev" href="https://jefofrank.xyz/cn_http/" /><link rel="next" href="https://jefofrank.xyz/algorithm_find/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Algorithm_sort",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/algorithm_sort\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "data structure","wordcount":  7430 ,
        "url": "https:\/\/jefofrank.xyz\/algorithm_sort\/","datePublished": "2022-02-20T19:52:01+08:00","dateModified": "2022-11-21T11:22:01+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Algorithm_sort</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/ms/"><i class="far fa-folder fa-fw"></i>MS</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-02-20 19:52:01">2022-02-20 19:52:01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7430 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#冒泡">冒泡</a></li>
    <li><a href="#选择">选择</a></li>
    <li><a href="#插入">插入</a></li>
    <li><a href="#希尔">希尔</a></li>
    <li><a href="#归并">归并</a></li>
    <li><a href="#优先队列及堆">优先队列及堆</a></li>
    <li><a href="#快速">快速</a></li>
    <li><a href="#内置库使用快排的原因">内置库使用快排的原因</a></li>
    <li><a href="#堆排序">堆排序</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><ul>
<li><a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" rel="">排序算法</a>
<ul>
<li><a href="#%e5%86%92%e6%b3%a1" rel="">冒泡</a></li>
<li><a href="#%e9%80%89%e6%8b%a9" rel="">选择</a></li>
<li><a href="#%e6%8f%92%e5%85%a5" rel="">插入</a></li>
<li><a href="#%e5%b8%8c%e5%b0%94" rel="">希尔</a></li>
<li><a href="#%e5%bd%92%e5%b9%b6" rel="">归并</a></li>
<li><a href="#%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97%e5%8f%8a%e5%a0%86" rel="">优先队列及堆</a></li>
<li><a href="#%e5%bf%ab%e9%80%9f" rel="">快速</a></li>
<li><a href="#%e5%86%85%e7%bd%ae%e5%ba%93%e4%bd%bf%e7%94%a8%e5%bf%ab%e6%8e%92%e7%9a%84%e5%8e%9f%e5%9b%a0" rel="">内置库使用快排的原因</a></li>
<li><a href="#%e5%a0%86%e6%8e%92%e5%ba%8f" rel="">堆排序</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000039668324" target="_blank" rel="noopener noreffer">https://segmentfault.com/a/1190000039668324</a>
<a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener noreffer">https://www.cnblogs.com/onepixel/p/7674659.html</a></p>
</blockquote>
<h1 id="排序算法">排序算法</h1>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220220204617.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220220204617.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220220204617.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220220204617.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220220204617.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220220204617.png" /></p>
<p>稳定性概念</p>
<ul>
<li>定义：能保证两个相等的数，经过排序之后，其在序列的前后位置顺序不变。（A1=A2，排序前A1在A2前面，排序后A1还在A2前面）</li>
<li>意义：稳定性本质是维持具有相同属性的数据的插入顺序，如果后面需要使用该插入顺序排序，则稳定性排序可以避免这次排序。</li>
</ul>
<p>冒泡排序，直接选择排序，直接插入排序被认为是初级的排序算法。中等规模用希尔排序，大规模排序使用快排、归并、堆排序这些高级排序算法。快排综合性能最好，甚至成为了很多编程库内置的排序算法。</p>
<h2 id="冒泡">冒泡</h2>
<p>时间复杂度一般是$O(n^2)$。冒泡排序是效率较低的排序算法，可以说是最慢的排序算法了，我们只需知道它是什么，在实际编程中一定不能使用如此之慢的排序算法!</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 冒泡排序 (bubble sort)
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">sorts</span>

<span class="kd">func</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">swapped</span> <span class="o">:=</span> <span class="kc">true</span>
    <span class="k">for</span> <span class="nx">swapped</span> <span class="p">{</span>
        <span class="nx">swapped</span> <span class="p">=</span> <span class="kc">false</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="nx">swapped</span> <span class="p">=</span> <span class="kc">true</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="选择">选择</h2>
<p>效率同样低下的排序算法。可以在每次循环选择时既选择最小的数，也选择最大的数，以减少循环次数达到优化的目的。工程上同样避免使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 选择排序 (selection sort)
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">sorts</span>

<span class="kd">func</span> <span class="nf">SelectionSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">min</span> <span class="o">:=</span> <span class="nx">i</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">]</span> <span class="p">{</span>
                <span class="nx">min</span> <span class="p">=</span> <span class="nx">j</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="nx">tmp</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">]</span>
        <span class="nx">arr</span><span class="p">[</span><span class="nx">min</span><span class="p">]</span> <span class="p">=</span> <span class="nx">tmp</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="插入">插入</h2>
<p>时间复杂度：$O(n)-O(n^2)$</p>
<p>数组规模 n 较小的大多数情况下，我们可以使用插入排序，它比冒泡排序，选择排序都快，甚至比任何的排序算法都快。</p>
<p>数列中的有序性越高，插入排序的性能越高，因为待排序数组有序性越高，插入排序比较的次数越少。</p>
<p>数据规模较大时，效率也低。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">insertionSortList</span><span class="p">(</span><span class="nx">head</span> <span class="o">*</span><span class="nx">ListNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">ListNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">head</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">dummyHead</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span><span class="nx">Next</span><span class="p">:</span> <span class="nx">head</span><span class="p">}</span>
    <span class="nx">lastSorted</span><span class="p">,</span> <span class="nx">curr</span> <span class="o">:=</span> <span class="nx">head</span><span class="p">,</span> <span class="nx">head</span><span class="p">.</span><span class="nx">Next</span>
    <span class="k">for</span> <span class="nx">curr</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">lastSorted</span><span class="p">.</span><span class="nx">Val</span> <span class="o">&lt;=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
            <span class="nx">lastSorted</span> <span class="p">=</span> <span class="nx">lastSorted</span><span class="p">.</span><span class="nx">Next</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">prev</span> <span class="o">:=</span> <span class="nx">dummyHead</span>
            <span class="k">for</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Next</span><span class="p">.</span><span class="nx">Val</span> <span class="o">&lt;=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
                <span class="nx">prev</span> <span class="p">=</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Next</span>
            <span class="p">}</span>
            <span class="nx">lastSorted</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span>
            <span class="nx">curr</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Next</span>
            <span class="nx">prev</span><span class="p">.</span><span class="nx">Next</span> <span class="p">=</span> <span class="nx">curr</span>
        <span class="p">}</span>
        <span class="nx">curr</span> <span class="p">=</span> <span class="nx">lastSorted</span><span class="p">.</span><span class="nx">Next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">dummyHead</span><span class="p">.</span><span class="nx">Next</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 插入排序 (insertion sort)
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">insertSort</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)[]</span><span class="kt">int</span><span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]&gt;</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">j</span><span class="p">,</span><span class="nx">temp</span><span class="o">:=</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]&gt;</span><span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">j</span><span class="o">==</span><span class="mi">0</span> <span class="p">{</span>
                <span class="nx">j</span><span class="o">--</span>
                <span class="k">break</span>
            <span class="p">}</span>
            <span class="nx">j</span><span class="o">--</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="nx">x</span><span class="o">:=</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">x</span><span class="p">&gt;</span><span class="nx">j</span><span class="p">;</span><span class="nx">x</span><span class="o">--</span><span class="p">{</span>
            <span class="nx">a</span><span class="p">[</span><span class="nx">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]=</span><span class="nx">a</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]=</span><span class="nx">temp</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><h2 id="希尔">希尔</h2>
<p>一个美国人1959年发明的，希尔排序是直接插入排序的改进版本。因为直接插入排序对那些几乎已经排好序的数列来说，排序效率极高，达到了 O(n) 的线性复杂度，但是每次只能将数据移动一位。<strong>希尔排序创造性的可以将数据移动 n 位，然后将 n 一直缩小，缩到与直接插入排序一样为 1</strong></p>
<p>先取一个小于 N 的整数 d1 ，将位置是 d1 整数倍的数们分成一组，对这些数进行直接
插入排序。接着取一个小于 d1 的整数 d2 ，将位置是 d2 整数倍的数们分成一组，对这些数进行直接插入排序。接着取一个小于 d2 的整数 d3 ，将位置是 d3 整数倍的数们分成一组，对这些数进行直接插入排序。…直到取到的整数 d=1 ，接着使用直接插入排序。</p>
<p>这是一种分组插入方法，最后一次迭代就相当于是直接插入排序，其他迭代相当于每次移动 n 个距离的直接插入排序，这些整数是两个数之间的距离，我们称它们为<strong>增量</strong>。</p>
<p>我们取数列长度的一半为增量，以后每次减半，直到增量为1。</p>
<p>希尔排序通过分组使用直接插入排序，因为步长比 1大，在一开始可以很快将无序的数列变得不那么无序，比较和交换的次数也减少，直到最后使用步长为 1 的直接插入排序，数列已经是相对有序了，所以时间复杂度会稍好一点。</p>
<p>在最好情况下，也就是数列是有序时，希尔排序需要进行 logn 次增量的直接插入排序，因为每次直接插入排序最佳时间复杂度都为： O(n) ，因此希尔排序的最佳时间复杂度为： O(nlogn) 。</p>
<p>在最坏情况下，每一次迭代都是最坏的，假设增量序列为： d8 d7 d6 &hellip; d3 d2 1 ，那么每一轮直接插入排序的元素数量为： n/d8 n/d7 n/d6 &hellip;. n/d3 n/d2 n ，那么时间复杂度按照直接插入的最坏复杂度来计算为：$O( (n/d8)^2 + (n/d7)^2 + (n/d6)^2 + &hellip; + (n/d2)^2 + n^2) = O( &lt; 2 ) * O(n^2)$</p>
<p>不同的分组增量序列，有不同的时间复杂度。<strong>Hibbard 增量序列： 1，3，7，···，2n−1 是被证明可广泛应用的分组序列，时间复杂度为： Θ(n^1.5) 。</strong></p>
<p>希尔排序的时间复杂度大约在这个范围： O(n^1.3)~O(n^2) ，具体还无法用数学来严格证明它。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 希尔排序 (shell sort)
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">sorts</span>

<span class="kd">func</span> <span class="nf">ShellSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">d</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">d</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">d</span> <span class="o">/=</span> <span class="mi">2</span> <span class="p">{</span> 
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="nx">d</span> <span class="o">&amp;&amp;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">d</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">];</span> <span class="nx">j</span> <span class="o">-=</span> <span class="nx">d</span> <span class="p">{</span>
                <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">d</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="o">-</span><span class="nx">d</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">arr</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="归并">归并</h2>
<p>分治法</p>
<p>将两个有序数组进行合并，最多进行 N 次比较就可以生成一个新的有序数组， N 是两个数组长度之和。</p>
<p>归并操作最坏的时间复杂度为： O(n) ，其中 n 是较长数组的长度（因为$N&lt;2n$）。归并操作最好的时间复杂度为： O(n) ，其中 n 是较短数组的长度。正是利用这个特点，归并排序先排序较小的数组，再将有序的小数组合并形成更大有序的数组。</p>
<p>归并排序有两种递归做法，一种是自顶向下，一种是自底向上。</p>
<ul>
<li>自顶向下：不断二分大数组直到无法切分，排序，不断两两合并，得到排序后数组。
<ul>
<li>每次都是一分为二，特别均匀，所以最差和最坏时间复杂度都一样。归并操作的时间复杂度为： O(n) ，因此总的时间复杂度为： T(n)=2T(n/2)+O(n) ，根据主定理公式可以知道时间复杂度为： O(nlogn)</li>
<li>因为不断地递归，程序栈层数会有 logn 层，所以递归栈的空间复杂度为： O(logn) ，对于排序十亿个整数，也只要： log(100 0000 0000)=29.897 ，占用的堆栈层数最多 30 层</li>
</ul>
</li>
<li>自底向上：小数组排序合并成大数组。
<ul>
<li>时间复杂度同上</li>
<li>因不需要递归，没有程序栈占用，空间复杂度为O(1)</li>
</ul>
</li>
</ul>
<p>归并排序归并操作占用了额外的辅助数组，且归并操作是从一个元素的数组开始。</p>
<p>改进：</p>
<ul>
<li>对于小规模数组，使用直接插入排序。</li>
<li>原地排序，节约掉辅助数组空间的占用。</li>
</ul>
<p>建议使用自底向上非递归排序，不会有程序栈空间损耗</p>
<p>手摇算法（翻转算法）：</p>
<ul>
<li>主要用来对数组两部分进行位置互换</li>
<li>eg:将字符串 abcde1234567 的前 5 个字符与后面的字符交换位置，那么手摇后变成： 1234567abcde 。</li>
<li>如何翻转：
<ul>
<li>将前部分逆序</li>
<li>将后部分逆序</li>
<li>对整体逆序</li>
</ul>
</li>
</ul>
<p>归并原地排序利用了手摇算法的特征，不需要额外的辅助数组。</p>
<p>我们自底开始，将元素按照数量为 blockSize 进行小数组排序，使用直接插入排序，然后我们对这些有序的数组向上进行原地归并操作。</p>
<p><strong>归并排序是唯一一个有稳定性保证的高级排序算法，某些时候，为了寻求大规模数据下排序前后，相同元素位置不变，可以使用归并排序。</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 归并排序 (merge sort)
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">sorts</span>

<span class="kd">func</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="nx">r</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
    <span class="kd">var</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nx">j</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
            <span class="nx">i</span><span class="o">++</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
            <span class="nx">j</span><span class="o">++</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="nx">i</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
        <span class="nx">j</span><span class="o">++</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span>

<span class="p">}</span>

<span class="c1">// Mergesort 合并两个数组
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Mergesort</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">items</span>

    <span class="p">}</span>

    <span class="kd">var</span> <span class="nx">middle</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="p">=</span> <span class="nf">Mergesort</span><span class="p">(</span><span class="nx">items</span><span class="p">[:</span><span class="nx">middle</span><span class="p">])</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="p">=</span> <span class="nf">Mergesort</span><span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">middle</span><span class="p">:])</span>
    <span class="k">return</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">nums</span>
    <span class="p">}</span>
    <span class="c1">// 分治法：divide 分为两段
</span><span class="c1"></span>    <span class="nx">mid</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nx">left</span> <span class="o">:=</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">mid</span><span class="p">])</span>
    <span class="nx">right</span> <span class="o">:=</span> <span class="nf">mergeSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">:])</span>
    <span class="c1">// 合并两段数据
</span><span class="c1"></span>    <span class="nx">result</span> <span class="o">:=</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">merge</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 两边数组合并游标
</span><span class="c1"></span>    <span class="nx">l</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="c1">// 注意不能越界
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">l</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 谁小合并谁
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">left</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">right</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">right</span><span class="p">[</span><span class="nx">r</span><span class="p">])</span>
            <span class="nx">r</span><span class="o">++</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">left</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
            <span class="nx">l</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 剩余部分合并
</span><span class="c1"></span>    <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">left</span><span class="p">[</span><span class="nx">l</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">result</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">right</span><span class="p">[</span><span class="nx">r</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="优先队列及堆">优先队列及堆</h2>
<p>堆排序属于选择类排序算法。</p>
<p>优先队列是一种能完成以下任务的队列：插入一个数值，取出最小或最大的数值（获取数值，并且删除）。</p>
<p>优先队列可以用二叉树来实现，我们称这种结构为二叉堆。</p>
<p>最小堆和最大堆是二叉堆的一种，是一棵<strong>完全二叉树</strong>（一种平衡树）。</p>
<p>最小堆的性质：</p>
<ol>
<li>父节点的值都小于左右儿子节点。</li>
<li>这是一个递归的性质。</li>
</ol>
<p>最大堆的性质：</p>
<ol>
<li>父节点的值都大于左右儿子节点。</li>
<li>这是一个递归的性质。</li>
</ol>
<p>最大堆和最小堆实现方式一样，只不过根节点一个是最大的，一个是最小的</p>
<p>最大堆特征：</p>
<ul>
<li>最大堆实现细节(两个操作)：
<ol>
<li>push：向堆中插入数据时，首先在堆的末尾插入数据，如果该数据比父亲节点还大，那么交换，然后不断向上提升，直到没有大小颠倒为止。</li>
<li>pop：从堆中删除最大值时，首先把最后一个值复制到根节点上，并且删除最后一个数值，然后和儿子节点比较，如果值小于儿子，与儿子节点交换，然后不断向下交换， 直到没有大小颠倒为止。在向下交换过程中，如果有两个子儿子都大于自己，就选择较大的。</li>
</ol>
</li>
<li>最大堆有两个核心操作，一个是上浮，一个是下沉，分别对应 push 和 pop 。</li>
<li>上浮操作
<ul>
<li>操作一次 push 的最好时间复杂度为： O(1) ，因为第一次上浮时如果不大于父亲，那么就结束了。最坏的时间复杂度为： O(logn) ，相当于每次都大于父亲，会一直往上浮到根节点，翻转次数等于树的高度，而树的高度等于元素个数的对数： log(n) 。</li>
<li>构建一个最大堆，从空堆开始，每次添加元素到尾部后，需要向上翻转，最坏翻转次数是：近似 = log(1)+log(2)+log(3)+&hellip;+log(n) = log(n!)</li>
<li>log(n!) 和 nlog(n) 是同阶的，故最坏时间复杂度便得到了。元素不全相同的情况下最好时间复杂度也是这个。</li>
</ul>
</li>
<li>下沉操作
<ul>
<li>操作一次 pop 最好的时间复杂度也是： O(1) ，因为第一次比较时根节点就是最大的。最坏时间复杂度仍然是树的高度： O(logn) 。</li>
<li>从一个最大堆，逐一移除堆顶元素，然后将堆尾元素置于堆顶后，向下翻转恢复堆特征，最坏翻转次数是:近似 = log(1)+log(2)+log(3)+&hellip;+log(n) = log(n!)，同上浮。元素不全相同的情况下最好时间复杂度也是O(nlog(n))</li>
</ul>
</li>
<li>如果所有的元素都一样的情况下，建堆和移除堆的每一步都不需要翻转，最好时间复杂度
为： O(n) ，复杂度主要在于遍历元素。</li>
</ul>
<p><strong>根据最大堆，可以实现堆排序。</strong></p>
<p>普通堆排序：先构建一个最小堆，然后依次把根节点元素 pop 出即可：</p>
<ul>
<li>因为一开始会认为堆是空的，每次添加元素都需要添加到尾部，然后向上翻转，需要用 Heap.Size来记录堆的大小增长，这种堆构建，可以认为是非原地的构建，影响了效率</li>
</ul>
<p>改进的原地自底向上的堆排序，不会从空堆开始，而是把待排序的数列当成一个混乱的最大堆，从底层逐层开始，对元素进行下沉操作，一直恢复最大堆的特征，直到根节点。</p>
<ul>
<li>将构建堆的时间复杂度从 O(nlogn) 降为 O(n) ，总的堆排序时间复杂度从 O(2nlogn) 改进到 O(n+nlogn) 。</li>
</ul>
<p>自底向上堆排序：</p>
<ul>
<li>构建最大堆步骤：
<ul>
<li>先对最底部的所有非叶子节点进行下沉，即这些非叶子节点与它们的儿子节点比较，较大的儿子和父亲交换位置。</li>
<li>接着从次二层开始的非叶子节点重复这个操作，直到到达根节点最大堆就构建好了</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 堆排序 (heap sort)
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">sorts</span>

<span class="kd">type</span> <span class="nx">maxHeap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">slice</span>    <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">heapSize</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="nx">maxHeap</span> <span class="p">{</span>
    <span class="nx">h</span> <span class="o">:=</span> <span class="nx">maxHeap</span><span class="p">{</span><span class="nx">slice</span><span class="p">:</span> <span class="nx">slice</span><span class="p">,</span> <span class="nx">heapSize</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nf">MaxHeapify</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">maxHeap</span><span class="p">)</span> <span class="nf">MaxHeapify</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="o">+</span><span class="mi">2</span>
    <span class="nx">max</span> <span class="o">:=</span> <span class="nx">i</span>

    <span class="k">if</span> <span class="nx">l</span> <span class="p">&lt;</span> <span class="nx">h</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">max</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">max</span> <span class="p">=</span> <span class="nx">l</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="nx">h</span><span class="p">.</span><span class="nf">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">max</span><span class="p">]</span> <span class="p">{</span>
        <span class="nx">max</span> <span class="p">=</span> <span class="nx">r</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">max</span> <span class="o">!=</span> <span class="nx">i</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">max</span><span class="p">]</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">max</span><span class="p">],</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="nx">h</span><span class="p">.</span><span class="nf">MaxHeapify</span><span class="p">(</span><span class="nx">max</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="nx">maxHeap</span><span class="p">)</span> <span class="nf">size</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">heapSize</span> <span class="p">}</span> 

<span class="kd">func</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">h</span> <span class="o">:=</span> <span class="nf">buildMaxHeap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">h</span><span class="p">.</span><span class="nx">heapSize</span><span class="o">--</span>
        <span class="nx">h</span><span class="p">.</span><span class="nf">MaxHeapify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">h</span><span class="p">.</span><span class="nx">slice</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="快速">快速</h2>
<p>亦使用了分治法。</p>
<p>对冒泡排序的改进。</p>
<p>快速排序通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<p>步骤：</p>
<ul>
<li>先从数列中取出一个数作为基准数。一般取第一个数。</li>
<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ul>
<p>在最好情况下，每一轮都能平均切分，这样遍历元素只要 n/2 次就可以把数列分成两部分，每一轮的时间复杂度都是： O(n) 。因为问题规模每次被折半，折半的数列继续递归进行切分，也就是总的时间复杂度计算公式为： T(n) = 2*T(n/2) + O(n) 。按照主定理公式计算，我们可以知道时间复杂度为： O(nlogn)</p>
<p>最差的情况下，每次都不能平均地切分，每次切分都因为基准数是最大的或者最小的，不能分成两个数列，这样时间复杂度变为了 T(n) = T(n-1) + O(n) ，按照主定理计算可以知道时间复杂度为： O(n^2)</p>
<p>数据规模越大越难以出现最差的情况，在综合情况下，快速排序的平均时间复杂度为： O(nlogn) 。对比之前介绍的排序算法，快速排序比那些动不动就是平方级别的初级排序算法更佳。</p>
<p>为了避免切分不均匀情况的发生，有几种方法改进：</p>
<ol>
<li>每次进行快速排序切分时，先将数列随机打乱，再进行切分，这样随机加了个震荡，减少不均匀的情况。当然，也可以随机选择一个基准数，而不是选第一个数。</li>
<li>每次取数列头部，中部，尾部三个数，取三个数的中位数为基准数进行切分。</li>
</ol>
<p>快速排序使用原地排序，存储空间复杂度为： O(1) 。而因为递归栈的影响，递归的程序栈开辟的层数范围在 $logn-n$ ，所以递归栈的空间复杂度为： $O(logn)-log(n)$ ，最坏为： log(n) ，当元素较多时，程序栈可能溢出。通过改进算法，使用伪尾递归进行优化，递归栈的空间复杂度可以减小到 O(logn)</p>
<p><strong>改进</strong>：</p>
<ol>
<li>在小规模数组的情况下，直接插入排序的效率最好，当快速排序递归部分进入小数组范围，可以
切换成直接插入排序。</li>
<li>排序数列可能存在大量重复值，使用三向切分快速排序，将数组分成三部分，大于基准数，等于
基准数，小于基准数，这个时候需要维护三个下标。</li>
<li>使用伪尾递归减少程序栈空间占用，使得栈空间复杂度从 O(logn)~log(n) 变
为： O(logn) 。</li>
</ol>
<p>伪尾递归优化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 伪尾递归快速排序
</span><span class="c1"></span> <span class="kd">func</span> <span class="nf">QuickSort3</span><span class="p">(</span><span class="nx">array</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">begin</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">begin</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
 <span class="c1">// 进行切分
</span><span class="c1"></span>        <span class="nx">loc</span> <span class="o">:=</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">begin</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>

 <span class="c1">// 那边元素少先排哪边
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">loc</span><span class="o">-</span><span class="nx">begin</span> <span class="p">&lt;</span> <span class="nx">end</span><span class="o">-</span><span class="nx">loc</span> <span class="p">{</span>
 <span class="c1">// 先排左边
</span><span class="c1"></span>            <span class="nf">QuickSort3</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">begin</span><span class="p">,</span> <span class="nx">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="nx">begin</span> <span class="p">=</span> <span class="nx">loc</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
 <span class="c1">// 先排右边
</span><span class="c1"></span>            <span class="nf">QuickSort3</span><span class="p">(</span><span class="nx">array</span><span class="p">,</span> <span class="nx">loc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
            <span class="nx">end</span> <span class="p">=</span> <span class="nx">loc</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>
 <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解析：很多人以为这样子是尾递归。其实这样的快排写法是伪装的尾递归，不是真正的尾递归，因为有for 循环，不是直接 return QuickSort ，递归还是不断地压栈，栈的层次仍然不断地增长。但是，因为先让规模小的部分排序，栈的深度大大减少，程序栈最深不会超过 logn 层，这样堆栈最坏空间复杂度从 O(n) 降为 O(logn) 。这种优化也是一种很好的优化，因为栈的层数减少了，对于排序十亿个整数，也只要： log(100 00000000)=29.897 ，占用的堆栈层数最多 30 层，比不进行优化，可能出现的 O(n) 常数层好很多。</p>
<p>非递归写法仅仅是将之前的递归栈转化为自己维持的手工栈。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">var</span> <span class="nx">swapcnt</span> <span class="kt">int</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
	<span class="c1">//idx := Swap(arr, 0, len(arr))
</span><span class="c1"></span>	<span class="c1">//fmt.Println(idx, arr)
</span><span class="c1"></span>	<span class="nf">myquickSort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">swapcnt</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">idx</span> <span class="o">:=</span> <span class="nx">l</span>
	<span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">pivot</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">idx</span> <span class="o">!=</span> <span class="nx">i</span> <span class="p">{</span>
				<span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span>
				<span class="nx">swapcnt</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="p">}</span>
			<span class="nx">idx</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">idx</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">myquickSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">l</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
		<span class="nx">m</span> <span class="o">:=</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
		<span class="nf">myquickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">myquickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//[l,r]
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">l</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
		<span class="nx">m</span> <span class="o">:=</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
		<span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">l</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">r</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">l</span>
	<span class="k">for</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">key</span> <span class="p">{</span>
			<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">j</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">r</span><span class="p">],</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>


<span class="c1">// 解决栈溢问题
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">qsort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">left</span> <span class="p">&gt;</span> <span class="nx">right</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">right</span><span class="p">]</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="nx">pivot</span> <span class="p">&lt;</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">j</span><span class="o">--</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span> <span class="o">&amp;&amp;</span> <span class="nx">pivot</span> <span class="o">&gt;=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="nx">i</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nf">qsort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">left</span><span class="p">,</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nf">qsort</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
<span class="p">}</span>


</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 三向切分快速排序 (quick sort)
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">sorts</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;math/rand&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">arr</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">arr</span>
    <span class="p">}</span>

    <span class="nx">pivot</span> <span class="o">:=</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))]</span>

    <span class="nx">lowPart</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>
    <span class="nx">highPart</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>
    <span class="nx">middlePart</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">arr</span><span class="p">))</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">item</span> <span class="p">&lt;</span> <span class="nx">pivot</span><span class="p">:</span>
            <span class="nx">lowPart</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">lowPart</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">item</span> <span class="o">==</span> <span class="nx">pivot</span><span class="p">:</span>
            <span class="nx">middlePart</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">middlePart</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
        <span class="k">case</span> <span class="nx">item</span> <span class="p">&gt;</span> <span class="nx">pivot</span><span class="p">:</span>
            <span class="nx">highPart</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">highPart</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">lowPart</span> <span class="p">=</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">lowPart</span><span class="p">)</span>
    <span class="nx">highPart</span> <span class="p">=</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">highPart</span><span class="p">)</span>

    <span class="nx">lowPart</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">lowPart</span><span class="p">,</span> <span class="nx">middlePart</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">lowPart</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">lowPart</span><span class="p">,</span> <span class="nx">highPart</span><span class="o">...</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">lowPart</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// 思路：把一个数组分为左右两段，左段小于右段
</span><span class="c1"></span>    <span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">nums</span>

<span class="p">}</span>
<span class="c1">// 原地交换，所以传入交换索引
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nx">end</span> <span class="p">{</span>
        <span class="c1">// 分治法：divide
</span><span class="c1"></span>        <span class="nx">pivot</span> <span class="o">:=</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
        <span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">pivot</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nf">quickSort</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">pivot</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 分区
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// 选取最后一个元素作为基准pivot
</span><span class="c1"></span>    <span class="nx">p</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">end</span><span class="p">]</span>
    <span class="nx">i</span> <span class="o">:=</span> <span class="nx">start</span>
    <span class="c1">// 最后一个值就是基准所以不用比较
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">&lt;</span> <span class="nx">p</span> <span class="p">{</span>
            <span class="nf">swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">)</span>
            <span class="nx">i</span><span class="o">++</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 把基准值换到中间
</span><span class="c1"></span>    <span class="nf">swap</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
<span class="c1">// 交换两个元素
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">swap</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span>
    <span class="nx">nums</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">t</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="内置库使用快排的原因">内置库使用快排的原因</h2>
<p>首先堆排序，归并排序最好最坏时间复杂度都是： O(nlogn) ，而快速排序最坏的时间复杂度是： O(n^2) ，但是很多编程语言内置的排序算法使用的仍然是快速排序，这是为什么？</p>
<ol>
<li>这个问题有偏颇，选择排序算法要看具体的场景， Linux 内核用的排序算法就是堆排序，而Java 对于数量比较多的复杂对象排序，内置排序使用的是归并排序，只是一般情况下，快速排序更快。</li>
<li>归并排序有两个稳定，第一个稳定是排序前后相同的元素位置不变，第二个稳定是，每次都是很平均地进行排序，读取数据也是顺序读取，能够利用存储器缓存的特征，比如从磁盘读取数据进行排序。因为排序过程需要占用额外的辅助数组空间，所以这部分有代价损耗，但是原地手摇的归并排序克服了这个缺陷。</li>
<li>复杂度中，大 O 有一个常数项被省略了，堆排序每次取最大的值之后，都需要进行节点翻转，重新恢复堆的特征，做了大量无用功，常数项比快速排序大，大部分情况下比快速排序慢很多。但是堆排序时间较稳定，不会出现快排最坏 O(n^2) 的情况，且省空间，不需要额外的存储空间和栈空间。</li>
<li>当待排序数量大于16000个元素时，使用自底向上的堆排序比快速排序还快，可见此：https://core.ac.uk/download/pdf/82350265.pdf。</li>
<li>快速排序最坏情况下复杂度高，主要在于切分不像归并排序一样平均，而是很依赖基准数的现在，我们通过改进，比如随机数，三切分等，这种最坏情况的概率极大的降低。大多数情况下，它并不会那么地坏，大多数快才是真的块。</li>
<li>归并排序和快速排序都是分治法，排序的数据都是相邻的，而堆排序比较的数可能跨越很大的范围，导致局部性命中率降低，不能利用现代存储器缓存的特征，加载数据过程会损失性能。</li>
</ol>
<p>对稳定性有要求的，要求排序前后相同元素位置不变，可以使用归并排序， Java 中的复杂对象类型，要求排序前后位置不能发生变化，所以小规模数据下使用了直接插入排序，大规模数据下使用了归并排序。</p>
<p>对栈，存储空间有要求的可以使用堆排序，比如 Linux 内核栈小，快速排序占用程序栈太大了，使用快速排序可能栈溢出，所以使用了堆排序。</p>
<p>在 Golang 中，标准库 sort 中对切片进行稳定排序：会先按照 20 个元素的范围，对整个切片分段进行插入排序，因为小数组插入排序效率高，然后再对这些已排好序的小数组进行归并排序。其中归并排序还使用了原地排序，节约了辅助空间。</p>
<p>快速排序限制程序栈的层数为： 2*ceil(log(n+1)) ，当递归超过该层时表示程序栈过深，那么转为堆排序。</p>
<h2 id="堆排序">堆排序</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nf">HeapSort</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// 1、无序数组a
</span><span class="c1"></span>    <span class="c1">// 2、将无序数组a构建为一个大根堆
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="nf">sink</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="c1">// 3、交换a[0]和a[len(a)-1]
</span><span class="c1"></span>    <span class="c1">// 4、然后把前面这段数组继续下沉保持堆结构，如此循环即可
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="c1">// 从后往前填充值
</span><span class="c1"></span>        <span class="nf">swap</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
        <span class="c1">// 前面的长度也减一
</span><span class="c1"></span>        <span class="nf">sink</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">sink</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">length</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="c1">// 左节点索引(从0开始，所以左节点为i*2+1)
</span><span class="c1"></span>        <span class="nx">l</span> <span class="o">:=</span> <span class="nx">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1">// 右节点索引
</span><span class="c1"></span>        <span class="nx">r</span> <span class="o">:=</span> <span class="nx">i</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="c1">// idx保存根、左、右三者之间较大值的索引
</span><span class="c1"></span>        <span class="nx">idx</span> <span class="o">:=</span> <span class="nx">i</span>
        <span class="c1">// 存在左节点，左节点值较大，则取左节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">l</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">idx</span> <span class="p">=</span> <span class="nx">l</span>
        <span class="p">}</span>
        <span class="c1">// 存在右节点，且值较大，取右节点
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">r</span> <span class="p">&lt;</span> <span class="nx">length</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">idx</span><span class="p">]</span> <span class="p">{</span>
            <span class="nx">idx</span> <span class="p">=</span> <span class="nx">r</span>
        <span class="p">}</span>
        <span class="c1">// 如果根节点较大，则不用下沉
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">idx</span> <span class="o">==</span> <span class="nx">i</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
        <span class="c1">// 如果根节点较小，则交换值，并继续下沉
</span><span class="c1"></span>        <span class="nf">swap</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">idx</span><span class="p">)</span>
        <span class="c1">// 继续下沉idx节点
</span><span class="c1"></span>        <span class="nx">i</span> <span class="p">=</span> <span class="nx">idx</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">swap</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-11-21 11:22:01&nbsp;<a class="git-hash" href="https://github.com/dillonzq/LoveIt/commit/e5069f98f2f19bc7c816e71839db7da13a75eeb8" target="_blank" title="commit by AdagioForSummerWind(2152343764@qq.com) e5069f98f2f19bc7c816e71839db7da13a75eeb8: autofeat">
                                    <i class="fas fa-hashtag fa-fw"></i>e5069f9</a></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/algorithm_sort/" data-title="Algorithm_sort" data-hashtags="data structure"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/algorithm_sort/" data-hashtag="data structure"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/algorithm_sort/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/algorithm_sort/" data-title="Algorithm_sort"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/algorithm_sort/" data-title="Algorithm_sort"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/algorithm_sort/" data-title="Algorithm_sort"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/data-structure/">data structure</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/cn_http/" class="prev" rel="prev" title="CN_HTTP"><i class="fas fa-angle-left fa-fw"></i>CN_HTTP</a>
            <a href="/algorithm_find/" class="next" rel="next" title="Algorithm_find">Algorithm_find<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
