<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Gb_20190801 - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Gb_20190801" />
<meta property="og:description" content="Experiment, Simplify, Ship Russ Cox
1 August 2019
Introduction This is the blog post version of my talk last week at GopherCon 2019.
We are all on the path to Go 2, together, but none of us know exactly where that path leads or sometimes even which direction the path goes. This post discusses how we actually find and follow the path to Go 2. Here’s what the process looks like." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/gb_20190801/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-29T19:43:38+08:00" />
<meta property="article:modified_time" content="2022-10-29T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Gb_20190801"/>
<meta name="twitter:description" content="Experiment, Simplify, Ship Russ Cox
1 August 2019
Introduction This is the blog post version of my talk last week at GopherCon 2019.
We are all on the path to Go 2, together, but none of us know exactly where that path leads or sometimes even which direction the path goes. This post discusses how we actually find and follow the path to Go 2. Here’s what the process looks like."/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/gb_20190801/" /><link rel="prev" href="https://jefofrank.xyz/gb_20190731/" /><link rel="next" href="https://jefofrank.xyz/gb_20190815/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Gb_20190801",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/gb_20190801\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "go official blogs","wordcount":  7126 ,
        "url": "https:\/\/jefofrank.xyz\/gb_20190801\/","datePublished": "2022-10-29T19:43:38+08:00","dateModified": "2022-10-29T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Gb_20190801</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/2022/"><i class="far fa-folder fa-fw"></i>2022</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-10-29 19:43:38">2022-10-29 19:43:38</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7126 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 34 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#the-four-rs-of-simplifying">The Four R’s of Simplifying</a></li>
    <li><a href="#go-development-process">Go Development Process</a></li>
    <li><a href="#errors">Errors</a></li>
    <li><a href="#generics">Generics</a></li>
    <li><a href="#dependencies">Dependencies</a></li>
    <li><a href="#tools">Tools</a></li>
    <li><a href="#coda">Coda</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="experiment-simplify-ship">Experiment, Simplify, Ship</h1>
<p>Russ Cox<br>
1 August 2019</p>
<h2 id="introduction">Introduction</h2>
<p>This is the blog post version of my talk last week at GopherCon 2019.</p>
<p>We are all on the path to Go 2, together, but none of us know exactly where that path leads or sometimes even which direction the path goes. This post discusses how we actually find and follow the path to Go 2. Here’s what the process looks like.</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="experiment/expsimp1.png"
        data-srcset="experiment/expsimp1.png, experiment/expsimp1.png 1.5x, experiment/expsimp1.png 2x"
        data-sizes="auto"
        alt="experiment/expsimp1.png"
        title="experiment/expsimp1.png" /></p>
<p>We experiment with Go as it exists now, to understand it better, learning what works well and what doesn’t. Then we experiment with possible changes, to understand them better, again learning what works well and what doesn’t. Based on what we learn from those experiments, we simplify. And then we experiment again. And then we simplify again. And so on. And so on.</p>
<h2 id="the-four-rs-of-simplifying">The Four R’s of Simplifying</h2>
<p>During this process, there are four main ways that we can simplify the overall experience of writing Go programs: reshaping, redefining, removing, and restricting.</p>
<p><strong>Simplify by Reshaping</strong></p>
<p>The first way we simplify is by reshaping what exists into a new form, one that ends up being simpler overall.</p>
<p>Every Go program we write serves as an experiment to test Go itself. In the early days of Go, we quickly learned that it was common to write code like this <code>addToList</code> function:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func addToList(list []int, x int) []int {
    n := len(list)
    if n+1 &gt; cap(list) {
        big := make([]int, n, (n+5)*2)
        copy(big, list)
        list = big
    }
    list = list[:n+1]
    list[n] = x
    return list
}
</code></pre></td></tr></table>
</div>
</div><p>We’d write the same code for slices of bytes, and slices of strings, and so on. Our programs were too complex, because Go was too simple.</p>
<p>So we took the many functions like <code>addToList</code> in our programs and reshaped them into one function provided by Go itself. Adding <code>append</code> made the Go language a little more complex, but on balance it made the overall experience of writing Go programs simpler, even after accounting for the cost of learning about <code>append</code>.</p>
<p>Here’s another example. For Go 1, we looked at the very many development tools in the Go distribution, and we reshaped them into one new command.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">5a      8g
5g      8l
5l      cgo
6a      gobuild
6cov    gofix         →     go
6g      goinstall
6l      gomake
6nm     gopack
8a      govet
</code></pre></td></tr></table>
</div>
</div><p>The <code>go</code> command is so central now that it is easy to forget that we went so long without it and how much extra work that involved.</p>
<p>We added code and complexity to the Go distribution, but on balance we simplified the experience of writing Go programs. The new structure also created space for other interesting experiments, which we’ll see later.</p>
<p><strong>Simplify by Redefining</strong></p>
<p>A second way we simplify is by redefining functionality we already have, allowing it to do more. Like simplifying by reshaping, simplifying by redefining makes programs simpler to write, but now with nothing new to learn.</p>
<p>For example, <code>append</code> was originally defined to read only from slices. When appending to a byte slice, you could append the bytes from another byte slice, but not the bytes from a string. We redefined append to allow appending from a string, without adding anything new to the language.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">var b []byte
var more []byte
b = append(b, more...) // ok

var b []byte
var more string
b = append(b, more...) // ok later
</code></pre></td></tr></table>
</div>
</div><p><strong>Simplify by Removing</strong></p>
<p>A third way we simplify is by removing functionality when it has turned out to be less useful or less important than we expected. Removing functionality means one less thing to learn, one less thing to fix bugs in, one less thing to be distracted by or use incorrectly. Of course, removing also forces users to update existing programs, perhaps making them more complex, to make up for the removal. But the overall result can still be that the process of writing Go programs becomes simpler.</p>
<p>An example of this is when we removed the boolean forms of non-blocking channel operations from the language:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">ok := c &lt;- x  // before Go 1, was non-blocking send
x, ok := &lt;-c  // before Go 1, was non-blocking receive
</code></pre></td></tr></table>
</div>
</div><p>These operations were also possible to do using <code>select</code>, making it confusing to need to decide which form to use. Removing them simplified the language without reducing its power.</p>
<p><strong>Simplify by Restricting</strong></p>
<p>We can also simplify by restricting what is allowed. From day one, Go has restricted the encoding of Go source files: they must be UTF-8. This restriction makes every program that tries to read Go source files simpler. Those programs don’t have to worry about Go source files encoded in Latin-1 or UTF-16 or UTF-7 or anything else.</p>
<p>Another important restriction is <code>gofmt</code> for program formatting. Nothing rejects Go code that isn’t formatted using <code>gofmt</code>, but we have established a convention that tools that rewrite Go programs leave them in <code>gofmt</code> form. If you keep your programs in <code>gofmt</code> form too, then these rewriters don’t make any formatting changes. When you compare before and after, the only diffs you see are real changes. This restriction has simplified program rewriters and led to successful experiments like <code>goimports</code>, <code>gorename</code>, and many others.</p>
<h2 id="go-development-process">Go Development Process</h2>
<p>This cycle of experiment and simplify is a good model for what we’ve been doing the past ten years. but it has a problem: it’s too simple. We can’t only experiment and simplify.</p>
<p>We have to ship the result. We have to make it available to use. Of course, using it enables more experiments, and possibly more simplifying, and the process cycles on and on.</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="experiment/expsimp2.png"
        data-srcset="experiment/expsimp2.png, experiment/expsimp2.png 1.5x, experiment/expsimp2.png 2x"
        data-sizes="auto"
        alt="experiment/expsimp2.png"
        title="experiment/expsimp2.png" /></p>
<p>We shipped Go to all of you for the first time on November 10, 2009. Then, with your help, we shipped Go 1 together in March 2012. And we’ve shipped twelve Go releases since then. All of these were important milestones, to enable more experimentation, to help us learn more about Go, and of course to make Go available for production use.</p>
<p>When we shipped Go 1, we explicitly shifted our focus to using Go, to understand this version of the language much better before trying any more simplifications involving language changes. We needed to take time to experiment, to really understand what works and what doesn’t.</p>
<p>Of course, we’ve had twelve releases since Go 1, so we have still been experimenting and simplifying and shipping. But we’ve focused on ways to simplify Go development without significant language changes and without breaking existing Go programs. For example, Go 1.5 shipped the first concurrent garbage collector and then the following releases improved it, simplifying Go development by removing pause times as an ongoing concern.</p>
<p>At Gophercon in 2017, we announced that after five years of experimentation, it was again time to think about significant changes that would simplify Go development. Our path to Go 2 is really the same as the path to Go 1: experiment and simplify and ship, towards an overall goal of simplifying Go development.</p>
<p>For Go 2, the concrete topics that we believed were most important to address are error handling, generics, and dependencies. Since then we have realized that another important topic is developer tooling.</p>
<p>The rest of this post discusses how our work in each of these areas follows that path. Along the way, we’ll take one detour, stopping to inspect the technical detail of what will be shipping soon in Go 1.13 for error handling.</p>
<h2 id="errors">Errors</h2>
<p>It is hard enough to write a program that works the right way in all cases when all the inputs are valid and correct and nothing the program depends on is failing. When you add errors into the mix, writing a program that works the right way no matter what goes wrong is even harder.</p>
<p>As part of thinking about Go 2, we want to understand better whether Go can help make that job any simpler.</p>
<p>There are two different aspects that could potentially be simplified: error values and error syntax. We’ll look at each in turn, with the technical detour I promised focusing on the Go 1.13 error value changes.</p>
<p><strong>Error Values</strong></p>
<p>Error values had to start somewhere. Here is the <code>Read</code> function from the first version of the <code>os</code> package:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">export func Read(fd int64, b *[]byte) (ret int64, errno int64) {
    r, e := syscall.read(fd, &amp;b[0], int64(len(b)));
    return r, e
}
</code></pre></td></tr></table>
</div>
</div><p>There was no <code>File</code> type yet, and also no error type. <code>Read</code> and the other functions in the package returned an <code>errno int64</code> directly from the underlying Unix system call.</p>
<p>This code was checked in on September 10, 2008 at 12:14pm. Like everything back then, it was an experiment, and code changed quickly. Two hours and five minutes later, the API changed:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">export type Error struct { s string }

func (e *Error) Print() { … } // to standard error!
func (e *Error) String() string { … }

export func Read(fd int64, b *[]byte) (ret int64, err *Error) {
    r, e := syscall.read(fd, &amp;b[0], int64(len(b)));
    return r, ErrnoToError(e)
}
</code></pre></td></tr></table>
</div>
</div><p>This new API introduced the first <code>Error</code> type. An error held a string and could return that string and also print it to standard error.</p>
<p>The intent here was to generalize beyond integer codes. We knew from past experience that operating system error numbers were too limited a representation, that it would simplify programs not to have to shoehorn all detail about an error into 64 bits. Using error strings had worked reasonably well for us in the past, so we did the same here. This new API lasted seven months.</p>
<p>The next April, after more experience using interfaces, we decided to generalize further and allow user-defined error implementations, by making the <code>os.Error</code> type itself an interface. We simplified by removing the <code>Print</code> method.</p>
<p>For Go 1 two years later, based on a suggestion by Roger Peppe, <code>os.Error</code> became the built-in <code>error</code> type, and the <code>String</code> method was renamed to <code>Error</code>. Nothing has changed since then. But we have written many Go programs, and as a result we have experimented a lot with how best to implement and use errors.</p>
<p><strong>Errors Are Values</strong></p>
<p>Making <code>error</code> a simple interface and allowing many different implementations means we have the entire Go language available to define and inspect errors. We like to say that <a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener noreffer">errors are values</a>, the same as any other Go value.</p>
<p>Here’s an example. On Unix, an attempt to dial a network connection ends up using the <code>connect</code> system call. That system call returns a <code>syscall.Errno</code>, which is a named integer type that represents a system call error number and implements the <code>error</code> interface:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">syscall</span>

<span class="kd">type</span> <span class="nx">Errno</span> <span class="kt">int64</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="nx">Errno</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="kd">const</span> <span class="nx">ECONNREFUSED</span> <span class="p">=</span> <span class="nf">Errno</span><span class="p">(</span><span class="mi">61</span><span class="p">)</span>

    <span class="o">...</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">ECONNREFUSED</span> <span class="o">...</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>syscall</code> package also defines named constants for the host operating system’s defined error numbers. In this case, on this system, <code>ECONNREFUSED</code> is number 61. Code that gets an error from a function can test whether the error is <code>ECONNREFUSED</code> using ordinary <a href="https://go.dev/ref/spec#Comparison_operators" target="_blank" rel="noopener noreffer">value equality</a>.</p>
<p>Moving up a level, in package <code>os</code>, any system call failure is reported using a larger error structure that records what operation was attempted in addition to the error. There are a handful of these structures. This one, <code>SyscallError</code>, describes an error invoking a specific system call with no additional information recorded:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">os</span>

<span class="kd">type</span> <span class="nx">SyscallError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Syscall</span> <span class="kt">string</span>
    <span class="nx">Err</span>     <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">SyscallError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Syscall</span> <span class="o">+</span> <span class="s">&#34;: &#34;</span> <span class="o">+</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Moving up another level, in package <code>net</code>, any network failure is reported using an even larger error structure that records the details of the surrounding network operation, such as dial or listen, and the network and addresses involved:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">net</span>

<span class="kd">type</span> <span class="nx">OpError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Op</span>     <span class="kt">string</span>
    <span class="nx">Net</span>    <span class="kt">string</span>
    <span class="nx">Source</span> <span class="nx">Addr</span>
    <span class="nx">Addr</span>   <span class="nx">Addr</span>
    <span class="nx">Err</span>    <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">OpError</span><span class="p">)</span> <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Putting these together, the errors returned by operations like <code>net.Dial</code> can format as strings, but they are also structured Go data values. In this case, the error is a <code>net.OpError</code>, which adds context to an <code>os.SyscallError</code>, which adds context to a <code>syscall.Errno</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">c, err := net.Dial(&#34;tcp&#34;, &#34;localhost:50001&#34;)

// &#34;dial tcp [::1]:50001: connect: connection refused&#34;

err is &amp;net.OpError{
    Op:   &#34;dial&#34;,
    Net:  &#34;tcp&#34;,
    Addr: &amp;net.TCPAddr{IP: ParseIP(&#34;::1&#34;), Port: 50001},
    Err: &amp;os.SyscallError{
        Syscall: &#34;connect&#34;,
        Err:     syscall.Errno(61), // == ECONNREFUSED
    },
}
</code></pre></td></tr></table>
</div>
</div><p>When we say errors are values, we mean both that the entire Go language is available to define them and also that the entire Go language is available to inspect them.</p>
<p>Here is an example from package net. It turns out that when you attempt a socket connection, most of the time you will get connected or get connection refused, but sometimes you can get a spurious <code>EADDRNOTAVAIL</code>, for no good reason. Go shields user programs from this failure mode by retrying. To do this, it has to inspect the error structure to find out whether the <code>syscall.Errno</code> deep inside is <code>EADDRNOTAVAIL</code>.</p>
<p>Here is the code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func spuriousENOTAVAIL(err error) bool {
    if op, ok := err.(*OpError); ok {
        err = op.Err
    }
    if sys, ok := err.(*os.SyscallError); ok {
        err = sys.Err
    }
    return err == syscall.EADDRNOTAVAIL
}
</code></pre></td></tr></table>
</div>
</div><p>A <a href="https://go.dev/ref/spec#Type_assertions" target="_blank" rel="noopener noreffer">type assertion</a> peels away any <code>net.OpError</code> wrapping. And then a second type assertion peels away any <code>os.SyscallError</code> wrapping. And then the function checks the unwrapped error for equality with <code>EADDRNOTAVAIL</code>.</p>
<p>What we’ve learned from years of experience, from this experimenting with Go errors, is that it is very powerful to be able to define arbitrary implementations of the <code>error</code> interface, to have the full Go language available both to construct and to deconstruct errors, and not to require the use of any single implementation.</p>
<p>These properties—that errors are values, and that there is not one required error implementation—are important to preserve.</p>
<p>Not mandating one error implementation enabled everyone to experiment with additional functionality that an error might provide, leading to many packages, such as <a href="https://godoc.org/github.com/pkg/errors" target="_blank" rel="noopener noreffer">github.com/pkg/errors</a>, <a href="https://godoc.org/gopkg.in/errgo.v2" target="_blank" rel="noopener noreffer">gopkg.in/errgo.v2</a>, <a href="https://godoc.org/github.com/hashicorp/errwrap" target="_blank" rel="noopener noreffer">github.com/hashicorp/errwrap</a>, <a href="https://godoc.org/upspin.io/errors" target="_blank" rel="noopener noreffer">upspin.io/errors</a>, <a href="https://godoc.org/github.com/spacemonkeygo/errors" target="_blank" rel="noopener noreffer">github.com/spacemonkeygo/errors</a>, and more.</p>
<p>One problem with unconstrained experimentation, though, is that as a client you have to program to the union of all the possible implementations you might encounter. A simplification that seemed worth exploring for Go 2 was to define a standard version of commonly-added functionality, in the form of agreed-upon optional interfaces, so that different implementations could interoperate.</p>
<p><strong>Unwrap</strong></p>
<p>The most commonly-added functionality in these packages is some method that can be called to remove context from an error, returning the error inside. Packages use different names and meanings for this operation, and sometimes it removes one level of context, while sometimes it removes as many levels as possible.</p>
<p>For Go 1.13, we have introduced a convention that an error implementation adding removable context to an inner error should implement an <code>Unwrap</code> method that returns the inner error, unwrapping the context. If there is no inner error appropriate to expose to callers, either the error shouldn’t have an <code>Unwrap</code> method, or the <code>Unwrap</code> method should return nil.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// Go 1.13 optional method for error implementations.

interface {
    // Unwrap removes one layer of context,
    // returning the inner error if any, or else nil.
    Unwrap() error
}
</code></pre></td></tr></table>
</div>
</div><p>The way to call this optional method is to invoke the helper function <code>errors.Unwrap</code>, which handles cases like the error itself being nil or not having an <code>Unwrap</code> method at all.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">errors</span>

<span class="c1">// Unwrap returns the result of calling
</span><span class="c1">// the Unwrap method on err,
</span><span class="c1">// if err’s type defines an Unwrap method.
</span><span class="c1">// Otherwise, Unwrap returns nil.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">Unwrap</span><span class="p">(</span><span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="kt">error</span>
</code></pre></td></tr></table>
</div>
</div><p>We can use the <code>Unwrap</code> method to write a simpler, more general version of <code>spuriousENOTAVAIL</code>. Instead of looking for specific error wrapper implementations like <code>net.OpError</code> or <code>os.SyscallError</code>, the general version can loop, calling <code>Unwrap</code> to remove context, until either it reaches <code>EADDRNOTAVAIL</code> or there’s no error left:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func spuriousENOTAVAIL(err error) bool {
    for err != nil {
        if err == syscall.EADDRNOTAVAIL {
            return true
        }
        err = errors.Unwrap(err)
    }
    return false
}
</code></pre></td></tr></table>
</div>
</div><p>This loop is so common, though, that Go 1.13 defines a second function, <code>errors.Is</code>, that repeatedly unwraps an error looking for a specific target. So we can replace the entire loop with a single call to <code>errors.Is</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">func spuriousENOTAVAIL(err error) bool {
    return errors.Is(err, syscall.EADDRNOTAVAIL)
}
</code></pre></td></tr></table>
</div>
</div><p>At this point we probably wouldn’t even define the function; it would be equally clear, and simpler, to call <code>errors.Is</code> directly at the call sites.</p>
<p>Go 1.13 also introduces a function <code>errors.As</code> that unwraps until it finds a specific implementation type.</p>
<p>If you want to write code that works with arbitrarily-wrapped errors, <code>errors.Is</code> is the wrapper-aware version of an error equality check:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">err == target

    →

errors.Is(err, target)
</code></pre></td></tr></table>
</div>
</div><p>And <code>errors.As</code> is the wrapper-aware version of an error type assertion:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">target, ok := err.(*Type)
if ok {
    ...
}

    →

var target *Type
if errors.As(err, &amp;target) {
   ...
}
</code></pre></td></tr></table>
</div>
</div><p><strong>To Unwrap Or Not To Unwrap?</strong></p>
<p>Whether to make it possible to unwrap an error is an API decision, the same way that whether to export a struct field is an API decision. Sometimes it is appropriate to expose that detail to calling code, and sometimes it isn’t. When it is, implement Unwrap. When it isn’t, don’t implement Unwrap.</p>
<p>Until now, <code>fmt.Errorf</code> has not exposed an underlying error formatted with <code>%v</code> to caller inspection. That is, the result of <code>fmt.Errorf</code> has not been possible to unwrap. Consider this example:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// errors.Unwrap(err2) == nil
// err1 is not available (same as earlier Go versions)
err2 := fmt.Errorf(&#34;connect: %v&#34;, err1)
</code></pre></td></tr></table>
</div>
</div><p>If <code>err2</code> is returned to a caller, that caller has never had any way to open up <code>err2</code> and access <code>err1</code>. We preserved that property in Go 1.13.</p>
<p>For the times when you do want to allow unwrapping the result of <code>fmt.Errorf</code>, we also added a new printing verb <code>%w</code>, which formats like <code>%v</code>, requires an error value argument, and makes the resulting error’s <code>Unwrap</code> method return that argument. In our example, suppose we replace <code>%v</code> with <code>%w</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// errors.Unwrap(err4) == err3
// (%w is new in Go 1.13)
err4 := fmt.Errorf(&#34;connect: %w&#34;, err3)
</code></pre></td></tr></table>
</div>
</div><p>Now, if <code>err4</code> is returned to a caller, the caller can use <code>Unwrap</code> to retrieve <code>err3</code>.</p>
<p>It is important to note that absolute rules like “always use <code>%v</code> (or never implement <code>Unwrap</code>)” or “always use <code>%w</code> (or always implement <code>Unwrap</code>)” are as wrong as absolute rules like “never export struct fields” or “always export struct fields.” Instead, the right decision depends on whether callers should be able to inspect and depend on the additional information that using <code>%w</code> or implementing <code>Unwrap</code> exposes.</p>
<p>As an illustration of this point, every error-wrapping type in the standard library that already had an exported <code>Err</code> field now also has an <code>Unwrap</code> method returning that field, but implementations with unexported error fields do not, and existing uses of <code>fmt.Errorf</code> with <code>%v</code> still use <code>%v</code>, not <code>%w</code>.</p>
<p><strong>Error Value Printing (Abandoned)</strong></p>
<p>Along with the design draft for Unwrap, we also published a <a href="https://go.dev/design/go2draft-error-printing" target="_blank" rel="noopener noreffer">design draft for an optional method for richer error printing</a>, including stack frame information and support for localized, translated errors.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// Optional method for error implementations
type Formatter interface {
    Format(p Printer) (next error)
}

// Interface passed to Format
type Printer interface {
    Print(args ...interface{})
    Printf(format string, args ...interface{})
    Detail() bool
}
</code></pre></td></tr></table>
</div>
</div><p>This one is not as simple as <code>Unwrap</code>, and I won’t go into the details here. As we discussed the design with the Go community over the winter, we learned that the design wasn’t simple enough. It was too hard for individual error types to implement, and it did not help existing programs enough. On balance, it did not simplify Go development.</p>
<p>As a result of this community discussion, we abandoned this printing design.</p>
<p><strong>Error Syntax</strong></p>
<p>That was error values. Let’s look briefly at error syntax, another abandoned experiment.</p>
<p>Here is some code from <a href="https://go.googlesource.com/go/&#43;/go1.12/src/compress/lzw/writer.go#209" target="_blank" rel="noopener noreffer"><code>compress/lzw/writer.go</code></a> in the standard library:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// Write the savedCode if valid.
if e.savedCode != invalidCode {
    if err := e.write(e, e.savedCode); err != nil {
        return err
    }
    if err := e.incHi(); err != nil &amp;&amp; err != errOutOfCodes {
        return err
    }
}

// Write the eof code.
eof := uint32(1)&lt;&lt;e.litWidth + 1
if err := e.write(e, eof); err != nil {
    return err
}
</code></pre></td></tr></table>
</div>
</div><p>At a glance, this code is about half error checks. My eyes glaze over when I read it. And we know that code that is tedious to write and tedious to read is easy to misread, making it a good home for hard-to-find bugs. For example, one of these three error checks is not like the others, a fact that is easy to miss on a quick skim. If you were debugging this code, how long would it take to notice that?</p>
<p>At Gophercon last year we <a href="https://go.dev/design/go2draft-error-handling" target="_blank" rel="noopener noreffer">presented a draft design</a> for a new control flow construct marked by the keyword <code>check</code>. <code>Check</code> consumes the error result from a function call or expression. If the error is non-nil, the <code>check</code> returns that error. Otherwise the <code>check</code> evaluates to the other results from the call. We can use <code>check</code> to simplify the lzw code:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// Write the savedCode if valid.
if e.savedCode != invalidCode {
    check e.write(e, e.savedCode)
    if err := e.incHi(); err != errOutOfCodes {
        check err
    }
}

// Write the eof code.
eof := uint32(1)&lt;&lt;e.litWidth + 1
check e.write(e, eof)
</code></pre></td></tr></table>
</div>
</div><p>This version of the same code uses <code>check</code>, which removes four lines of code and more importantly highlights that the call to <code>e.incHi</code> is allowed to return <code>errOutOfCodes</code>.</p>
<p>Maybe most importantly, the design also allowed defining error handler blocks to be run when later checks failed. That would let you write shared context-adding code just once, like in this snippet:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">handle err {
    err = fmt.Errorf(&#34;closing writer: %w&#34;, err)
}

// Write the savedCode if valid.
if e.savedCode != invalidCode {
    check e.write(e, e.savedCode)
    if err := e.incHi(); err != errOutOfCodes {
        check err
    }
}

// Write the eof code.
eof := uint32(1)&lt;&lt;e.litWidth + 1
check e.write(e, eof)
</code></pre></td></tr></table>
</div>
</div><p>In essence, <code>check</code> was a short way to write the <code>if</code> statement, and <code>handle</code> was like <a href="https://go.dev/ref/spec#Defer_statements" target="_blank" rel="noopener noreffer"><code>defer</code></a> but only for error return paths. In contrast to exceptions in other languages, this design retained Go’s important property that every potential failing call was marked explicitly in the code, now using the <code>check</code> keyword instead of <code>if err != nil</code>.</p>
<p>The big problem with this design was that <code>handle</code> overlapped too much, and in confusing ways, with <code>defer</code>.</p>
<p>In May we posted <a href="https://go.dev/design/32437-try-builtin" target="_blank" rel="noopener noreffer">a new design with three simplifications</a>: to avoid the confusion with <code>defer</code>, the design dropped <code>handle</code> in favor of just using <code>defer</code>; to match a similar idea in Rust and Swift, the design renamed <code>check</code> to <code>try</code>; and to allow experimentation in a way that existing parsers like <code>gofmt</code> would recognize, it changed <code>check</code> (now <code>try</code>) from a keyword to a built-in function.</p>
<p>Now the same code would look like this:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">defer errd.Wrapf(&amp;err, &#34;closing writer&#34;)

// Write the savedCode if valid.
if e.savedCode != invalidCode {
    try(e.write(e, e.savedCode))
    if err := e.incHi(); err != errOutOfCodes {
        try(err)
    }
}

// Write the eof code.
eof := uint32(1)&lt;&lt;e.litWidth + 1
try(e.write(e, eof))
</code></pre></td></tr></table>
</div>
</div><p>We spent most of June discussing this proposal publicly on GitHub.</p>
<p>The fundamental idea of <code>check</code> or <code>try</code> was to shorten the amount of syntax repeated at each error check, and in particular to remove the <code>return</code> statement from view, keeping the error check explicit and better highlighting interesting variations. One interesting point raised during the public feedback discussion, however, was that without an explicit <code>if</code> statement and <code>return</code>, there’s nowhere to put a debugging print, there’s nowhere to put a breakpoint, and there’s no code to show as unexecuted in code coverage results. The benefits we were after came at the cost of making these situations more complex. On balance, from this as well as other considerations, it was not at all clear that the overall result would be simpler Go development, so we abandoned this experiment.</p>
<p>That’s everything about error handling, which was one of the main focuses for this year.</p>
<h2 id="generics">Generics</h2>
<p>Now for something a little less controversial: generics.</p>
<p>The second big topic we identified for Go 2 was some kind of way to write code with type parameters. This would enable writing generic data structures and also writing generic functions that work with any kind of slice, or any kind of channel, or any kind of map. For example, here is a generic channel filter:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">// Filter copies values from c to the returned channel,
// passing along only those values satisfying f.
func Filter(type value)(f func(value) bool, c &lt;-chan value) &lt;-chan value {
    out := make(chan value)
    go func() {
        for v := range c {
            if f(v) {
                out &lt;- v
            }
        }
        close(out)
    }()
    return out
}
</code></pre></td></tr></table>
</div>
</div><p>We’ve been thinking about generics since work on Go began, and we wrote and rejected our first concrete design in 2010. We wrote and rejected three more designs by the end of 2013. Four abandoned experiments, but not failed experiments, We learned from them, like we learned from <code>check</code> and <code>try</code>. Each time, we learned that the path to Go 2 is not in that exact direction, and we noticed other directions that might be interesting to explore. But by 2013 we had decided that we needed to focus on other concerns, so we put the entire topic aside for a few years.</p>
<p>Last year we started exploring and experimenting again, and we presented a <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md" target="_blank" rel="noopener noreffer">new design</a>, based on the idea of a contract, at Gophercon last summer. We’ve continued to experiment and simplify, and we’ve been working with programming language theory experts to understand the design better.</p>
<p>Overall, I am hopeful that we’re headed in a good direction, toward a design that will simplify Go development. Even so, we might find that this design doesn’t work either. We might have to abandon this experiment and adjust our path based on what we learned. We’ll find out.</p>
<p>At Gophercon 2019, Ian Lance Taylor talked about why we might want to add generics to Go and briefly previewed the latest design draft. For details, see his blog post “<a href="https://blog.golang.org/why-generics" target="_blank" rel="noopener noreffer">Why Generics?</a>”</p>
<h2 id="dependencies">Dependencies</h2>
<p>The third big topic we identified for Go 2 was dependency management.</p>
<p>In 2010 we published a tool called <code>goinstall</code>, which we called “<a href="https://groups.google.com/forum/#!msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J" target="_blank" rel="noopener noreffer">an experiment in package installation</a>.” It downloaded dependencies and stored them in your Go distribution tree, in GOROOT.</p>
<p>As we experimented with <code>goinstall</code>, we learned that the Go distribution and the installed packages should be kept separate, so that it was possible to change to a new Go distribution without losing all your Go packages. So in 2011 we introduced <code>GOPATH</code>, an environment variable that specified where to look for packages not found in the main Go distribution.</p>
<p>Adding GOPATH created more places for Go packages but simplified Go development overall, by separating your Go distribution from your Go libraries.</p>
<p><strong>Compatibility</strong></p>
<p>The <code>goinstall</code> experiment intentionally left out an explicit concept of package versioning. Instead, <code>goinstall</code> always downloaded the latest copy. We did this so we could focus on the other design problems for package installation.</p>
<p><code>Goinstall</code> became <code>go get</code> as part of Go 1. When people asked about versions, we encouraged them to experiment by creating additional tools, and they did. And we encouraged package authors to provide their users with the same backwards compatibility we did for the Go 1 libraries. Quoting <a href="https://go.dev/doc/faq#get_version" target="_blank" rel="noopener noreffer">the Go FAQ</a>:</p>
<p>“Packages intended for public use should try to maintain backwards compatibility as they evolve.</p>
<p>If different functionality is required, add a new name instead of changing an old one.</p>
<p>If a complete break is required, create a new package with a new import path.”</p>
<p>This convention simplifies the overall experience of using a package by restricting what authors can do: avoid breaking changes to APIs; give new functionality a new name; and give a whole new package design a new import path.</p>
<p>Of course, people kept experimenting. One of the most interesting experiments was started by Gustavo Niemeyer. He created a Git redirector called <a href="https://gopkg.in/" target="_blank" rel="noopener noreffer"><code>gopkg.in</code></a>, which provided different import paths for different API versions, to help package authors follow the convention of giving a new package design a new import path.</p>
<p>For example, the Go source code in the GitHub repository <a href="https://github.com/go-yaml/yaml" target="_blank" rel="noopener noreffer">go-yaml/yaml</a> has different APIs in the v1 and v2 semantic version tags. The <code>gopkg.in</code> server provides these with different import paths <a href="https://godoc.org/gopkg.in/yaml.v1" target="_blank" rel="noopener noreffer">gopkg.in/yaml.v1</a> and <a href="https://godoc.org/gopkg.in/yaml.v2" target="_blank" rel="noopener noreffer">gopkg.in/yaml.v2</a>.</p>
<p>The convention of providing backwards compatibility, so that a newer version of a package can be used in place of an older version, is what makes <code>go get</code>’s very simple rule—“always download the latest copy”—work well even today.</p>
<p><strong>Versioning And Vendoring</strong></p>
<p>But in production contexts you need to be more precise about dependency versions, to make builds reproducible.</p>
<p>Many people experimented with what that should look like, building tools that served their needs, including Keith Rarick’s <code>goven</code> (2012) and <code>godep</code> (2013), Matt Butcher’s <code>glide</code> (2014), and Dave Cheney’s <code>gb</code> (2015). All of these tools use the model that you copy dependency packages into your own source control repository. The exact mechanisms used to make those packages available for import varied, but they were all more complex than it seemed they should be.</p>
<p>After a community-wide discussion, we adopted a proposal by Keith Rarick to add explicit support for referring to copied dependencies without GOPATH tricks. This was simplifying by reshaping: like with <code>addToList</code> and <code>append</code>, these tools were already implementing the concept, but it was more awkward than it needed to be. Adding explicit support for vendor directories made these uses simpler overall.</p>
<p>Shipping vendor directories in the <code>go</code> command led to more experimentation with vendoring itself, and we realized that we had introduced a few problems. The most serious was that we lost <em>package uniqueness</em>. Before, during any given build, an import path might appear in lots of different packages, and all the imports referred to the same target. Now with vendoring, the same import path in different packages might refer to different vendored copies of the package, all of which would appear in the final resulting binary.</p>
<p>At the time, we didn’t have a name for this property: package uniqueness. It was just how the GOPATH model worked. We didn’t completely appreciate it until it went away.</p>
<p>There is a parallel here with the <code>check</code> and <code>try</code> error syntax proposals. In that case, we were relying on how the visible <code>return</code> statement worked in ways we didn’t appreciate until we considered removing it.</p>
<p>When we added vendor directory support, there were many different tools for managing dependencies. We thought that a clear agreement about the format of vendor directories and vendoring metadata would allow the various tools to interoperate, the same way that agreement about how Go programs are stored in text files enables interoperation between the Go compiler, text editors, and tools like <code>goimports</code> and <code>gorename</code>.</p>
<p>This turned out to be naively optimistic. The vendoring tools all differed in subtle semantic ways. Interoperation would require changing them all to agree about the semantics, likely breaking their respective users. Convergence did not happen.</p>
<p><strong>Dep</strong></p>
<p>At Gophercon in 2016, we started an effort to define a single tool to manage dependencies. As part of that effort, we conducted surveys with many different kinds of users to understand what they needed as far as dependency management, and a team started work on a new tool, which became <code>dep</code>.</p>
<p><code>Dep</code> aimed to be able to replace all the existing dependency management tools. The goal was to simplify by reshaping the existing different tools into a single one. It partly accomplished that. <code>Dep</code> also restored package uniqueness for its users, by having only one vendor directory at the top of the project tree.</p>
<p>But <code>dep</code> also introduced a serious problem that took us a while to fully appreciate. The problem was that <code>dep</code> embraced a design choice from <code>glide</code>, to support and encourage incompatible changes to a given package without changing the import path.</p>
<p>Here is an example. Suppose you are building your own program, and you need to have a configuration file, so you use version 2 of a popular Go YAML package:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="experiment/yamldeps1.png"
        data-srcset="experiment/yamldeps1.png, experiment/yamldeps1.png 1.5x, experiment/yamldeps1.png 2x"
        data-sizes="auto"
        alt="experiment/yamldeps1.png"
        title="experiment/yamldeps1.png" /></p>
<p>Now suppose your program imports the Kubernetes client. It turns out that Kubernetes uses YAML extensively, and it uses version 1 of the same popular package:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="experiment/yamldeps2.png"
        data-srcset="experiment/yamldeps2.png, experiment/yamldeps2.png 1.5x, experiment/yamldeps2.png 2x"
        data-sizes="auto"
        alt="experiment/yamldeps2.png"
        title="experiment/yamldeps2.png" /></p>
<p>Version 1 and version 2 have incompatible APIs, but they also have different import paths, so there is no ambiguity about which is meant by a given import. Kubernetes gets version 1, your config parser gets version 2, and everything works.</p>
<p><code>Dep</code> abandoned this model. Version 1 and version 2 of the yaml package would now have the same import path, producing a conflict. Using the same import path for two incompatible versions, combined with package uniqueness, makes it impossible to build this program that you could build before:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="experiment/yamldeps3.png"
        data-srcset="experiment/yamldeps3.png, experiment/yamldeps3.png 1.5x, experiment/yamldeps3.png 2x"
        data-sizes="auto"
        alt="experiment/yamldeps3.png"
        title="experiment/yamldeps3.png" /></p>
<p>It took us a while to understand this problem, because we had been applying the “new API means new import path” convention for so long that we took it for granted. The dep experiment helped us appreciate that convention better, and we gave it a name: the <em>import compatibility rule</em>:</p>
<p>“If an old package and a new package have the same import path, the new package must be backwards compatible with the old package.”</p>
<p><strong>Go Modules</strong></p>
<p>We took what worked well in the dep experiment and what we learned about what didn’t work well, and we experimented with a new design, called <code>vgo</code>. In <code>vgo</code>, packages followed the import compatibility rule, so that we can provide package uniqueness but still not break builds like the one we just looked at. This let us simplify other parts of the design as well.</p>
<p>Besides restoring the import compatibility rule, another important part of the <code>vgo</code> design was to give the concept of a group of packages a name and to allow that grouping to be separated from source code repository boundaries. The name of a group of Go packages is a module, so we refer to the system now as Go modules.</p>
<p>Go modules are now integrated with the <code>go</code> command, which avoids needing to copy around vendor directories at all.</p>
<p><strong>Replacing GOPATH</strong></p>
<p>With Go modules comes the end of GOPATH as a global name space. Nearly all the hard work of converting existing Go usage and tools to modules is caused by this change, from moving away from GOPATH.</p>
<p>The fundamental idea of GOPATH is that the GOPATH directory tree is the global source of truth for what versions are being used, and the versions being used don’t change as you move around between directories. But the global GOPATH mode is in direct conflict with the production requirement of per-project reproducible builds, which itself simplifies the Go development and deployment experience in many important ways.</p>
<p>Per-project reproducible builds means that when you are working in a checkout of project A, you get the same set of dependency versions that the other developers of project A get at that commit, as defined by the <code>go.mod</code> file. When you switch to working in a checkout of project B, now you get that project’s chosen dependency versions, the same set that the other developers of project B get. But those are likely different from project A. The set of dependency versions changing when you move from project A to project B is necessary to keep your development in sync with that of the other developers on A and on B. There can’t be a single global GOPATH anymore.</p>
<p>Most of the complexity of adopting modules arises directly from the loss of the one global GOPATH. Where is the source code for a package? Before, the answer depended only on your GOPATH environment variable, which most people rarely changed. Now, the answer depends on what project you are working on, which may change often. Everything needs updating for this new convention.</p>
<p>Most development tools use the <a href="https://godoc.org/go/build" target="_blank" rel="noopener noreffer"><code>go/build</code></a> package to find and load Go source code. We’ve kept that package working, but the API did not anticipate modules, and the workarounds we added to avoid API changes are slower than we’d like. We’ve published a replacement, <a href="https://godoc.org/golang.org/x/tools/go/packages" target="_blank" rel="noopener noreffer"><code>golang.org/x/tools/go/packages</code></a>. Developer tools should now use that instead. It supports both GOPATH and Go modules, and it is faster and easier to use. In a release or two we may move it into the standard library, but for now <a href="https://godoc.org/golang.org/x/tools/go/packages" target="_blank" rel="noopener noreffer"><code>golang.org/x/tools/go/packages</code></a> is stable and ready for use.</p>
<p><strong>Go Module Proxies</strong></p>
<p>One of the ways modules simplify Go development is by separating the concept of a group of packages from the underlying source control repository where they are stored.</p>
<p>When we talked to Go users about dependencies, almost everyone using Go at their companies asked how to route <code>go get</code> package fetches through their own servers, to better control what code can be used. And even open-source developers were concerned about dependencies disappearing or changing unexpectedly, breaking their builds. Before modules, users had attempted complex solutions to these problems, including intercepting the version control commands that the <code>go</code> command runs.</p>
<p>The Go modules design makes it easy to introduce the idea of a module proxy that can be asked for a specific module version.</p>
<p>Companies can now easily run their own module proxy, with custom rules about what is allowed and where cached copies are stored. The open-source <a href="https://docs.gomods.io/" target="_blank" rel="noopener noreffer">Athens project</a> has built just such a proxy, and Aaron Schlesinger gave a talk about it at Gophercon 2019. (We’ll add a link here when the video becomes available.)</p>
<p>And for individual developers and open source teams, the Go team at Google has <a href="https://groups.google.com/forum/#!topic/golang-announce/0wo8cOhGuAI" target="_blank" rel="noopener noreffer">launched a proxy</a> that serves as a public mirror of all open-source Go packages, and Go 1.13 will use that proxy by default when in module mode. Katie Hockman gave a <a href="https://youtu.be/KqTySYYhPUE" target="_blank" rel="noopener noreffer">talk about this system at Gophercon 2019</a>.</p>
<p><strong>Go Modules Status</strong></p>
<p>Go 1.11 introduced modules as an experimental, opt-in preview. We keep experimenting and simplifying. Go 1.12 shipped improvements, and Go 1.13 will ship more improvements.</p>
<p>Modules are now at the point where we believe that they will serve most users, but we aren’t ready to shut down GOPATH just yet. We will keep experimenting, simplifying, and revising.</p>
<p>We fully recognize that the Go user community built up almost a decade of experience and tooling and workflows around GOPATH, and it will take a while to convert all of that to Go modules.</p>
<p>But again, we think that modules will now work very well for most users, and I encourage you to take a look when Go 1.13 is released.</p>
<p>As one data point, the Kubernetes project has a lot of dependencies, and they have migrated to using Go modules to manage them. You probably can too. And if you can’t, please let us know what’s not working for you or what’s too complex, by <a href="https://go.dev/issue/new" target="_blank" rel="noopener noreffer">filing a bug report</a>, and we will experiment and simplify.</p>
<h2 id="tools">Tools</h2>
<p>Error handling, generics, and dependency management are going to take a few more years at least, and we’re going to focus on them for now. Error handling is close to done, modules will be next after that, and maybe generics after that.</p>
<p>But suppose we look a couple years out, to when we are done experimenting and simplifying and have shipped error handling, modules, and generics. Then what? It’s very difficult to predict the future, but I think that once these three have shipped, that may mark the start of a new quiet period for major changes. Our focus at that point will likely shift to simplifying Go development with improved tools.</p>
<p>Some of the tool work is already underway, so this post finishes by looking at that.</p>
<p>While we helped update all the Go community’s existing tools to understand Go modules, we noticed that having a ton of development helper tools that each do one small job is not serving users well. The individual tools are too hard to combine, too slow to invoke, and too different to use.</p>
<p>We began an effort to unify the most commonly-required development helpers into a single tool, now called <code>gopls</code> (pronounced “go, please”). <code>Gopls</code> speaks the <a href="https://langserver.org/" target="_blank" rel="noopener noreffer">Language Server Protocol, LSP</a>, and works with any integrated development environment or text editor with LSP support, which is essentially everything at this point.</p>
<p><code>Gopls</code> marks an expansion in focus for the Go project, from delivering standalone compiler-like, command-line tools like go vet or gorename to also delivering a complete IDE service. Rebecca Stambler gave a talk with more details about <code>gopls</code> and IDEs at Gophercon 2019. (We’ll add a link here when the video becomes available.)</p>
<p>After <code>gopls</code>, we also have ideas for reviving <code>go fix</code> in an extensible way and for making <code>go vet</code> even more helpful.</p>
<h2 id="coda">Coda</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="experiment/expsimp2.png"
        data-srcset="experiment/expsimp2.png, experiment/expsimp2.png 1.5x, experiment/expsimp2.png 2x"
        data-sizes="auto"
        alt="experiment/expsimp2.png"
        title="experiment/expsimp2.png" /></p>
<p>So there’s the path to Go 2. We will experiment and simplify. And experiment and simplify. And ship. And experiment and simplify. And do it all again. It may look or even feel like the path goes around in circles. But each time we experiment and simplify we learn a little more about what Go 2 should look like and move another step closer to it. Even abandoned experiments like <code>try</code> or our first four generics designs or <code>dep</code> are not wasted time. They help us learn what needs to be simplified before we can ship, and in some cases they help us better understand something we took for granted.</p>
<p>At some point we will realize we have experimented enough, and simplified enough, and shipped enough, and we will have Go 2.</p>
<p>Thanks to all of you in the Go community for helping us experiment and simplify and ship and find our way on this path.</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-10-29 00:00:00</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/gb_20190801/" data-title="Gb_20190801" data-hashtags="go official blogs"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/gb_20190801/" data-hashtag="go official blogs"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/gb_20190801/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/gb_20190801/" data-title="Gb_20190801"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/gb_20190801/" data-title="Gb_20190801"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/gb_20190801/" data-title="Gb_20190801"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/go-official-blogs/">go official blogs</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/gb_20190731/" class="prev" rel="prev" title="Gb_20190731"><i class="fas fa-angle-left fa-fw"></i>Gb_20190731</a>
            <a href="/gb_20190815/" class="next" rel="next" title="Gb_20190815">Gb_20190815<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
