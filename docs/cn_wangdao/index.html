<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>CN_wangdao - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="CN_wangdao" />
<meta property="og:description" content="第1章计算机网络体系结构 1.1计算机网络概述 1.1.1概念 简而言之，计算机网络是一些互联的、自治的计算机系统的集合。 广义观点：能够实现远程信" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/cn_wangdao/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-03T10:46:24+08:00" />
<meta property="article:modified_time" content="2022-10-08T19:55:40+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="CN_wangdao"/>
<meta name="twitter:description" content="第1章计算机网络体系结构 1.1计算机网络概述 1.1.1概念 简而言之，计算机网络是一些互联的、自治的计算机系统的集合。 广义观点：能够实现远程信"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/cn_wangdao/" /><link rel="prev" href="https://jefofrank.xyz/git/" /><link rel="next" href="https://jefofrank.xyz/k8s_base/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "CN_wangdao",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/cn_wangdao\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "computer network","wordcount":  83329 ,
        "url": "https:\/\/jefofrank.xyz\/cn_wangdao\/","datePublished": "2022-06-03T10:46:24+08:00","dateModified": "2022-10-08T19:55:40+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">CN_wangdao</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/school-courses/"><i class="far fa-folder fa-fw"></i>School courses</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-06-03 10:46:24">2022-06-03 10:46:24</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 83329 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 167 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#第1章计算机网络体系结构">第1章计算机网络体系结构</a>
      <ul>
        <li><a href="#11计算机网络概述">1.1计算机网络概述</a>
          <ul>
            <li><a href="#111概念">1.1.1概念</a></li>
            <li><a href="#112组成">1.1.2组成</a></li>
            <li><a href="#113计算机网络的功能">1.1.3计算机网络的功能</a></li>
            <li><a href="#114计算机网络的分类">1.1.4计算机网络的分类</a></li>
            <li><a href="#115计算机网络的标准化工作及相关组织略">1.1.5计算机网络的标准化工作及相关组织（略）</a></li>
            <li><a href="#116计算机网络的性能指标">1.1.6计算机网络的性能指标</a></li>
          </ul>
        </li>
        <li><a href="#12计算机网络体系结构与参考模型">1.2计算机网络体系结构与参考模型</a>
          <ul>
            <li><a href="#121计算机网络分层结构">1.2.1计算机网络分层结构</a></li>
            <li><a href="#122协议接口服务">1.2.2协议、接口、服务</a></li>
            <li><a href="#123isoosi参考模型和tcpip模型">1.2.3ISO/OSI参考模型和TCP/IP模型</a></li>
          </ul>
        </li>
        <li><a href="#13本章小结及疑难点">1.3本章小结及疑难点</a></li>
      </ul>
    </li>
    <li><a href="#第2章物理层">第2章物理层</a>
      <ul>
        <li><a href="#21通信基础">2.1通信基础</a>
          <ul>
            <li><a href="#211概念">2.1.1概念</a></li>
            <li><a href="#212奈奎斯特定理香农定理">2.1.2奈奎斯特定理、香农定理</a></li>
            <li><a href="#213编码与调制">2.1.3编码与调制</a></li>
            <li><a href="#214电路交换报文交换分组交换">2.1.4电路交换、报文交换、分组交换</a></li>
            <li><a href="#215数据报与虚电路">2.1.5数据报与虚电路</a></li>
          </ul>
        </li>
        <li><a href="#22传输介质">2.2传输介质</a>
          <ul>
            <li><a href="#221双绞线同轴电缆光纤与无线传输介质">2.2.1双绞线、同轴电缆、光纤与无线传输介质</a></li>
            <li><a href="#222物理层接口的特性">2.2.2物理层接口的特性</a></li>
          </ul>
        </li>
        <li><a href="#23物理层设备">2.3物理层设备</a>
          <ul>
            <li><a href="#231中继器">2.3.1中继器</a></li>
            <li><a href="#222集线器">2.2.2集线器</a></li>
          </ul>
        </li>
        <li><a href="#24本章小结及疑难点">2.4本章小结及疑难点</a></li>
      </ul>
    </li>
    <li><a href="#第3章数据链路层">第3章数据链路层</a>
      <ul>
        <li><a href="#31数据链路层的功能">3.1数据链路层的功能</a>
          <ul>
            <li><a href="#311为网络层提供服务">3.1.1为网络层提供服务</a></li>
            <li><a href="#312链路管理">3.1.2链路管理</a></li>
            <li><a href="#313帧定界帧同步透明传输">3.1.3帧定界、帧同步、透明传输</a></li>
            <li><a href="#314流量控制">3.1.4流量控制</a></li>
            <li><a href="#315差错控制">3.1.5差错控制</a></li>
          </ul>
        </li>
        <li><a href="#32组帧">3.2组帧</a>
          <ul>
            <li><a href="#321字符计数法">3.2.1字符计数法</a></li>
            <li><a href="#322字符填充的首尾定界符法">3.2.2字符填充的首尾定界符法</a></li>
            <li><a href="#323零比特填充的首尾标志法">3.2.3零比特填充的首尾标志法</a></li>
            <li><a href="#324违规编码法">3.2.4违规编码法</a></li>
          </ul>
        </li>
        <li><a href="#33差错控制">3.3差错控制</a>
          <ul>
            <li><a href="#331检错编码">3.3.1检错编码</a></li>
            <li><a href="#332纠错编码">3.3.2纠错编码</a></li>
          </ul>
        </li>
        <li><a href="#34流量控制与可靠传输机制">3.4流量控制与可靠传输机制</a>
          <ul>
            <li><a href="#341流量控制可靠传输和滑动窗口机制">3.4.1流量控制、可靠传输和滑动窗口机制</a></li>
            <li><a href="#342单帧滑动窗口与停止-等待协议">3.4.2单帧滑动窗口与停止-等待协议</a></li>
            <li><a href="#343多帧滑动窗口与后退n帧协议gbn">3.4.3多帧滑动窗口与后退N帧协议(GBN)</a></li>
            <li><a href="#344多帧滑动窗口与选择重传协议sr">3.4.4多帧滑动窗口与选择重传协议(SR)</a></li>
          </ul>
        </li>
        <li><a href="#35介质访问控制">3.5介质访问控制</a>
          <ul>
            <li><a href="#351信道划分介质访问控制">3.5.1信道划分介质访问控制</a></li>
            <li><a href="#352随机访问介质访问控制">3.5.2随机访问介质访问控制</a></li>
            <li><a href="#353轮询访问介质访问控制令牌传递协议">3.5.3轮询访问介质访问控制:令牌传递协议</a></li>
          </ul>
        </li>
        <li><a href="#36局域网">3.6局域网</a>
          <ul>
            <li><a href="#361局域网">3.6.1局域网</a></li>
            <li><a href="#362以太网与ieee-8023">3.6.2以太网与IEEE 802.3</a></li>
            <li><a href="#363ieee-80211">3.6.3IEEE 802.11</a></li>
            <li><a href="#364令牌环网的基本原理">3.6.4令牌环网的基本原理</a></li>
          </ul>
        </li>
        <li><a href="#37广域网">3.7广域网</a>
          <ul>
            <li><a href="#371广域网基本概念">3.7.1广域网基本概念</a></li>
            <li><a href="#372ppp协议">3.7.2PPP协议</a></li>
            <li><a href="#373hdlc协议">3.7.3HDLC协议</a></li>
          </ul>
        </li>
        <li><a href="#38数据链路层设备">3.8数据链路层设备</a>
          <ul>
            <li><a href="#381网桥的概念与基本原理">3.8.1网桥的概念与基本原理</a></li>
            <li><a href="#382局域网交换机及其工作原理">3.8.2局域网交换机及其工作原理</a></li>
          </ul>
        </li>
        <li><a href="#39本章小结及疑难点">3.9本章小结及疑难点</a></li>
      </ul>
    </li>
    <li><a href="#第4章网络层">第4章网络层</a>
      <ul>
        <li><a href="#41网络层的功能">4.1网络层的功能</a>
          <ul>
            <li><a href="#411异构网络互联">4.1.1异构网络互联</a></li>
            <li><a href="#412路由和转发">4.1.2路由和转发</a></li>
            <li><a href="#413拥塞控制">4.1.3拥塞控制</a></li>
          </ul>
        </li>
        <li><a href="#42路由算法">4.2路由算法</a>
          <ul>
            <li><a href="#421静态路由和动态路由">4.2.1静态路由和动态路由</a></li>
            <li><a href="#422距离向量路由算法">4.2.2距离向量路由算法</a></li>
            <li><a href="#423链路状态路由算法">4.2.3链路状态路由算法</a></li>
            <li><a href="#424层次路由">4.2.4层次路由</a></li>
          </ul>
        </li>
        <li><a href="#43-ipv4">4.3 IPv4</a>
          <ul>
            <li><a href="#431ipv4分组">4.3.1IPv4分组</a></li>
            <li><a href="#432ipv4地址与nat">4.3.2IPv4地址与NAT</a></li>
            <li><a href="#433子网划分与子网掩码cidr">4.3.3子网划分与子网掩码、CIDR</a></li>
            <li><a href="#434arpdhcpicmp">4.3.4ARP、DHCP、ICMP</a></li>
          </ul>
        </li>
        <li><a href="#44-ipv6">4.4 IPv6</a>
          <ul>
            <li><a href="#441ipv6主要特点">4.4.1IPv6主要特点</a></li>
            <li><a href="#442ipv6地址">4.4.2IPv6地址</a></li>
          </ul>
        </li>
        <li><a href="#45路由协议">4.5路由协议</a>
          <ul>
            <li><a href="#451自治系统">4.5.1自治系统</a></li>
            <li><a href="#452域内路由与域间路由">4.5.2域内路由与域间路由</a></li>
            <li><a href="#453路由信息协议rip">4.5.3路由信息协议（RIP）</a></li>
            <li><a href="#454开放最短路径优先ospf协议">4.5.4开放最短路径优先(OSPF)协议</a></li>
            <li><a href="#455边界网关协议bgp">4.5.5边界网关协议(BGP)</a></li>
          </ul>
        </li>
        <li><a href="#46-ip组播">4.6 IP组播</a>
          <ul>
            <li><a href="#461组播概念">4.6.1组播概念</a></li>
            <li><a href="#462ip组播地址">4.6.2IP组播地址</a></li>
            <li><a href="#463igmp与组播路由算法">4.6.3IGMP与组播路由算法</a></li>
          </ul>
        </li>
        <li><a href="#47移动ip">4.7移动IP</a>
          <ul>
            <li><a href="#471概念">4.7.1概念</a></li>
            <li><a href="#472移动ip通信过程">4.7.2移动IP通信过程</a></li>
          </ul>
        </li>
        <li><a href="#48网络层设备">4.8网络层设备</a>
          <ul>
            <li><a href="#481路由器的组成和功能">4.8.1路由器的组成和功能</a></li>
            <li><a href="#482路由表和路由转发">4.8.2路由表和路由转发</a></li>
          </ul>
        </li>
        <li><a href="#49本章小结及疑难点">4.9本章小结及疑难点</a></li>
      </ul>
    </li>
    <li><a href="#第5章传输层">第5章传输层</a>
      <ul>
        <li><a href="#51传输层提供的服务">5.1传输层提供的服务</a>
          <ul>
            <li><a href="#511传输层的功能">5.1.1传输层的功能</a></li>
            <li><a href="#512传输层的寻址与端口">5.1.2传输层的寻址与端口</a></li>
            <li><a href="#513无连接服务与面向连接服务">5.1.3无连接服务与面向连接服务</a></li>
          </ul>
        </li>
        <li><a href="#52-udp协议">5.2 UDP协议</a>
          <ul>
            <li><a href="#521udp数据报">5.2.1UDP数据报</a></li>
            <li><a href="#522udp校验">5.2.2UDP校验</a></li>
          </ul>
        </li>
        <li><a href="#53-tcp协议">5.3 TCP协议</a>
          <ul>
            <li><a href="#531tcp协议特点">5.3.1TCP协议特点</a></li>
            <li><a href="#532tcp报文段">5.3.2TCP报文段</a></li>
            <li><a href="#533tcp连接管理">5.3.3TCP连接管理</a></li>
            <li><a href="#534tcp可靠传输">5.3.4TCP可靠传输</a></li>
            <li><a href="#535tcp流量控制">5.3.5TCP流量控制</a></li>
            <li><a href="#536tcp拥塞控制">5.3.6TCP拥塞控制</a></li>
          </ul>
        </li>
        <li><a href="#54本章小结及疑难点">5.4本章小结及疑难点</a></li>
      </ul>
    </li>
    <li><a href="#第6章应用层">第6章应用层</a>
      <ul>
        <li><a href="#61网络应用模型">6.1网络应用模型</a>
          <ul>
            <li><a href="#611cs模型">6.1.1CS模型</a></li>
            <li><a href="#612p2p模型">6.1.2P2P模型</a></li>
          </ul>
        </li>
        <li><a href="#62域名系统dns">6.2域名系统(DNS)</a>
          <ul>
            <li><a href="#621层次域名空间">6.2.1层次域名空间</a></li>
            <li><a href="#622域名服务器">6.2.2域名服务器</a></li>
            <li><a href="#623域名解析过程">6.2.3域名解析过程</a></li>
          </ul>
        </li>
        <li><a href="#63文件传输协议ftp">6.3文件传输协议(FTP)</a>
          <ul>
            <li><a href="#631ftp工作原理">6.3.1FTP工作原理</a></li>
            <li><a href="#632控制连接和数据连接">6.3.2控制连接和数据连接</a></li>
          </ul>
        </li>
        <li><a href="#64电子邮件">6.4电子邮件</a>
          <ul>
            <li><a href="#641电子邮件系统的组成结构">6.4.1电子邮件系统的组成结构</a></li>
            <li><a href="#642电子邮件格式与mime">6.4.2电子邮件格式与MIME</a></li>
            <li><a href="#643smtp和pop3">6.4.3SMTP和POP3</a></li>
          </ul>
        </li>
        <li><a href="#65万维网www">6.5万维网(WWW)</a>
          <ul>
            <li><a href="#651www的概念与组成结构">6.5.1WWW的概念与组成结构</a></li>
            <li><a href="#652http">6.5.2HTTP</a></li>
          </ul>
        </li>
        <li><a href="#66本章小结及疑难点">6.6本章小结及疑难点</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="第1章计算机网络体系结构">第1章计算机网络体系结构</h2>
<h3 id="11计算机网络概述">1.1计算机网络概述</h3>
<h4 id="111概念">1.1.1概念</h4>
<p>简而言之，计算机网络是一些互联的、自治的计算机系统的集合。</p>
<ul>
<li>广义观点：能够实现远程信息处理的系统或进一步达到资源共享</li>
<li>资源共享观点：能够以相互资源共享的方式互联起来的自治计算机系统的集合，计算机需遵循统一规则&ndash;网络协议</li>
<li>用户透明性观点：能够为用户自动管理资源的网络操作系统，对用户透明。用户使用网络就像使用一台单一的超级计算机，无须了解网络的存在、资源的位置信息。用户透明性观点的定义描述了一个分布式系统，它是网络未来发展追求的目标。</li>
</ul>
<h4 id="112组成">1.1.2组成</h4>
<p>不同角度：</p>
<ul>
<li>
<p>组成部分：硬件、软件、协议</p>
<ul>
<li>硬件主要由主机(也称端系统)、通信链路(如双绞线、光纤)、交换设备(如路由器、交换机等)和通信处理机(如网卡)等组成。</li>
<li>软件主要包括各种实现资源共享的软件和方便用户使用的各种工具软件(如网络操作系统、邮件收发程序、FTP 程序、聊天程序等)。软件部分多属于应用层。</li>
<li>协议是计算机网络的核心，协议规定了网络传输数据时所遵循的规范。1.2.1 节将详细讨论协议。</li>
</ul>
</li>
<li>
<p>工作方式：可分为边缘部分和核心部分。</p>
<ul>
<li>边缘部分由所有连接到因特网上、供用户直接使用的主机组成，用来进行通信(如传输数据、音频或视频)和资源共享;</li>
<li>核心部分由大量的网络和连接这些网络的路由器组成，它为边缘部分提供连通性和交换服务。</li>
</ul>
</li>
<li>
<p>功能组成：由通信子网和资源子网组成。</p>
<ul>
<li>通信子网由各种传输介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制和存储的能力，实现联网计算机之间的数据通信。</li>
<li>资源子网是实现资源共享功能的设备及其软件的集合,向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</li>
</ul>
</li>
</ul>
<h4 id="113计算机网络的功能">1.1.3计算机网络的功能</h4>
<ul>
<li>数据通信：比如文件传输、电子邮件等</li>
<li>资源共享：软件、数据、硬件共享</li>
<li>分布式处理：某个计算机系统负荷过重，分配任务给空闲计算机资源</li>
<li>提高可靠性：计算机网络中的各台计算机可通过网络互为替代机</li>
<li>负载均衡：均衡分配工作任务</li>
</ul>
<h4 id="114计算机网络的分类">1.1.4计算机网络的分类</h4>
<ul>
<li>分布范围：
<ul>
<li>WAN：几十千米到几千千米</li>
<li>MAN：5~50千米</li>
<li>LAN：几十米到几千米</li>
<li>PAN：10M</li>
</ul>
</li>
<li>传输技术：
<ul>
<li>广播式网络：联网计算机共享公共通信信道（LAN基本都采用这个，WAN中的无线、卫星通信网络也采用这个）</li>
<li>点对点网络：WAN基本都属于这个</li>
</ul>
</li>
<li>拓扑结构：（网络中节点和线路之间的几何关系，主要指通信子网的拓扑结构）
<ul>
<li>总线形网络</li>
<li>星形网络</li>
<li>环形网络</li>
<li>网状形网络</li>
<li>以上四种互联形成的更复杂网络</li>
</ul>
</li>
<li>使用者：
<ul>
<li>公用网</li>
<li>专用网</li>
</ul>
</li>
<li>交换技术：（交换信息所采用的数据格式和交换装置的方式）
<ul>
<li>电路交换网络：时延小但线路利用率低</li>
<li>报文交换网络：充分利用线路容量、格式转换、差错控制等，但增大了资源开销、缓冲时延、缓冲区难以管理（因为报文大小不确定，不能预知报文大小）等</li>
<li>分组交换网络/包交换网络：具备报文交换的优点，且缓冲区易于管理，包的平均时延更小等，目前为主流网络。</li>
</ul>
</li>
<li>传输介质：
<ul>
<li>有线</li>
<li>无线</li>
</ul>
</li>
</ul>
<h4 id="115计算机网络的标准化工作及相关组织略">1.1.5计算机网络的标准化工作及相关组织（略）</h4>
<p>计算机网络的标准化对计算机网络的发展和推广起到了极为重要的作用。</p>
<p>因特网的所有标准都以RFC ( Request For Comments)的形式在因特网上发布，但并每个RFC都是因特网标准，RFC要上升为因特网的正式标准需经过以下4个阶段。</p>
<ul>
<li>1)因特网草案(Internet Draft)。这个阶段还不是RFC文档。</li>
<li>2)建议标准( Proposed Standard)。从这个阶段开始就成为RFC文档。</li>
<li>3)草案标准(Draft Standard)。</li>
<li>4)因特网标准(Internet Standard)。</li>
</ul>
<p>此外，还有实验的RFC和提供信息的RFC。各种RFC之间的关系略。</p>
<h4 id="116计算机网络的性能指标">1.1.6计算机网络的性能指标</h4>
<ul>
<li>带宽：b/s(比特每秒)</li>
<li>时延：
<ul>
<li>发送时延（传输）</li>
<li>传播时延</li>
<li>处理时延</li>
<li>排队时延</li>
</ul>
</li>
<li>时延带宽积
<ul>
<li>传播时延和信道带宽之积</li>
</ul>
</li>
<li>往返时延
<ul>
<li>发送端发送数据开始，到发送端接收到来自接收端的确认。</li>
</ul>
</li>
<li>吞吐量
<ul>
<li>单位时间内通过某个网络的数据量</li>
</ul>
</li>
<li>速率：b/s</li>
<li>信道利用率
<ul>
<li>某信道有百分之几的时间是有数据通过的</li>
</ul>
</li>
</ul>
<h3 id="12计算机网络体系结构与参考模型">1.2计算机网络体系结构与参考模型</h3>
<h4 id="121计算机网络分层结构">1.2.1计算机网络分层结构</h4>
<p>在计算机网络体系结构的各个层次中，每个报文都分为两部分:一是数据部分，即SDU;
是控制信息部分，即PCI，它们共同组成PDU。</p>
<p>服务数据单元(SDU): 为完成用户所要求的功能而应传送的数据。第n层的服务数据单元
记为n-SDU。
协议控制信息(PCD): 控制协议操作的信息。第n层的协议控制信息记为n-PCI.
协议数据单元(PDU):对等层次之间传送的数据单位称为该层的PDU。第n层的协议数据
单元记为n-PDU。在实际的网络中，每层的协议数据单元都有一个通俗的名称，如物理层的PDU
称为比特，链路层的PDU称为帧，网络层的PDU称为分组，传输层的PDU称为报文。
在各层间传输数据时，把从第n+ 1层收到的PDU作为第n层的SDU,加上第n层的PCI,
就变成了第n层的PDU,交给第n-1层后作为SDU发送，接收方接收时做相反的处理，因此可
知三者的关系为n-SDU + n-PCI= n-PDU =(n- 1)-SDU,其变换过程如图1.5所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220611200345258.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220611200345258.png, D:%5cBlog%5clocalImages%5cimage-20220611200345258.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220611200345258.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220611200345258.png"
        title="image-20220611200345258" /></p>
<h4 id="122协议接口服务">1.2.2协议、接口、服务</h4>
<ul>
<li>协议：规则的集合</li>
<li>接口：同一结点内相邻两层间交换信息的连接点</li>
<li>服务：指下层为紧邻的上层提供的功能调用，是垂直的
<ul>
<li>
<p>OSI中的服务原语有四类</p>
<ul>
<li>1)请求(Request)。 由服务用户发往服务提供者，请求完成某项工作。</li>
<li>2)指示(Indication)。由服务提供者发往服务用户，指示用户做某件事情。</li>
<li>3)响应(Response)。由服务用户发往服务提供者，作为对指示的响应。</li>
<li>4)证实(Confirmation)。由服务提供者发往服务用户，作为对请求的证实。</li>
<li>有应答服务包括上述4类，无服务应答只有请求和指示</li>
</ul>
</li>
<li>
<p>计算机提供的服务可以三种方式分类</p>
<ul>
<li>面向连接服务和无连接服务</li>
<li>可靠服务和不可靠服务</li>
<li>有应答服务和无应答服务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="123isoosi参考模型和tcpip模型">1.2.3ISO/OSI参考模型和TCP/IP模型</h4>
<p>ISO国际标准化组织，OSI/RM开放系统互连参考模型简称OSI参考模型，7层，低三层为通信子网，高三层为资源子网，传输层承上启下</p>
<ul>
<li>
<p>会话层：</p>
<ul>
<li>会话层允许不同主机上的各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。这种服务主要为表示层实体或用户进程建立连接并在连接上有序地传输数据，这就是会话，也称建立同步(SYN)。</li>
<li>会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。会话层可以使用校验点使通信会话在通信失效时从校验点继续恢复通信，实现数据同步。</li>
</ul>
</li>
<li>
<p>表示层</p>
<ul>
<li>表示层主要处理在两个通信系统中交换信息的表示方式。不同机器采用的编码和表示方法不同，使用的数据结构也不同。为了使不同表示方法的数据和信息之间能互相交换，表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密和解密也是表示层可提供的数据表示变换功能。</li>
</ul>
</li>
<li>
<p>应用层</p>
<ul>
<li>应用层是OSI模型的最高层，是用户与网络的界面。应用层为特定类型的网络应用提供访问OSI环境的手段。因为用户的实际应用多种多样，这就要求应用层采用不同的应用协议来解决不同类型的应用要求，因此应用层是最复杂的一层，使用的协议也最多。典型的协议有用于文件传送的FTP、用于电子邮件的SMTP、用于万维网的HTTP等。</li>
</ul>
</li>
</ul>
<p>TCP/IP:
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603151730.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603151730.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603151730.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603151730.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603151730.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603151730.png" /></p>
<p>网络接口层类似OSI的物理层和数据链路层，网际层是关键部分</p>
<p>传输层：传输控制协议TCP+用户数据报协议UDP</p>
<p>应用层(用户-用户)包含所有的高层协议，如虚拟终端协议(Telnet)、文件传输协议(FTP)、域名解析服务(DNS)、 电子邮件协议(SMTP)和超文本传输协议(HTTP)。</p>
<p><strong>学习计算机网络时，我们往往采取折中的办法，即综合OSI和TCP/IP的优点，采用一种只有五层协议的体系结构，即我们所熟知的物理层、数据链路层、网络层、传输层和应用层。本书也采用这种体系结构进行讨论。</strong></p>
<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h3 id="13本章小结及疑难点">1.3本章小结及疑难点</h3>
<h2 id="第2章物理层">第2章物理层</h2>
<h3 id="21通信基础">2.1通信基础</h3>
<h4 id="211概念">2.1.1概念</h4>
<ul>
<li>
<p>数据、信号、码元</p>
<ul>
<li>码元：用固定时长的信号波形/数字脉冲表示一位k进制数字</li>
</ul>
</li>
<li>
<p>信源、信道、信宿</p>
<ul>
<li>
<p>信道按传输信号形式的不同可分为传送模拟信号的模拟信道和传送数字信号的数字信道两大类;信道按传输介质的不同可分为无线信道和有线信道。</p>
</li>
<li>
<p>信道上传送的信号有<strong>基带信号和宽带信号</strong>之分。基带信号将数字信号1和0直接用两种不同的电压表示，然后送到数字信道上传输(称为基带传输);宽带信号将基带信号进行调制后形成频分复用模拟信号，然后传送到模拟信道上去传输(称为宽带传输)。</p>
</li>
<li>
<p>从通信双方信息的交互方式看，可分为三种基本方式:</p>
<ul>
<li>1)单工通信。只有一个方向的通信而没有反方向的交互，仅需要一 条信道。例如，无线电广播、电视广播就属于这种类型。</li>
<li>2)半双工通信。通信的双方都可以发送或接收信息，但任何一方都不能同时发送和接收信息，此时需要两条信道。</li>
<li>3)全双工通信。通信双方可以同时发送和接收信息，也需要两条信道。
信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>速率、波特、带宽</p>
<ul>
<li>码元传输速率（也称调制速率、波形速率、符号速率）：单位是波特Baud，单位时间传输的码元数。和进制数无关</li>
<li>信息传输速率：也称比特率b/s,表示<strong>单位时间内数字通信系统传输的二进制码元个数</strong>，也就是比特数</li>
<li>一个码元若携带n比特的信息量，M Baud的码元传输速率对应Mn b/s的信息传输速率。</li>
</ul>
</li>
</ul>
<h4 id="212奈奎斯特定理香农定理">2.1.2奈奎斯特定理、香农定理</h4>
<ul>
<li>奈奎斯特定理：
<ul>
<li>奈奎斯特(Nyquist) 定理又称奈氏准则，它指出在理想低通(没有噪声、带宽有限)的信道中，极限码元传输率为2W波特，其中W是理想低通信道的带宽，单位为Hz。<strong>若用V表示每个码元离散电平的数目</strong>(码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍)，则极限数据率为：
<ul>
<li><strong>理想低通信道下的极限数据传输率= $2W log_2V$ ( 单位为b/s)</strong></li>
</ul>
</li>
<li>对于奈氏准则，可以得出以下结论:
<ul>
<li>1)在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的<strong>码间串扰问题</strong>(指在接收端收到的信号波形失去了码元之间的清晰界限)，使得接收端不可能完全正确识别码元。</li>
<li>2)信道的频带越宽(即通过的信号高频分量越多)，就可用更高的速率进行码元的有效传输。</li>
<li>3)奈氏准则给出了码元传输速率的限制，但并未对信息传输速率给出限制，即未对一个码元可以对应多少个二进制位给出限制。由于码元的传输速率受奈氏准则的制约，所以要提高数据的传输速率，就必须设法使每个码元携带更多个比特的信息量，此时就需要采用多元制的调制方法。</li>
</ul>
</li>
</ul>
</li>
<li>香农定理：
<ul>
<li>香农(Shannon)定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输率，当用此速率进行传输时，可以做到不产生误差。香农定理定义为
<ul>
<li><strong>信道的极限数据传输率= $Wlog_2(1 + S/N)$(单位为b/s)</strong></li>
</ul>
</li>
<li>式中，W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，即信号的平均功率与噪声的平均功率之比，<strong>信噪比= $10log_10(S/N)$(单位为dB)</strong>,例如如当S/N= 10时，信噪比为10dB， 而当S/N= 1000时，信噪比为30dB。</li>
<li>对于香农定理，可以得出以下结论:
<ul>
<li>1)信道的带宽或信道中的信噪比越大，信息的极限传输速率越高。</li>
<li>2)对一定的传输带宽和一定的信噪比，信息传输速率的上限是确定的。</li>
<li>3)只要信息的传输速率低于信道的极限传输速率，就能找到某种方法来实现无差错的传输。</li>
<li>4)香农定理得出的是极限信息传输速率，实际信道能达到的传输速率要比它低不少。</li>
</ul>
</li>
<li>从香农定理可以看出，若信道带宽W或信噪比S/N没有上限(实际信道当然不可能这样)，则信道的极限信息传输速率也没有上限。</li>
<li>奈氏准则只考虑了带宽与极限码元传输速率的关系，而香农定理不仅考虑到了带宽，也考虑到了信噪比。这从另一个侧面表明，一个码元对应的二进制位数是有限的。</li>
</ul>
</li>
</ul>
<h4 id="213编码与调制">2.1.3编码与调制</h4>
<ul>
<li>
<p>数字数据编码为数字信号</p>
<ul>
<li>归零编码（RZ）
<ul>
<li>每个时钟周期中间均跳变为低电平</li>
</ul>
</li>
<li>非归零编码（NRZ）
<ul>
<li>不归零，但无法传递时钟信号，双方难以同步，需要时钟线</li>
</ul>
</li>
<li>反向非归零编码（NRZI）
<ul>
<li>不归零，信号翻转代表0，保持不变代表1，集成了前两种的优点。</li>
</ul>
</li>
<li>曼彻斯特编码
<ul>
<li>每个码元中间出现电平跳变，频带宽度翻倍。</li>
<li><strong>以太网使用的编码方式就是曼彻斯特编码</strong></li>
</ul>
</li>
<li>差分曼彻斯特编码
<ul>
<li><strong>常用于局域网传输</strong>，码元为1，则前半个码元的电平与上个码元的后半个码元的电平一致；若码元为0，则相反。每个码元中间会有跳转，可以实现自同步，抗干扰性好。</li>
</ul>
</li>
<li>4B/5B编码
<ul>
<li>将欲发送数据流的每4位作为-组，然后按照4B/5B编码规则将其转换成相应的5位码。5位码共32种组合，但只采用其中的16种对应16种不同的4位码，其他的16种作为控制码(帧的开始和结束、线路的状态信息等)或保留。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数字数据调制为模拟信号</p>
<ul>
<li>1)幅移键控(ASK)。通过改变载波信号的振幅来表示数字信号1和0，而载波的频率和相位都不改变。比较容易实现，但抗干扰能力差。</li>
<li>2)频移键控(FSK)。通过改变载波信号的频率来表示数字信号1和0，而载波的振幅和相位都不改变。容易实现，抗干扰能力强，<strong>目前应用较为广泛</strong>。</li>
<li>3)相移键控(PSK)。 通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。</li>
<li>4)正交振幅调制(QAM)。在频率相同的前提下，将ASK与PSK结合起来，形成叠加信号。设波特率为B,采用m个相位，每个相位有n种振幅，则该QAM技术的数据传输率R为
<ul>
<li>$R = Blog_2(mn)$(单位为b/s)
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603165431.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603165431.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603165431.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603165431.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603165431.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603165431.png" /></li>
</ul>
</li>
</ul>
</li>
<li>
<p>模拟数据编码为数字信号</p>
<ul>
<li>这种编码方式最典型的例子是常用于对音频信号进行编码的脉码调制(PCM)。它主要包括三个步骤，即采样、量化和编码。</li>
<li>先来介绍采样定理:在通信领域，带宽是指信号最高频率与最低频率之差，单位为Hz。因此，将模拟信号转换成数字信号时，假设原始信号中的最大频率为f,那么采样频率$f_{采祥}$必须大于等于最大频率f的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息(只需记住结论)。另外，采样定理又称奈奎斯特定理。
<ul>
<li>1)采样是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带带宽(最高变化频率)的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。</li>
<li>2)量化是把采样取得的电平幅值按照&ndash;定的分级标度转化为对应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。</li>
<li>3)编码是把量化的结果转换为与之对应的二进制编码。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>模拟数据调制为模拟信号</p>
<ul>
<li>为了实现传输的有效性，可能需要较高的频率。这种调制方式还可以使用频分复用(FDM)技术，充分利用带宽资源。电话机和本地局交换机采用模拟信号传输模拟数据的编码方式;模拟的声音数据是加载到模拟的载波信号中传输的。</li>
</ul>
</li>
</ul>
<h4 id="214电路交换报文交换分组交换">2.1.4电路交换、报文交换、分组交换</h4>
<ul>
<li>电路交换：
<ul>
<li>连接建立，传输数据、连接释放</li>
</ul>
</li>
<li>报文交换：
<ul>
<li>报文交换在交换节点采用的是存储转发的传输方式。报文大小未知。</li>
</ul>
</li>
<li>分组交换：
<ul>
<li>也是存储转发，解决了大报文传输问题。</li>
<li>缺点：
<ul>
<li>1)存在传输时延。尽管分组交换比报文交换的传输时延少，但相对于电路交换仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。</li>
<li>2)需要传输额外的信息量。每个小数据块都要加上源地址、目的地址和分组编号等信息，从而构成分组，因此使得传送的信息量增大了5%~10%，一定程度 上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。</li>
<li>3)当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，因此很麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虛电路释放三个过程。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="215数据报与虚电路">2.1.5数据报与虚电路</h4>
<p>分组交换根据<strong>其通信子网向端点系统提供的服务</strong>，还可进一步分为面向连接的虛电路方式和无连接的数据报方式。这两种服务方式都由网络层提供。要<strong>注意****数据报方式和虚电路方式是分组交换的两种方式。</strong></p>
<ul>
<li>数据报</li>
<li>虚电路（ppt无）：
<ul>
<li>虚电路方式试图将数据报方式与电路交换方式结合起来，充分发挥两种方法的优点，以达到最佳的数据交换效果。在分组发送之前，要求在发送方和接收方建立一条逻辑上相连的虚电路，并且连接一旦建立，就固定了虚电路所对应的物理路径。与电路交换类似，整个通信过程分为三个阶段:虚电路建立、数据传输与虚电路释放。</li>
</ul>
</li>
</ul>
<h3 id="22传输介质">2.2传输介质</h3>
<h4 id="221双绞线同轴电缆光纤与无线传输介质">2.2.1双绞线、同轴电缆、光纤与无线传输介质</h4>
<ul>
<li>双绞线
<ul>
<li>STP屏蔽双绞线</li>
<li>UTP非屏蔽双绞线</li>
</ul>
</li>
<li>同轴电缆
<ul>
<li>50欧 同轴电缆和75欧同轴电缆。其中，50欧同轴电缆主要用于传送基带数字信号，又称基带同轴电缆，它在局域网中应用广泛; 75欧同轴电缆主要用于传送宽带信号，又称宽带同轴电缆，主要用于有线电视系统。</li>
</ul>
</li>
<li>光纤</li>
<li>无线传输介质
<ul>
<li>无线电波</li>
<li>微波、红外线、激光。三者都需要发送者和接收者之间存在视线通路。</li>
</ul>
</li>
</ul>
<h4 id="222物理层接口的特性">2.2.2物理层接口的特性</h4>
<ul>
<li>1)机械特性。主要定义物理连接的边界点，即接插装置。规定物理连接时所采用的规格、引线的数目、引脚的数量和排列情况等。</li>
<li>2)电气特性。规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。</li>
<li>3)功能特性。指明某条线上出现的某一一电平的电压表示何种意义，接口部件的信号线(数据线、控制线、定时线等)的用途。</li>
<li>4)规程特性。主要定义各条物理线路的工作规程和时序关系。</li>
</ul>
<h3 id="23物理层设备">2.3物理层设备</h3>
<h4 id="231中继器">2.3.1中继器</h4>
<h4 id="222集线器">2.2.2集线器</h4>
<p>多端口中继器</p>
<h3 id="24本章小结及疑难点">2.4本章小结及疑难点</h3>
<h2 id="第3章数据链路层">第3章数据链路层</h2>
<h3 id="31数据链路层的功能">3.1数据链路层的功能</h3>
<h4 id="311为网络层提供服务">3.1.1为网络层提供服务</h4>
<ul>
<li>1)无确认的无连接服务。源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。适用于实时通信或误码率较低的通信信道，如以太网。</li>
<li>2)有确认的无连接服务。源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，以提高传输的可靠性。该服务适用于误码率较高的通信信道，如无线通信。</li>
<li>3)有确认的面向连接服务。帧传输过程分为三个阶段:建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧，因
而该服务的可靠性最高。该服务适用于通信要求(可靠性、实时性)较高的场合。</li>
<li><strong><strong>注意</strong>:有连接就一定要有确认，即不存在无确认的面向连接的服务。</strong></li>
</ul>
<h4 id="312链路管理">3.1.2链路管理</h4>
<p>数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。</p>
<h4 id="313帧定界帧同步透明传输">3.1.3帧定界、帧同步、透明传输</h4>
<p>帧同步指的是接收方应能从接收到的二进制比特流中区分出帧的起始与终止。</p>
<p>如果在数据中恰好出现与帧定界符相同的比特组合(会误认为“传输结束”而丢弃后面的数
据)，那么就要采取有效的措施解决这个问题，即透明传输。</p>
<h4 id="314流量控制">3.1.4流量控制</h4>
<p>流量控制实际上就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。</p>
<p>流量控制并不是数据链路层特有的功能，许多高层协议中也提供此功能，只不过控制的对象不同而已。对于数据链路层来说，控制的是相邻两结点之间数据链路上的流量,而对于传输层来说，控制的则是从源端到目的端之间的流量。</p>
<h4 id="315差错控制">3.1.5差错控制</h4>
<p>由于信道噪声等各种原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，这些错误可分为<strong>位错和帧错。</strong></p>
<p>位错指帧中某些位出现了差错。通常<strong>采用循环冗余校验(CRC)方式发现位错，通过自动重传请求(Automatic Repeat reQuest, ARQ) 方式来重传出错的帧</strong>。具体做法是:让发送方将要发送的数据帧附加一定的CRC冗余检错码一并发送，接收方则根据检错码对数据帧进行错误检测，若发现错误则丢弃，发送方超时重传该数据帧。这种差错控制方法称为ARQ法。ARQ法只需返回很少的控制信息就可有效地确认所发数据帧是否被正确接收。</p>
<p>帧错指帧的丢失、重复或失序等错误。在数据链路层引入<strong>定时器和编号机制</strong>，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</p>
<h3 id="32组帧">3.2组帧</h3>
<p>组帧主要解决：帧定界、帧同步、透明传输等问题</p>
<p>有以下四种方法：</p>
<h4 id="321字符计数法">3.2.1字符计数法</h4>
<p>字符计数法是指在帧头部使用一一个计数字段来标明帧内字符数。目的结点的数据链路层收到字节计数值时，就知道后面跟随的字节数，从而可以确定帧结束的位置(计数字段提供的字节数包含自身所占用的一个字节)。</p>
<p>但如果计数字段出错，便失去了帧边界划分的依据。</p>
<h4 id="322字符填充的首尾定界符法">3.2.2字符填充的首尾定界符法</h4>
<p>字符填充法使用一些特定的字符来定界一帧的开始(DLE STX)与结束(DLE ETX)。为了
使信息位中出现的特殊字符不被误判为帧的首尾定界符，可以在特殊字符前面填充-一个转义字符(DLE)来加以区分(<strong>注意</strong>，转义字符是ASCII码中的控制字符，是一-个字符，而非“D”&ldquo;L”&ldquo;E”三个字符的组合)，以实现数据的透明传输。接收方收到转义字符后，就知道其后面紧跟的是数据信息，而不是控制信息。</p>
<h4 id="323零比特填充的首尾标志法">3.2.3零比特填充的首尾标志法</h4>
<p>如图3.5所示，零比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。它使用一个特定的比特模式，即01111110来标志一帧的开始和结束。为了不使信息位中出现的比特流01111110被误判为帧的首尾标志，发送方的数据链路层在信息位中遇到5个连续的“1”时，将自动在其后插入一个“0”;而接收方做该过程的逆操作，即每收到5个连续的“1” 时，自动删除后面紧跟的“0”，以恢复原信息。</p>
<p>很容易由硬件实现，性能优于字符填充法。</p>
<h4 id="324违规编码法">3.2.4违规编码法</h4>
<p>在物理层进行比特编码时，通常采用违规编码法。例如，曼彻斯特编码方法将数据比特“1”编码成“高-低”电平对，将数据比特“0” 编码成“低-高”电平对，而“高高”电平对和“低-低”电平对在数据比特中是违规的(即没有采用)。可以借用这些违规编码序列来定界帧的起始和终止。局域网IEEE 802标准就采用了这种方法。</p>
<p><strong>违规编码法不需要采用任何填充技术，便能实现数据传输的透明性，但它只适用于采用冗余编码的特殊编码环境。</strong></p>
<p>由于字节计数法中计数字段的脆弱性和字符填充法实现上的复杂性与不兼容性，目前较常用的组帧方法是<strong>比特填充法和违规编码法。</strong></p>
<h3 id="33差错控制">3.3差错控制</h3>
<p>实际通信链路都不是理想的，比特在传输过程中可能会产生差错，1可能会变成0，0也
可能会变成1,这就是比特差错。比特差错是传输差错中的一种，本节仅讨论比特差错。</p>
<p>通常利用编码技术进行差错控制，主要有两类:<strong>自动重传请求ARQ和前向纠错FEC</strong>。在ARQ方式中，接收端检测出差错时，就设法通知发送端重发，直到接收到正确的码字为止。在FEC方式中，接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正。因此，差错控制又可分为检错编码和纠错编码。</p>
<h4 id="331检错编码">3.3.1检错编码</h4>
<p>检错编码都采用冗余编码技术，其核心思想是在有效数据(信息位)被发送前，先按某种关系附加一定的冗余位，构成一个符合某一规则的码字后再发送。当要发送的有效数据变化时，相应的冗余位也随之变化，使得码字遵从不变的规则。接收端根据收到的码字是否仍符合原规则来判断是否出错。常见的检错编码有<strong>奇偶校验码和循环冗余码。</strong></p>
<ul>
<li>1.奇偶校验码
<ul>
<li>奇偶校验码是奇校验码和偶校验码的统称，是一种最基本的检错码。它由n-1位信息元和1位校验元组成，如果是奇校验码，那么在附加一个校验元后，码长为n的码字中“1”的个数为奇数;如果是偶校验码，那么在附加一个校验元以后，码长为n的码字中“1” 的个数为偶数。它又分为垂直奇偶校验、水平奇偶校验和水平垂直奇偶校验。</li>
</ul>
</li>
<li>2.<strong>循环冗余码</strong>
<ul>
<li>给定一个 m bit的帧或报文，发送器生成一个 r bit的序列，称为帧检验序列(FCS)。 这样所形成的帧将由m +r比特组成。发送方和接收方事先商定一个多项式G(x) (最高位和最低位必须为1)，使这个带检验码的帧刚好能被预先确定的多项式G(x)整除。接收方用相同的多项式去除收到的帧，如果无余数，那么认为无差错。</li>
<li>假设-一个帧有m位，其对应的多项式为M(x)，则计算冗余码的步骤如下:
<ul>
<li>1)加0。假设G(x)的阶为r, 在帧的低位端加上r个0。</li>
<li>2)模2除。利用模2除法，用G(x)对应的数据串去除1)中计算出的数据串，得到的余数即为冗余码(共r位，前面的0不可省略)。</li>
</ul>
</li>
<li>多项式以2为模运算。按照模2运算规则，加法不进位，减法不借位，它刚好是异或操作。乘除法类似于二进制的运算，只是在做加减法时按模2规则进行。</li>
<li>冗余码的计算举例:设G(x)=1101 (即r=3)，待传送数据M= 101001 (即m=6)，经模2除法运算后的结果是:商Q= 110101 (这个商没什么用)，余数R= 001。所以发送出去的数据为101001 001 (即2&rsquo;M+FCS)，共有m+r位。循环冗余码的运算过程如图3.6所示。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603202406.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603202406.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603202406.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603202406.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603202406.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603202406.png" /></li>
</ul>
</li>
</ul>
<h4 id="332纠错编码">3.3.2纠错编码</h4>
<p>在数据通信的过程中，解决差错问题的一种方法是在每个要发送的数据块上附加足够的冗余信息，使接收方能够推导出发送方实际送出的应该是什么样的比特串。最常见的纠错编码是海明码，其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，而且能指出错位的位置，为自动纠错提供依据。</p>
<p>海明码的编码原理和过程：略</p>
<h3 id="34流量控制与可靠传输机制">3.4流量控制与可靠传输机制</h3>
<h4 id="341流量控制可靠传输和滑动窗口机制">3.4.1流量控制、可靠传输和滑动窗口机制</h4>
<p>流量控制的基本方法是由接收方控制发送方发送数据的速率，常见的方式有两种:
停止-等待协议和滑动窗口协议。</p>
<ul>
<li>1.停止-等待流量控制基本原理
<ul>
<li>发送方每发送- -帧,都要等待接收方的应答信号，之后才能发送下- -帧;接收方每接收一帧，都要反馈一个应答信号，表示可接收下一帧，如果接收方不反馈应答信号，那么发送方必须一直等待。每次只允许发送&ndash;帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低。</li>
</ul>
</li>
<li>2.滑动窗口流量控制基本原理
<ul>
<li>在任意时刻，发送方都维持-组连续的允许发送的帧的序号，称为发送窗口;同时接收方也维持一组连续的允许接收帧的序号，称为接收窗口。发送窗口用来对发送方进行流量控制，而发送窗口的大小Wr代表在还未收到对方确认信息的情况下发送方最多还可以发送多少个数据帧。同理，在接收端设置接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些帧。在接收方，只有收到的数据帧的序号落入接收窗口内时，才允许将该数据帧收下。若接收到的数据帧落在接收窗口之外，则一律将其丢弃。</li>
</ul>
</li>
</ul>
<p>图3.7给出了发送窗口的工作原理，图3.8给出了接收窗口的工作原理。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203024.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203024.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203024.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203024.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203024.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203024.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203049.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203049.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203049.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203049.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203049.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603203049.png" /></p>
<p>发送端每收到一一个确认帧，发送窗口就向前滑动-一个帧的位置，当发送窗口内没有可以发送的帧(即窗口内的帧全部是已发送但未收到确认的帧)时，发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧后，才开始继续发送。</p>
<p>接收端收到数据帧后，将窗口向前移-一个位置， 并发回确认帧，若收到的数据帧落在接收窗口之外，则一律丢弃。</p>
<p>滑动窗口有以下重要特性:</p>
<ul>
<li>
<p>1)只有接收窗口向前滑动(同时接收方发送了确认帧)时，发送窗口才有可能(只有发送
方收到确认帧后才- -定)向前滑动。</p>
</li>
<li>
<p>2)从滑动窗口的概念看，停止等待协议、后退N帧协议和选择重传协议只在发送窗口大小与接收窗口大小上有所差别:</p>
<ul>
<li>停止-等待协议:发送窗口大小=1,接收窗口大小= 1。</li>
<li>后退N帧协议:发送窗口大小&gt; 1,接收窗口大小= 1。</li>
<li>选择重传协议:发送窗口大小&gt;1,接收窗口大小&gt; 1。</li>
</ul>
</li>
<li>
<p>3)接收窗口的大小为1时，可保证帧的有序接收。</p>
</li>
<li>
<p>4)数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的(<strong>注意</strong>与第5章传输层的滑动窗口协议的区别)。</p>
</li>
<li>
<p>3.可靠传输机制</p>
<ul>
<li>数据链路层的可靠传输通常使用确认和超时重传两种机制来完成。确认是一&ndash;种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收。有些情况下为了提高传输效率，将确认捎带在一一个回复帧中，称为捎带确认。超时重传是指发送方在发送某个数据帧后就开启一个计时器，在- -定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止。</li>
<li>自动重传请求(Auto Repeat reQuest, ARQ)通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一。传统自动重传请求分为三种，即停止等待(Stop-and-Wait) ARQ、后退N帧(Go-Back-N) ARQ和选择性重传(Selective Repeat)ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。<strong>注意</strong>，在数据链路层中流量控制机制和可靠传输机制是交织在一起的。</li>
</ul>
</li>
</ul>
<h4 id="342单帧滑动窗口与停止-等待协议">3.4.2单帧滑动窗口与停止-等待协议</h4>
<h4 id="343多帧滑动窗口与后退n帧协议gbn">3.4.3多帧滑动窗口与后退N帧协议(GBN)</h4>
<h4 id="344多帧滑动窗口与选择重传协议sr">3.4.4多帧滑动窗口与选择重传协议(SR)</h4>
<h3 id="35介质访问控制">3.5介质访问控制</h3>
<p>介质访问控制所要完成的主要任务是，为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。用来决定广播信道中信道分配的协议属于数据链路层的一个子层，称为介质访问控制(Medium Access Control, MAC) 子层。</p>
<p>常见的介质访问控制方法有信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制。其中前者是静态划分信道的方法，而后两者是动态分配信道的方法。</p>
<h4 id="351信道划分介质访问控制">3.5.1信道划分介质访问控制</h4>
<p>信道划分介质访问控制将使用介质的每个设备与来自同&ndash;通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备。</p>
<p>下面介绍多路复用技术的概念。当传输介质的带宽超过传输单个信号所需的带宽时，人们就通过在一条介质上同时携带多个传输信号的方法来提高传输系统的利用率，这就是所谓的多路复用，也是实现信道划分介质访问控制的途径。多路复用技术把多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源，提高了信道的利用率。</p>
<p>采用多路复用技术可把多个输入通道的信息整合到一一个复用通道中，在接收端把收到的信息分离出来并传送到对应的输出通道。</p>
<p><strong>信道划分的实质就是通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对点信道。</strong></p>
<p>信道划分介质访问控制分为以下4种。</p>
<ol>
<li>频分多路复用(FDM)
<ul>
<li>频分多路复用是一-种将多路基带信号调制到不同频率载波上，再叠加形成-一个复合信号的多路复用技术。在物理信道的可用带宽超过单个原始信号所需带宽的情况下，可将该物理信道的总带宽分割成若干与传输单个信号带宽相同(或略宽)的子信道，每个子信道传输一-种信号，这就是频分多路复用，如图3.14所示。每个子信道分配的带宽可不相同，但它们的总和必须不超过信道的总带宽。在实际应用中，为了防止子信道之间的干扰，相邻信道之间需要加入“保护频带”。</li>
<li>频分多路复用的优点在于充分利用了传输介质的带宽，系统效率较高:由于技术比较成熟，实现也较容易</li>
</ul>
</li>
<li>时分多路复用(TDM)
<ul>
<li>时分多路复用是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用。每个时间片由复用的一个信号占用，而不像FDM那样，同一时间同时发送多路信号。这样，利用每个信号在时间上的交叉，就可以在一条物理信道上传输多个信号，如图3.15所示。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603204719.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603204719.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603204719.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603204719.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603204719.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603204719.png" /></li>
</ul>
</li>
</ol>
<p>就某个时刻来看,时分多路复用信道上传送的仅是某一对设备之间的信号;就某段时间而言，传送的是按时间分割的多路复用信号。但由于计算机数据的突发性，-一个用户对已经分配到的子信道的利用率一般不高。</p>
<p>统计时分多路复用(STDM， 又称异步时分多路复用)是TDM的一种改进，它采用STDM帧，STDM帧并不固定分配时隙，而按需动态地分配时隙，当终端有数据要传送时，才会分配到时间片，因此可以提高线路的利用率。例如，线路传输率为8000b/s, 4个用户的平均速率都为2000b/s，当采用TDM方式时，每个用户的最高速率为2000b/s，而在STDM方式下，每个用户的最高速率可达8000b/s。</p>
<ol start="3">
<li>波分多路复用(WDM)
<ul>
<li>波分多路复用即光的频分多路复用，它在一根光纤中传输多种不同波长(频率)的光信号，由于波长(频率)不同，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。由于光波处于频谱的高频段，有很高的带宽，因而可以实现多路的波分复用</li>
</ul>
</li>
<li>码分多路复用(CDM)
<ul>
<li>码分多路复用是采用不同的编码来区分各路原始信号的一种复用方式。与FDM和TDM不同，它既共享信道的频率，又共享时间。</li>
</ul>
</li>
</ol>
<h4 id="352随机访问介质访问控制">3.5.2随机访问介质访问控制</h4>
<p>在随机访问协议中，不采用集中控制方式解决发送信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。在总线形网络中，当有两个或多个用户同时发送信息时，就会产生帧的冲突(碰撞，即前面所说的相互干扰)，导致所有冲突用户的发送均以失败告终。为了解决随机接入发生的碰撞，每个用户需要按照一-定 的规则反复地重传它的帧，直到该帧无碰撞地通过。这些规则就是随机访问介质访问控制协议，常用的协议有ALOHA协议、CSMA协议、CSMA/CD协议和CSMA/CA协议等，它们的核心思想都是:胜利者通过争用获得信道，从而获得信息的发送权。因此，随机访问介质访问控制协议又称争用型协议。</p>
<p>读者会发现，如果介质访问控制采用信道划分机制，那么结点之间的通信要么共享空间要
么共享时间，要么两者都共享;而如果采用随机访问控制机制，那么各结点之间的通信就可既不共享时间，也不共享空间。所以随机介质访问控制实质上是一-种将广 播信道转化为点到点信道的行为.</p>
<ol>
<li>ALOHA协议
<ul>
<li>夏威夷大学早期研制的随机接入系统称为ALOHA,它是Additive Link On-line HAwaii system的缩写。ALOHA协议分为纯ALOHA协议和时隙ALOHA协议两种。</li>
<li>(1)纯ALOHA协议
<ul>
<li>纯ALOHA协议的基本思想是，当网络中的任何-一个站点需要发送数据时，可以不进行任何检测就发送数据。如果在- -段时间内未收到确认，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后 再发送数据，直至发送成功。</li>
<li>图3.20表示-一个纯ALOHA协议的工作原理。每个站均自由地发送数据帧。为简化问题，不考虑由信道不良而产生的误码，并假定所有站发送的帧都是定长的，帧的长度不用比特而用发送这个帧所需的时间来表示，在图3.20中用To表示这段时间。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603210405.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603210405.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603210405.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603210405.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603210405.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603210405.png" /></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在图3.20的例子中，当站1发送帧1时，其他站都未发送数据，所以站1的发送必定是成功
的。但随后站2和站N-1发送的帧2和帧3在时间上重叠了一-些(即发生了碰撞)。碰撞的结果是，碰撞双方(有时也可能是多方)所发送的数据出现了差错，因而都须进行重传。但是发生碰撞的各站并不能马上进行重传，因为这样做必然会继续发生碰撞。纯ALOHA系统采用的重传策略是让各站等待一段随机的时间， 然后再进行重传。若再次发生碰撞，则需要再等待一段随机的时间，直到重传成功为止。图中其余一些帧的发送情况是帧4发送成功，而帧5和帧6发生碰撞。</p>
<p>假设网络负载(To时间内所有站点发送成功的和未成功而重传的帧数)为G，则纯ALOHA
网络的吞吐量(To 时间内成功发送的平均帧数)为 $S=Ge^{-2G}$。 当G=0.5时，$S= 0.5e^{-1}≈0.184$,这是吞吐量s可能达到的极大值。可见，纯ALOHA网络的吞吐量很低。为了克服这- -缺点，人们在原始的纯ALOHA协议的基础.上进行改进，产生了时隙ALOHA协议。</p>
<ol start="2">
<li>时隙ALOHA协议
<ul>
<li>时隙ALOHA协议把所有各站在时间.上同步起来，并将时间划分为一段段等长的时 隙(Slot),规定只能在每个时隙开始时才能发送一一个帧。 从而避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率。</li>
<li>图3.21为两个站的时隙ALOHA协议的工作原理示意图。时隙的长度To使得每个帧正好在一个时隙内发送完毕。每个帧在到达后，-般都要在缓存中等待一段小于 To的时间，然后才能发送出去。在一个时隙内有两个或两个以上的帧到达时，在下一个时隙将产生碰撞。碰撞后重传的策略与纯ALOHA的情况是相似的。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603213348.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603213348.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603213348.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603213348.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603213348.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603213348.png" /></li>
</ul>
</li>
</ol>
<p>时隙ALOHA网络的吞吐量S与网络负载G的关系是$S=Ge^{-G}$。当G=1时，$S=e^{-1}≈0.368$。这是吞吐量S可能达到的极大值。可见，时隙ALOHA网络比纯ALOHA网络的吞吐量大了1倍。</p>
<p><strong>CSMA协议</strong>:</p>
<p>时隙ALOHA系统的效率虽然是纯ALOHA系统的两倍，但每个站点都是随心所欲地发送数
据的，即使其他站点正在发送也照发不误，因此发送碰撞的概率很大。</p>
<p>若每个站点在发送前都先侦听- -下共用信道，发现信道空闲后再发送，则就会大大降低冲突的可能，从而提高信道的利用率，载波侦听多路访问(Carrier Sense Multiple Access, CSMA)协议依据的正是这一思想。CSMA协议是在ALOHA协议基础上提出的一种改进协议， 它与ALOHA协议的主要区别是多了一个载波侦听装置。</p>
<p>根据侦听方式和侦听到信道忙后的处理方式不同，CSMA 协议分为三种。</p>
<p>(1) 1-坚持CSMA</p>
<ul>
<li>1-坚持CSMA ( l-persistent CSMA)的基本思想是: -一个结点要发送数据时，首先侦听信道;如果信道空闲，那么立即发送数据;如果信道忙，那么等待，同时继续侦听直至信道空闲;如果发生冲突，那么随机等待一段时间后， 再重新开始侦听信道。</li>
<li>“1-坚持”的含义是:侦听到信道忙后，继续坚持侦听信道;侦听到信道空闲后，发送帧的概率为1,即立刻发送数据。</li>
<li>传播延迟对1-坚持CSMA协议的性能影响较大。结点A开始发送数据时，结点B也正好有数
据要发送，但这时结点A发出数据的信号还未到达结点B,结点B侦听到信道空闲，于是立即发送数据，结果必然导致冲突。即使不考虑延迟，1-坚持CSMA协议也可能产生冲突。例如，结点A正在发送数据时，结点B和C也准备发送数据，侦听到信道忙，于是坚持侦听，结果当结点A一发送完毕，结点B和C就会立即发送数据，同样导致冲突。</li>
</ul>
<p>(2)非坚持CSMA</p>
<ul>
<li>非坚持CSMA (Non-persistent CSMA)的基本思想是: - 一个结点要发送数据时，首先侦听信道;如果信道空闲，那么立即发送数据;如果信道忙，那么放弃侦听，等待一个随机的时间后再重复上述过程。</li>
<li>非坚持CSMA协议在侦听到信道忙后就放弃侦听，因此降低了多个结点等待信道空闲后同时发送数据导致冲突的概率，但也会增加数据在网络中的平均延迟。可见，信道利用率的提高是以增加数据在网络中的延迟时间为代价的。</li>
</ul>
<p>(3) p-坚持CSMA .</p>
<ul>
<li>p-坚持CSMA (P-persistent CSMA)用于时分信道，其基本思想是: - - 个结点要发送数据时，首先帧听信道;如果信道忙，就持续侦听，直至信道空闲;如果信道空闲，那么以概率p发送数据，以概率1-p推迟到下一-个时隙;如果在下一-个时隙信道仍然空闲，那么仍以概率p发送数据，以概率1-p推迟到下一个时隙;这个过程一直持续到数据 发送成功或因其他结点发送数据而检测到信道忙为止，若是后者，则等待下一个时隙再重新开始帧听。</li>
<li>p-坚持CSMA在检测到信道空闲后，以概率p发送数据，以概率1 - p推迟到下一个时隙，
其目的是降低1-坚持CSMA协议中多个结点检测到信道空闲后同时发送数据的冲突概率;采用坚持“帧听”的目的是，试图克服非坚持CSMA协议中由于随机等待而造成的延迟时间较长的缺点。因此，p-坚持CSMA协议是非坚持CSMA协议和1-坚持CSMA协议的折中方案。</li>
</ul>
<p>三种不同类型的CSMA协议比较如表3.1所示。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603214901.png"
        data-srcset="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603214901.png, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603214901.png 1.5x, https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603214901.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603214901.png"
        title="https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220603214901.png" /></p>
<p><strong>CSMA/CD协议</strong></p>
<p><strong>CSMA/CA协议</strong></p>
<h4 id="353轮询访问介质访问控制令牌传递协议">3.5.3轮询访问介质访问控制:令牌传递协议</h4>
<p>在轮询访问中，用户不能随机地发送信息，而要通过-一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配。当某结点使用信道时，其他结点都不能使用信道。典型的轮询访问介质访问控制协议是令牌传递协议，它主要用在令牌环局域网中。</p>
<p>在令牌传递协议中，-个令牌在各结点间以某个固定次序交换。令牌是由一-组特殊的比特组合而成的帧。当环上的一个站希望传送帧时，必须等待令牌。一 旦收到令牌，站点便可启动发送帧。帧中包括目的站的地址，以标识哪个站应接收此帧。帧在环上传送时，不管该帧是否是发给本站点的，所有站点都进行转发，直到该帧回到它的始发站，并由该始发站撤销该帧。帧的目的站除转发帧外，应针对该帧维持-一个副本， 并通过在帧的尾部设置“响应比特”来指示已收到此副本。站点在发送完- -帧后，应释放令牌，以便让其他站使用。</p>
<p>当计算机都不需要发送数据时，令牌就在环形网上游荡，而需要发送数据的计算机只有在拿到该令牌后才能发送数据帧，因此不会发送冲突(因为令牌只有一个)。在令牌传递网络中，传输介质的物理拓扑不必是一个环，但是为了把对介质访问的许可从一个设备传递到另-一个设备，令牌在设备间的传递通路逻辑上必须是-一个环。</p>
<p>轮询介质访问控制非常适合负载很高的广播信道。所谓负载很高的信道，是指多个结点在同一时刻发送数据概率很大的信道。可以想象，如果这样的广播信道采用随机介质访问控制，那么发生冲突的概率将会很大，而采用轮询介质访问控制则可以很好地满足各结点间的通信需求。</p>
<p>轮询介质访问控制既不共享时间，也不共享空间，它实际上是在随机介质访问控制的基础上，限定了有权力发送数据的结点只能有一个。</p>
<p>即使是广播信道也可通过介质访问控制机制使广播信道逻辑上变为点对点的信道，所以说数据链路层研究的是“点到点”之间的通信。</p>
<h3 id="36局域网">3.6局域网</h3>
<h4 id="361局域网">3.6.1局域网</h4>
<p>(Local Area Network, LAN) 是指在-一个较小的地理范围(如一-所学校)内，将各种
计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络。主要特点如下:</p>
<ul>
<li>1)为一个单位所拥有，且地理范围和站点数目均有限。</li>
<li>2)所有站点共享较高的总带宽(即较高的数据传输率)。</li>
<li>3)较低的时延和较低的误码率。</li>
<li>4)各站为平等关系而非主从关系。</li>
<li>5)能进行广播和组播。</li>
</ul>
<p>局域网的特性主要由三个要素决定:拓扑结构、传输介质、介质访问控制方式，其中最重要的是介质访问控制方式，它决定着局域网的技术特性。</p>
<p>常见的局域网拓扑结构主要有以下4大类:①星形结构;②环形结构;③总线形结构;④星形和总线形结合的复合型结构。</p>
<p>局域网可以使用双绞线、铜缆和光纤等多种传输介质，其中双绞线为主流传输介质。</p>
<p>局域网的介质访问控制方法主要有CSMA/CD、令牌总线和令牌环，其中前两种方法主要用
于总线形局域网，令牌环主要用于环形局域网。</p>
<p>三种特殊的局域网拓扑实现如下:</p>
<ul>
<li>以太网(目前使用范围最广的局域网)。逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。</li>
<li>令牌环 (Token Ring, IEEE 802.5)。逻辑拓扑是环形结构，物理拓扑是星形结构。</li>
<li>FDDI (光纤分布数字接口，IEEE 802.8)。逻辑拓扑是环形结构，物理拓扑是双环结构。</li>
</ul>
<p>IEEE802标准定义的局域网参考模型只对应于OSI参考模型的数据链路层和物理层,并将数
据链路层拆分为两个子层:逻辑链路控制(LLC) 子层和媒体接入控制(MAC)子层。与接入传输媒体有关的内容都放在MAC子层，它向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括:组帧和拆卸帧、比特传输差错检测、透明传输。LLC子层与传输媒体无关，它向网络层提供无确认无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型。</p>
<p>由于以太网在局域网市场中取得垄断地位，几乎成为局域网的代名词，而802委员会制定的LLC子层作用已经不大，因此现在许多网卡仅装有MAC协议而没有LLC协议。</p>
<h4 id="362以太网与ieee-8023">3.6.2以太网与IEEE 802.3</h4>
<ol>
<li>以太网的传输介质与网卡</li>
</ol>
<p>以太网常用的传输介质有4种:粗缆、细缆、双绞线和光纤。各种传输介质的适用情况见表3.2。</p>
<ul>
<li><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605161131617.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605161131617.png, D:%5cBlog%5clocalImages%5cimage-20220605161131617.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605161131617.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605161131617.png"
        title="image-20220605161131617" /></li>
<li>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板[又称网络适配器(Adapter)或网络接口卡(Network Interface Card，NIC)]实现的。网卡上装有处理器和存储器，是工作在数据链路层的网路组件。网卡是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能等。</li>
<li>全世界的每块网卡在出厂时都有一个唯一的代码，称为介质访问控制(MAC)地址，这个地址用于控制主机在网络上的数据通信。数据链路层设备(网桥、交换机等）都使用各个网卡的MAC地址。另外，网卡控制着主机对介质的访问，因此网卡也工作在物理层，因为它只关注比特，而不关注任何地址信息和高层协议信息。</li>
</ul>
<ol start="2">
<li>
<p>以太网的MAC帧</p>
<p>每块网络适配器（网卡）都有一个地址，称为MAC 地址，也称物理地址;MAC地址长6字节，一般用由连字符(或冒号）分隔的6个十六进制数表示，如02-60-8c-c4-b1-21。高24位为厂商代码，低24位为厂商自行分配的网卡序列号。
由于总线上使用的是广播通信，因此网卡从网络上每收到一个MAC帧，首先要用硬件检查MAC帧中的MAC地址。如果是发往本站的帧，那么就收下，否则丢弃。
以太网MAC帧格式有两种标准:DIX Ethernet V2标准（即以太网V2标准）和IEEE 802.3标准。这里只介绍最常用的以太网V2的MAC帧格式，如图3.24所示。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605161729316.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605161729316.png, D:%5cBlog%5clocalImages%5cimage-20220605161729316.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605161729316.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605161729316.png"
        title="image-20220605161729316" /></p>
<p><strong>前导码</strong>:使接收端与发送端时钟同步。在帧前面插入的8字节可再分为两个字段:第一个字段共7字节，是前同步码，用来快速实现MAC帧的比特同步﹔第二个字段是帧开始定界符，表示后面的信息就是MAC帧。
<strong>注意</strong>:MAC帧并不需要帧结束符，因为以太网在传送帧时，各帧之间必须有一定的间隙。因此，接收端只要找到帧开始定界符，其后面连续到达的比特流就都属于同一个MAC帧，所以图3.24只有帧开始定界符。但不要误以为以太网MAC帧不需要尾部，在数据链路层上，帧既要加首部，也要加尾部。
地址:通常使用6字节(48bit）地址（MAC地址)。
类型:2字节，指出数据域中携带的数据应交给哪个协议实体处理。
数据:46~1500字节，包含高层的协议消息。由于CSMA/CD算法的限制，以太网帧必须满足最小长度要求64字节，数据较少时必须加以填充（0～46字节)。
<strong>注意</strong>:46和1500是怎么来的?首先，由CSMA/CD算法可知以太网帧的最短帧长为64B，而MAC帧的首部和尾部的长度为18字节，所以数据最短为64-18=46字节。其次，最大的1500字节是规定的，没有为什么。
填充:0~46字节，当帧长太短时填充帧，使之达到64字节的最小长度。
校验码（FCS):4字节，校验范围从目的地址段到数据段的末尾，算法采用32位循环冗余码(CRC)，不但需要检验MAC帧的数据部分，还要检验目的地址、源地址和类型字段，但不校验前导码。
802.3帧格式与DIX以太帧格式的不同之处在于用长度域替代了DIX帧中的类型域，指出数据域的长度。在实践中，前述长度/类型两种机制可以并存，由于IEEE 802.3数据段的最大字节数是1500，所以长度段的最大值是1500，因此从1501到65535的值可用于类型段标识符</p>
</li>
<li>
<p>高速以太网</p>
<p>速率达到或超过100Mb/s的以太网称为高速以太网。</p>
<p>(1）100BASE-T以太网
100BASE-T以太网是在双绞线上传送100Mb/s基带信号的星形拓扑结构以太网，它使用CSMA/CD 协议。这种以太网既支持全双工方式，又支持半双工方式，可在全双工方式下工作而无冲突发生。因此，在全双工方式下不使用CSMA/CD协议。
MAC帧格式仍然是802.3标准规定的。保持最短帧长不变，但将一个网段的最大电缆长度减小到100m。帧间时间间隔从原来的9.6us 改为现在的0.96js。
(2）吉比特以太网
吉比特以太网又称千兆以太网，允许在1Gb/s下用全双工和半双工两种方式工作。使用802.3协议规定的帧格式。在半双工方式下使用CSMA/CD协议（全双工方式不需要使用CSMA/CD协议)。与10BASE-T和100BASE-T技术向后兼容。
(3）10吉比特以太网
10吉比特以太网与10Mb/s、100Mbls 和 1Gbls 以太网的帧格式完全相同。10吉比特以太网还保留了802.3标准规定的以太网最小和最大帧长，便于升级。10吉比特以太网不再使用铜线而只使用光纤作为传输媒体。10吉比特以太网只工作在全双工方式，因此没有争用问题，也不使用CSMA/CD协议。
以太网从10Mb/s到10Gb/s的演进证明了以太网是可扩展的(从10Mb/s到10Gb/s)、灵活的(多种传输媒体、全/半双工、共享/交换)，易于安装，稳健性好。</p>
</li>
</ol>
<h4 id="363ieee-80211">3.6.3IEEE 802.11</h4>
<p>IEEE802.11是无线局域网的一系列协议标准，包括802.11a和802.11b等。它们制定了MAC层协议，运行在多个物理层标准上。除基本的协调访问问题外，标准还进行错误控制（以克服通道固有的不可靠性)、适宜的寻址和关联规程（以处理站的可携带性和移动性)、互联过程（以扩展无线站的通信范围)，并且允许用户在移动的同时进行通信。
802.11的MAC层采用CSMA/CA协议进行介质访问控制。冲突避免要求每个发送结点在发送帧之前先侦听信道。如果信道空闲，那么结点可以发送帧;发送站在发送完一帧之后，必须再等待一个短的时间间隔，检查接收站是否发回帧的确认ACK。如果接收到确认，那么说明此次发送未出现冲突，发送成功;如果在规定的时间内没有接收到确认，那么表明出现冲突，发送失败，重发该帧，直到在规定的最大重发次数之内，发送成功。
<strong>注意</strong>:在无线局域网中，即使在发送过程中发生了碰撞，也要把整个帧发送完毕。而在有线局域网中，发生冲突则结点立即停止发送数据。再次提醒读者要熟悉局域网的各种协议。
无线局域网可分为两大类:固定基础设施无线局域网和无固定基础设施无线局域网自组织网络（Ad Hoc Network)。</p>
<ol>
<li>有固定基础设施无线局域网</li>
<li>无固定基础设施无线局域网自组织网络</li>
</ol>
<h4 id="364令牌环网的基本原理">3.6.4令牌环网的基本原理</h4>
<p>令牌环网的基本原理如图3.27所示。令牌环网的每一站通过电缆与环接口干线耦合器(TCU)相连。TCU的主要作用是，传递所有经过的帧，为接入站发送和接收数据提供接口。与此对应，TCU 的状态也有两个:收听状态和发送状态。数据总是在某个特定的方向上从一个TCU到下一个TCU逐比特地依次传送，每个TCU重新产生并重新传输每一比特。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605165802937.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605165802937.png, D:%5cBlog%5clocalImages%5cimage-20220605165802937.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605165802937.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605165802937.png"
        title="image-20220605165802937" />令牌环网的媒体接入控制机制采用的是分布式控制模式的循环方法。在令牌环网中有一个令牌（Token）沿着环形总线在入网结点计算机间依次传递，令牌实际上是一个特殊格式的MAC控制帧，它本身并不包含信息，仅控制信道的使用，确保在同一时刻只有一个结点能够独占信道。站点只有取得令牌后才能发送数据帧，因此令牌环网不会发生碰撞。由于令牌在网环上是按顺序依次传递的，因此对所有入网计算机而言，访问权是公平的。
令牌环网中令牌和数据的传递过程如下:
1）网络空闲时，环路中只有令牌帧在循环传递。
2）令牌传递到有数据要发送的站点处时，该站点就修改令牌中的一个标志位，并在令牌中
附加自己需要传输的数据，将令牌变成一个数据帧，然后将这个数据帧发送出去。3）数据帧沿着环路传输，接收到的站点一边转发数据，一边查看帧的目的地址。如果目的
地址和自己的地址相同，那么接收站就复制该数据帧以便进一步处理。
4）数据帧沿着环路传输，直到到达该帧的源站点，源站点接收到自己发出去的数据帧后便
不再进行转发。同时，发送方可以通过检验返回的数据帧来查看数据传输过程中是否有错，若有错则重传该帧。
5）源站点传送完数据后，重新产生一个令牌，并将令牌传递给下一个站点，以交出对媒体
的访问权限。
令牌环网在物理上采用星形拓扑结构，但逻辑上仍是环形拓扑结构，其标准由IEEE 802.5定义。图3.27中的环并不是由通信线路连接而成的物理环。</p>
<h3 id="37广域网">3.7广域网</h3>
<h4 id="371广域网基本概念">3.7.1广域网基本概念</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605170041125.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605170041125.png, D:%5cBlog%5clocalImages%5cimage-20220605170041125.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605170041125.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605170041125.png"
        title="image-20220605170041125" /></p>
<h4 id="372ppp协议">3.7.2PPP协议</h4>
<p>PPP (Point-to-Point Protocol)是使用串行线路通信的面向字节的协议，该协议应用在直接连接两个结点的链路上。设计的目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同的解决方案。</p>
<p>PPP协议是在SLIP协议的基础上发展而来的，它既可以在异步线路上传输，又可在同步线路上使用;不仅用于Modem链路，也用于租用的路由器到路由器的线路。</p>
<p>背景:SLIP主要完成数据报的传送，但没有寻址、数据检验、分组类型识别和数据压缩等功能，只能传送P分组。如果上层不是IP协议，那么无法传输，并且此协议对一些高层应用也不支持，但实现比较简单。为了改进SLIP的缺点，于是制定了点对点协议(PPP)。</p>
<p>PPP协议有三个组成部分:
1)链路控制协议(LCP)。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。2）网络控制协议(NCP)。PPP协议允许同时采用多种网络层协议，每个不同的网络层协议
要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。
3)一个将I数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信
息部分的长度受最大传送单元(MTU)的限制。</p>
<p>PPP帧的格式如图3.29所示。PPP帧的前3个字段和最后2个字段与HDLC帧是一样的，标志字段(F)仍为7E（01111110)，前后各占1字节，若它出现在信息字段中，就必须做字节填充,使用的控制转义字节是7D(01111101)。但在PPP中，地址字段(A)占1字节，规定为0xFF，控制字段(C)占1字节，规定为0x03，两者的内容始终是固定不变的。PPP是面向字符的，因而所有PPP帧的长度都是整数个字节。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605170242385.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605170242385.png, D:%5cBlog%5clocalImages%5cimage-20220605170242385.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605170242385.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605170242385.png"
        title="image-20220605170242385" />第4个字段是协议段，占2字节，在HDLC中没有该字段，它是说明信息段中运载的是什么种类的分组。以比特О开始的是诸如IP、IPX和AppleTalk这样的网络层协议;以比特1开始的被用来协商其他协议，包括LCP及每个支持的网络层协议的一个不同的NCP。
第5段信息段的长度是可变的，大于等于0且小于等于1500B。为了实现透明传输，当信息段中出现和标志字段一样的比特组合时，必须采用一些措施来改进。
<strong>注意</strong>:因为PPP是点对点的，并不是总线形，所以无须采用CSMA/CD 协议，自然就没有最短帧，所以信息段占0~1500字节，而不是46~1500字节。另外，当数据部分出现和标志位一样的比特组合时，就需要采用一些措施来实现透明传输。
第6个字段是帧检验序列(FCS)，占2字节，即循环冗余码检验中的冗余码。检验区包括地址字段、控制字段、协议字段和信息字段。</p>
<p>图3.30给出了PPP链路建立、使用、撤销所经历的状态图。当线路处于静止状态时，不存在物理层连接。当线路检测到载波信号时，建立物理连接，线路变为建立状态。此时，LCP开始选项商定，商定成功后就进入身份验证状态。双发身份验证通过后，进入网络状态。这时，采用NCP 配置网络层，配置成功后，进入打开状态，然后就可进行数据传输。当数据传输完成后，线路转为终止状态。载波停止后则回到静止状态。
<strong>注意</strong>:
1 )PPP提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验)。
它是不可靠的传输协议，因此也不使用序号和确认机制。
2）它仅支持点对点的链路通信，不支持多点线路。
3 ) PPP只支持全双工链路。
4)PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信。
5 ) PPP是面向字节的，当信息字段出现和标志字段一致的比特组合时，PPP有两种不同的处
理方法:若 PPP用在异步线路（默认)，则采用字节填充法;若PPP用在SONET/SDH等同步线路，则协议规定采用硬件来完成比特填充（和HDLC的做法一样).<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605170342779.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605170342779.png, D:%5cBlog%5clocalImages%5cimage-20220605170342779.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605170342779.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605170342779.png"
        title="image-20220605170342779" /></p>
<h4 id="373hdlc协议">3.7.3HDLC协议</h4>
<p>高级数据链路控制（High-level Data Link Control，HDLC)协议是ISO制定的面向比特（记住PPP协议是面向字节的）的数据链路层协议。该协议不依赖于任何一种字符编码集;数据报文可透明传输，用于实现透明传输的“О比特插入法”易于硬件实现;全双工通信，有较高的数据链路传输效率;所有帧采用CRC 检验，对信息帧进行顺序编号，可防止漏收或重发，传输可靠性高;传输控制功能与处理功能分离，具有较大的灵活性。
HDLC适用于链路的两种基本配置:非平衡配置和平衡配置。</p>
<p>1）非平衡配置的特点是由一个主站控制整个链路的工作。
2）平衡配置的特点是链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传
输，而不需要得到对方复合站的允许。</p>
<ol>
<li>
<p>站</p>
<p>HDLC有3种站类型:主站、从站和复合站。主站负责控制链路的操作，主站发出的帧称为命令帧。从站受控于主站，按主站的命令进行操作;发出的帧称为响应帧。另外，有些站既具有主站的功能，又具有从站的功能，所以这类站称为复合站，它可以发出命令帧和响应帧。</p>
</li>
<li>
<p>数据操作方式</p>
<p>HDLC有3种数据操作方式:
1)）正常响应方式。这是一种非平衡结构操作方式，即主站向从站传输数据，从站响应传输,
但从站只有在收到主站的许可后，才可进行响应。
2）异步平衡方式。这是一种平衡结构操作方式。在这种方式中，每个复合站都可以进行对
另一站的数据传输。
3）异步响应方式。这是一种非平衡结构操作方式。在这种方式中，从站即使未受到主站的
允许，也可进行传输。</p>
</li>
<li>
<p>HDLC帧</p>
<p>图3.31所示为HDLC的帧格式，它由标志、地址、控制、信息和帧校验序列(FCS)等字段构成。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605170735040.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605170735040.png, D:%5cBlog%5clocalImages%5cimage-20220605170735040.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605170735040.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605170735040.png"
        title="image-20220605170735040" /></p>
<p>标志字段F，为01111110。在接收端只要找到标志字段就可确定一个帧的位置。HDLC协议采用比特填充的首尾标志法实现透明传输。在发送端，当一串比特流数据中有5个连续的1时，就立即在其后填入一个0。接收帧时，先找到F字段以确定帧的边界，接着对比特流进行扫描。每当发现5个连续的1时，就将其后的一个0删除，以还原成原来的比特流。
地址字段A，共8位，在使用非平衡方式传送数据时，站地址字段总是写入从站的地址;在使用平衡方式传送数据时，站地址字段填入的是应答站的地址。
控制字段C，共8位，是最复杂的字段。HDILC的许多重要功能都靠控制字段来实现。根据其第1位或第1、2位的取值，可将HDLC帧划分为三类:
1）信息帧(I)，第1位为o，用来传输数据信息，或使用捎带技术对数据进行确认。
2）监督帧(S)，第1、2位分别为1、0，用于流量控制和差错控制，执行对信息帧的确认、
请求重发和请求暂停发送等功能;
3）无编号帧（U)，第1、2位均为1，用于提供对链路的建立、拆除等多种控制功能。由图3.29和图3.31可知，PPP帧和 HDLC帧的格式很相似。但两者有以下几点不同:1 ) PPP协议是面向字节的，HDLC协议是面向比特的。
2)PPP帧比HDLC帧多一个2字节的协议字段。当协议字段值为0x0021时，表示信息字段
是IP数据报。
3）PPP协议不使用序号和确认机制，只保证无差错接收（通过硬件进行CRC 检验)，而端
到端差错检测由高层协议负责。HDLC协议的信息帧使用了编号和确认机制，能够提供可靠传输。</p>
</li>
</ol>
<h3 id="38数据链路层设备">3.8数据链路层设备</h3>
<h4 id="381网桥的概念与基本原理">3.8.1网桥的概念与基本原理</h4>
<p>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就称为一个网段。网桥工作在链路层的MAC子层，可以使以太网各网段成为隔离开的碰撞域。如果把网桥换成工作在物理层的转发器，那么就没有这种过滤通信量的功能。由于各网段相对独立，因此一个网段的故障不会影响到另一个网段的运行。
<strong>注意</strong>:网桥处理数据的对象是帧，所以它是工作在数据链路层的设备，中继器、放大器处理数据的对象是信号，所以它是工作在物理层的设备。
网络1和网络2通过网桥连接后，网桥接收网络1发送的数据帧，检查数据帧中的地址，如果是网络2的地址，那么就转发给网络2;如果是网络1的地址，那么就将其丢弃，因为源站和目的站处在同一个网段，目的站能够直接收到这个帧而不需要借助网桥转发。
如图3.32所示，设每个网段的数据率都是10Mbls，那么三个网段合起来的最大吞吐量就变成了30Mb/s。如果把两个网桥换成集线器或转发器,那么整个网络仍然是一个碰撞域(即冲突域),当A和B通信时，所有其他站点都不能通信，整个碰撞域的最大吞吐量仍然是10Mb/s。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605170900066.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605170900066.png, D:%5cBlog%5clocalImages%5cimage-20220605170900066.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605170900066.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605170900066.png"
        title="image-20220605170900066" /></p>
<p>网桥的基本特点:①网桥必须具备寻址和路径选择能力，以确定帧的传输方向;②从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧;③网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换。<strong>注意</strong>，一般情况下，存储转发类设备都能进行协议转换，即连接的两个网段可以使用不同的协议;④网桥对接收到的帧不做任何修改，或只对帧的封装格式做很少的修改;⑤网桥可以通过执行帧翻译互联不同类型的局域网，即把原协议的信息段的内容作为另一种协议的信息部分封装在帧中;⑥网桥应有足够大的缓冲空间，因为在短时间内帧的到达速率可能高于转发速率。
网桥的优点:①能过滤通信量;②扩大了物理范围;③可使用不同的物理层;④可互联不同类型的局域网;⑤提高了可靠性;⑥性能得到改善。
网桥的缺点:①增大了时延;②MAC子层没有流量控制功能（流量控制需要用到编号机制，编号机制的实现在LLC子层);③不同MAC子层的网段桥接在一起时，需要进行帧格式的转换;④网桥只适合于用户数不多和通信量不大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞，这就是所谓的广播风暴。
网桥必须具有路径选择的功能，接收到帧后，要决定正确的路径，将该帧转送到相应的目的局域网站点。根据路径选择算法的不同，可将网桥分为透明网桥和源路由网桥。</p>
<ol>
<li>
<p>透明网桥（选择的不是最佳路由）</p>
<p>透明网桥以混杂方式工作，它接收与之连接的所有LAN传送的每一帧。到达帧的路由选择过程取决于源LAN和目的LAN:①如果源LAN和目的LAN相同,那么丢弃该帧;②如果源LAN和目的LAN不同，那么转发该帧;③如果目的LAN未知，那么扩散该帧。
当网桥刚连接到以太网时，其转发表是空的，网桥按照自学习算法处理收到的帧。该算法的基本思想是:若从站A发出的帧从某端口进入网桥，那么从这个端口出发沿相反方向一定可把一个帧传送到站A。所以网桥每收到一个帧，就记下其源地址和进入网桥的端口，作为转发表中的一个项目（源地址、进入的接口和时间)。在建立转发表时，把帧首部中的源地址写在“地址”一栏的下面。在转发帧时，则根据收到的帧首部中的目的地址来转发。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入端口当作转发端口。网桥就是在这样的转发过程中逐渐将其转发表建立起来的。
为了避免转发的帧在网络中不断地“兜圈子”，透明网桥使用了一种生成树算法（无环)，以确保每个源到每个目的地只有唯一的路径。生成树使得整个扩展局域网在逻辑上形成树形结构，所以工作时逻辑上没有环路，但生成树一般不是最佳路由。</p>
</li>
<li>
<p>源路由网桥（选择的是最佳路由）</p>
<p>在源路由网桥中，路由选择由发送数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行接收和转发。
源路由网桥对主机是不透明的，主机必须知道网桥的标识及连接到哪个网段上。路由选择由发送帧的源站负责，那么源站如何知道应当选择什么样的路由呢?为了找到最佳的路由，源站以广播方式向目的站发送一个发现帧（Discovery Frame)作为探测之用。源路由的生成过程是:在未知路径前，源站要先发送一个发现帧;途中的每个网桥都转发此帧，最终该发现帧可能从多个途径到达目的站;目的站也将一一发送应答帧;每个应答帧将通过原路径返回，途经的网桥把自己的标志记录在应答帧中;源站选择出一个最佳路由。以后，凡从这个源站向该目的站发送的帧的首部，都必须携带这一路由信息。
此外，发送帧还可以帮助源站确定整个网络可以通过的帧的最大长度。由于发现帧的数量指数式增加，可能会使网络严重拥塞。</p>
</li>
<li>
<p>两种网桥的比较</p>
<p>使用源路由网桥可以利用最佳路由。若在两个以太网之间使用并联的源路由网桥，则还可使通信量较平均地分配给每个网桥。采用透明网桥时，只能使用生成树，而使用生成树一般并不能保证所用的路由是最佳的，也不能在不同的链路中进行负载均衡。</p>
<p><strong>注意</strong>:透明网桥和源路由网桥中提到的最佳路由并不是经过路由器最少的路由，而可以是发送帧往返时间最短的路由，这样才能真正地进行负载平衡，因为往返时间长说明中间某个路由器可能超载了，所以不走这条路，换个往返时间短的路走。</p>
</li>
</ol>
<h4 id="382局域网交换机及其工作原理">3.8.2局域网交换机及其工作原理</h4>
<ol>
<li>
<p>局域网交换机</p>
<p>桥接器的主要限制是在任一时刻通常只能执行一个帧的转发操作，于是出现了局域网交换机，又称以太网交换机。从本质上说，以太网交换机是一个多端口的网桥，它工作在数据链路层。交换机能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽。
以太网交换机对工作站是透明的，因此管理开销低廉，简化了网络结点的增加、移动和网络变化的操作。利用以太网交换机还可以方便地实现虚拟局域网(Virtual LAN，VLAN)，VLAN不仅可以隔离冲突域，而且可以隔离广播域。</p>
</li>
<li>
<p>原理</p>
<p>以太网交换机的原理是，它检测从以太端口来的数据帧的源和目的地的MAC(介质访问层)地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</p>
</li>
<li>
<p>特点</p>
<p>以太网交换机的特点如下:
1）以太网交换机的每个端口都直接与单台主机相连（普通网桥的端口往往连接到以太网的一个网段)，并且-一般都工作在全双工方式。
2〉以太网交换机能同时连通许多对端口，使每对相互通信的主机都能像独占通信媒体那样，无碰撞地传输数据。
3〉以太网交换机也是一种即插即用设备（和透明网桥一样)，其内部的帧的转发表也是通过自学习算法自动地逐渐建立起来的。
4)以太网交换机由于使用了专用的交换结构芯片，因此交换速率较高。</p>
<p>5）以太网交换机独占传输媒体的带宽。</p>
<p>对于普通10Mb/s的共享式以太网，若共有N个用户，则每个用户占有的平均带宽只有总带宽(10Mb/s）的1/N。在使用以太网交换机时，虽然从每个端口到主机的带宽还是10Mb/s，但由于一个用户在通信时是独占而不是和其他网络用户共享传输媒体的带宽，因此拥有N对端口的交换机的总容量为N×10Mb/s。这正是交换机的最大优点。
以太网交换机一般都具有多种速率的端口，例如可以具有10Mb/s、100Mb/s和1Gb/s的端口的各种组合，因此大大方便了各种不同情况的用户。</p>
</li>
<li>
<p>两种交换模式</p>
<p>目前，以太网交换机主要采用两种交换模式，即直通式和存储转发式。
1)）直通式交换机只检查帧的目的地址，这使得帧在接收后几乎能马上被传出去。这种方式
速度快，但缺乏智能性和安全性，也无法支持具有不同速率的端口的交换。
2）存储转发式交换机先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，确认无
误后通过查找表转换成输出端口将该帧发送出去。如果发现帧有错，那么就将其丢弃。存储转发式的优点是可靠性高，并能支持不同速率端口间的转换，缺点是延迟较大。</p>
</li>
</ol>
<h3 id="39本章小结及疑难点">3.9本章小结及疑难点</h3>
<h2 id="第4章网络层">第4章网络层</h2>
<h3 id="41网络层的功能">4.1网络层的功能</h3>
<h4 id="411异构网络互联">4.1.1异构网络互联</h4>
<p>要在全球范围内把数以百万计的网络互联起来，并且能够互相通信，是一项非常复杂的任务，此时需要解决许多问题，比如不同的寻址方案、不同的网络接入机制、不同的差错处理方法、不同的路由选择机制等。用户的需求是多样的，没有一种单一的网络能适应所有用户的需求。网络层所要完成的任务之一就是使这些异构的网络实现互联。
所谓网络互联，是指将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（即中间设备）相互连接起来，以构成更大的网络系统。中间设备又称中间系统或中继系统。根据所在的层次，中继系统分为以下4种:
1）物理层中继系统:中继器，集线器（Hub)。</p>
<p>2）数据链路层中继系统:网桥或交换机。3）网络层中继系统:路由器。
4)网络层以上的中继系统:网关。
使用物理层或数据链路层的中继系统时，只是把一个网络扩大了，而从网络层的角度看，它仍然是同一个网络，一般并不称之为网络互联。因此网络互联通常是指用路由器进行网络互联和路由选择。路由器是一台专用计算机，用于在互联网中进行路由选择。
TCP/P体系在网络互联上采用的做法是在网络层（即P层）采用标准化协议，但相互连接的网络可以是异构的。图4.1(a)显示了许多计算机网络通过一些路由器进行的互联。由于参加互联的计算机网络都使用相同的网际协议（Internet Protocol，TP)，因此可以把互联后的计算机网络视为如图4.1(b)所示的一个虚拟IP网络。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605171317554.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605171317554.png, D:%5cBlog%5clocalImages%5cimage-20220605171317554.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605171317554.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605171317554.png"
        title="image-20220605171317554" /></p>
<p>虚拟互联网络也就是逻辑互联网络，即互联起来的各种物理网络的异构性本来是客观存在的，但是通过使用P就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用IP的虚拟互联网络可简称为IP网络。
使用虚拟互联网络的好处是:当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节(如具体的编址方案、路由选择协议等)。</p>
<h4 id="412路由和转发">4.1.2路由和转发</h4>
<p>路由器主要完成两个功能:一是路由选择（确定哪一条路径)，二是分组转发（当一个分组到达时所采取的动作)。前者是根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。后者处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等。
1）路由选择。指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑
的变化情况，动态地改变所选择的路由。
2）分组转发。指路由器根据转发表将用户的P数据报从合适的端口转发出去。
路由表是根据路由选择算法得出的，而转发表是从路由表得出的。转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表一词。</p>
<h4 id="413拥塞控制">4.1.3拥塞控制</h4>
<p>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞。例如，某个路由器所在链路的带宽为R B/s，如果IP分组只从它的某个端口进入，那么其速率为r;n B/s。当rn=R时，可能看起来是件“好事”，因为链路带宽被充分利用。但是，如图4.2所示，当分组到达路由器的速率接近R时，平均时延急剧增加，并且会有大量的分组被丢弃（路由器端口的缓冲区是有限的)，整个网络的吞吐量会骤降，源与目的地之间的平均时延也会变得近乎无穷大。
判断网络是否进入拥塞状态的方法是，观察网络的吞吐量与网络负载的关系:如果随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，那么网络就可能已进入“轻度拥塞”<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605171429547.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605171429547.png, D:%5cBlog%5clocalImages%5cimage-20220605171429547.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605171429547.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605171429547.png"
        title="image-20220605171429547" />状态;如果网络的吞吐量随着网络负载的增大而下降，那么网络就可能已进入拥塞状态;如果网络的负载继续增大，而网络的吞吐量下降到零，那么网络就可能已进入死锁状态。
为避免拥塞现象的出现，要采用能防止拥塞的一系列方法对子网进行拥塞控制。拥塞控制主要解决的问题是如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞而出现分组的丢失，以及严重拥塞而产生网络死锁的现象。
拥塞控制的作用是确保子网能够承载所达到的流量，这是一个全局性的过程，涉及各方面的行为:主机、路由器及路由器内部的转发处理过程等。单一地增加资源并不能解决拥塞。
流量控制和拥塞控制的区别:流量控制往往是指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，涉及网络中所有的主机、路由器及导致网络传输能力下降的所有因素。
拥塞控制的方法有两种:
1)开环控制。在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产
生拥塞。这是一种静态的预防方法。一旦整个系统启动并运行，中途就不再需要修改。开环控制手段包括确定何时可接收新流量、何时可丢弃分组及丢弃哪些分组，确定何种调度决策等。所有这些手段的共性是，在做决定时不考虑当前网络的状态。
2）闭环控制。事先不考虑有关发生拥塞的各种因素，采用监测网络系统去监视，及时检测
哪里发生了拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。闭环控制是基于反馈环路的概念，是一种动态的方法。</p>
<h3 id="42路由算法">4.2路由算法</h3>
<h4 id="421静态路由和动态路由">4.2.1静态路由和动态路由</h4>
<p>路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。从能否随网络的通信量或拓扑自适应地进行调整变化来划分，路由算法可分为如下两大类。
<strong>静态路由算法</strong>（又称非自适应路由算法)。指由网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。大型和复杂的网络环境通常不宜采用静态路由。一方面，网络管理员难以全面了解整个网络的拓扑结构;另一方面，当网络的拓扑结构和链路状态发生变化时，路由器中的静态路由信息需要大范围地调整，这一工作的难度和复杂程度非常高。
<strong>动态路由算法</strong>（又称自适应路由算法)。指路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的算法优化出来的，而这些路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优的寻路效果。
静态路由算法的优点是简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，因此仍广泛用于高度安全的军事系统和较小的商业网络。动态路由算法能改善网络的性能并有助于流量控制;但算法复杂，会增加网络的负担，有时因对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性，因此要仔细设计动态路由算法，以发挥其优势。常用的动态路由算法可分为两类:距离-向量路由算法和链路状态路由算法。</p>
<h4 id="422距离向量路由算法">4.2.2距离向量路由算法</h4>
<p>在距离-向量路由算法中,所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包含:
●每条路径的目的地(另一结点)。●路径的代价（也称距离)。
<strong>注意</strong>:这里的距离是一个抽象的概念，如RIP就将距离定义为“跳数”。跳数指从源端口到达目的端口所经过的路由个数，每经过一个路由器，跳数加1。
在这种算法中，所有结点都必须参与距离向量交换，以保证路由的有效性和一致性，也就是说，所有的结点都监听从其他结点传来的路由选择更新信息，并在下列情况下更新它们的路由选择表:
1）被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的
路由。
2）发来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较
短的距离（较小的代价)。此种情况下，就用经过发送路由信息的结点的新路由替换路由表中到达那个目的地的现有路由。
距离-向量路由算法的实质是，迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短(最小代价）通路。它要求每个结点在每次更新时都将它的全部路由表发送给所有相邻的结点。显然，更新报文的大小与通信子网的结点个数成正比，大的通信子网将导致很大的更新报文。由于更新报文发给直接邻接的结点，所以所有结点都将参加路由选择信息交换。基于这些原因，在通信子网上传送的路由选择信息的数量很容易变得非常大。
最常见的距离-向量路由算法是RIP算法，它采用“跳数”作为距离的度量。</p>
<h4 id="423链路状态路由算法">4.2.3链路状态路由算法</h4>
<p>链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑信息，它们执行下述两项任务。第一，主动测试所有邻接结点的状态。两个共享一条链接的结点是相邻结点，它们连接到同一条链路，或者连接到同一广播型物理网络。第二，定期地将链路状态传播给所有其他结点(或称路由结点)。典型的链路状态算法是OSPF算法。
在一个链路状态路由选择中，一个结点检查所有直接链路的状态，并将所得的状态信息发送给网上的所有其他结点，而不是仅送给那些直接相连的结点。每个结点都用这种方式从网上所有其他的结点接收包含直接链路状态的路由选择信息。</p>
<p>每当链路状态报文到达时，路由结点便使用这些状态信息去更新自己的网络拓扑和状态“视野图”，一旦链路状态发生变化,结点就对更新的网络图利用Dijsktra最短路径算法重新计算路由,从单一的源出发计算到达所有目的结点的最短路径。
链路状态路由算法主要有三个特征:
1)向本自治系统（见4.2.4节)中所有路由器发送信息，这里使用的方法是泛洪法，即路由
器通过所有端口向所有相邻的路由器发送信息。而每个相邻路由器又将此信息发往其所有相邻路由器（但不再发送给刚刚发来信息的那个路由器)。
2）发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信
息。所谓“链路状态”，是指说明本路由器与哪些路由器相邻及该链路的“度量”。对于OSPF 算法，链路状态的“度量”主要用来表示费用、距离、时延、带宽等。
3）只有当链路状态发生变化时，路由器才向所有路由器发送此消息。
由于一个路由器的链路状态只涉及相邻路由器的连通状态，而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或路由信息变化聚敛的互联网环境。
链路状态路由算法的主要优点是，每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算;链路状态报文不加改变地传播，因此采用该算法易于查找故障。当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚。最后，由于链路状态报文仅运载来自单个结点关于直接链路的信息，其大小与网络中的路由结点数目无关，因此链路状态算法比距离-向量算法有更好的规模可伸展性。
距离-向量路由算法与链路状态路由算法的比较:在距离-向量路由算法中，每个结点仅与它的直接邻居交谈，它为它的邻居提供从自己到网络中所有其他结点的最低费用估计。在链路状态路由算法中，每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链路的费用。相较之下，距离-向量路由算法有可能遇到路由环路等问题。</p>
<h4 id="424层次路由">4.2.4层次路由</h4>
<p>当网络规模扩大时，路由器的路由表成比例地增大。这不仅会消耗越来越多的路由器缓冲区空间，而且需要用更多CPU时间来扫描路由表，用更多的带宽来交换路由状态信息。因此路由选择必须按照层次的方式进行。
因特网将整个互联网划分为许多较小的自治系统（<strong>注意</strong>一个自治系统中包含很多局域网)，每个自治系统有权自主地决定本系统内应采用何种路由选择协议。如果两个自治系统需要通信，那么就需要一种在两个自治系统之间的协议来屏蔽这些差异。据此，因特网把路由选择协议划分为两大类:
1)一个自治系统内部所使用的路由选择协议称为内部网关协议(IGP)，也称域内路由选择，
具体的协议有RIP和 OSPF等。
2〉自治系统之间所使用的路由选择协议称为外部网关协议（EGP)，也称域间路由选择，用
在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径。具体的协议有BGP。
使用层次路由时，OSPF 将一个自治系统再划分为若干区域(Area)，每个路由器都知道在本区域内如何把分组路由到目的地的细节，但不用知道其他区域的内部结构。
采用分层次划分区域的方法虽然会使交换信息的种类增多，但也会使OSPF 协议更加复杂。但这样做却能使每个区域内部交换路由信息的通信量大大减小，因而使OSPF 协议能够用于规模很大的自治系统中。</p>
<h3 id="43-ipv4">4.3 IPv4</h3>
<h4 id="431ipv4分组">4.3.1IPv4分组</h4>
<p>IPv4即现在普遍使用的IP(版本4)。IP定义数据传送的基本单元——IP分组及其确切的数据格式。I 也包括一套规则，指明分组如何处理、错误怎样控制。特别是P还包含非可靠投递的思想，以及与此关联的分组路由选择的思想。</p>
<ol>
<li>
<p>IPv4分组的格式</p>
<p>一个IP分组由首部和数据两部分组成。首部前一部分的长度固定，共20B，是所有IP分组必须具有的。在首部固定部分的后面是一些可选字段，其长度可变，用来提供错误检测及安全等机制。IP数据报的格式如图4.3所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605171838576.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605171838576.png, D:%5cBlog%5clocalImages%5cimage-20220605171838576.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605171838576.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605171838576.png"
        title="image-20220605171838576" />IP首部的部分重要字段含义如下:
1）版本。指IP的版本，目前广泛使用的版本号为4。
2）首部长度。占4位。以32位为单位，最大值为60B (15x4B)。最常用的首部长度是20B,
此时不使用任何选项（即可选字段)。
3)总长度。占16位。指首部和数据之和的长度，单位为字节，因此数据报的最大长度为216-1=65535B。以太网帧的最大传送单元(MTU)为1500B，因此当一个P数据报封装成帧时，数据报的总长度（首部加数据）一定不能超过下面数据链路层的MTU值。
4)标识。占16位。它是一个计数器，每产生一个数据报就加1，并赋值给标识字段。但它
并不是“序号”(因为P是无连接服务)。当一个数据报的长度超过网络的MTU时，必须分片，此时每个数据报片都复制一次标识号，以便能正确重装成原来的数据报。
5）标志。占3位。标志字段的最低位为MF，MF= 1表示后面还有分片，MF=0表示最后一个分片。标志字段中间的一位是DF，只有当DF=0时才允许分片。
6）片偏移。占13位。它指出较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位，即每个分片的长度一定是8B(64位）的整数倍。
7）首部校验和。占16位。P数据报的首部校验和只校验分组的首部，而不校验数据部分。8）生存时间（TTL)。占8位。数据报在网络中可通过的路由器数的最大值，标识分组在网
络中的寿命，以确保分组不会永远在网络中循环。路由器在转发分组前，先把TTL减1。若TTL被减为0，则该分组必须丢弃。
9）协议。占8位。指出此分组携带的数据使用何种协议，即分组的数据部分应交给哪个传
输层协议，如TCP、UDP等。其中值为6表示TCP，值为17表示UDP。
10）源地址字段。占4B，标识发送方的P地址。
11）目的地址字段。占4B，标识接收方的P地址。
<strong>注意</strong>:在IP数据报首部中有三个关于长度的标记，一个是首部长度、一个是总长度、一个是片偏移，基本单位分别为4B、1B、8B(这个一定要记住)。题目中经常会出现这几个长度之间的加减运算。另外，读者要熟悉IP数据报首部的各个字段的意义和功能，但不需要记忆P数据报的首部，正常情况下如果需要参考首部，题目都会直接给出。第5章学到的TCP、UDP的首部也是一样的。</p>
</li>
<li>
<p>IP数据报分片</p>
<p>一个链路层数据报能承载的最大数据量称为最大传送单元(MTU)。因为IP数据报被封装在链路层数据报中，因此链路层的MTU严格地限制着IP数据报的长度，而且在P数据报的源与目的地路径上的各段链路可能使用不同的链路层协议，有不同的MTU。例如，以太网的MTU为1500B，而许多广域网的MTU不超过576B。当P数据报的总长度大于链路MTU时，就需要将IP数据报中的数据分装在两个或多个较小的I数据报中，这些较小的数据报称为片。
片在目的地的网络层被重新组装。目的主机使用IP首部中的标识、标志和片偏移字段来完成对片的重组。创建一个P数据报时，源主机为该数据报加上一个标识号。当一个路由器需要将一个数据报分片时，形成的每个数据报（即片）都具有原始数据报的标识号。当目的主机收到来自同一发送主机的一批数据报时，它可以通过检查数据报的标识号来确定哪些数据报属于同一个原始数据报的片。IP首部中的标志位有3比特，但只有后2比特有意义，分别是 MF位(MoreFragment）和 DF位(Don&rsquo;t Fragment)。只有当DF=0时，该P数据报才可以被分片。MF则用来告知目的主机该IP数据报是否为原始数据报的最后一个片。当MF = 1时，表示相应的原始数据报还有后续的片;当MF = 0时，表示该数据报是相应原始数据报的最后一个片。目的主机在对片进行重组时，使用片偏移字段来确定片应放在原始IP数据报的哪个位置。
IP分片涉及一定的计算。例如，一个长4000B的IP数据报（首部20B，数据部分3980B)到达一个路由器，需要转发到一条MTU为1500B的链路上。这意味着原始数据报中的3980B数据必须被分配到3个独立的片中（每片也是一个IP数据报)。假定原始数据报的标识号为777，那么分成的3片如图4.4所示。可以看出，由于偏移值的单位是8B，所以除最后一个片外，其他所有片中的有效数据载荷都是8的倍数。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605171943763.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605171943763.png, D:%5cBlog%5clocalImages%5cimage-20220605171943763.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605171943763.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605171943763.png"
        title="image-20220605171943763" /></p>
</li>
<li>
<p>网络层转发分组的流程</p>
<p>网络层的路由器执行的分组转发算法如下:
1）从数据报的首部提取目的主机的P地址D，得出目的网络地址N。
2）若网络N与此路由器直接相连，则把数据报直接交付给目的主机D，这称为路由器的直
接交付;否则是间接交付，执行步骤3)。
3）若路由表中有目的地址为D的特定主机路由（对特定的目的主机指明一个特定的路由，
通常是为了控制或测试网络，或出于安全考虑才采用的)，则把数据报传送给路由表中所指明的下一跳路由器;否则，执行步骤4)。
4）若路由表中有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由器;否则,
执行步骤5)。
5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否则，
执行步骤6)。
6）报告转发分组出错。
<strong>注意</strong>:得到下一跳路由器的IP地址后并不是直接将该地址填入待发送的数据报，而是将该IP地址转换成MAC地址（通过ARP，见 4.3.4节)，将其放到MAC帧首部中，然后根据这个MAC地址找到下一跳路由器。在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化,但是网桥在转发帧时，不改变帧的源地址，请<strong>注意</strong>区分。</p>
</li>
</ol>
<h4 id="432ipv4地址与nat">4.3.2IPv4地址与NAT</h4>
<ol>
<li>
<p>IPv4地址</p>
<p>连接到因特网上的每台主机(或路由器）都分配一个32比特的全球唯一标识符，即P地址。传统的IP地址是分类的地址，分为A、B、C、D、E五类。
无论哪类地址，都由网络号和主机号两部分组成。即P地址::= {&lt;网络号&gt;,&lt;主机号&gt;}。其中网络号标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。主机号标志该主机（或路由器)。一台主机号在它前面的网络号所指明的网络范围内必须是唯的。由此可见，一个IP地址在整个因特网范围内是唯一的。
分类的P地址如图4.5所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605172045015.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605172045015.png, D:%5cBlog%5clocalImages%5cimage-20220605172045015.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605172045015.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605172045015.png"
        title="image-20220605172045015" />在各类P地址中，有些IP地址具有特殊用途，不用做主机的P地址:·主机号全为0表示本网络本身，如202.98.174.0。
主机号全为1表示本网络的广播地址，又称直接广播地址，如202.98.174.255。
127.0.0.0保留为环路自检(Loopback Test)地址，此地址表示任意主机本身，目的地址为环回地址的P数据报永远不会出现在任何网络上。
32位全为0，即0.0.0.0表示本网络上的本主机。
32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址，又称受限广播地址。实际使用时，由于路由器对广播域的隔离，255.255.255.255等效为本网络的广播地址。常用的三种类别P地址的使用范围见表4.1。
在表4.1中，A类地址可用的网络数为$2^7$-2，减2的原因是:第一，网络号字段全为0的IP地址是保留地址，意思是“本网络”，第二，网络号为127的P地址是环回测试地址。B类地址的可用网络数为$2^14$-1，减1的原因是128.0这个网络号是不可指派的。C类地址的可用网络数为$2^21$-1，减1的原因是网络号为192.0.0的网络是不可指派的。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605172232326.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605172232326.png, D:%5cBlog%5clocalImages%5cimage-20220605172232326.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605172232326.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605172232326.png"
        title="image-20220605172232326" />IP地址有以下重要特点:
1)每个P地址都由网络号和主机号两部分组成，因此IP地址是一种分等级的地址结构。分
等级的好处是:①IP地址管理机构在分配P地址时只分配网络号（第一级)，而主机号(第二级）则由得到该网络的单位自行分配，方便了IP地址的管理;②路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目标主机号)，从而减小了路由表所占的存储空间。
2)IP地址是标志一台主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网
络时，该主机就必须同时具有两个相应的P地址，每个地址的网络号必须与所在网络的网络号相同，且这两个P地址的网络号是不同的。因此P网络上的一个路由器必然至少应具有两个P地址（路由器每个端口必须至少分配一个IP地址)。
3）用转发器或桥接器（网桥等）连接的若干LAN仍然是同一个网络（同一个广播域)，因
此该LAN中所有主机的IP地址的网络号必须相同，但主机号必须不同。
4）在IP地址中，所有分配到网络号的网络（无论是LAN还是WAN）都是平等的。
5）在同一个局域网上的主机或路由器的P地址中的网络号必须是一样的。路由器总是具有
两个或两个以上的IP地址，路由器的每个端口都有一个不同网络号的IP地址。</p>
</li>
<li>
<p>网络地址转化</p>
<p>网络地址转换(NAT)是指通过将专用网络地址(如Intranet）转换为公用地址(如Internet),从而对外隐藏内部管理的IP地址。它使得整个专用网只需要一个全球IP地址就可以与因特网连通，由于专用网本地IP地址是可重用的，所以NAT大大节省了P地址的消耗。同时，它隐藏了内部网络结构，从而降低了内部网络受到攻击的风险。
此外，为了网络安全，划出了部分IP地址为私有P地址。私有IP地址只用于LAN，不用于WAN连接(因此私有IP地址不能直接用于Internet，必须通过网关利用NAT把私有IP地址转换为Internet中合法的全球P地址后才能用于Internet)，并且允许私有P地址被LAN重复使用。这有效地解决了IP地址不足的问题。私有IP地址网段如下:
A类:1个A类网段，即10.0.0.0～10.255.255.255。
B类: 16个B类网段，即172.16.0.0～172.31.255.255。</p>
<p>C类: 256个C类网段，即192.168.0.0~～192.168.255.255。
在因特网中的所有路由器，对目的地址是私有地址的数据报一律不进行转发。这种采用私有IP地址的互联网络称为专用互联网或本地互联网。私有IP地址也称可重用地址。
使用NAT时需要在专用网连接到因特网的路由器上安装NAT软件，NAT路由器至少有一个有效的外部全球地址。使用本地地址的主机和外界通信时，NAT路由器使用NAT转换表将本地地址转换成全球地址，或将全球地址转换成本地地址。NAT转换表中存放着{本地IP地址:端口}到{全球I地址:端口}的映射。通过{ip地址:端口}这样的映射方式，可让多个私有P地址映射到同一个全球IP地址。</p>
<p>下面以宿舍共享宽带上网为例进行说明。假设某个宿舍办理了2Mb/s的电信宽带，那么这个宿舍就获得了一个全球IP地址(如138.76.29.7)，而宿舍内4台主机使用私有地址(如192.168.0.0网段)。宿舍的网关路由器应该开启NAT功能，并且某时刻路由器上的NAT转换表见表4.2。那么，当路由器从LAN端口收到源IP及源端口号为192.168.0.2:2233的数据报时，就将其映射成138.76.29.7:5001，然后从WAN端口发送到因特网上。当路由器从WAN端口收到目的P及目的端口号为138.76.29.7:5060的数据报时，就将其映射成192.168.0.3:1234，然后从LAN端口发送给相应的本地主机。这样，只需要一个全球地址，就可以让多台主机同时访问因特网。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605172433037.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605172433037.png, D:%5cBlog%5clocalImages%5cimage-20220605172433037.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605172433037.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605172433037.png"
        title="image-20220605172433037" /><strong>注意</strong>:普通路由器在转发IP数据报时，不改变其源P地址和目的P地址。而NAT路由器在转发IP数据报时，一定要更换其IP地址（转换源IP地址或目的P地址)。普通路由器仅工作在网络层，而NAT路由器转发数据报时需要查看和转换传输层的端口号。</p>
</li>
</ol>
<h4 id="433子网划分与子网掩码cidr">4.3.3子网划分与子网掩码、CIDR</h4>
<ol>
<li>
<p>子网划分</p>
<p>两级IP地址的缺点:IP 地址空间的利用率有时很低;给每个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏;两级的P地址不够灵活。
从1985年起，在P地址中又增加了一个“子网号字段”，使两级P地址变成了三级P地址。这种做法称为子网划分。子网划分已成为因特网的正式标准协议。
子网划分的基本思路如下:
·子网划分纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。
·从主机号借用若干比特作为子网号，当然主机号也就相应减少了相同的比特。三级IP地址的结构如下:P地址={&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}。
凡是从其他网络发送给本单位某台主机的P数据报,仍然是根据P数据报的目的网络号，先找到连接到本单位网络上的路由器。然后该路由器在收到P数据报后，按目的网络号和子网号找到目的子网。最后把IP数据报直接交付给目的主机。
<strong>注意</strong>:
1)划分子网只是把P地址的主机号这部分进行再划分，而不改变P地址原来的网络号。因
此，从一个P地址本身或P数据报的首部，无法判断源主机或目的主机所连接的网络是否进行了子网划分。
2 ) RFC 950规定，对分类的IPv4地址进行子网划分时，子网号不能为全1或全0。但随着
CIDR的广泛使用，现在全1和全0的子网号也可使用，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全0或全1的子网号。
3）不论是分类的IPv4地址还是CIDR，其子网中的主机号为全0或全1的地址都不能被指
派。子网中主机号全0的地址为子网的网络号，主机号全1的地址为子网的广播地址。</p>
</li>
<li>
<p>子网掩码</p>
<p>为了告诉主机或路由器对一个A类、B类、C类网络进行了子网划分，使用子网掩码来表达对原网络中主机号的借位。子网掩码是一个与IP地址相对应的、长32bit 的二进制串，它由一串1和跟随的一串0组成。其中，1对应于P地址中的网络号及子网号，而0对应于主机号。计算机只需将IP地址和其对应的子网掩码逐位“与”(逻辑AND运算)，就可得出相应子网的网络地址。
现在的因特网标准规定:所有的网络都必须使用子网掩码。如果一个网络未划分子网，那么就采用默认子网掩码。A、B、C类地址的默认子网掩码分别为255.0.0.0、255.255.0.0、255.255.255.0。例如，某主机的IP地址192.168.5.56，子网掩码为255.255.255.0，进行逐位“与”运算后，得出该主机所在子网的网络号为192.168.5.0。
由于子网掩码是一个网络或一个子网的重要属性，所以路由器在相互之间交换路由信息时，必须把自己所在网络(或子网）的子网掩码告诉对方。路由表中的每个条目，除要给出目的网络地址和下一跳地址外，还要同时给出该目的网络的子网掩码。
在使用子网掩码的情况下:
1)一台主机在设置IP地址信息的同时，必须设置子网掩码。
2）同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码。
3）路由器的路由表中，所包含信息的主要内容必须有目的网络地址、子网掩码、下一跳地址。使用子网掩码时路由器的分组转发算法如下:
1）从收到的分组的首部提取目的P地址，记为D。
2）先判断是否为直接交付。对路由器直接相连的网络逐个进行检查:用各网络的子网掩码
和D逐位相“与”，看结果是否和相应的网络地址匹配。若匹配，则将分组直接交付，否则间接交付，执行步骤3)。
3）若路由表中有目的地址为D的特定主机路由，则将分组传送给路由表中所指明的下一跳
路由器;否则，执行4)。
4）对路由表中的每一行（目的网络地址、子网掩码、下一跳地址）中的子网掩码和D逐位
相“与”，其结果为N。若N与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器;否则，执行步骤5)。
5）若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器;否则，执
行步骤6)。
6）报告转发分组出错。</p>
</li>
<li>
<p>无分类域间路由选择CIDR</p>
<p>无分类域间路由选择是在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法。
例如，如果一个单位需要2000个地址，那么就给它分配一个2048地址的块(8个连续的C类网络)，而不是一个完全的B类地址。这样可以大幅度提高P地址空间的利用率，减小路由器的路由表大小，提高路由转发能力。CIDR的主要特点如下:
1）消除了传统A、B、C类地址及划分子网的概念，因而可以更有效地分配IPv4的地址空
间。CIDR使用“网络前缀”的概念代替子网络的概念。因此，IP地址的无分类两级编址为:IP::={&lt;网络前缀&gt;，&lt;主机号&gt;}。
CIDR还使用“斜线记法”(或称CIDR记法)，即P地址/网络前缀所占比特数。其中，网络前缀所占比特数对应于网络号的部分，等效于子网掩码中连续1的部分。例如，对于128.14.32.5/20这个地址，它的掩码是20个连续的1和后续12个连续的0，通过逐位相“与”的方法可以得到该地址的网络前缀（(或直接截取前20位):</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605172854125.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605172854125.png, D:%5cBlog%5clocalImages%5cimage-20220605172854125.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605172854125.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605172854125.png"
        title="image-20220605172854125" />
CIDR虽然不使用子网，但仍然使用“掩码”一词。“CIDR不使用子网”是指CIDR并没有在32位地址中指明若干位作为子网字段。但分配到一个CIDR地址块的组织，仍可以在本组织内根据需要划分出一些子网。例如，某组织分配到地址块/20，就可以再继续划分为8个子网(从主机号中借用3位来划分子网)，这时每个子网的网络前缀就变成了23位。全0和全1的主机号地址一般不使用。
2)将网络前缀都相同的连续P地址组成“CIDR地址块”。一个CIDR地址块可以表示很多
地址，这种地址的聚合称为路由聚合，或称构成超网。路由聚合使得路由表中的一个项目可以表示多个原来传统分类地址的路由，有利于减少路由器之间的路由选择信息的交换，从而提高网络性能。
例如，在如图4.6 所示的网络中，如果不使用路由聚合，那么R1的路由表中需要分别有到网络1和网络2的路由表项。不难发现，网络1和网络2的网络前缀在二进制表示的情况下，前16位都是相同的，第17位分别是0和1，并且从R1到网络1和网络2的路由的下一跳皆为R2。若使用路由聚合，在R1看来，网络1和网络2可以构成一个更大的地址块206.1.0.0/16，到网络1和网络2的两条路由就可以聚合成一条到206.1.0.0/16的路由。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605172914201.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605172914201.png, D:%5cBlog%5clocalImages%5cimage-20220605172914201.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605172914201.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605172914201.png"
        title="image-20220605172914201" />CIDR地址块中的地址数一定是2的整数次幂，实际可指派的地址数通常为2%一2,N表示主机号的位数，主机号全0代表网络号，主机号全1为广播地址。网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的P地址中，划分子网是使网络前缀变长。
CIDR的优点在于网络前缀长度的灵活性。由于上层网络的前缀长度较短，因此相应的路由表的项目较少。而内部又可采用延长网络前缀的方法来灵活地划分子网。
最长前缀匹配（最佳匹配):使用CIDR时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。此时，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，因而路由就越具体。
CIDR查找路由表的方法:为了更加有效地查找最长前缀匹配，通常将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的数据结构就是二叉线索。</p>
</li>
</ol>
<h4 id="434arpdhcpicmp">4.3.4ARP、DHCP、ICMP</h4>
<ol>
<li>
<p>IP地址与硬件地址</p>
<p>IP地址是网络层使用的地址，它是分层次等级的。硬件地址是数据链路层使用的地址（如MAC地址)，它是平面式的。在网络层及网络层之上使用IP地址，IP地址放在P数据报的首部，而MAC地址放在MAC帧的首部。通过数据封装，把P数据报分组封装为MAC帧后，数据链路层看不见数据报分组中的P地址。
由于路由器的隔离，IP网络中无法通过广播方式依靠MAC地址来完成跨网络的寻址，因此在P网络的网络层只使用地址来完成寻址。寻址时，每个路由器依据其路由表（依靠静态路由或动态路由协议生成)选择到目标网络(即主机号全为0的网络地址)需要转发到的下一跳(路由器的物理端口号或下一网络地址)，而IP分组通过多次路由转发到达目标网络后，改为在目标LAN中通过数据链路层的MAC地址以广播方式寻址。这样可以提高路由选择的效率。
1）在IP层抽象的互联网上只能看到IP数据报。
2）虽然在P数据报首部中有完整的源P地址和目的IP地址，但路由器只根据目的IP地址
的网络号进行路由选择。
3）在局域网的链路层，只能看见MAC帧。而通过路由器转发IP分组时，此IP分组在每个
网络中都被路由器解封装和重新封装。因此P数据报在被路由器转发时，其数据链路层封装所使用的MAC地址是不断改变的。这也决定了无法使用MAC地址跨网络通信。4〉尽管互联在一起的网络的硬件地址体系各不相同，但P层抽象的互联网却屏蔽了下层这
些复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的IP地址研究主机与主机或路由器之间的通信。
<strong>注意</strong>:路由器由于互联多个网络，因此它不仅有多个P地址，也有多个硬件地址。</p>
</li>
<li>
<p>地址解析协议（ARP）</p>
<p>无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址。所以需要一种方法来完成IP地址到MAC地址的映射，这就是地址解析协议(Address ResolutionProtocol，ARP)。每台主机都设有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表，称ARP表。使用ARP来动态维护此ARP表。
ARP工作在网络层，其工作原理如下:主机A欲向本局域网上的某台主机B发送IP数据报时，先在其ARP高速缓存中查看有无主机B的P地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。如果没有，那么就通过使用目的MAC地址为FF-FF-FF-FF-FF-FF的帧来封装并广播ARP请求分组，使同一个局域网里的所有主机收到ARP请求。主机B收到该ARP请求后，向主机A发出响应ARP分组，分组中包含主机B的IP与MAC地址的映射关系，主机A在收到后将此映射写入ARP缓存，然后按查询到的硬件地址发送MAC帧。ARP由于“看到了”IP地址，所以它工作在网络层，而NAT路由器由于“看到了”端口，所以它工作在传输层。对于某个协议工作在哪个层次，读者应该能通过协议的工作原理进行猜测。</p>
<p><strong>注意</strong>:ARP用于解决同一个局域网上的主机或路由器的I地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上,那么就要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做，尽管ARP请求分组是广播发送的，但ARP响应分组是普通的单播，即从一个源地址发送到一个目的地址。</p>
<p>ARP的4种典型情况总结如下:
1)发送方是主机时，要把IP数据报发送到本网络上的另一台主机。这时用ARP找到目的主
机的硬件地址。
2)发送方是主机时，要把P数据报发送到另一个网络上的一台主机。这时用ARP找到本网
络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成。
3)发送方是路由器时，要把IP数据报转发到本网络上的一台主机。这时用ARP找到目的主
机的硬件地址。</p>
<p>4)发送方是路由器时，要把P数据报转发到另一个网络上的一台主机。这时用ARP找到本
网络上的一个路由器的硬件地址，剩下的工作由找到的这个路由器完成。
从IP地址到硬件地址的解析是自动进行的，主机的用户并不知道这种地址解析过程。只要主机或路由器和本网络上的另一个已知IP地址的主机或路由器进行通信，ARP就会自动地将这个IP地址解析为链路层所需要的硬件地址。</p>
</li>
<li>
<p>动态主机配置协议（DHCP）</p>
<p>动态主机配置协议(Dynamic Host Configuration Protocol，DHCP)常用于给主机动态地分配IP地址，它提供了即插即用联网的机制，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。DHCP是应用层协议，它是基于UDP的。
DHCP的工作原理如下:使用客户/服务器方式。需要IP地址的主机在启动时就向DHCP服务器广播发送发现报文，这时该主机就成为DHCP客户。本地网络上所有主机都能收到此广播报文，但只有DHCP服务器才回答此广播报文。DHCP服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。DHCP服务器的回答报文称为提供报文。
DHCP服务器聚合DHCP客户端的交换过程如下:
1)DHCP客户机广播“DHCP发现”消息，试图找到网络中的DHCP服务器，以便从DHCP服务器获得一个IP地址。
2)DHCP服务器收到“DHCP &lsquo;发现”消息后，向网络中广播“DHCP提供”消息，其中包括
提供 DHCP客户机的IP地址和相关配置信息。
3)DHCP客户机收到“DHCP提供”消息，如果接收DHCP服务器所提供的相关参数，那
么通过广播“DHCP请求”消息向DHCP服务器请求提供IP地址。
4）DHCP服务器广播“DHCP确认”消息，将IP地址分配给DHCP客户机。
DHCP允许网络上配置多台DHCP服务器，当DHCP客户机发出 DHCP请求时，有可能收到多个应答消息。这时，DHCP客户机只会挑选其中的一个，通常挑选最先到达的。
DHCP服务器分配给DHCP客户的P地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的IP地址。DHCP称这段时间为租用期。租用期的数值应由DHCP服务器自己决定，DHCP客户也可在自己发送的报文中提出对租用期的要求。
DHCP是应用层协议，因为它是通过客户/服务器方式工作的，DHCP客户端向 DHCP服务器请求服务。读者在后面的学习中会了解到，应用层协议有两种工作方式:客户/服务器方式和P2P方式，而其他层次的协议是没有这两种工作方式的。
DHCP的客户端和服务器端需要通过广播方式来进行交互，原因是在 DHCP执行期间，客户端和服务器端都没有标识自己身份的P地址，因此不可能通过单播的形式进行交互。采用UDP而不采用TCP的原因也很明显:TCP需要建立连接，如果连对方的IP地址都不知道，那么更不可能通过双方的套接字建立连接。</p>
</li>
<li>
<p>网际控制报文协议（ICMP）</p>
<p>为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议（Internet ControlMessage Protocol，ICMP）来让主机或路由器报告差错和异常情况。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报发送出去。ICMP是IP层协议。
ICMP报文的种类有两种，即ICMP差错报告报文和ICMP询问报文。
ICMP 差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。共有以下5种类型:</p>
<p>1）终点不可达。当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。
2）源点抑制。当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使
源点知道应当把数据报的发送速率放慢。
3)时间超过。当路由器收到生存时间（TTL)为零的数据报时，除丢弃该数据报外，还要向
源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。
4）参数问题。当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃
该数据报，并向源点发送参数问题报文。
5）改变路由（重定向)。路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由)。</p>
<p>不应发送ICMP差错报告报文的几种情况如下:
1）对ICMP差错报告报文不再发送ICMP差错报告报文。
2）对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。3）对具有组播地址的数据报都不发送ICMP差错报告报文。
4）对具有特殊地址（如 127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。
ICMP 询问报文有4种类型:回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文，最常用的是前两类。
ICMP的两个常见应用是分组网间探测PING(用来测试两台主机之间的连通性)和Traceroute(UNIX中的名字，在 Windows 中是 tracert，可以用来跟踪分组经过的路由)。其中 PNG使用了ICMP回送请求和回答报文，Traceroute (Tracert）使用了ICMP时间超过报文。
<strong>注意</strong>:PING工作在应用层，它直接使用网络层的ICMP，而未使用传输层的TCP或UDP.Traceroute/Tracert 工作在网络层。</p>
</li>
</ol>
<h3 id="44-ipv6">4.4 IPv6</h3>
<h4 id="441ipv6主要特点">4.4.1IPv6主要特点</h4>
<p>解决IP地址耗尽问题的措施有以下三种:①采用无类别编址CIDR，使P地址的分配更加合理;②采用网络地址转换(NAT)方法以节省全球IP地址;③采用具有更大地址空间的新版本的IPv6。其中前两种方法只是延长了IPv4地址分配结束的时间，只有第三种方法从根本上解决了IP地址的耗尽问题。
IPv6的主要特点如下:
1)更大的地址空间。IPv6将地址从IPv4的32位增大到了128位。IPv6的字节数〈16B）是IPv4字节数（4B）的平方。
2）扩展的地址层次结构。3）灵活的首部格式。4）改进的选项。
5）允许协议继续扩充。
6）支持即插即用（即自动配置)。7）支持资源的预分配。
8）IPv6 只有在包的源结点才能分片，是端到端的，传输路径中的路由器不能分片，所以从一般意义上说，IPv6不允许分片（不允许类似IPv4在路由分片)。
9)IPv6首部长度必须是8B的整数倍，而IPv4首部是4B的整数倍。10）增大了安全性。身份验证和保密功能是IPv6的关键特征。
虽然IPv6与IPv4不兼容，但总体而言它与所有其他的因特网协议兼容，包括TCP、UDP、ICMP、IGMP、OSPF、BGP和 DNS，只是在少数地方做了必要的修改(大部分是为了处理长的地址)。IPv6相当好地满足了预定的目标，主要体现在:
1）首先也是最重要的，IPv6有比 IPv4长得多的地址。IPv6的地址用16个字节表示，地址
空间是IPv4的2128-32=2倍，从长远来看，这些地址是绝对够用的。
2）简化了IP分组头，它包含8个域(IPv4是 12个域)。这一改变使得路由器能够更快地处
理分组，从而可以改善吞吐率。
3）更好地支持选项。这一改变对新的分组首部很重要，因为一些从前必要的段现在变成了
可选段。此外，表示选项的方式的改变还能加快分组的处理速度。</p>
<h4 id="442ipv6地址">4.4.2IPv6地址</h4>
<p>IPv6数据报的目的地址可以是以下三种基本类型地址之一:1）单播。单播就是传统的点对点通信。
2〉多播。多播是一点对多点的通信，分组被交付到一组计算机的每台计算机。
3)任播。这是IPv6增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交
付其中的一台计算机，通常是距离最近的一台计算机。
IPv4地址通常使用点分十进制表示法。如果 IPv6也使用这种表示法，那么地址书写起来将会相当长。在IPv6标准中指定了一种比较紧凑的表示法，即把地址中的每4位用一个十六进制数表示，并用冒号分隔每16位，如4BF5:AA12:0216:FEBC:BA5F:039A:BE9A:2170。
通常可以把IPv6地址缩写成更紧凑的形式。当16位域的开头有一些0时，可以采用一种缩写表示法，但在域中必须至少有一个数字。例如，可以把地址4BF5:0000:0000:0000:BA 5F:039A:000A:2176缩写为4BF5:0:0O:0:BA5F:39A:A:2176。
当有相继的О值域时，还可以进一步缩写。这些域可以用双冒号缩写(::)。当然，双冒号表示法在一个地址中仅能出现一次，因为0值域的个数没有编码，需要从指定的总的域的个数来推算。这样一来，前述地址可被更紧凑地书写成4BF5:;BA5F:39A:A:2176。</p>
<p>IPv6扩展了IPv4地址的分级概念，它使用以下3个等级:第一级（顶级）指明全球都知道的公共拓扑;第二级（场点级）指明单个场点;第三级指明单个网络接口。IPv6地址采用多级体系主要是为了使路由器能够更快地查找路由。
IPv4向IPv6过渡只能采用逐步演进的办法,同时还必须使新安装的IPv6系统能够向后兼容。IPv6系统必须能够接收和转发IPv4分组，并且能够为IPv4分组选择路由。
IPv4向IPv6过渡可以采用双协议栈和隧道技术两种策略:双协议栈技术是指在一台设备上同时装有IPv4和IPv6协议栈，那么这台设备既能和IPv4网络通信，又能和IPv6网络通信。如果这台设备是一个路由器，那么在路由器的不同接口上分别配置了IPv4地址和IPv6地址，并很可能分别连接了IPv4网络和IPv6网络;如果这台设备是一台计算机，那么它将同时拥有IPv4地址和IPv6地址，并具备同时处理这两个协议地址的功能。隧道技术是将整个IPv6数据报封装到IPv4数据报的数据部分，使得IPv6数据报可以在IPv4网络的隧道中传输。</p>
<h3 id="45路由协议">4.5路由协议</h3>
<h4 id="451自治系统">4.5.1自治系统</h4>
<p>自治系统（Autonomous System，AS):单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由，同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由。
一个自治系统内的所有网络都由一个行政单位（如一家公司、一所大学、一个政府部门等)管辖，一个自治系统的所有路由器在本自治系统内都必须是连通的。</p>
<h4 id="452域内路由与域间路由">4.5.2域内路由与域间路由</h4>
<p>自治系统内部的路由选择称为域内路由选择，自治系统之间的路由选择称为域间路由选择。因特网有两大类路由选择协议。</p>
<ol>
<li>
<p>内部网关协议</p>
<p>内部网关协议即在一个自治系统内部使用的路由选择协议，它与互联网中其他自治系统选用什么路由选择协议无关。目前这类路由选择协议使用得最多，如RIP和 OSPF。</p>
</li>
<li>
<p>外部网关协议</p>
<p>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时（两个自治系统可能使用不同的IGP)，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议（EGP)。目前使用最多的外部网关协议是 BGP-4。
图4.7是两个自治系统互联的示意图。每个自治系统自己决定在本自治系统内部运行哪个内部路由选择协议（例如，可以是RIP，也可以是OSPF)，但每个自治系统都有一个或多个路由器(图中的路由器R1和R2)。除运行本系统的内部路由选择协议外，还要运行自治系统间的路由选择协议（如 BGP-4)。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605173606969.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605173606969.png, D:%5cBlog%5clocalImages%5cimage-20220605173606969.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605173606969.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605173606969.png"
        title="image-20220605173606969" /></p>
</li>
</ol>
<h4 id="453路由信息协议rip">4.5.3路由信息协议（RIP）</h4>
<p>路由信息协议（Routing Information Protocol，RIP）是内部网关协议(IGP）中最先得到广泛应用的协议。RIP是一种分布式的基于距离向量的路由选择协议，其最大优点就是简单。</p>
<ol>
<li>RIP规定
1）网络中的每个路由器都要维护从它自身到其他每个目的网络的距离记录〈因此这是一组
距离，称为距离向量)。
2〉距离也称跳数(Hop Count)，规定从一个路由器到直接连接网络的距离（跳数〉为1。而
每经过一个路由器，距离（跳数）加1。
3）RIP认为好的路由就是它通过的路由器的数目少，即优先选择跳数少的路径。
4）RIP允许一条路径最多只能包含15个路由器（即最多允许15跳)。因此距离等于16时，
它表示网络不可达。可见RIP只适用于小型互联网。距离向量路由可能会出现环路的情况，规定路径上的最高跳数的目的是为了防止数据报不断循环在环路上，减少网络拥塞的可能性。
5）RIP默认在任意两个使用RIP的路由器之间每30秒广播一次RIP路由更新信息，以便自
动建立并维护路由表（动态维护)。
6）在 RIP中不支持子网掩码的RIP广播，所以RIP中每个网络的子网掩码必须相同。但在
新的RIP2中，支持变长子网掩码和CIDR。</li>
<li>RIP的特点（<strong>注意</strong>与OSPF的特点比较）1）仅和相邻路由器交换信息。
2）路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表。3）按固定的时间间隔交换路由信息，如每隔30秒。
RIP通过距离向量算法来完成路由表的更新。最初，每个路由器只知道与自己直接相连的网络。通过每30秒的RIP广播，相邻两个路由器相互将自己的路由表发给对方。于是经过第一次RIP广播，每个路由器就知道了与自己相邻的路由器的路由表〈即知道了距离自己跳数为Ⅰ的网络的路由)。同理,经过第二次RIP广播,每个路由器就知道了距离自己跳数为2的网络的路由……因此经过若干RIP广搢后，所有路由器都最终知道了整个P网络的路由表，成为RIP最终是收敛的。通过RIP收敛后,每个路由器到每个目标网络的路由都是距离最短的(即跳数最少，最短路由),哪怕还存在另一条高速（低时延〉但路由器较多的路由。</li>
<li>距离向量算法
每个路由表项目都有三个关键数据:&lt;目的网络N，距离d，下一跳路由器X&gt;。对于每个相邻路由器发送过来的RIP报文，执行如下步骤:
1）对地址为X的相邻路由器发来的RIP报文，先修改此报文中的所有项目:把“下一跳”
字段中的地址都改为X，并把所有“距离”字段的值加1。
2）对修改后的RIP报文中的每个项目，执行如下步骤;
当原来的路由表中没有目的网络N时，把该项目添加到路由表中。
当原来的路由表中有目的网络N，且下一跳路由器的地址是X时，用收到的项目替换
原路由表中的项目。
③当原来的路由表中有目的网络N，且下一跳路由器的地址不是X时，如果收到的项目
中的距离d小于路由表中的距离，那么就用收到的项目替换原路由表中的项目﹔否则什么也不做。
3）如果180秒(RIP默认超时时间为180秒)还没有收到相邻路由器的更新路由表，那么把
此相邻路由器记为不可达路由器，即把距离设置为16（距离为16表示不可达)。
4）返回。
RIP最大的优点是实现简单、开销小、收敛过程较快。RIP的缺点如下:1) RIP限制了网络的规模，它能使用的最大距离为15(16表示不可达)。
2）路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销也越大。
3)网络出现故障时，会出现慢收敛现象（即需要较长时间才能将此信息传送到所有路由器),
俗称“坏消息传得慢”，使更新过程的收敛时间长。
RIP是应用层协议，它使用UDP传送数据（端口520)。RIP选择的路径不一定是时间最短的，但一定是具有最少路由器的路径。因为它是根据最少的跳数进行路径选择的。</li>
</ol>
<h4 id="454开放最短路径优先ospf协议">4.5.4开放最短路径优先(OSPF)协议</h4>
<ol>
<li>
<p>基本特点</p>
<p>开放最短路径优先（OSPF）协议是使用分布式链路状态路由算法的典型代表，也是内部网关协议（IGP）的一种。OSPF与 RIP相比有以下4点主要区别:
1)OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法。而RIP仅向自
己相邻的几个路由器发送信息。
2）发送的信息是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分
信息。“链路状态”说明本路由器和哪些路由器相邻及该链路的“度量”(或代价)。而在RIP中，发送的信息是本路由器所知道的全部信息，即整个路由表。
3）只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过
程收敛得快，不会出现 RIP“坏消息传得慢”的问题。而在 RIP中，不管网络拓扑是否发生变化，路由器之间都会定期交换路由表的信息。
4)OSPF是网络层协议，它不使用UDP或TCP，而直接用P数据报传送（其P数据报首
部的协议字段为89)。而RIP是应用层协议，它在传输层使用UDP。
除以上区别外，OSPF 还有以下特点:
1)OSPF对不同的链路可根据分组的不同服务类型（TOS）而设置成不同的代价。因此，
OSPF 对于不同类型的业务可计算出不同的路由，十分灵活。
2）如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。
这称为多路径间的负载平衡。
3）所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器
之间交换链路状态信息。
4）支持可变长度的子网划分和无分类编址CIDR。
5）每个链路状态都带上一个32位的序号，序号越大，状态就越新。</p>
</li>
<li>
<p>基本工作原理</p>
<p>由于各路由器之间频繁地交换链路状态信息，因此所有路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（称为链路状态数据库的同步)。然后，每个路由器根据这个全网拓扑结构图，使用 Dijkstra最短路径算法计算从自己到各目的网络的最优路径，以此构造自己的路由表。此后，当链路状态发生变化时，每个路由器重新计算到各目的网络的最优路径，构造新的路由表。<strong>注意</strong>:虽然使用Dijkstra算法能计算出完整的最优路径，但路由表中不会存储完整路径，而只存储“下一跳”(只有到了下一跳路由器，才能知道再下一跳应当怎样走).
为使OSPF 能够用于规模很大的网络，OSPF将一个自治系统再划分为若干更小的范围，称为区域。划分区域的好处是，将利用洪泛法交换链路状态信息的范围局限于每个区域而非整个自治系统，减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑情况。这些区域也有层次之分。处在上层的域称为主干区域，负责连通其他下层的区域，并且还连接其他自治域。</p>
</li>
<li>
<p>五种分组类型</p>
<p>OSPF共有以下五种分组类型:
1)问候分组，用来发现和维持邻站的可达性。
2）数据库描述分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。3）链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。
4）链路状态更新分组，用洪泛法对全网更新链路状态。
5）链路状态确认分组，对链路更新分组的确认。
通常每隔10秒，每两个相邻路由器要交换一次问候分组，以便知道哪些站可达。在路由器刚开始工作时，OSPF 让每个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。然后，路由器使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。经过一系列的这种分组交换，就建立了全网同步的链路数据库。图4.8给出了OSPF 的基本操作，说明了两个路由器需要交换的各种类型的分组。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605174017288.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605174017288.png, D:%5cBlog%5clocalImages%5cimage-20220605174017288.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605174017288.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605174017288.png"
        title="image-20220605174017288" />在网络运行的过程中，只要一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态。其他路由器在更新后，发送链路状态确认分组对更新分组进行确认。
为了确保链路状态数据库与全网的状态保持一致，OSPF还规定每隔一段时间（如30分钟)就刷新一次数据库中的链路状态。由于一个路由器的链路状态只涉及与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此，当互联网规模很大时，OSPF 要比RIP好得多，而且OSPF协议没有“坏消息传播得慢”的问题。
<strong>注意</strong>:教材上说OSPF 协议不使用UDP数据报传送，而是直接使用IP数据报传送，在此解释一下什么称为用UDP传送，什么称为用IP数据报传送，用UDP传送是指将该信息作为UDP报文的数据部分，而直接使用IP数据报传送是指将该信息直接作为P数据报的数据部分。RIP报文是作为UDP数据报的数据部分。</p>
</li>
</ol>
<h4 id="455边界网关协议bgp">4.5.5边界网关协议(BGP)</h4>
<p>边界网关协议(Border Gateway Protocol，BGP)是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。边界网关协议常用于互联网的网关之间。路由表包含已知路由器的列表、路由器能够达到的地址及到达每个路由器的路径的跳数。
内部网关协议主要设法使数据报在一个AS中尽可能有效地从源站传送到目的站。在一个AS内部不需要考虑其他方面的策略。然而BGP使用的环境却不同，主要原因如下:
1)因特网的规模太大，使得自治系统之间路由选择非常困难。
2）对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。3）自治系统之间的路由选择必须考虑有关策略。
边界网关协议（BGP）只能力求寻找一条能够到达目的网络且比较好的路由(不能兜圈子)，而并非寻找一条最佳路由。BGP采用的是路径向量路由选择协议，它与距离向量协议和链路状态协议有很大的区别。BGP是应用层协议，它是基于TCP的。
BGP的工作原理如下:每个自治系统的管理员要选择至少一个路由器(可以有多个)作为该自治系统的“BGP发言人”。一个BGP 发言人与其他自治系统中的BGP 发言人要交换路由信息，就要先建立TCP连接（可见BGP报文是通过TCP传送的，也就是说BGP报文是TCP报文的数据部分)，然后在此连接上交换BGP报文以建立BGP会话，再利用BGP会话交换路由信息。当所有BGP发言人都相互交换网络可达性的信息后，各BGP发言人就可找出到达各个自治系统的较好路由。
每个BGP 发言人除必须运行BGP外，还必须运行该AS所用的内部网关协议，如OSPF或RIP。BGP所交换的网络可达性信息就是要到达某个网络（用网络前缀表示）所要经过的一系列AS。图4.9给出了一个BGP发言人交换路径向量的例子。
BGP的特点如下:
1） BGP交换路由信息的结点数量级是自治系统的数量级，要比这些自治系统中的网络数少
很多。
2）每个自治系统中 BGP发言人(或边界路由器）的数目是很少的。这样就使得自治系统之
间的路由选择不致过分复杂。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605174113081.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605174113081.png, D:%5cBlog%5clocalImages%5cimage-20220605174113081.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605174113081.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605174113081.png"
        title="image-20220605174113081" />3）BGP支持CIDR，因此BGP的路由表也就应当包括目的网络前缀、下一跳路由器，以及
到达该目的网络所要经过的各个自治系统序列。
4）在 BGP刚运行时，BGP的邻站交换整个BGP路由表，但以后只需在发生变化时更新有
变化的部分。这样做对节省网络带宽和减少路由器的处理开销都有好处。</p>
<p>BGP-4共使用4种报文:
1)打开(Open）报文。用来与相邻的另一个BGP发言人建立关系。
2）更新（Update）报文。用来发送某一路由的信息，以及列出要撤销的多条路由。3）保活(Keepalive）报文。用来确认打开报文并周期性地证实邻站关系。
4)通知(Notification)报文。用来发送检测到的差错。
RIP、OSPF与 BGP的比较如表4.3所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605174156479.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605174156479.png, D:%5cBlog%5clocalImages%5cimage-20220605174156479.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605174156479.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605174156479.png"
        title="image-20220605174156479" /></p>
<h3 id="46-ip组播">4.6 IP组播</h3>
<h4 id="461组播概念">4.6.1组播概念</h4>
<p>为了能够支持像视频点播和视频会议这样的多媒体应用，网络必须实施某种有效的组播机制。使用多个单播传送来仿真组播总是可能的，但这会引起主机上大量的处理开销和网络上太多的交通量。人们所需要的组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收。
组播一定仅应用于UDP，它对将报文同时送往多个接收者的应用来说非常重要。而TCP是一个面向连接的协议，它意味着分别运行于两台主机(由lP地址来确定)内的两个进程（由端口号来确定）之间存在一条连接，因此会一对一地发送。
使用组播的缘由是，有的应用程序要把一个分组发送给多个目的地主机。不是让源主机给每个目的地主机都发送一个单独的分组，而是让源主机把单个分组发送给一个组播地址，该组播地址标识一组地址。网络（如因特网）把这个分组的副本投递给该组中的每台主机。主机可以选择加入或离开一个组，因此一台主机可以同时属于多个组。
因特网中的IP 组播也使用组播组的概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址。在IPv4中，这些地址在D类地址空间中分配，而IPv6也有一部分地址空间保留给组播组。
主机使用一个称为IGMP(因特网组管理协议）的协议加入组播组。它们使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望。通过扩展路由器的路由选择和转发功能，可以在许多路由器互联的支持硬件组播的网络上面实现因特网组播。
需要<strong>注意</strong>的是，主机组播时仅发送一份数据，只有数据在传送路径出现分岔时才将分组复制后继续转发。因此，对发送者而言，数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担。组播需要路由器的支持才能实现，能够运行组播协议的路由器称为组播路由器。单播与组播的比较如图4.10所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605174501858.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605174501858.png, D:%5cBlog%5clocalImages%5cimage-20220605174501858.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605174501858.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605174501858.png"
        title="image-20220605174501858" /></p>
<h4 id="462ip组播地址">4.6.2IP组播地址</h4>
<p>IP组播使用D类地址格式。D类地址的前四位是1110，因此D类地址范围是224.0.0.0～239.255.255.255。每个D类IP地址标志一个组播组。
组播数据报和一般的数据报的区别是，前者使用D类P地址作为目的地址，并且首部中的协议字段值是2，表明使用IGMP。需要<strong>注意</strong>的是:
1）组播数据报也是“尽最大努力交付”，不提供可靠交付。2）组播地址只能用于目的地址，而不能用于源地址。
3）对组播数据报不产生ICMP差错报文。因此，若在PING命令后面键入组播地址，将永远
不会收到响应。
4）并非所有的D类地址都可作为组播地址。
I组播可以分为两种:一种只在本局域网上进行硬件组播;另一种则在因特网的范围内进行组播。在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员〔见图4.10(b)]。下面讨论这种硬件组播。
IANA拥有的以太网组播地址的范围是从01-00-5E-00-00-00到01-00-5E-7F-FF-FF。不难看出，在每个地址中，只有23位可用作组播。这只能和D类P地址中的23位有一一对应关系。D类I地址可供分配的有28位,可见在这28位中,前5位不能用来构成以太网的硬件地址,如图4.11所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605174530435.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605174530435.png, D:%5cBlog%5clocalImages%5cimage-20220605174530435.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605174530435.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605174530435.png"
        title="image-20220605174530435" />例如，IP组播地址224.128.64.32（即 EO-80-40-20）和另一个P组播地址224.0.64.32（即EO-00-40-20)转换成以太网的硬件组播地址都是01-00-5E-00-40-20。由于组播IP地址与以太网硬件地址的映射关系不是唯一的，因此收到组播数据报的主机，还要在lP层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>
<h4 id="463igmp与组播路由算法">4.6.3IGMP与组播路由算法</h4>
<p>要使路由器知道组播组成员的信息，需要利用因特网组管理协议(Internet Group ManagementProtocol，IGMP)。连接到局域网上的组播路由器还必须和因特网上的其他组播路由器协同工作，以便把组播数据报用最小代价传送给所有组成员，这就需要使用组播路由选择协议。
IGMP并不是在因特网范围内对所有组播组成员进行管理的协议。IGMP不知道IP组播组包含的成员数，也不知道这些成员分布在哪些网络上。IGMP让连接到本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组。
IGMP应视为TCP/IP的一部分，其工作可分为两个阶段。
第一阶段:当某台主机加入新的组播组时，该主机应向组播组的组播地址发送一个IGMP报文，声明自己要成为该组的成员。本地的组播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他组播路由器。
第二阶段:因为组成员关系是动态的，本地组播路由器要周期性地探询本地局域网上的主机,以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，那么组播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一台主机响应时，则不再将该组的成员关系转发给其他的组播路由器。
组播路由选择实际上就是要找出以源主机为根结点的组播转发树，其中每个分组在每条链路上只传送一次（即在组播转发树上的路由器不会收到重复的组播数据报)。不同的多播组对应于不同的多播转发树;同一个多播组，对不同的源点也会有不同的多播转发树。
在许多由路由器互联的支持硬件多点传送的网络上实现因特网组播时，主要有三种路由算法:第一种是基于链路状态的路由选择;第二种是基于距离-向量的路由选择;第三种可以建立在任何路由器协议之上，因此称为协议无关的组播(PIM)。</p>
<h3 id="47移动ip">4.7移动IP</h3>
<h4 id="471概念">4.7.1概念</h4>
<p>支持移动性的因特网体系结构与协议共称为移动IP，它是为了满足移动结点(计算机、服务器、网段等）在移动中保持其连接性而设计的。更确切地说，移动技术是指移动结点以固定的网络P地址实现跨越不同网段的漫游功能，并保证基于网络的网络权限在漫游过程中不发生任何改变。移动I的目标是把分组自动地投递给移动结点。一个移动结点是把其连接点从一个网络或子网改变到另一个网络或子网的主机。使用移动IP，一个移动结点可以在不改变其P地址的情况下改变其驻留位置。
基于IPv4的移动P定义三种功能实体:移动结点、归属代理（也称本地代理）和外埠代理(也称外部代理)。归属代理和外埠代理又统称为移动代理。
1）移动结点。具有永久IP地址的移动结点。
2）本地代理。在一个网络环境中，一个移动结点的永久“居所”被称为归属网络，在归属
网络中代表移动结点执行移动管理功能的实体称为归属代理（本地代理)，它根据移动用户的转交地址，采用隧道技术转交移动结点的数据包。
3）外部代理。在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理。
移动I和移动自组网络并不相同,移动IP技术使漫游的主机可以用多种方式连接到因特网，移动IP的核心网络功能仍然是基于固定互联网中一直使用的各种路由选择协议,移动自组网络是将移动性扩展到无线领域中的自治系统，它具有自己独特的路由选择协议，并且可以不和因特网相联。
移动IP与动态IP是两个完全不同的概念，动态I指的是局域网中的计算机可以通过网络中的DHCP服务器动态地获得一个IP地址，而不需要用户在计算机的网络设置中指定IP地址，动态IP和 DHCP经常会应用在我们的实际工作环境中。</p>
<h4 id="472移动ip通信过程">4.7.2移动IP通信过程</h4>
<p>在移动IP中，每个移动结点都有一个唯一的本地地址，当移动结点移动时，它的本地地址是不变的，在本地网络链路上每个本地结点还必须有一个本地代理来为它维护当前的位置信息，这就需要引入转交地址。当移动结点连接到外地网络链路上时，转交地址就用来标识移动结点现在所处的位置，以便进行路由选择。移动结点的本地地址与当前转交地址的联合称为移动绑定或简称绑定。当移动结点得到一个新的转交地址时，通过绑定向本地代理进行注册，以便让本地代理即时了解移动结点的当前位置。
移动IP技术的基本通信流程如下:
1）移动结点在本地网时，按传统的TCP/IP方式进行通信（在本地网中有固有的地址)。2〉移动结点漫游到一个外地网络时，仍然使用固定的地址进行通信。为了能够收到通信
对端发给它的IP分组，移动结点需要向本地代理注册当前的位置地址，这个位置地址就是转交地址（它可以是外部代理的地址或动态配置的一个地址)。
3）本地代理接收来自转交地址的注册后，会构建一条通向转交地址的隧道，将截获的发给
移动结点的P分组通过隧道送到转交地址处。
4）在转交地址处解除隧道封装，恢复原始的P分组，最后送到移动结点，这样移动结点在
外网就能够收到这些发送给它的I分组。
5）移动结点在外网通过外网的路由器或外部代理向通信对端发送IP数据包。
6）移动结点来到另一个外网时，只需向本地代理更新注册的转交地址，就可继续通信。7）移动结点回到本地网时，移动结点向本地代理注销转交地址，这时移动结点又将使用传
统的TCP/IP方式进行通信。
移动IP为移动主机设置了两个IP地址，即主地址和辅地址（转交地址)。移动主机在本地网时，使用的是主地址。当移动到另一个网络时，需要获得一个临时的辅地址，但此时主地址仍然不变。从外网移回本地网时，辅地址改变或撤销，而主地址仍然保持不变。</p>
<h3 id="48网络层设备">4.8网络层设备</h3>
<h4 id="481路由器的组成和功能">4.8.1路由器的组成和功能</h4>
<p>路由器是一种具有多个输入/输出端口的专用计算机，其任务是连接不同的网络（连接异构网络）并完成路由转发。在多个逻辑网络（即多个广播域）互联时必须使用路由器。
当源主机要向目标主机发送数据报时，路由器先检查源主机与目标主机是否连接在同&ndash;个网络上。如果源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器。如果源主机和目标主机不在同一个网络上，那么路由器按照转发表（路由表）指出的路由将数据报转发给下一个路由器，这称为间接交付。可见，在同-个网络中传递数据无须路由器的参与，而跨网络通信必须通过路由器进行转发。例如，路由器可以连接不同的LAN，连接不同的VLAN，连接不同的WAN，或者把LAN和WAN互联起来。路由器隔离了广播域。
从结构上看，路由器由路由选择和分组转发两部分构成，如图4.12所示。而从模型的角度看，路由器是网络层设备，它实现了网络模型的下三层，即物理层、数据链路层和网络层。
<strong>注意</strong>，如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段（网络)。如果网桥实现了物理层和数据链路层，那么网桥可以互联两个物理层和数据链路层不同的网段;但中继器实现了物理层后，却不能互联两个物理层不同的网段，这是因为中继器不是存储转发设备，它属于直通式设备。
路由选择部分也称控制部分，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和其他相邻路由器交换路由信息而不断更新和维护路由表。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605220620119.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605220620119.png, D:%5cBlog%5clocalImages%5cimage-20220605220620119.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605220620119.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605220620119.png"
        title="image-20220605220620119" />分组转发部分由三部分组成:交换结构、一组输入端口和一组输出端口。输入端口在从物理层接收到的比特流中提取出链路层帧，进而从帧中提取出网络层数据报，输出端口则执行恰好相反的操作。交换结构是路由器的关键部件，它根据转发表对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。有三种常用的交换方法:通过存储器进行交换、通过总线进行交换和通过互联网络进行交换。交换结构本身就是一个网络。
路由器主要完成两个功能:一是分组转发，二是路由计算。前者处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等;后者通过和其他路由器进行基于路由协议的交互，完成路由表的计算。
路由器和网桥的重要区别是:网桥与高层协议无关，而路由器是面向协议的，它依据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等。现今的路由器一般都提供多种协议的支持，包括OSI、TCP/IP、IPX等。</p>
<h4 id="482路由表和路由转发">4.8.2路由表和路由转发</h4>
<p>路由表是根据路由选择算法得出的，主要用途是路由选择。从历年统考真题可以看出，标准的路由表有4个项目:目的网络P地址、子网掩码、下一跳I地址、接口。在如图4.13所示的网络拓扑中，R1的路由表见表4.4，该路由表包含到互联网的默认路由。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605220710597.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605220710597.png, D:%5cBlog%5clocalImages%5cimage-20220605220710597.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605220710597.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605220710597.png"
        title="image-20220605220710597" />转发表是从路由表得出的，其表项和路由表项有直接的对应关系。但转发表的格式和路由表的格式不同，其结构应使查找过程最优化（而路由表则需对网络拓扑变化的计算最优化)。转发表中含有一个分组将要发往的目的地址，以及分组的下一跳（即下一步接收者的目的地址，实际为MAC地址)。为了减少转发表的重复项目，可以使用一个默认路由代替所有具有相同“下一跳”的项目，并将默认路由设置得比其他项目的优先级低，如图4.14所示。路由表总是用软件来实现的;转发表可以用软件来实现，甚至也可以用特殊的硬件来实现。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605220736251.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605220736251.png, D:%5cBlog%5clocalImages%5cimage-20220605220736251.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605220736251.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605220736251.png"
        title="image-20220605220736251" /><strong>注意</strong>转发和路由选择的区别;“转发”是路由器根据转发表把收到的IP数据报从合适的端口转发出去，它仅涉及一个路由器。而“路由选择”则涉及很多路由器，路由表是许多路由器协同工作的结果。这些路由器按照复杂的路由算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由，并由此构造出整个路由表。</p>
<p><strong>注意</strong>，在讨论路由选择的原理时，往往不去区分转发表和路由表的区别，但要<strong>注意</strong>路由表不等于转发表。分组的实际转发是靠直接查找转发表，而不是直接查找路由表。</p>
<h3 id="49本章小结及疑难点">4.9本章小结及疑难点</h3>
<h2 id="第5章传输层">第5章传输层</h2>
<h3 id="51传输层提供的服务">5.1传输层提供的服务</h3>
<h4 id="511传输层的功能">5.1.1传输层的功能</h4>
<p>从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。
传输层位于网络层之上，它为运行在不同主机上的进程之间提供了逻辑通信，而网络层提供主机之间的逻辑通信。显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复),传输层同样能为应用程序提供可靠的服务。
从图5.1可以看出，网络的边缘部分的两台主机使用网络核心部分的功能进行端到端的通信时，只有主机的协议栈才有传输层和应用层，而路由器在转发分组时都只用到下三层的功能（即在通信子网中没有传输层，传输层只存在于通信子网以外的主机中)。
传输层的功能如下:
1)传输层提供应用进程之间的逻辑通信（即端到端的通信)。与网络层的区别是，网络层提
供的是主机之间的逻辑通信。
从网络层来说，通信的双方是两台主机，IP数据报的首部给出了这两台主机的P地址。但“两台主机之间的通信”实际上是两台主机中的应用进程之间的通信，应用进程之间的通信又称端到端的逻辑通信。这里“逻辑通信”的意思是:传输层之间的通信好像是沿水平方向传送数据，但事实上这两个传输层之间并没有一条水平方向的物理连接。</p>
<p>2〉复用和分用。复用是指发送方不同的应用进程都可使用同一个传输层协议传送数据;分
用是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。</p>
<p><strong>注意</strong>:传输层的复用分用功能与网络层的复用分用功能不同。网络层的复用是指发送方不同协议的数据都可以封装成P数据报发送出去,分用是指接收方的网络层在剥去首部后把数据交付给相应的协议。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605221002572.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605221002572.png, D:%5cBlog%5clocalImages%5cimage-20220605221002572.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605221002572.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605221002572.png"
        title="image-20220605221002572" /></p>
<p>3）传输层还要对收到的报文进行差错检测（首部和数据部分)。而网络层只检查IP数据报
的首部，不检验数据部分是否出错。
4）提供两种不同的传输协议，即面向连接的TCP和无连接的UDP。而网络层无法同时实现
两种协议（即在网络层要么只提供面向连接的服务，如虚电路;要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式)。
传输层向高层用户屏蔽了低层网络核心的细节（如网络拓扑、路由协议等)，它使应用进程看见的是好像在两个传输层实体之间有一条端到端的逻辑通信信道，这条逻辑通信信道对上层的表现却因传输层协议不同而有很大的差别。当传输层采用面向连接的TCP时，尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条全双工的可靠信道。但当传输层采用无连接的UDP时，这种逻辑通信信道仍然是一条不可靠信道。</p>
<h4 id="512传输层的寻址与端口">5.1.2传输层的寻址与端口</h4>
<ol>
<li>端口的作用
端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。端口是传输层服务访问点(TSAP)，它在传输层的作用类似于P地址在网络层的作用或MAC地址在数据链路层的作用，只不过P地址和 MAC地址标识的是主机，而端口标识的是主机中的应用进程。
数据链路层的SAP是MAC地址，网络层的SAP是地址，传输层的SAP是端口。在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。</li>
<li>端口号
应用进程通过端口号进行标识，端口号长度为16bit，能够表示65536(21)个不同的端口号。端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。根据端口号范围可将端口分为两类:
1）服务端使用的端口号。这里又分为两类，最重要的一类是熟知端口号，数值为0~1023,
IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。另一类称为登记端口号，数值为1024~49151。它是供没有熟知端口号的应用程序使用的，使用这类端口号必须在IANA登记，以防止重复。
一些常用的熟知端口号如下:<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605221118056.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605221118056.png, D:%5cBlog%5clocalImages%5cimage-20220605221118056.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605221118056.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605221118056.png"
        title="image-20220605221118056" />2）客户端使用的端口号，数值为49152~65535。由于这类端口号仅在客户进程运行时才动
态地选择，因此又称短暂端口号（也称临时端口)。通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程使用。</li>
<li>套接字
在网络中通过IP地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程。在网络中采用发送方和接收方的套接字（Socket）组合来识别端点。所谓套接字，实际上是一个通信端点，即
套接字=(主机IP地址，端口号）
它唯一地标识网络中的一台主机和其上的一个应用（进程)。
在网络通信中，主机A发给主机B的报文段包含目的端口号和源端口号，源端口号是“返回地址”的一部分，即当B需要发回一个报文段给A时,B到A的报文段中的目的端口号便是A到B的报文段中的源端口号(完全的返回地址是A的P地址和源端口号)。</li>
</ol>
<h4 id="513无连接服务与面向连接服务">5.1.3无连接服务与面向连接服务</h4>
<p>面向连接服务就是在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理。通信结束后，应该释放这个连接。
无连接服务是指两个实体之间的通信不需要先建立好连接，需要通信时，直接将信息发送到“网络”中，让该信息的传递在网上尽力而为地往目的地传送。
TCP/IP协议族在层之上使用了两个传输协议:一个是面向连接的传输控制协议（TCP)，采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道;另一个是无连接的用户数据报协议（UDP)，采用UDP时，传输层向上提供的是一条不可靠的逻辑信道。
TCP提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或组播服务。由于TCP提供面向连接的可靠传输服务，因此不可避免地增加了许多开销，如确认、流量控制、计时器及连接管理等。这不仅使协议数据单元的头部增大很多，还要占用许多的处理机资源。因此TCP主要适用于可靠性更重要的场合，如文件传输协议(FTP)超文本传输协议（HTTP)、远程登录（TELNET）等。
UDP是一个无连接的非可靠传输层协议。它在P之上仅提供两个附加服务:多路复用和对数据的错误检查。IP知道怎样把分组投递给一台主机，但不知道怎样把它们投递给主机上的具体应用。UDP在传送数据之前不需要先建立连接，远程主机的传输层收到UDP报文后，不需要给出任何确认。由于UDP比较简单，因此执行速度比较快、实时性好。使用UDP的应用主要包括小文件传送协议(TFTP)、DNS、SNMP和实时传输协议（RTP)。</p>
<h3 id="52-udp协议">5.2 UDP协议</h3>
<h4 id="521udp数据报">5.2.1UDP数据报</h4>
<ol>
<li>
<p>UDP概述
RFC 768定义的UDP只是做了传输协议能够做的最少工作，它仅在P的数据报服务之上增加了两个最基本的服务:复用和分用以及差错检测。如果应用程序开发者选择UDP而非 TCP,那么应用程序几乎直接与P打交道。
为什么应用开发人员宁愿在UDP之上构建应用,也不选择TCP?既然TCP提供可靠的服务，而UDP不提供，那么TCP总是首选吗?答案是否定的，因为有很多应用更适合用UDP，主要是因为UDP具有如下优点:
1)UDP无须建立连接。因此UDP不会引入建立连接的时延。试想如果DNS运行在TCP而
非UDP 上，那么DNS的速度会慢很多。HTTP使用TCP而非 UDP，是因为对于基于文本数据的Web网页来说，可靠性是至关重要的。
2）无连接状态。TCP需要在端系统中维护连接状态。此连接状态包括接收和发送缓存、拥
塞控制参数和序号与确认号的参数。而UDP不维护连接状态，也不跟踪这些参数。因此,某些专用应用服务器使用UDP时，一般都能支持更多的活动客户机。
3）分组首部开销小。TCP有20B的首部开销，而UDP仅有8B的开销。4）应用层能更好地控制要发送的数据和发送时间。UDP没有拥塞控制，因此网络中的拥塞
不会影响主机的发送效率。某些实时应用要求以稳定的速度发送，能容忍一些数据的丢失，但不允许有较大的时延，而 UDP正好满足这些应用的需求。
UDP常用于一次性传输较少数据的网络应用、如 DNS、SNMP等，因为对于这些应用，若采用TCP，则将为连接创建、维护和拆除带来不小的开销。UDP也常用于多媒体应用（如IP电话、实时视频会议、流媒体等)，显然，可靠数据传输对这些应用来说并不是最重要的，但TCP的拥塞控制会导致数据出现较大的延迟，这是它们不可容忍的。
UDP提供尽最大努力的交付，即不保证可靠交付，但这并不意味着应用对数据的要求是不可靠的，因此所有维护传输可靠性的工作需要用户在应用层来完成。应用实体可以根据应用的需求来灵活设计自己的可靠性机制。
UDP是面向报文的。发送方UDP对应用层交下来的报文,在添加首部后就向下交付给P层，既不合并，也不拆分，而是保留这些报文的边界;接收方UDP对P层交上来UDP用户数据报,在去除首部后就原封不动地交付给上层应用进程，一次交付一个完整的报文。因此报文不可分割,是UDP数据报处理的最小单位。</p>
</li>
<li>
<p>UDP的首部格式
UDP数据报包含两部分:UDP首部和用户数据，整个UDP数据报作为IP数据报的数据部分封装在IP数据报中，如图5.2所示。UDP首部有8B，由4个字段组成，每个字段的长度都是2B，如图5.2所示。各字段意义如下:
1）源端口。源端口号。在需要对方回信时选用，不需要时可用全0。2）目的端口。目的端口号。这在终点交付报文时必须使用到。
3）长度。UDP数据报的长度（包括首部和数据)，其最小值是8（仅有首部)。
4）校验和。检测UDP数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机
不想计算校验和时，则直接令该字段为全0。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605221458080.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605221458080.png, D:%5cBlog%5clocalImages%5cimage-20220605221458080.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605221458080.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605221458080.png"
        title="image-20220605221458080" /></p>
<p>当传输层从IP层收到UDP数据报时,就根据首部中的目的端口,把 UDP数据报通过相应的端口上交给应用进程，如图5.3所示。
如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于端口号的应用进程)，那么就丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605221527461.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605221527461.png, D:%5cBlog%5clocalImages%5cimage-20220605221527461.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605221527461.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605221527461.png"
        title="image-20220605221527461" /></p>
</li>
</ol>
<h4 id="522udp校验">5.2.2UDP校验</h4>
<p>在计算校验和时,要在UDP数据报之前增加12B的伪首部,伪首部并不是UDP的真正首部。只是在计算校验和时，临时添加在UDP数据报的前面，得到一个临时的UDP数据报。校验和就是按照这个临时的UDP数据报计算的。伪首部既不向下传送也不向上递交，而仅为了计算校验和。这样的校验和，既检查了UDP数据报，又对P数据报的源IP地址和目的IP地址进行了检验。图5.4给出了UDP 数据报的伪首部各字段的内容。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605221606691.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605221606691.png, D:%5cBlog%5clocalImages%5cimage-20220605221606691.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605221606691.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605221606691.png"
        title="image-20220605221606691" /></p>
<p>UDP校验和的计算方法和P数据报首部校验和的计算方法相似，都使用二进制反码运算求和再取反。但不同的是，P数据报的校验和只检验P数据报的首部，但UDP的校验和则检查首部和数据部分。
发送方首先把全零放入校验和字段并添加伪首部，然后把UDP数据报视为许多16位的字连接起来。若UDP数据报的数据部分不是偶数个字节，则要在数据部分末尾增加一个全零字节(但此字节不发送)。接下来按二进制反码计算出这些16位字的和，并将此和的二进制反码写入校验和字段。接收方把收到的UDP数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节)后，按二进制反码计算出这些16位字的和。当无差错时其结果应全为1，否则表明有差错出现，接收方就应该丢弃这个UDP数据报。
图5.5给出了一个计算UDP校验和的例子。本例中，UDP数据报的长度是15B（不含伪首部)，因此需要添加一个全0字节。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605221651147.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605221651147.png, D:%5cBlog%5clocalImages%5cimage-20220605221651147.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605221651147.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605221651147.png"
        title="image-20220605221651147" /></p>
<p><strong>注意</strong>:
1)校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节，如图5.5
所示。但是此字节和伪首部一样，是不发送的。
2）如果UDP校验和校验出UDP数据报是错误的，那么可以丢弃，也可以交付给上层，但
是需要附上错误报告，即告诉上层这是错误的数据报。
3）通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，还可
以检查IP数据报的源IP地址和目的地址。</p>
<p>这种简单的差错检验方法的检错能力并不强，但它的好处是简单、处理速度快。</p>
<h3 id="53-tcp协议">5.3 TCP协议</h3>
<h4 id="531tcp协议特点">5.3.1TCP协议特点</h4>
<p>TCP是在不可靠的P层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。TCP是TCP/IP体系中非常复杂的一个协议，主要特点如下:
1)TCP是面向连接的传输层协议。
2)每条TCP连接只能有两个端点，每条TCP连接只能是点对点的（一对一)。3）TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序。
4）TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连
接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
发送缓存用来暂时存放以下数据:①发送应用程序传送给发送方TCP准备发送的数据;②TCP已发送但尚未收到确认的数据。接收缓存用来暂时存放以下数据:①按序到达但尚未被接收应用程序读取的数据;②不按序到达的数据。
5)TCP是面向字节流的，虽然应用程序和TCP的交互是一次一个数据块（大小不等)，但
TCP把应用程序交下来的数据仅视为一连串的无结构的字节流。</p>
<h4 id="532tcp报文段">5.3.2TCP报文段</h4>
<p>TCP传送的数据单元称为报文段。一个TCP报文段分为TCP首部和TCP数据两部分，整个TCP报文段作为IP数据报的数据部分封装在P数据报中，如图5.6所示。其首部的前20B是固定的。TCP报文段的首部最短为20B，后面有4N字节是根据需要而增加的选项，通常长度为4B的整数倍。
TCP报文段既可以用来运载数据，又可以用来建立连接、释放连接和应答。</p>
<p>各字段意义如下:
1）源端口和目的端口字段。各占2B。端口是运输层与应用层的服务接口，运输层的复用和
分用功能都要通过端口实现。
2〉序号字段。占4B。TCP是面向字节流的（即TCP传送时是逐个字节传送的)，所以TCP
连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。
例如，一报文段的序号字段值是301，而携带的数据共有100B，表明本报文段的数据的最后一个字节的序号是400，因此下一个报文段的数据序号应从401开始。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605222042823.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605222042823.png, D:%5cBlog%5clocalImages%5cimage-20220605222042823.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605222042823.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605222042823.png"
        title="image-20220605222042823" /></p>
<p>3）确认号字段。占4B，是期望收到对方的下一个报文段的数据的第一个字节的序号。若确认
号为N，则表明到序号N-1为止的所有数据都已正确收到。
例如,B正确收到了A发送过来的-个报文段，其序号字段是501，而数据长度是200B(序号501～700)，这表明B正确收到了A发送的到序号700为止的数据。因此B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701。
4）数据偏移（即首部长度)。占4位，这里不是P数据报分片的那个数据偏移，而是表示
首部长度，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。
“数据偏移”的单位是32位(以4B为计算单位)。因此当此字段的值为15时，达到TCP首部的最大长度60B。
5）保留字段。占6位，保留为今后使用，但目前应置为0，该字段可以忽略不计。
6）紧急位URG。URG= 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，
应尽快传送（相当于高优先级的数据)。但URG需要和紧急指针配套使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。
7）确认位ACK。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。
TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。
8）推送位PSH (Push)。接收TCP收到PSH=1的报文段，就尽快地交付给接收应用进程,
而不再等到整个缓存都填满后再向上交付。
9)复位位RST (Reset)。RST=1时，表明TCP连接中出现严重差错（如主机崩溃或其他原
因)，必须释放连接，然后再重新建立运输连接。
10）同步位SYN。同步SYN=1表示这是一个连接请求或连接接收报文。
当SYN= 1，ACK=0时，表明这是一个连接请求报文，对方若同意建立连接，则在响应报文中使用SYN=1，ACK=1。即SYN=1表示这是一个连接请求或连接接收报文。11)终止位FIN (Finish)。用来释放一个连接。FIN=1表明此报文段的发送方的数据已发送
完毕，并要求释放传输连接。
12）窗口字段。占2B。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限
的，因此用窗口值作为接收方让发送方设置其发送窗口的依据，单位为字节。
例如，假设确认号是701，窗口字段是1000。这表明，从701号算起，发送此报文段的一方还有接收1000B数据（字节序号为701～1700）的接收缓存空间。</p>
<p>13）校验和。占2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和
UDP一样，要在TCP报文段的前面加上12B的伪首部(只需将UDP伪首部的第4个字段，即协议字段的17改成6，其他的和UDP一样)。
14）紧急指针字段。占16位，指出在本报文段中紧急数据共有多少字节（紧急数据放在本
报文段数据的最前面)。
15)选项字段。长度可变。TCP最初只规定了一种选项，即最大报文段长度(Maximum Segment
Size，MSS)。MSS是TCP报文段中的数据字段的最大长度。
16）填充字段。这是为了使整个首部长度是4B的整数倍。</p>
<h4 id="533tcp连接管理">5.3.3TCP连接管理</h4>
<p>TCP是面向连接的协议，因此每个TCP连接都有三个阶段:连接建立、数据传送和连接释放。TCP连接的管理就是使运输连接的建立和释放都能正常进行。
在TCP连接建立的过程中，要解决以下三个问题:
1)要使每一方都能够确知对方的存在。
2）要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项、时间戳选项及服务
质量等)。
3）能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。
TCP把连接作为最基本的抽象，每条TCP连接有两个端点，TCP连接的端点不是主机，不是主机的P地址,不是应用进程,也不是传输层的协议端口。TCP连接的端口称为套接字( socket)或插口。端口拼接到IP地址即构成套接字。
每条TCP连接唯一地被通信两端的两个端点(即两个套接字）确定。
TCP连接的建立采用客户机/服务器方式。主动发起连接建立的应用进程称为客户机(Client),而被动等待连接建立的应用进程称为服务器(Server)。</p>
<ol>
<li>
<p>TCP连接的建立
连接的建立经历以下3个步骤，通常称为三次握手，如图5.7所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605222217226.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605222217226.png, D:%5cBlog%5clocalImages%5cimage-20220605222217226.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605222217226.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605222217226.png"
        title="image-20220605222217226" />第一步:客户机的TCP首先向服务器的TCP发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标志位被置为1。另外，客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗-一个序号)。
第二步:服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。在确认报文段中，SYN和ACK位都被置为1，确认号字段的值为x+1,并且服务器随机产生起始序号 seq=y(确认报文不携带数据,但也要消耗一个序号)。确认报文段同样不包含应用层数据。
第三步:当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量。这个报文段的ACK标志位被置1，序号字段为x+1，确认号字段ack=y+1。该报文段可以携带数据，若不携带数据则不消耗序号。
成功进行以上三步后，就建立了TCP连接，接下来就可以传送应用层数据。TCP提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。
另外，值得<strong>注意</strong>的是，服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到SYN洪泛攻击。</p>
</li>
<li>
<p>TCP连接的释放
天下没有不散的筵席，TCP同样如此。参与TCP连接的两个进程中的任何一个都能终止该连接。TCP连接释放的过程通常称为四次握手，如图5.8所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605222318722.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605222318722.png, D:%5cBlog%5clocalImages%5cimage-20220605222318722.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605222318722.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605222318722.png"
        title="image-20220605222318722" />第一步:客户机打算关闭连接时，向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1，seq= u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗一个序号)。TCP是全双工的，即可以想象为一条TCP 连接上有两条数据通路。发送FIN报文时，发送FIN 的一端不能再发送数据，即关闭了其中一条数据通路，但对方还可以发送数据。
第二步:服务器收到连接释放报文段后即发出确认，确认号是ack = u+l，而这个报文段自己的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1。此时，从客户机到服务器这个方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机仍要接收，即从服务器到客户机这个方向的连接并未关闭。</p>
<p>第三步:若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN=1的连接释放报文段。
第四步:客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack = w +1，序号 seq=u+1。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL后，A才进入连接关闭状态。
对上述TCP连接建立和释放的总结如下:1）连接建立。分为3步:
SYN= 1，seq=X。
SYN= 1，ACK=1，seq= y， ack =x +1。③ACK=1，seq=x+1，ack =y+1。
2）释放连接。分为4步:
①FIN= 1，seq= u。
②ACK=1，seq= v, ack = u+1。
FIN=1，ACK=1，seq = w,ack = u+1。ACK= 1，seq= u+1，ack = w+1。
选择题喜欢考查（关于连接和释放的题目，ACK、SYN、FIN一定等于1)，请牢记。</p>
</li>
</ol>
<h4 id="534tcp可靠传输">5.3.4TCP可靠传输</h4>
<p>TCP的任务是在IP层不可靠的、尽力而为服务的基础上建立一种可靠数据传输服务。TCP提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样。TCP使用了校验、序号、确认和重传等机制来达到这一目的。其中，TCP的校验机制与UDP校验一样，这里不再赘述。</p>
<ol>
<li>
<p>序号
TCP首部的序号字段用来保证数据能有序提交给应用层，TCP把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。
TCP连接传送的数据流中的每个字节都编上一个序号。序号字段的值是指本报文段所发送的数据的第一个字节的序号。如图5.9所示，假设A和B之间建立了一条TCP连接，A的发送缓存区中共有10B，序号从О开始标号，第一个报文包含第0~2个字节，则该TCP报文段的序号是0，第二个报文段的序号是3。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605222535325.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605222535325.png, D:%5cBlog%5clocalImages%5cimage-20220605222535325.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605222535325.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605222535325.png"
        title="image-20220605222535325" /></p>
</li>
<li>
<p>确认
TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。在图5.9中，如果接收方B已收到第一个报文段,此时B希望收到的下一个报文段的数据是从第3个字节开始的，那么B发送给A的报文中的确认号字段应为3。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。
TCP 默认使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节。例如，在图5.8中，接收方B收到了A发送的包含字节0~2及字节6~7的报文段。由于某种原因，B还未收到字节3~5的报文段，此时B仍在等待字节3(和其后面的字节)，因此B到A的下一个报文段将确认号字段置为3。</p>
</li>
<li>
<p>重传
有两种事件会导致TCP对报文段进行重传:超时和冗余ACK。(1）超时
TCP每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。
由于TCP的下层是一个互联网环境，IP数据报所选择的路由变化很大，因而传输层的往返时延的方差也很大。为了计算超时计时器的重传时间，TCP采用一种自适应算法，它记录一个报文段发出的时间，以及收到相应确认的时间，这两个时间之差称为报文段的往返时间(Round-TripTime，RTT)。TCP 保留了RTT的一个加权平均往返时间RTTs，它会随新测量RTT样本值的变化而变化。显然，超时计时器设置的超时重传时间(Retransmission Time-Out，RTO）应略大于RTTs，但也不能大太多，否则当报文段丢失时，TCP不能很快重传，导致数据传输时延大。
(2）冗余ACK（冗余确认)
超时触发重传存在的一个问题是超时周期往往太长。所幸的是，发送方通常可在超时事件发生之前通过<strong>注意</strong>所谓的冗余ACK来较好地检测丢包情况。冗余ACK就是再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认。例如，发送方A发送了序号为1、2、3、4、5的TCP报文段，其中2号报文段在链路中丢失，它无法到达接收方B。因此3、4、5号报文段对于B来说就成了失序报文段。TCP规定每当比期望序号大的失序报文段到达时,就发送一个冗余ACK,指明下一个期待字节的序号[RFC 1122,RFC 2581]。在本例中，3、4、5号报文到达B，但它们不是B所期望收到的下一个报文，于是B就发送3个对1号报文段的冗余ACK，表示自己期望接收2号报文段。TCP 规定当发送方收到对同&ndash;个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。就前面的例子而言,当A收到对于1号报文段的3个冗余ACK时，它可以认为2号报文段已经丢失。这时发送方A可以立即对2号报文执行重传，这种技术通常称为快速重传。当然，冗余ACK还被用在拥塞控制中，这将在后面的内容中讨论。</p>
</li>
</ol>
<h4 id="535tcp流量控制">5.3.5TCP流量控制</h4>
<p>TCP提供流量控制服务来消除发送方使接收方缓存区溢出的可能性，因此可以说流量控制是一个速度匹配服务（匹配发送方的发送速率与接收方的读取速率)。
TCP提供一种基于滑动窗口协议的流量控制机制，滑动窗口的基本原理已在第3章的数据链路层介绍过，这里要介绍的是TCP如何使用窗口机制来实现流量控制。
在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为接收窗口rwnd，即调整TCP报文段首部中的“窗口”字段值，来限制发送方向网络注入报文的速率。同时，发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为拥塞窗口cwnd(后面会讲到)，其大小与网络的带宽和时延密切相关。
例如，在通信中，有效数据只从A发往B，而B仅向A发送确认报文，这时B可以通过设置确认报文段首部的窗口字段来将rwnd通知给A。rwnd即接收方允许连续接收的最大能力，单位是字节。发送方A总是根据最新收到的rwnd值来限制自己发送窗口的大小，从而将未确认的数据量控制在rwnd 大小之内，保证A不会使B的接收缓存溢出。当然，A的发送窗口的实际大小取rwnd和 cwnd中的最小值。
图5.10中的例子说明了如何利用滑动窗口机制进行流量控制。设主机A向主机B发送数据，在连接建立时，B告诉A:“我的接收窗口rwnd = 400(字节)”。
传输层和数据链路层的流量控制的区别是:传输层定义端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制。另外，数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605222709231.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605222709231.png, D:%5cBlog%5clocalImages%5cimage-20220605222709231.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605222709231.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605222709231.png"
        title="image-20220605222709231" /></p>
<h4 id="536tcp拥塞控制">5.3.6TCP拥塞控制</h4>
<p>所谓拥塞控制，是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。出现拥塞时，端点并不了解到拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。
拥塞控制与流量控制的区别:拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。
例如，某个链路的传输速率为10Gb/s，某巨型机向一台PC 以1Gb/s的速率传送文件，显然网络的带宽是足够大的，不存在拥塞问题，但如此高的发送速率将导致PC可能来不及接收，因此必须进行流量控制。但若有100万台PC在此链路上以 1Mb/s 的速率传送文件，则现在的问题就变为网络的负载是否超过了现有网络所能承受的范围。
为了更好地对传输层进行拥塞控制，因特网建议标准定义了以下4种算法:慢开始、拥塞避免、快重传、快恢复。
发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此，TCP协议要求发送方维护以下两个窗口:
1）接收窗口rwnd，接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。
由接收方根据其放在TCP报文的首部的窗口字段通知发送方。
2）拥塞窗口cwnd，发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前
容量。只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数。
发送窗口的上限值应取接收窗口 rwnd和拥塞窗口cwnd中较小的一个，即
<strong>发送窗口的上限值 = min[rwnd, cwnd]</strong></p>
<p><strong>注意</strong>:接收方总有足够大的缓存空间，因而发送窗口大小由网络的拥塞程度决定，也就是说，可以将发送窗口等同为拥塞窗口。
接收窗口的大小可根据TCP报文首部的窗口字段通知发送方，而发送方如何维护拥塞窗口呢?这就是下面讲解的慢开始和拥塞避免算法。</p>
<ol>
<li>慢开始和拥塞避免(1）慢开始算法
在TCP刚刚连接好并开始发送TCP报文段时，先令拥塞窗口cwnd = 1，即一个最大报文段长度MSS。每收到一个对新报文段的确认后，将cwnd加 1，即增大一个MSS。用这样的方法逐步增大发送方的拥塞窗口cwnd，可使分组注入网络的速率更加合理。
例如，A向B发送数据，发送时A的拥塞窗口为2，那么A一次可以发送两个TCP报文段，经过一个RTT后（也称一个传输轮次)，A收到B对刚才两个报文的确认，于是把拥塞窗口调整为4，下一次发送时就可一次发送4个报文段。
使用慢开始算法后，每经过一个传输轮次（即往返时延RTT)，拥塞窗口 cwnd就会加倍，即cwnd 的大小指数式增长。这样,慢开始一直把拥塞窗口cwnd增大到一个规定的慢开始门限ssthresh(阈值)，然后改用拥塞避免算法。
(2）拥塞避免算法
拥塞避免算法的做法如下:发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍，使cwnd按线性规律缓慢增长(即加法增大)，而当出现一次超时(网络拥塞)时，令慢开始门限ssthresh 等于当前cwnd的一半（即乘法减小)。
根据cwnd 的大小执行不同的算法，可归纳如下:
·当cwnd &lt; ssthresh 时，使用慢开始算法。
当cwnd &gt; ssthresh时，停止使用慢开始算法而改用拥塞避免算法。
·当cwnd = ssthresh 时，既可使用慢开始算法，又可使用拥塞避免算法（通常做法)。(3）网络拥塞的处理
网络出现拥塞时，无论是在慢开始阶段还是在拥塞避免阶段，只要发送方检测到超时事件的发生（未按时收到确认，重传计时器超时)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半(但不能小于2)。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的是迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完。
拥塞避免并不能完全能避免拥塞。利用以上措施要完全避免网络拥塞是不可能的。拥塞避免是指在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。
慢开始和拥塞避免算法的实现过程如图5.11所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605222910062.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605222910062.png, D:%5cBlog%5clocalImages%5cimage-20220605222910062.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605222910062.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605222910062.png"
        title="image-20220605222910062" />初始时，拥塞窗口置为1，即cwnd= 1，慢开始门限置为16，即 ssthresh = 16。慢开始阶段，cwnd的初值为1，以后发送方每收到一个确认ACK，cwnd值加1，也即经过每个传输轮次(RTT)，cwnd呈指数规律增长。
拥塞窗口cwnd增长到慢开始门限ssthresh时(即当cwnd= 16时),就改用拥塞避免算法，cwnd按线性规律加性增长。
假定cwnd =24时网络发生拥塞，更新ssthresh的值为12(即变为超时时cwnd 值24的一半)，cwnd重置1，并执行慢开始算法，cwnd= 12时，改为拥塞避免算法。
<strong>注意</strong>在慢开始（指数级增长)阶段，若2cwnd &gt; ssthresh，则下一个RTT的cwnd等于ssthresh，而不等于2cwnd，即 cwnd不能跃过ssthresh值。如图5.11所示，在第16个轮次时cwnd=8、ssthresh= 12,在第17个轮次时cwnd = 12，而不等于16。
在慢开始和拥塞避免算法中使用了“乘法减小”和“加法增大”方法。“乘法减小”是指不论是在慢开始阶段还是在拥塞避免阶段，只要出现一次超时（即很可能出现了网络拥塞)，就把慢开始门限值ssthresh设置为当前拥塞窗口值的一半。网络频繁出现拥塞时，ssthresh值就下降得很快，以大大减少注入网络的分组数。而“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个RTT)，就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</li>
<li>快重传和快恢复
快重传和快恢复算法是对慢开始和拥塞避免算法的改进。(1）快重传
在上一节介绍的TCP可靠传输机制中，快重传技术使用了冗余ACK来检测丢包的发生。同样，冗余ACK也用于网络拥塞的检测（丢了包当然意味着网络可能出现了拥塞)。快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。
当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。
(2）快恢复
快恢复算法的原理如下:发送端收到连续三个冗余ACK(即重复确认〉时，执行“乘法减小”算法，把慢开始门限 ssthresh设置为出现拥塞时发送方cwnd的一半。与慢开始（慢开始算法将拥塞窗口cwnd 设置为1)的不同之处是，它把 cwnd 的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。
由于跳过了cwnd 从1起始的慢开始过程,所以被称为快恢复。快恢复算法的实现过程如图5.12所示，作为对比，虚线为慢开始的处理过程。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605223130629.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605223130629.png, D:%5cBlog%5clocalImages%5cimage-20220605223130629.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605223130629.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605223130629.png"
        title="image-20220605223130629" />在流量控制中，发送方发送数据的量由接收方决定，而在拥塞控制中，则由发送方自己通过检测网络状况来决定。实际上，慢开始、拥塞避免、快重传和快恢复几种算法应是同时应用在拥塞控制机制之中的，当发送方检测到超时的时候，就采用慢开始和拥塞避免，当发送方接收到冗余ACK时，就采用快重传和快恢复。
在本节的最后，再次提醒读者;发送方发送窗口的实际大小由流量控制和拥塞控制共同决定。因此，当题目中同时出现接收端窗口（rwnd）和拥塞窗口(cwnd)时，发送方实际的发送窗口大小是由rwnd 和 cwnd 中较小的那一个确定的。</li>
</ol>
<h3 id="54本章小结及疑难点">5.4本章小结及疑难点</h3>
<h2 id="第6章应用层">第6章应用层</h2>
<h3 id="61网络应用模型">6.1网络应用模型</h3>
<h4 id="611cs模型">6.1.1CS模型</h4>
<p>在客户/服务器(Client/Server，C/S）模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求。其工作流程如下:
1)）服务器处于接收请求的状态。
2）客户机发出服务请求，并等待接收结果。
3）服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。
客户程序必须知道服务器程序的地址，客户机上一般不需要特殊的硬件和复杂的操作系统。而服务器上运行的软件则是专门用来提供某种服务的程序，可同时处理多个远程或本地客户的要求。系统启动后即自动调用并一直不断地运行着，被动地等待并接收来自各地客户的请求。因此,服务器程序不需要知道客户程序的地址。
客户/服务器模型最主要的特征是:客户是服务请求方，服务器是服务提供方。如Web应用程序，其中总是打开的Web服务器服务于运行在客户机上的浏览器的请求。当Web服务器接收到来自客户机对某对象的请求时，它向该客户机发送所请求的对象以做出响应。常见的使用客户/服务器模型的应用包括 Web、文件传输协议(FTP)、远程登录和电子邮件等。
客户/服务器模型的主要特点还有:</p>
<p>1）网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的
目的，使它们不能随意存储/删除数据，或进行其他受限的网络活动。整个网络的管理工作由少数服务器担当，因此网络的管理非常集中和方便。
2）客户机相互之间不直接通信。例如，在 Web应用中两个浏览器并不直接通信。3）可扩展性不佳。受服务器硬件和网络带宽的限制，服务器支持的客户机数有限。</p>
<h4 id="612p2p模型">6.1.2P2P模型</h4>
<p>不难看出，在CIS模型中（见图6.1)，服务器性能的好坏决定了整个系统的性能，当大量用户请求服务时，服务器就必然成为系统的瓶颈。P2P模型（见图6.2）的思想是整个网络中的传输内容不再被保存在中心服务器上，每个结点都同时具有下载、上传的功能，其权利和义务都是大体对等的。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605223347290.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605223347290.png, D:%5cBlog%5clocalImages%5cimage-20220605223347290.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605223347290.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605223347290.png"
        title="image-20220605223347290" />在P2P模型中，各计算机没有固定的客户和服务器划分。相反，任意一对计算机——称为对等方(Peer)，直接相互通信。实际上，P2P模型从本质上来看仍然使用客户/服务器方式，每个结点既作为客户访问其他结点的资源,也作为服务器提供资源给其他结点访问。当前比较流行的P2P应用有PPlive、Bittorrent和电驴等。
与C/S模型相比，P2P模型的优点主要体现如下:
1）减轻了服务器的计算压力，消除了对某个服务器的完全依赖，可以将任务分配到各个结
点上，因此大大提高了系统效率和资源利用率（例如，播放流媒体时对服务器的压力过大，而通过P2P模型，可以利用大量的客户机来提供服务)。
2）多个客户机之间可以直接共享文档。
3）可扩展性好，传统服务器有响应和带宽的限制，因此只能接受一定数量的请求。4）网络健壮性强，单个结点的失效不会影响其他部分的结点。
P2P模型也有缺点。在获取服务的同时，还要给其他结点提供服务，因此会占用较多的内存，影响整机速度。例如，经常进行P2P下载还会对硬盘造成较大的损伤。据某互联网调研机构统计，当前P2Р程序已占互联网50%～90%的流量，使网络变得非常拥塞，因此各大ISP(互联网服务提供商，如电信、网通等）通常都对P2P应用持反对态度。</p>
<h3 id="62域名系统dns">6.2域名系统(DNS)</h3>
<h4 id="621层次域名空间">6.2.1层次域名空间</h4>
<p>因特网采用层次树状结构的命名方法。采用这种命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名（Domain Name)。域(Domain〉是名字空间中一个可被管理的划分。域还可以划分为子域，而子域还可以继续划分为子域的子域，这样就形成了顶级域、二级域、三级域等。每个域名都由标号序列组成，而各标号之间用点(“.”)隔开。一个典型的例子如图6.3所示，它是王道论坛用于提供wwW服务的计算机(Web服务器）的域名，它由三个标号组成，其中标号com是顶级域名,标号cskaoyan是二级域名,标号www是三级域名。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605223559020.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605223559020.png, D:%5cBlog%5clocalImages%5cimage-20220605223559020.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605223559020.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605223559020.png"
        title="image-20220605223559020" /></p>
<p>关于域名中的标号有以下几点需要<strong>注意</strong>:1）标号中的英文不区分大小写。
2）标号中除连字符(-)外不能使用其他的标点符号。
3）每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符。4）级别最低的域名写在最左边，级别最高的顶级域名写在最右边。
顶级域名（Top Level Domain，TLD)分为如下三大类:</p>
<p>1）国家顶级域名(nTLD)。国家和某些地区的域名，如“.cn”表示中国，“.us”表示美国，
“.uk”表示英国。
2）通用顶级域名(gTLD)。常见的有“.com”(公司)、“.net”(网络服务机构)、“.org”(非
营利性组织）和“.gov”(国家或政府部门）等。
3）基础结构域名。这种顶级域名只有一个，即 arpa，用于反向域名解析，因此又称反向
域名。
国家顶级域名下注册的二级域名均由该国家自行确定。图6.4展示了域名空间的树状结构。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605223659767.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605223659767.png, D:%5cBlog%5clocalImages%5cimage-20220605223659767.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605223659767.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605223659767.png"
        title="image-20220605223659767" />在域名系统中，每个域分别由不同的组织进行管理。每个组织都可以将它的域再分成一定数目的子域，并将这些子域委托给其他组织去管理。例如，管理CN域的中国将EDU.CN子域授权给中国教育和科研计算机网(CERNET)来管理。</p>
<h4 id="622域名服务器">6.2.2域名服务器</h4>
<p>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户/服务器模型。域名到IP地址的解析是由运行在域名服务器上的程序完成的，一个服务器所负责管辖的(或有权限的)范围称为区（不以“域”为单位)，各单位根据具体情况来划分自己管辖范围的区，但在一个区中的所有结点必须是能够连通的，每个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。每个域名服务器不但能够进行一些域名到P地址的解析，而且还必须具有连向其他域名服务器的信息。当自己不能进行域名到P地址的转换时，能够知道到什么地方去找其他域名服务器。
DNS使用了大量的域名服务器，它们以层次方式组织。没有一台域名服务器具有因特网上所有主机的映射，相反，该映射分布在所有的 DNS 上。采用分布式设计的 DNS，是一个在因特网上实现分布式数据库的精彩范例。主要有4种类型的域名服务器。</p>
<ol>
<li>根域名服务器
根域名服务器是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的P地址。根域名服务器也是最重要的域名服务器，不管是哪个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先要求助于根域名服务器。因特网上有13个根域名服务器，尽管我们将这13个根域名服务器中的每个都视为单个服务器，但每个“服务器”实际上是冗余服务器的集群，以提供安全性和可靠性。需要<strong>注意</strong>的是，根域名服务器用来管辖顶级域（如.com)，通常它并不直接把待查询的域名直接转换成P地址，而是告诉本地域名服务器下一步应当找哪个顶级域名服务器进行查询。</li>
<li>顶级域名服务器
这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。收到DNS查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的P地址)。</li>
<li>授权域名服务器（权限域名服务器）
每台主机都必须在授权域名服务器处登记。为了更加可靠地工作，一台主机最好至少有两个授权域名服务器。实际上，许多域名服务器都同时充当本地域名服务器和授权域名服务器。授权域名服务器总能将其管辖的主机名转换为该主机的IP地址。</li>
<li>本地域名服务器
本地域名服务器对域名系统非常重要。每个因特网服务提供者（ISP)，或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器。当一台主机发出 DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。事实上，我们在Windows系统中配置“本地连接”时，就需要填写DNS地址，这个地址就是本地DNS(域名服务器）的地址。
DNS的层次结构如图6.5所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605223756071.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605223756071.png, D:%5cBlog%5clocalImages%5cimage-20220605223756071.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605223756071.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605223756071.png"
        title="image-20220605223756071" /></li>
</ol>
<h4 id="623域名解析过程">6.2.3域名解析过程</h4>
<p>域名解析是指把域名映射成为ⅣP地址或把Ⅳ地址映射成域名的过程。前者称为正向解析，后者称为反向解析。当客户端需要域名解析时,通过本机的DNS客户端构造一个 DNS请求报文，以UDP 数据报方式发往本地域名服务器。域名解析有两种方式:递归查询和递归与迭代相结合的查询。递归查询的过程如图6.6(a)所示，由于该方法给根域名服务造成的负载过大，所以在实际中几乎不使用。
常用递归与迭代相结合的查询方式如图6.6(b)所示，该方式分为两个部分。</p>
<p>(1）主机向本地域名服务器的查询采用的是递归查询
也就是说，如果本地主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向根域名服务器继续发出查询请求报文（即替该主机继续查询)，而不是让该主机自己进行下一步的查询。在这种情况下，本地域名服务器只需向根域名服务器查询一次，后面的几次查询都是递归地在其他几个域名服务器之间进行的〔见图6.6(a)中的步骤③~⑥]。在步骤⑦中，本地域名服务器从根域名服务器得到了所需的IP地址，最后在步骤⑧中，本地域名服务器把查询结果告诉主机 m.xyz.com。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605223857437.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605223857437.png, D:%5cBlog%5clocalImages%5cimage-20220605223857437.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605223857437.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605223857437.png"
        title="image-20220605223857437" />(2）本地域名服务器向根域名服务器的查询采用迭代查询
当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器:“你下一步应当向哪个顶级域名服务器进行查询”。然后让本地域名服务器向这个顶级域名服务器进行后续的查询，如图6.6(b)所示。同样，顶级域名服务器收到查询报文后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应向哪个权限域名服务器查询。最后，知道所要解析的域名的P地址后，把这个结果返回给发起查询的主机。
下面举例说明域名解析的过程。假定某客户机想获知域名为y.abc.com主机的IP地址，域名解析的过程（共使用8个UDP报文)如下:
客户机向其本地域名服务器发出DNS请求报文。
本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以DNS客户的身份向根
域名服务器发出解析请求。
③根域名服务器收到请求后，判断该域名属于.com域，将对应的顶级域名服务器dns.com
的P地址返回给本地域名服务器。
本地域名服务器向顶级域名服务器dns.com发出解析请求报文。
顶级域名服务器dns.com收到请求后，判断该域名属于abc.com域，因此将对应的授权域
名服务器dns.abc.com的IP地址返回给本地域名服务器。
⑥本地域名服务器向授权域名服务器dns.abc.com发起解析请求报文。
⑦授权域名服务器dns.abc.com收到请求后，将查询结果返回给本地域名服务器。本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。
为了提高DNS的查询效率，并减少因特网上的DNS查询报文数量，在域名服务器中广泛地使用了高速缓存。当一个 DNS 服务器接收到DNS查询结果时，它能将该DNS信息缓存在高速缓存中。这样，当另一个相同的域名查询到达该DNS服务器时，该服务器就能够直接提供所要求的IP地址，而不需要再去向其他DNS服务器询问。因为主机名和P地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息。</p>
<h3 id="63文件传输协议ftp">6.3文件传输协议(FTP)</h3>
<h4 id="631ftp工作原理">6.3.1FTP工作原理</h4>
<p>文件传输协议（File Transfer Protocol，FTP)是因特网上使用得最广泛的文件传输协议。FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件。
FTP提供以下功能:
①提供不同种类主机系统（硬、软件体系等都可以不同)之间的文件传输能力。以用户权限管理的方式提供用户对远程FTP服务器上的文件管理能力。
以匿名FTP的方式提供公用文件共享的能力。
FTP采用客户/服务器的工作方式，它使用TCP可靠的传输服务。一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由两大部分组成:一个主进程，负责接收新的请求;另外有若干从属进程，负责处理单个请求。其工作步骤如下:
①打开熟知端口21(控制端口)，使客户进程能够连接上。等待客户进程发连接请求。
启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客
户进程的请求处理完毕后即终止。
④回到等待状态，继续接收其他客户进程的请求。
FTP服务器必须在整个会话期间保留用户的状态信息。特别是服务器必须把指定的用户账户与控制连接联系起来，服务器必须追踪用户在远程目录树上的当前位置。</p>
<h4 id="632控制连接和数据连接">6.3.2控制连接和数据连接</h4>
<p>FTP在工作时使用两个并行的TCP连接（见图6.7):一个是控制连接（端口号21)，一个是数据连接（端口号20)。使用两个不同的端口号可使协议更加简单和更容易实现。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605224107441.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605224107441.png, D:%5cBlog%5clocalImages%5cimage-20220605224107441.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605224107441.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605224107441.png"
        title="image-20220605224107441" /></p>
<ol>
<li>控制连接
服务器监听21号端口，等待客户连接，建立在这个端口上的连接称为控制连接，控制连接用来传输控制信息（如连接请求、传送请求等)，并且控制信息都以┐位ASCII格式传送。FTP客户发出的传送请求，通过控制连接发送给服务器端的控制进程，但控制连接并不用来传送文件。在传输文件时还可以使用控制连接（如客户在传输中途发一个中止传输的命令)，因此控制连接在整个会话期间一直保持打开状态。</li>
<li>数据连接
服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建“数据传送进程”和“数据连接”。数据连接用来连接客户端和服务器端的数据传送进程，数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。
因为FTP使用了一个分离的控制连接，所以也称FTP的控制信息是带外（Out-of-band）传送的。使用FTP时，若要修改服务器上的文件，则需要先将此文件传送到本地主机，然后再将修改后的文件副本传送到原服务器。网络文件系统(NFS）允许进程打开一个远程文件，并在该文件的某个特定位置开始读写数据。这样，NFS可使用户复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</li>
</ol>
<h3 id="64电子邮件">6.4电子邮件</h3>
<h4 id="641电子邮件系统的组成结构">6.4.1电子邮件系统的组成结构</h4>
<p>自从有了因特网，电子邮件就在因特网上流行起来。电子邮件是一种异步通信方式，通信时不需要双方同时在场。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取。
一个电子邮件系统应具有图6.8所示的三个最主要的组成构件，即用户代理(User Agent)、邮件服务器和电子邮件使用的协议，如SMTP、POP3（或IMAP)等。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605224333730.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605224333730.png, D:%5cBlog%5clocalImages%5cimage-20220605224333730.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605224333730.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605224333730.png"
        title="image-20220605224333730" />用户代理(UA):用户与电子邮件系统的接口。用户代理使用户能够通过一个很友好的接口发送和接收邮件，用户代理至少应当具有撰写、显示和邮件处理的功能。通常情况下，用户代理就是一个运行在PC上的程序，常见的有Outlook、Foxmail和Thunderbird等。
邮件服务器:组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等)。邮件服务器采用客户/服务器方式工作，但它能够同时充当客户和服务器。例如，当邮件服务器A向邮件服务器B发送邮件时，A就作为SMTP客户，而B是SMTP服务器;反之，当B向A发送邮件时，B就是SMTP客户，而A就是SMTP服务器。
邮件发送协议和读取协议:邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用的是SMTP;邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3。<strong>注意</strong>，SMTP采用的是“推”(Push)的通信方式，即在用户代理向邮件服务器发送邮件及在邮件服务器之间发送邮件时，SMTP客户端主动将邮件“推”送到SMTP服务器端。而POP3采用的是“拉”(Pull)的通信方式，即用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。
电子邮件的发送、接收过程可简化为如图6.9所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605224415074.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605224415074.png, D:%5cBlog%5clocalImages%5cimage-20220605224415074.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605224415074.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605224415074.png"
        title="image-20220605224415074" />下面简单介绍电子邮件的收发过程。</p>
<ol>
<li>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送
方邮件服务器。</li>
<li>发送方邮件服务器将邮件放入邮件缓存队列中，等待发送。</li>
<li>运行在发送方邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运
行在接收方邮件服务器的SMTP服务器进程发起建立TCP连接。</li>
<li>TCP连接建立后，SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送
邮件发完后，SMTP就关闭所建立的TCP连接。</li>
<li>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户
邮箱，等待收信人在方便时进行读取。</li>
<li>收信人打算收信时，调用用户代理，使用POP3(或IMAP）协议将自己的邮件从接收方
邮件服务器的用户邮箱中取回(如果邮箱中有来信的话)。</li>
</ol>
<h4 id="642电子邮件格式与mime">6.4.2电子邮件格式与MIME</h4>
<ol>
<li>
<p>电子邮件格式
一个电子邮件分为信封和内容两大部分，邮件内容又分为首部和主体两部分。RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。
邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。最重要的关键字是To:和 Subject:。
To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名，如 <a href="mailto:abc@cskaoyan.com" rel="">abc@cskaoyan.com</a>，其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的。这也就保证了abc@cskaoyan.com这个邮件地址在整个因特网上是唯一的。
Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。
当然，还有一个必填的关键字是 From，但它通常由邮件系统自动填入。首部与主体之间用一个空行进行分割。典型的邮件内容如下:<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605224549034.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605224549034.png, D:%5cBlog%5clocalImages%5cimage-20220605224549034.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605224549034.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605224549034.png"
        title="image-20220605224549034" /></p>
</li>
<li>
<p>多用途网际邮件扩充(MIME)
由于SMTP只能传送一定长度的ASCII码，许多其他非英语国家的文字(如中文、俄文，甚至带重音符号的法文或德文）就无法传送，且无法传送可执行文件及其他二进制对象，因此提出了多用途网络邮件扩充(Multipurpose Internet MailExtensions，MIME)。
MIME并未改动SMTP或取代它。MIME的意图是继续使用目前的格式，但增加了邮件主体的结构，并定义了传送非ASCII码的编码规则。也就是说，MIME邮件可在现有的电子邮件程序和协议下传送。MIME与 SMTP的关系如图6.10所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605224754207.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605224754207.png, D:%5cBlog%5clocalImages%5cimage-20220605224754207.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605224754207.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605224754207.png"
        title="image-20220605224754207" />
MIME主要包括以下三部分内容:</p>
</li>
<li>
<p>5个新的邮件首部字段，包括MIME版本、内容描述、内容标识、内容传送编码和内容
类型。</p>
</li>
<li>
<p>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</p>
</li>
<li>
<p>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</p>
</li>
</ol>
<h4 id="643smtp和pop3">6.4.3SMTP和POP3</h4>
<ol>
<li>SMTP
简单邮件传输协议(Simple Mail Transfer Protocol，SMTP）是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的SMTP进程交换信息。由于SMTP使用客户/服务器方式,因此负责发送邮件的SMTP进程就是SMTP客户,而负责接收邮件的SMTP进程就是SMTP服务器。SMTP用的是TCP连接，端口号为25。SMTP通信有以下三个阶段。
(1）连接建立
发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定时间对邮件缓存扫描一次。如发现有邮件，就使用SMTP的熟知端口号(25）与接收方邮件服务器的SMTP服务器建立TCP连接。连接建立后，接收方SMTP服务器发出220 Service ready(服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。
SMTP不使用中间邮件服务器。TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远。接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。                                                       (2）邮件传送
连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL命令后面有发件人的地址。如 MAIL FROM:<a href="mailto:hoopdog@hust.edu.cn" rel="">hoopdog@hust.edu.cn</a>。若SMTP服务器已准备好接收邮件，则回答250 OK。接着SMTP客户端发送一个或多个RCPT(收件人recipient 的缩写)命令，格式为RCPTTO:&lt;收件人地址&gt;。每发送一个RCPT命令，都应有相应的信息从SMTP服务器返回，如250 OK.或550 No such user here（无此用户)。
RCPT命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。
获得OK的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。正常情况下，SMTP服务器回复信息是354 Start mail input; end with <CRLF>,<CRLF>。<CRLF>表示回车换行。此时SMTP客户端就可开始传送邮件内容，并用<CRLF>.<CRLF>(两个回车，中间一个点）表示邮件内容的结束。
(3）连接释放
邮件发送完毕后，SMTP客户应发送QUIT命令。SMTP服务器返回的信息是221(服务关闭)，表示SMTP同意释放TCP连接。邮件传送的全部过程就此结束。</li>
<li>POP3
邮局协议（Post Office Protocol，POP）是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3。POP3采用的是“拉”(Pull)的通信方式，当用户读取邮件时，用户代理向邮件服务器发出请求，“拉”取用户邮箱中的邮件。
POP也使用客户/服务器的工作方式，在传输层使用TCP，端口号为110。接收方的用户代理上必须运行POP客户程序，而接收方的邮件服务器上则运行POP服务器程序。POP有两种工作方式:“下载并保留”和“下载并删除”。在“下载并保留”方式下，用户从邮件服务器上读取邮件后，邮件依然会保存在邮件服务器上，用户可再次从服务器上读取该邮件;而使用“下载并删除”方式时，邮件一旦被读取，就被从邮件服务器上删除，用户不能再次从服务器上读取。
另一个邮件接收协议是因特网报文存取协议（IMAP)，它比POP复杂得多，IMAP为用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此IMAP服务器维护了会话用户的状态信息。IMAP 的另一特性是允许用户代理只获取报文的某些部分，例如可以只读取一个报文的首部,或一个多部分MIME报文的一部分。这非常适用于低带宽的情况，用户可能并不想取回邮箱中的所有邮件，尤其是包含很多音频或视频的大邮件。此外，随着万维网的流行，目前出现了很多基于万维网的电子邮件，如Hotmail、Gmail等。这种电子邮件的特点是，用户浏览器与Hotmail或Gmail 的邮件服务器之间的邮件发送或接收使用的是HTTP，而仅在不同邮件服务器之间传送邮件时才使用SMTP。</li>
</ol>
<h3 id="65万维网www">6.5万维网(WWW)</h3>
<h4 id="651www的概念与组成结构">6.5.1WWW的概念与组成结构</h4>
<p>万维网(World Wide Web，wWW）是一个资料空间，在这个空间中:一样有用的事物称为一样“资源”,并由一个全域“统一资源定位符”(URL)标识。这些资源通过超文本传输协议(HTTP)传送给使用者，而后者通过单击链接来获取资源。
万维网使用链接的方法能让用户非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。超文本标记语言（HyperText Markup Language，HTML)使得万维网页面的设计者可以很方便地用一个超链接从本页面的某处链接到因特网上的任何一个万维网页面，并能够在自己的计算机屏幕上显示这些页面。
万维网的内核部分是由三个标准构成的:
1)统一资源定位符（URL)。负责标识万维网上的各种文档，并使每个文档在整个万维网的
范围内具有唯一的标识符URL。
2)超文本传输协议（HTTP)。一个应用层协议，它使用TCP连接进行可靠的传输，HTTP
是万维网客户程序和服务器程序之间交互所必须严格遵守的协议。
3）超文本标记语言(HTML)。一种文档结构的标记语言，它使用一些约定的标记对页面上
的各种信息（包括文字、声音、图像、视频等)、格式进行描述。</p>
<p>URL是对可以从因特网上得到的资源的位置和访问方法的一种简洁表示。URL相当于一个文件名在网络范围的扩展。
URL的一般形式是:&lt;协议&gt;:!//&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;。
常见的&lt;协议&gt;有 http、ftp等;&lt;主机&gt;是存放资源的主机在因特网中的域名，也可以是P地址;&lt;端口&gt;和&lt;路径&gt;有时可以省略。在URL中不区分大小写。
万维网以客户/服务器方式工作。浏览器是在用户计算机上的万维网客户程序，而万维网文档所驻留的计算机则运行服务器程序，这台计算机称万维网服务器。客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的文档。工作流程如下:</p>
<ol>
<li>Web 用户使用浏览器（指定URL)与Web服务器建立连接，并发送浏览请求。</li>
<li>Web 服务器把URL转换为文件路径，并返回信息给Web浏览器。</li>
<li>通信完成，关闭连接。
万维网是无数个网络站点和网页的集合，它们在一起构成了因特网最主要的部分(因特网也包括电子邮件、Usenet 和新闻组)。</li>
</ol>
<h4 id="652http">6.5.2HTTP</h4>
<p>HTTP定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。从层次的角度看，HTTP是面向事务的(Transaction-oriented）应用层协议，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</p>
<ol>
<li>HTTP的操作过程
从协议执行过程来说，浏览器要访问wwW服务器时，首先要完成对wwW服务器的域名解析。一旦获得了服务器的地址，浏览器就通过TCP向服务器发送连接建立请求。万维网的大致工作过程如图6.11所示。每个万维网站点都有一个服务器进程，它不断地监听TCP的端口80（默认)，当监听到连接请求后便与浏览器建立连接。TCP连接建立后，浏览器就向服务器发送请求获取某个Web页面的HTTP请求。服务器收到HTTP请求后，将构建所请求 Web 页的必需信息，并通过HTTP响应返回给浏览器。浏览器再将信息进行解释，然后将Web页显示给用户。最后，TCP连接释放。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605225257685.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605225257685.png, D:%5cBlog%5clocalImages%5cimage-20220605225257685.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605225257685.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605225257685.png"
        title="image-20220605225257685" />
在浏览器和服务器之间的请求与响应的交互，必须遵循规定的格式和规则，这些格式和规则就是HTTP。因此HTTP有两类报文:                                                                                请求报文(从 Web客户端向Web服务器发送服务请求〉和响应报文（从Web服务器对Web客户端请求的回答)。
用户单击鼠标后所发生的事件按顺序如下〔以访问清华大学的网站为例):
1）浏览器分析链接指向页面的URL (<a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener noreffer">http://www.tsinghua.edu.cn</a> /chn/index.htm)。      2）浏览器向DNS请求解析www.tsinghua.edu.cn的IP地址。
3）域名系统DNS解析出清华大学服务器的P地址。                                                                 4）浏览器与该服务器建立TCP连接（默认端口号为80)。5）浏览器发出HTTP请求:GET /chn/index.htm。
6）服务器通过HTTP响应把文件 index.htm发送给浏览器。7)TCP连接释放。
8）浏览器解释文件index.htm，并将Web页显示给用户。</li>
<li>HTTP的特点
HTTP是无状态的。也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。因为服务器并不记得曾经访问过的这个客户，也不记得为该客户曾经服务过多少次。
HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求。在实际应用中，通常使用Cookie 加数据库的方式来跟踪用户的活动（如记录用户最近浏览的商品等)。Cookie是一个存储在用户主机中的文本文件，里面含有一串“识别码”，如“123456”，用于Web服务识别用户。Web服务器根据Cookie就能从数据库中查询到该用户的活动记录，进而执行一些个性化的工作，如根据用户之前浏览过的商品向其推荐新产品等。
HTTP 采用TCP作为运输层协议，保证了数据的可靠传输。HTTP不必考虑数据在传输过程中被丢弃后又怎样被重传。但是，HTTP本身是无连接的（请读者务必<strong>注意</strong>)。也就是说，虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文之前不需要先建立HTTP连接。
HTTP既可以使用非持久连接，也可以使用持久连接(HTTP/1.1支持)。
对于非持久连接，每个网页元素对象（如JPEG图形、Flash等）的传输都需要单独建立一个TCP连接，如图6.12所示(第三次握手的报文段中捎带了客户对万维网文档的请求)。也就是说，请求一个万维网文档所需的时间是该文档的传输时间(与文档大小成正比)加上两倍往返时间RTT(一个RTT用于TCP连接，另一个RTT用于请求和接收文档)。
所谓持久连接，是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文，如图6.13所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605225433931.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605225433931.png, D:%5cBlog%5clocalImages%5cimage-20220605225433931.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605225433931.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605225433931.png"
        title="image-20220605225433931" />持久连接又分为非流水线和流水线两种方式。对于非流水线方式，客户在收到前一个响应后才能发出下一个请求。HTTP/1.1的默认方式是使用流水线的持久连接。这种情况下，客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历1个RTT延迟，而不是像非流水线方式那样，每个引用都必须有1个RTT延迟。</li>
<li>HTTP的报文结构
HTTP是面向文本的(Text-Oriented)，因此报文中的每个字段都是一些ASCII码串，并且每个字段的长度都是不确定的。有两类HTTP报文:
请求报文:从客户向服务器发送的请求报文，如图6.14(a)所示。响应报文:从服务器到客户的回答，如图6.14(b)所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605225513742.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605225513742.png, D:%5cBlog%5clocalImages%5cimage-20220605225513742.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605225513742.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605225513742.png"
        title="image-20220605225513742" />HTTP请求报文和响应报文都由三个部分组成。从图6.14可以看出，这两种报文格式的区别是开始行不同。
开始行:用于区分是请求报文还是响应报文。在请求报文中的开始行称为请求行，而在响应报文中的开始行称为状态行。开始行的三个字段之间都以空格分隔，最后的“CR”和“LF”分别代表“回车”和“换行”。请求报文的“请求行”有三个内容:方法、请求资源的URL及HTTP的版本。其中，“方法”是对所请求对象进行的操作，这些方法实际上也就是一些命令。表6.1 给出了HTTP请求报文中常用的几个方法。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605225558257.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605225558257.png, D:%5cBlog%5clocalImages%5cimage-20220605225558257.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605225558257.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605225558257.png"
        title="image-20220605225558257" />                                               首部行:用来说明浏览器、服务器或报文主体的一些信息。首部可有几行，但可不使用。在每个首部行都有首部字段名和它的值，每行在结束的地方都要有“回车”和“换行”。整个首部结束时，还有一空行将首部行和后面的实体主体分开。
实体主体:在请求报文中一般不用这个字段，而在响应报文中也可能没有这个字段。
图6.15所示为使用Wireshark捕获的HTTP请求报文的示例，下面将结合前面几章的内容对请求报文（图中下部分）进行分析。
根据帧（见3.1.1节）)的结构定义，在图6.15所示的以太网数据帧中，第1~6个字节为目的MAC地址（默认网关地址)，即00-Of-e2-3f-27-3f;第7～12个字节为本机 MAC 地址，即00-27-13-67-73-8d;第13~14个字节08～00为类型字段，表示上层使用的是P数据报协议。第15~34个字节(共20B)为P数据报的首部，其中第27~30个字节为源P地址，即 db-df-d2-70,转换成十进制为219.223.210.112;第31~34个字节为目的P地址，即71-69-4e-0a，转换成十进制为113.105.78.10。第35～54个字节(共20B）为TCP报文段的首部。
从第55个字节开始才是TCP数据部分(阴影部分)，即从应用层传递下来的数据（本例中即请求报文)，GET对应请求行的方法，lface/20.gif对应请求行的URL，HTTP/1.1对应请求行的版本，左边数字是对应字符的ASCII码，如&rsquo;G&rsquo;=0x47、E'=0x45、&ldquo;T'=Ox54等。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605225804277.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605225804277.png, D:%5cBlog%5clocalImages%5cimage-20220605225804277.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605225804277.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605225804277.png"
        title="image-20220605225804277" /> 右下角开始的“…?&rdquo;?.’ .gs…E..%..@.@..0…pgi”等是上面介绍过的第1~54个字节中对应的ASCH码字符，而这些字符本身不代表任何意义。
常见应用层协议小结如表6.2所示。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="D:%5cBlog%5clocalImages%5cimage-20220605225833999.png"
        data-srcset="D:%5cBlog%5clocalImages%5cimage-20220605225833999.png, D:%5cBlog%5clocalImages%5cimage-20220605225833999.png 1.5x, D:%5cBlog%5clocalImages%5cimage-20220605225833999.png 2x"
        data-sizes="auto"
        alt="D:\Blog\localImages\image-20220605225833999.png"
        title="image-20220605225833999" /></li>
</ol>
<h3 id="66本章小结及疑难点">6.6本章小结及疑难点</h3>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-10-08 19:55:40&nbsp;<a class="git-hash" href="https://github.com/dillonzq/LoveIt/commit/08d4d6cf8a78e5a1cb353b041919a9e49a704d6a" target="_blank" title="commit by JF-011101(2838264218@qq.com) 08d4d6cf8a78e5a1cb353b041919a9e49a704d6a: feat">
                                    <i class="fas fa-hashtag fa-fw"></i>08d4d6c</a></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/cn_wangdao/" data-title="CN_wangdao" data-hashtags="computer network"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/cn_wangdao/" data-hashtag="computer network"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/cn_wangdao/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/cn_wangdao/" data-title="CN_wangdao"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/cn_wangdao/" data-title="CN_wangdao"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/cn_wangdao/" data-title="CN_wangdao"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/computer-network/">computer network</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/git/" class="prev" rel="prev" title="Git"><i class="fas fa-angle-left fa-fw"></i>Git</a>
            <a href="/k8s_base/" class="next" rel="next" title="K8s_base">K8s_base<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
