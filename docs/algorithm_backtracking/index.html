<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Algorithm_backTracking - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Algorithm_backTracking" />
<meta property="og:description" content="学习代码随想录笔记 回溯算法 理论基础 也叫回溯搜索算法。 回溯是递归的副产品，只要有递归就会有回溯 回溯的本质是穷举，穷举所有可能，然后选出我们想要" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/algorithm_backtracking/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-06T08:22:27+08:00" />
<meta property="article:modified_time" content="2022-12-04T21:44:37+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Algorithm_backTracking"/>
<meta name="twitter:description" content="学习代码随想录笔记 回溯算法 理论基础 也叫回溯搜索算法。 回溯是递归的副产品，只要有递归就会有回溯 回溯的本质是穷举，穷举所有可能，然后选出我们想要"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/algorithm_backtracking/" /><link rel="prev" href="https://jefofrank.xyz/algorithm_binarytree/" /><link rel="next" href="https://jefofrank.xyz/algorithm_greedy/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Algorithm_backTracking",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/algorithm_backtracking\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "data structure","wordcount":  5592 ,
        "url": "https:\/\/jefofrank.xyz\/algorithm_backtracking\/","datePublished": "2022-01-06T08:22:27+08:00","dateModified": "2022-12-04T21:44:37+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Algorithm_backTracking</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/coding/"><i class="far fa-folder fa-fw"></i>Coding</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-01-06 08:22:27">2022-01-06 08:22:27</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 5592 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#理论基础">理论基础</a></li>
    <li><a href="#组合问题及其优化">*组合问题及其优化</a></li>
    <li><a href="#组合总和iii">组合总和III</a></li>
    <li><a href="#电话号码的字母组合">电话号码的字母组合</a></li>
    <li><a href="#组合总和">组合总和</a></li>
    <li><a href="#组合总和ii">组合总和II</a></li>
    <li><a href="#分割回文串">分割回文串</a></li>
    <li><a href="#复原ip地址">复原IP地址</a></li>
    <li><a href="#子集问题">子集问题</a></li>
    <li><a href="#子集ii">子集II</a></li>
    <li><a href="#递增子序列">递增子序列</a></li>
    <li><a href="#全排列">全排列</a></li>
    <li><a href="#全排列ii">全排列II</a></li>
    <li><a href="#回溯算法去重问题的另一种写法">回溯算法去重问题的另一种写法</a></li>
    <li><a href="#重新安排行程">重新安排行程</a></li>
    <li><a href="#n皇后">N皇后</a></li>
    <li><a href="#解数独">解数独</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p>学习<a href="https://programmercarl.com/" target="_blank" rel="noopener noreffer">代码随想录</a>笔记</p>
</blockquote>
<h1 id="回溯算法">回溯算法</h1>
<h2 id="理论基础">理论基础</h2>
<p>也叫回溯搜索算法。</p>
<p>回溯是递归的副产品，只要有递归就会有回溯</p>
<p>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，并不算高效。加一些剪枝操作或许会高效一点。</p>
<p>一般用来解决除了暴力搜索无可奈何的情况。</p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
<p><strong>回溯法解决的问题都可以抽象为树形结构</strong></p>
<ul>
<li>因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。</li>
</ul>
<p><strong>回溯模板</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
</code></pre></td></tr></table>
</div>
</div><h2 id="组合问题及其优化">*组合问题及其优化</h2>
<p>给定两个整数 n 和 k，返回 1 &hellip; n 中所有可能的 k 个数的组合。</p>
<p><strong>回溯法三部曲</strong>：函数参数、终止条件和单层搜索</p>
<p>剪枝优化：</p>
<ul>
<li>可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。</li>
<li>如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span> 
<span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="nx">res</span><span class="p">=[][]</span><span class="kt">int</span><span class="p">{}</span>
   <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>
    <span class="nf">backtrack</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{})</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backtrack</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">start</span> <span class="kt">int</span><span class="p">,</span><span class="nx">track</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
        <span class="nx">temp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span><span class="nx">track</span><span class="p">)</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">temp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="nx">start</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">k</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">start</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">n</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">track</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">track</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">track</span><span class="p">)</span>
        <span class="nx">track</span><span class="p">=</span><span class="nx">track</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>剪枝：<strong>go语言的剪枝优化会爆内存溢出，不知道是为啥……</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span> 
<span class="kd">func</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="nx">res</span><span class="p">=[][]</span><span class="kt">int</span><span class="p">{}</span>
   <span class="k">if</span> <span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="p">&gt;</span> <span class="nx">n</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">res</span>
	<span class="p">}</span>
    <span class="nf">backtrack</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{})</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backtrack</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">start</span> <span class="kt">int</span><span class="p">,</span><span class="nx">track</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
        <span class="nx">temp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span><span class="nx">track</span><span class="p">)</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">temp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">+</span><span class="nx">n</span><span class="o">-</span><span class="nx">start</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">k</span> <span class="p">{</span>
			<span class="k">return</span>
		<span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">start</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="nx">k</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span> 
        <span class="nx">track</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">track</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">track</span><span class="p">)</span>
        <span class="nx">track</span><span class="p">=</span><span class="nx">track</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">track</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="组合总和iii">组合总和III</h2>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<ul>
<li>所有数字都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p>回溯+减枝</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">combinationSum3</span><span class="p">(</span><span class="nx">k</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">track</span> <span class="p">[]</span><span class="kt">int</span><span class="c1">// 遍历路径
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">int</span><span class="c1">// 存放结果集
</span><span class="c1"></span>    <span class="nf">backTree</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">track</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backTree</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">,</span><span class="nx">track</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">result</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">track</span><span class="p">)</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
        <span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="o">*</span><span class="nx">track</span><span class="p">{</span>
            <span class="nx">sum</span><span class="o">+=</span><span class="nx">v</span>
            <span class="nx">tmp</span><span class="p">[</span><span class="nx">k</span><span class="p">]=</span><span class="nx">v</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">sum</span><span class="o">==</span><span class="nx">n</span><span class="p">{</span>
            <span class="o">*</span><span class="nx">result</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="mi">9</span><span class="o">-</span><span class="p">(</span><span class="nx">k</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">track</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span><span class="c1">//减枝（k-len(*track)表示还剩多少个可填充的元素）
</span><span class="c1"></span>        <span class="o">*</span><span class="nx">track</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">track</span><span class="p">,</span><span class="nx">i</span><span class="p">)</span><span class="c1">//记录路径
</span><span class="c1"></span>        <span class="nf">backTree</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span><span class="nx">k</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">track</span><span class="p">,</span><span class="nx">result</span><span class="p">)</span><span class="c1">//递归
</span><span class="c1"></span>        <span class="o">*</span><span class="nx">track</span><span class="p">=(</span><span class="o">*</span><span class="nx">track</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">track</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="电话号码的字母组合">电话号码的字母组合</h2>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如电话按键。<strong>注意</strong> 1 不对应任何字母。</p>
<p>主要在于递归中传递下一个数字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">letterCombinations</span><span class="p">(</span><span class="nx">digits</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">lenth</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">digits</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">lenth</span><span class="o">==</span><span class="mi">0</span> <span class="o">||</span><span class="nx">lenth</span><span class="p">&gt;</span><span class="mi">4</span><span class="p">{</span>
       <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">digitsMap</span><span class="o">:=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span>
         <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="c1">// 0
</span><span class="c1"></span>        <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="c1">// 1
</span><span class="c1"></span>        <span class="s">&#34;abc&#34;</span><span class="p">,</span> <span class="c1">// 2
</span><span class="c1"></span>        <span class="s">&#34;def&#34;</span><span class="p">,</span> <span class="c1">// 3
</span><span class="c1"></span>        <span class="s">&#34;ghi&#34;</span><span class="p">,</span> <span class="c1">// 4
</span><span class="c1"></span>        <span class="s">&#34;jkl&#34;</span><span class="p">,</span> <span class="c1">// 5
</span><span class="c1"></span>        <span class="s">&#34;mno&#34;</span><span class="p">,</span> <span class="c1">// 6
</span><span class="c1"></span>        <span class="s">&#34;pqrs&#34;</span><span class="p">,</span> <span class="c1">// 7
</span><span class="c1"></span>        <span class="s">&#34;tuv&#34;</span><span class="p">,</span> <span class="c1">// 8
</span><span class="c1"></span>        <span class="s">&#34;wxyz&#34;</span><span class="p">,</span> <span class="c1">// 9
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">res</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="nf">recursion</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">,</span><span class="nx">digits</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">digitsMap</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
     <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">recursion</span><span class="p">(</span><span class="nx">tempString</span> <span class="p">,</span><span class="nx">digits</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">Index</span> <span class="kt">int</span><span class="p">,</span><span class="nx">digitsMap</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">res</span> <span class="o">*</span><span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span><span class="c1">//index表示第几个数字
</span><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tempString</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">digits</span><span class="p">){</span><span class="c1">//终止条件，字符串长度等于digits的长度
</span><span class="c1"></span>        <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">tempString</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">tmpK</span><span class="o">:=</span><span class="nx">digits</span><span class="p">[</span><span class="nx">Index</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span> <span class="c1">// 将index指向的数字转为int（确定下一个数字）
</span><span class="c1"></span>    <span class="nx">letter</span><span class="o">:=</span><span class="nx">digitsMap</span><span class="p">[</span><span class="nx">tmpK</span><span class="p">]</span><span class="c1">// 取数字对应的字符集
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">letter</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">tempString</span><span class="p">=</span><span class="nx">tempString</span><span class="o">+</span><span class="nb">string</span><span class="p">(</span><span class="nx">letter</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="c1">//拼接结果
</span><span class="c1"></span>        <span class="nf">recursion</span><span class="p">(</span><span class="nx">tempString</span><span class="p">,</span><span class="nx">digits</span><span class="p">,</span><span class="nx">Index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">digitsMap</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
        <span class="nx">tempString</span><span class="p">=</span><span class="nx">tempString</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">tempString</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="组合总和">组合总和</h2>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<p>主要在于递归中传递下一个数字</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">combinationSum</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">trcak</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="nf">backtracking</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">target</span> <span class="kt">int</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">){</span>
    <span class="c1">//终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">sum</span><span class="o">==</span><span class="nx">target</span><span class="p">{</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">trcak</span><span class="p">))</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">trcak</span><span class="p">)</span><span class="c1">//拷贝
</span><span class="c1"></span>        <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">sum</span><span class="p">&gt;</span><span class="nx">target</span><span class="p">{</span><span class="k">return</span><span class="p">}</span>
    <span class="c1">//回溯
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="c1">//更新路径集合和sum
</span><span class="c1"></span>        <span class="nx">trcak</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">trcak</span><span class="p">,</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">sum</span><span class="o">+=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="c1">//递归
</span><span class="c1"></span>        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
        <span class="c1">//回溯
</span><span class="c1"></span>        <span class="nx">trcak</span><span class="p">=</span><span class="nx">trcak</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">trcak</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">sum</span><span class="o">-=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="组合总和ii">组合总和II</h2>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>主要在于如何在回溯中去重</p>
<p>使用used数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">combinationSum2</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">trcak</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">history</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span>
    <span class="nx">history</span><span class="p">=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span>
    <span class="nf">backtracking</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">,</span><span class="nx">history</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">target</span> <span class="kt">int</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">,</span><span class="nx">history</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">bool</span><span class="p">){</span>
    <span class="c1">//终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">sum</span><span class="o">==</span><span class="nx">target</span><span class="p">{</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">trcak</span><span class="p">))</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">trcak</span><span class="p">)</span><span class="c1">//拷贝
</span><span class="c1"></span>        <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">sum</span><span class="p">&gt;</span><span class="nx">target</span><span class="p">{</span><span class="k">return</span><span class="p">}</span>
    <span class="c1">//回溯
</span><span class="c1"></span>    <span class="c1">// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
</span><span class="c1"></span>    <span class="c1">// used[i - 1] == false，说明同一树层candidates[i - 1]使用过
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">i</span><span class="p">&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="nx">history</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="kc">false</span><span class="p">{</span>
                <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">//更新路径集合和sum
</span><span class="c1"></span>        <span class="nx">trcak</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">trcak</span><span class="p">,</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">sum</span><span class="o">+=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="nx">history</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="kc">true</span>
        <span class="c1">//递归
</span><span class="c1"></span>        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span><span class="p">,</span><span class="nx">res</span><span class="p">,</span><span class="nx">history</span><span class="p">)</span>
        <span class="c1">//回溯
</span><span class="c1"></span>        <span class="nx">trcak</span><span class="p">=</span><span class="nx">trcak</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">trcak</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">sum</span><span class="o">-=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="nx">history</span><span class="p">[</span><span class="nx">i</span><span class="p">]=</span><span class="kc">false</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>不使用used数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">combinationSum2</span><span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">trcak</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span>
    <span class="nf">backtracking</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backtracking</span><span class="p">(</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">target</span> <span class="kt">int</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">){</span>
    <span class="c1">//终止条件
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">sum</span><span class="o">==</span><span class="nx">target</span><span class="p">{</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">trcak</span><span class="p">))</span>
        <span class="c1">//拷贝
</span><span class="c1"></span>        <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">trcak</span><span class="p">)</span>
        <span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">//回溯
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">sum</span><span class="o">+</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="nx">target</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="c1">// 若当前树层有使用过相同的元素，则跳过
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">i</span><span class="p">&gt;</span><span class="nx">startIndex</span><span class="o">&amp;&amp;</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]{</span>
                <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">//更新路径集合和sum
</span><span class="c1"></span>        <span class="nx">trcak</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">trcak</span><span class="p">,</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nx">sum</span><span class="o">+=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="nf">backtracking</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">target</span><span class="p">,</span><span class="nx">candidates</span><span class="p">,</span><span class="nx">trcak</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
        <span class="c1">//回溯
</span><span class="c1"></span>        <span class="nx">trcak</span><span class="p">=</span><span class="nx">trcak</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">trcak</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">sum</span><span class="o">-=</span><span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="分割回文串">分割回文串</h2>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">示例: 输入: &#34;aab&#34; 输出: [ [&#34;aa&#34;,&#34;b&#34;], [&#34;a&#34;,&#34;a&#34;,&#34;b&#34;] ]
</code></pre></td></tr></table>
</div>
</div><p><strong>注意</strong>切片（go切片是披着值类型外衣的引用类型）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">partition</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">tmpString</span> <span class="p">[]</span><span class="kt">string</span><span class="c1">//切割字符串集合
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">string</span><span class="c1">//结果集合
</span><span class="c1"></span>    <span class="nf">backTracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">tmpString</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backTracking</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">tmpString</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">string</span><span class="p">){</span>
    <span class="k">if</span> <span class="nx">startIndex</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">){</span><span class="c1">//到达字符串末尾了
</span><span class="c1"></span>        <span class="c1">//进行一次切片拷贝，怕之后的操作影响tmpString切片内的值
</span><span class="c1"></span>        <span class="nx">t</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tmpString</span><span class="p">))</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">tmpString</span><span class="p">)</span>
        <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">t</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="c1">//处理（首先通过startIndex和i判断切割的区间，进而判断该区间的字符串是否为回文，若为回文，则加入到tmpString，否则继续后移，找到回文区间）（这里为一层处理）
</span><span class="c1"></span>        <span class="k">if</span> <span class="nf">isPartition</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">i</span><span class="p">){</span>
            <span class="nx">tmpString</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmpString</span><span class="p">,</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c1">//递归
</span><span class="c1"></span>        <span class="nf">backTracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">tmpString</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
        <span class="c1">//回溯
</span><span class="c1"></span>        <span class="nx">tmpString</span><span class="p">=</span><span class="nx">tmpString</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">tmpString</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//判断是否为回文
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isPartition</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">end</span> <span class="kt">int</span><span class="p">)</span><span class="kt">bool</span><span class="p">{</span>
    <span class="nx">left</span><span class="o">:=</span><span class="nx">startIndex</span>
    <span class="nx">right</span><span class="o">:=</span><span class="nx">end</span>
    <span class="k">for</span> <span class="p">;</span><span class="nx">left</span><span class="p">&lt;</span><span class="nx">right</span><span class="p">;{</span>
        <span class="k">if</span> <span class="nx">s</span><span class="p">[</span><span class="nx">left</span><span class="p">]</span><span class="o">!=</span><span class="nx">s</span><span class="p">[</span><span class="nx">right</span><span class="p">]{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="c1">//移动左右指针
</span><span class="c1"></span>        <span class="nx">left</span><span class="o">++</span>
        <span class="nx">right</span><span class="o">--</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="复原ip地址">复原IP地址</h2>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 &lsquo;.&rsquo; 分隔。</p>
<p>例如：&ldquo;0.1.2.201&rdquo; 和 &ldquo;192.168.1.1&rdquo; 是 有效的 IP 地址，但是 &ldquo;0.011.255.245&rdquo;、&ldquo;192.168.1.312&rdquo; 和 &ldquo;<a href="mailto:192.168@1.1" rel="">192.168@1.1</a>&rdquo; 是 无效的 IP 地址。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">示例 1：

输入：s = &#34;25525511135&#34;
输出：[&#34;255.255.11.135&#34;,&#34;255.255.111.35&#34;]
示例 2：

输入：s = &#34;0000&#34;
输出：[&#34;0.0.0.0&#34;]
</code></pre></td></tr></table>
</div>
</div><p>回溯（对于前导 0的IP（特别<strong>注意</strong>s[startIndex]==&lsquo;0&rsquo;的判断，不应该写成s[startIndex]==0，因为s截取出来不是数字））</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">restoreIpAddresses</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">res</span><span class="p">,</span><span class="nx">path</span> <span class="p">[]</span><span class="kt">string</span>
	<span class="nf">backTracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">path</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backTracking</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">path</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[]</span><span class="kt">string</span><span class="p">){</span>
	<span class="c1">//终止条件
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">startIndex</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">==</span><span class="mi">4</span><span class="p">{</span>
		<span class="nx">tmpIpString</span><span class="o">:=</span><span class="nx">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s">&#34;.&#34;</span><span class="o">+</span><span class="nx">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="s">&#34;.&#34;</span><span class="o">+</span><span class="nx">path</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="s">&#34;.&#34;</span><span class="o">+</span><span class="nx">path</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
		<span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmpIpString</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="c1">//处理
</span><span class="c1"></span>		<span class="nx">path</span><span class="o">:=</span><span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">if</span> <span class="nx">i</span><span class="o">-</span><span class="nx">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;=</span><span class="mi">3</span><span class="o">&amp;&amp;</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">4</span><span class="o">&amp;&amp;</span><span class="nf">isNormalIp</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">i</span><span class="p">){</span>
			<span class="c1">//递归
</span><span class="c1"></span>			<span class="nf">backTracking</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span><span class="nx">path</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
		<span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="c1">//如果首尾超过了3个，或路径多余4个，或前导为0，或大于255，直接回退
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>
        <span class="c1">//回溯
</span><span class="c1"></span>		<span class="nx">path</span><span class="p">=</span><span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">isNormalIp</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span><span class="nx">startIndex</span><span class="p">,</span><span class="nx">end</span> <span class="kt">int</span><span class="p">)</span><span class="kt">bool</span><span class="p">{</span>
	<span class="nx">checkInt</span><span class="p">,</span><span class="nx">_</span><span class="o">:=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Atoi</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">:</span><span class="nx">end</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">if</span> <span class="nx">end</span><span class="o">-</span><span class="nx">startIndex</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;</span><span class="mi">1</span><span class="o">&amp;&amp;</span><span class="nx">s</span><span class="p">[</span><span class="nx">startIndex</span><span class="p">]</span><span class="o">==</span><span class="sc">&#39;0&#39;</span><span class="p">{</span><span class="c1">//对于前导 0的IP（特别**注意**s[startIndex]==&#39;0&#39;的判断，不应该写成s[startIndex]==0，因为s截取出来不是数字）
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">checkInt</span><span class="p">&gt;</span><span class="mi">255</span><span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="子集问题">子集问题</h2>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="kd">func</span> <span class="nf">subset</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="nf">Dfs</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span> <span class="nx">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Dfs</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span> <span class="kt">int</span><span class="p">){</span>
	<span class="nx">tmp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">))</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span> <span class="nx">temp</span><span class="p">)</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">tmp</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">start</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="c1">//if i&gt;start&amp;&amp;nums[i]==nums[i-1]{
</span><span class="c1"></span>		<span class="c1">//	continue
</span><span class="c1"></span>		<span class="c1">//}
</span><span class="c1"></span>		<span class="nx">temp</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nf">Dfs</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">nums</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">temp</span> <span class="p">=</span> <span class="nx">temp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="子集ii">子集II</h2>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">res</span><span class="p">[][]</span><span class="kt">int</span>
<span class="kd">func</span> <span class="nf">subsetsWithDup</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span><span class="p">=</span><span class="nb">make</span><span class="p">([][]</span><span class="kt">int</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	 <span class="nx">sort</span><span class="p">.</span><span class="nf">Ints</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
	<span class="nf">dfs</span><span class="p">([]</span><span class="kt">int</span><span class="p">{},</span><span class="nx">nums</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">dfs</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span> <span class="nx">num</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">start</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">))</span>
	<span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">temp</span><span class="p">)</span>

	<span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">start</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">i</span><span class="p">&gt;</span><span class="nx">start</span><span class="o">&amp;&amp;</span><span class="nx">num</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">num</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">temp</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span><span class="nx">num</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
		<span class="nf">dfs</span><span class="p">(</span><span class="nx">temp</span><span class="p">,</span><span class="nx">num</span><span class="p">,</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
		<span class="nx">temp</span><span class="p">=</span><span class="nx">temp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="递增子序列">递增子序列</h2>
<p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findSubsequences</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">subRes</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
    <span class="nf">backTring</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nx">nums</span><span class="p">,</span><span class="nx">subRes</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backTring</span><span class="p">(</span><span class="nx">startIndex</span> <span class="kt">int</span><span class="p">,</span><span class="nx">nums</span><span class="p">,</span><span class="nx">subRes</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)&gt;</span><span class="mi">1</span><span class="p">{</span>
    <span class="nx">tmp</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">))</span>
    <span class="nb">copy</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">subRes</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">history</span><span class="o">:=</span><span class="p">[</span><span class="mi">201</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//记录本层元素使用记录
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startIndex</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="c1">//分两种情况判断：一，当前取的元素小于子集的最后一个元素，则继续寻找下一个适合的元素
</span><span class="c1"></span>        <span class="c1">//                或者二，当前取的元素在本层已经出现过了，所以跳过该元素，继续寻找
</span><span class="c1"></span>        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)&gt;</span><span class="mi">0</span><span class="o">&amp;&amp;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]&lt;</span><span class="nx">subRes</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">||</span><span class="nx">history</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">history</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">100</span><span class="p">]=</span><span class="mi">1</span><span class="c1">//表示本层该元素使用过了
</span><span class="c1"></span>        <span class="nx">subRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">subRes</span><span class="p">,</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="nf">backTring</span><span class="p">(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="nx">nums</span><span class="p">,</span><span class="nx">subRes</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
        <span class="nx">subRes</span><span class="p">=</span><span class="nx">subRes</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">subRes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="全排列">全排列</h2>
<p>给定一个 没有重复 数字的序列，返回其所有可能的全排列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nf">backTrack</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),[]</span><span class="kt">int</span><span class="p">{})</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backTrack</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">numsLen</span> <span class="kt">int</span><span class="p">,</span><span class="nx">path</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span>
		<span class="nx">p</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">))</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="nx">path</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">numsLen</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="nx">cur</span><span class="o">:=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">cur</span><span class="p">)</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="c1">//直接使用切片
</span><span class="c1"></span>		<span class="nf">backTrack</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span><span class="nx">path</span><span class="p">)</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span><span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">cur</span><span class="p">},</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span><span class="c1">//回溯的时候切片也要复原，元素位置不能变
</span><span class="c1"></span>		<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="全排列ii">全排列II</h2>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="nx">res</span> <span class="p">=</span> <span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
	<span class="nf">backTrack</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),[]</span><span class="kt">int</span><span class="p">{})</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">backTrack</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">numsLen</span> <span class="kt">int</span><span class="p">,</span><span class="nx">path</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span>
		<span class="nx">p</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">))</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span><span class="nx">path</span><span class="p">)</span>
		<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">used</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">21</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//跟前一题唯一的区别，同一层不使用重复的数。关于used的思想carl在递增子序列那一题中提到过
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">numsLen</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
		<span class="k">if</span> <span class="nx">used</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="nx">cur</span><span class="o">:=</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">path</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span><span class="nx">cur</span><span class="p">)</span>
		<span class="nx">used</span><span class="p">[</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">+</span><span class="mi">10</span><span class="p">]=</span><span class="mi">1</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span>
		<span class="nf">backTrack</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">),</span><span class="nx">path</span><span class="p">)</span>
		<span class="nx">nums</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">i</span><span class="p">],</span><span class="nb">append</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="nx">cur</span><span class="p">},</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">path</span> <span class="p">=</span> <span class="nx">path</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="回溯算法去重问题的另一种写法">回溯算法去重问题的另一种写法</h2>
<p><a href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.html#_90-%E5%AD%90%E9%9B%86ii" target="_blank" rel="noopener noreffer">https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.html#_90-%E5%AD%90%E9%9B%86ii</a></p>
<p>看c++版的</p>
<h2 id="重新安排行程">重新安排行程</h2>
<p>深搜和回溯也是相辅相成的，都用了递归。</p>
<p>给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。</p>
<p>提示：</p>
<ul>
<li>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [&ldquo;JFK&rdquo;, &ldquo;LGA&rdquo;] 与 [&ldquo;JFK&rdquo;, &ldquo;LGB&rdquo;] 相比就更小，排序更靠前</li>
<li>所有的机场都用三个大写字母表示（机场代码）。</li>
<li>假定所有机票至少存在一种合理的行程。</li>
<li>所有的机票必须都用一次 且 只能用一次。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">示例 1：

输入：[[&#34;MUC&#34;, &#34;LHR&#34;], [&#34;JFK&#34;, &#34;MUC&#34;], [&#34;SFO&#34;, &#34;SJC&#34;], [&#34;LHR&#34;, &#34;SFO&#34;]]
输出：[&#34;JFK&#34;, &#34;MUC&#34;, &#34;LHR&#34;, &#34;SFO&#34;, &#34;SJC&#34;]
示例 2：

输入：[[&#34;JFK&#34;,&#34;SFO&#34;],[&#34;JFK&#34;,&#34;ATL&#34;],[&#34;SFO&#34;,&#34;ATL&#34;],[&#34;ATL&#34;,&#34;JFK&#34;],[&#34;ATL&#34;,&#34;SFO&#34;]]
输出：[&#34;JFK&#34;,&#34;ATL&#34;,&#34;JFK&#34;,&#34;SFO&#34;,&#34;ATL&#34;,&#34;SFO&#34;]
解释：另一种有效的行程是 [&#34;JFK&#34;,&#34;SFO&#34;,&#34;ATL&#34;,&#34;JFK&#34;,&#34;ATL&#34;,&#34;SFO&#34;]。但是它自然排序更大更靠后
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="c1">// unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets
</span><span class="c1"></span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">targets</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">backtracking</span><span class="p">(</span><span class="kt">int</span> <span class="n">ticketNum</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">ticketNum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="nl">target</span> <span class="p">:</span> <span class="n">targets</span><span class="p">[</span><span class="n">result</span><span class="p">[</span><span class="n">result</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// 记录到达机场是否飞过了
</span><span class="c1"></span>            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
            <span class="n">target</span><span class="p">.</span><span class="n">second</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">backtracking</span><span class="p">(</span><span class="n">ticketNum</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="n">result</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
            <span class="n">target</span><span class="p">.</span><span class="n">second</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">findItinerary</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;&amp;</span> <span class="n">tickets</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">targets</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="nl">vec</span> <span class="p">:</span> <span class="n">tickets</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">targets</span><span class="p">[</span><span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 记录映射关系
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&#34;JFK&#34;</span><span class="p">);</span> <span class="c1">// 起始机场
</span><span class="c1"></span>        <span class="n">backtracking</span><span class="p">(</span><span class="n">tickets</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">result</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="n皇后">N皇后</h2>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &lsquo;Q&rsquo; 和 &lsquo;.&rsquo; 分别代表了皇后和空位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kn">import</span> <span class="s">&#34;strings&#34;</span>
<span class="kd">var</span> <span class="nx">res</span> <span class="p">[][]</span><span class="kt">string</span>

<span class="kd">func</span> <span class="nf">isValid</span><span class="p">(</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="kt">bool</span><span class="p">){</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">board</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">row</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;Q&#34;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;Q&#34;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="p">,</span><span class="nx">j</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span> <span class="mi">1</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;Q&#34;</span><span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span><span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#34;Q&#34;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">backtrack</span><span class="p">(</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">row</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">size</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">board</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">row</span> <span class="o">==</span> <span class="nx">size</span><span class="p">{</span>
        <span class="nx">temp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="p">&lt;</span><span class="nx">size</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">strings</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="s">&#34;&#34;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">res</span> <span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">temp</span><span class="p">)</span>
        <span class="k">return</span> 
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">col</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="p">&lt;</span> <span class="nx">size</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">!</span><span class="nf">isValid</span><span class="p">(</span><span class="nx">board</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">){</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">board</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;Q&#34;</span>
        <span class="nf">backtrack</span><span class="p">(</span><span class="nx">board</span><span class="p">,</span> <span class="nx">row</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="nx">board</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;.&#34;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">solveNQueens</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="p">=</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">{}</span>
    <span class="nx">board</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span><span class="p">&lt;</span><span class="nx">n</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;.&#34;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">backtrack</span><span class="p">(</span><span class="nx">board</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="解数独">解数独</h2>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">solveSudoku</span><span class="p">(</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span>  <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">backtracking</span> <span class="kd">func</span><span class="p">(</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nx">backtracking</span><span class="p">=</span><span class="kd">func</span><span class="p">(</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">9</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="mi">9</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
                <span class="c1">//判断此位置是否适合填数字
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">!=</span><span class="sc">&#39;.&#39;</span><span class="p">{</span>
                    <span class="k">continue</span>
                <span class="p">}</span>
                <span class="c1">//尝试填1-9
</span><span class="c1"></span>                <span class="k">for</span> <span class="nx">k</span><span class="o">:=</span><span class="sc">&#39;1&#39;</span><span class="p">;</span><span class="nx">k</span><span class="o">&lt;=</span><span class="sc">&#39;9&#39;</span><span class="p">;</span><span class="nx">k</span><span class="o">++</span><span class="p">{</span>
                    <span class="k">if</span> <span class="nf">isvalid</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="nx">j</span><span class="p">,</span><span class="nb">byte</span><span class="p">(</span><span class="nx">k</span><span class="p">),</span><span class="nx">board</span><span class="p">)</span><span class="o">==</span><span class="kc">true</span><span class="p">{</span><span class="c1">//如果满足要求就填
</span><span class="c1"></span>                        <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]=</span><span class="nb">byte</span><span class="p">(</span><span class="nx">k</span><span class="p">)</span>
                       <span class="k">if</span>  <span class="nf">backtracking</span><span class="p">(</span><span class="nx">board</span><span class="p">)</span><span class="o">==</span><span class="kc">true</span><span class="p">{</span>
                           <span class="k">return</span> <span class="kc">true</span>
                       <span class="p">}</span>
                        <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]=</span><span class="sc">&#39;.&#39;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="nf">backtracking</span><span class="p">(</span><span class="nx">board</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">//判断填入数字是否满足要求
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isvalid</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span><span class="nx">col</span> <span class="kt">int</span><span class="p">,</span><span class="nx">k</span> <span class="kt">byte</span><span class="p">,</span><span class="nx">board</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">)</span><span class="kt">bool</span><span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">9</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span><span class="c1">//行
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">i</span><span class="p">]</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="mi">9</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span><span class="c1">//列
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//方格
</span><span class="c1"></span>    <span class="nx">startrow</span><span class="o">:=</span><span class="p">(</span><span class="nx">row</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
    <span class="nx">startcol</span><span class="o">:=</span><span class="p">(</span><span class="nx">col</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">3</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="nx">startrow</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">startrow</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="nx">startcol</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nx">startcol</span><span class="o">+</span><span class="mi">3</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
            <span class="k">if</span> <span class="nx">board</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span><span class="o">==</span><span class="nx">k</span><span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-12-04 21:44:37&nbsp;<a class="git-hash" href="https://github.com/dillonzq/LoveIt/commit/27576bd164ebf9916e305a5dc11212f58b476eee" target="_blank" title="commit by AdagioForSummerWind(2152343764@qq.com) 27576bd164ebf9916e305a5dc11212f58b476eee: autofeat">
                                    <i class="fas fa-hashtag fa-fw"></i>27576bd</a></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/algorithm_backtracking/" data-title="Algorithm_backTracking" data-hashtags="data structure"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/algorithm_backtracking/" data-hashtag="data structure"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/algorithm_backtracking/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/algorithm_backtracking/" data-title="Algorithm_backTracking"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/algorithm_backtracking/" data-title="Algorithm_backTracking"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/algorithm_backtracking/" data-title="Algorithm_backTracking"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/data-structure/">data structure</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/algorithm_binarytree/" class="prev" rel="prev" title="Algorithm_binaryTree"><i class="fas fa-angle-left fa-fw"></i>Algorithm_binaryTree</a>
            <a href="/algorithm_greedy/" class="next" rel="next" title="Algorithm_greedy">Algorithm_greedy<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
