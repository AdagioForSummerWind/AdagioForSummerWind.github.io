# SEK_base_05

# 软件编码、测试和质量保障
## 5.1 软件编程
软件编程是一个复杂而迭代的过程，它**不仅仅是编写代码，还应该包括代码审查、单元测试、代码优化、集成调试等**一系列工作。
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228142530.png)

软件设计描述SDD(逻辑概念)---->程序代码Program code（物理实体）

软件编码是一个复杂而迭代的过程，包括程序设计(program design)和程序实现(program implementation)。
- 软件编码要求
    - 正确的理解用户需求和软件设计思想
    - 正确的根据设计模型进行程序设计
    - 正确而高效率的编写和测试源代码
- 软件编码是设计的继续，会影响软件质量和可维护性。

软件编程规范的必要性
- 软件编码规范是与特定语言相关的描写如何编写代码的规则集合。
- 现实
    - 软件全生命周期的 70% 成本是维护
    - 软件在其生命周期中很少由原编写人员进行维护
- 目的
    - 提高编码质量，避免不必要的程序错误
    - 增强程序代码的可读性、可重用性和可移植性

### 良好的编程实践
不要编写需要外部文档支持的代码，这样的代码是脆弱的，要确保你的代码本身读起来就很清晰。
- **编写自文档化的代码**
    - 唯一能完整并正确地描述代码的文档是代码本身
    - 编写可以阅读的代码，其本身简单易懂

**程序模板**：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228143105.png)

**注释**：
- 学会只编写够用的注释，过犹不及，重视质量而不是数量。应该把时间花在编写不需要大量注释支持的代码上，即让代码自文档化。
    - 好的注释解释为什么，而不是怎么样
    - 不要在注释中重复描述代码
    - 当你发现自己在编写密密麻麻的注释来解释代码时，需要停下来看是否存在更大的问题
    - 想一想在注释中写什么，不要不动脑筋就输入，写完之后还要在代码的上下文中回顾一下这些注释，它们是否包含正确的信息？
    - 当修改代码时，维护代码周围的所有注释
- 形式1：由 # 开头的“真正的”注释，说明选择当前实现的原因以及这种实现的原理和难点；
- 形式2：文档字符串，说明如何使用包、模块、类、函数（方法），甚至包括使用示例和单元测试。
- 例子：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228143548.png)
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228143608.png)

**函数编写的第一条规则是短小，第二条规则是更短小。函数应该做一件事，做好这件事，并且只做这件事。**

**浮点运算**：
- 一个数值的准确度反映了这个值与它所代表的数量之间的接近程度，即衡量我们得到这个数值过程中的误差。
- 数字的精度表示其规格的紧密程度，即能够区分所表达的数与其邻近数的程度。
- 数字应该使用它们的准确度相当的精度来存储，但是应该使用底层硬件所能有效支持的最大精度来操作。
- 大多数有尽十进制小数不能被有尽二进制小数准确表示。
    - $0.1_{10} = 0.1000000000000000055511151231257827021181583404541015625$
- 在正常的表示范围内乘以或除以2的幂（2、4、8、16、…）永远都是精确运算，永远不会存在舍入问题

运用代码分析工具。

### 代码审查
**代码审查（Code Review）是一种用来确认方案设计和代码实现的质量保证机制，它通过阅读代码来检查源代码与编码规范的符合性以及代码的质量。**

代码审查的作用
- 检查设计的合理性
- 互为 Backup
- 分享知识、设计、技术
- 增加代码可读性
- 处理代码中的“地雷区

**缺陷检查表**：
- 编程规范
    - 按照具体编程语言的编码规范进行检查，包括命名规则、程序注释、缩进排版、声明与初始化、语句格式等。
- 面向对象设计
    - 类的设计和抽象是否合适
    - 是否符合面向接口编程的思想
    - 是否使用合适的设计模式
- 性能方面
    - 在出现海量数据时，队列、表、文件在传输、上载等方面是否会出现问题，是否控制如分配的内存块大小、队列长度等
    - 对 Hashtable、Vector 等集合类数据结构的选择和设置是否合适
    - 有无滥用 String 对象的现象
    - 是否采用通用的线程池、对象池等高速缓存技术以提高性能
    - 类的接口是否定义良好，如参数类型等应避免内部转换
    - 是否采用内存或硬盘缓冲机制以提高效率？
    - 并发访问时的应对策略
    - I/O 方面是否使用了合适的类或采用良好的方法以提高性能（如减少序列化、使用 buffer 类封装流等）
    - 同步方法的使用是否得当，是否过度使用？
    - 递归方法中的迭代次数是否合适（应保证在合理的栈空间范围内）
    - 如果调用了阻塞方法，是否考虑了保证性能的措施
    - 避免过度优化，对性能要求高的代码是否使用profile工具
- 资源释放处理
    - 分配的内存是否释放，尤其在错误处理路径上（如 C/C++）
    - 错误发生时是否所有对象被释放，如数据库连接、Socket、文件等
    - 是否同一个对象被释放多次（如 C/C++）
    - 代码是否保存准确的对象引用计数
- 程序流程
    - 循环结束条件是否准确
    - 是否避免了死循环的产生
    - 对循环的处理是否合适，应考虑到性能方面的影响
- 线程安全
    - 代码中所有的全局变量是否是线程安全的
    - 需要被多个线程访问的对象是否线程安全，检查有无通过同步方法保护
    - 同步对象上的锁是否按相同的顺序获得和释放以避免死锁，注意
    - 错误处理代码
    - 是否存在可能的死锁或是竞争，当用到多个锁时，避免出现类似情况：线程A获得锁1，然后锁2，线程B获得锁2，然后锁1
    - 在保证线程安全的同时，注意避免过度使用同步，导致性能降低
- 数据库处理
    - 数据库设计或SQL语句是否便于移植（注意与性能会存在冲突）
    - 数据库资源是否正常关闭和释放
    - 数据库访问模块是否正确封装，便于管理和提高性能
    - 是否采用合适的事务隔离级别
    - 是否采用存储过程以提高性能
    - 是否采用 PreparedStatement 以提高性能
- 通讯方面
    - Socket 通讯是否存在长期阻塞问题
    - 发送接收的数据流是否采用缓冲机制
    - Socket 超时处理和异常处理
    - 数据传输的流量控制问题
- JAVA对象处理
    - 对象生命周期的处理，是否对象引用已失效可设置 null 并被回收
    - 在对象传值和传参方面有无问题，对象的 clone 方法使用是否过度
    - 是否大量经常地创建临时对象
    - 是否尽量使用局部对象（堆栈对象）
    - 在只需要对象引用的地方是否创建了新的对象实例
- 异常处理
    - 每次当方法返回时是否正确处理了异常，如最简单的处理是记录日志到日志文件中
    - 是否对数据的值和范围是否合法进行校验，包括使用断言
    - 在出错路径上是否所有的资源和内存都已经释放
    - 所有抛出的异常是否都得到正确的处理，特别是对子方法抛出的异常，在整个调用栈中必须能够被捕捉并处理
    - 当调用导致错误发生时，方法的调用者应该得到一个通知
    - 不要忘了对错误处理部分的代码进行测试，很多代码在正常情况下执行良好，而一旦出错整个系统就崩溃了？
- 方法（函数）
    - 方法的参数是否都做了校验
    - 数组类结构是否做了边界校验
    - 变量在使用前是否做了初始化
    - 返回堆对象的引用，不要返回栈对象的引用
    - 方法的 API 是否被良好定义，即是否尽量面向接口编程，以便于维护和重构
- 安全方面
    - 对命令行执行的代码，需要详细检查命令行参数
    - WEB 类程序检查是否对访问参数进行合法性验证
    - 重要信息的保存是否选用合适的加密算法
    - 通讯时考虑是否选用安全的通讯方式
- 其他
    - 日志是否正常输出和控制
    - 配置信息如何获得，是否有硬编码
### 代码重构
重构（Refactoring）是对软件内部结构的一种调整，其目的是在不改变软件功能和外部行为的前提下，提高其可理解性、可扩展性和可重用性。

什么时候不适合重构？
- 代码太混乱，设计完全错误
    - 与其重构不如重新开始
- 明天是Deadline
    - 永远不要做Last-Minute-Change；应推迟重构但不可忽略，即使进入Production的代码都正确地运行。
- 重构的工作量显著地影响估算
    - 一个任务的估算时间是3天，如果为了重构，就需要更多的时间。
    - 推迟重构但不忽略，可以把重构作为一个新任务，或者安排在重构的迭代周期中完成

重构与添加新功能：
- 添加新功能
    - 添加新功能时，不应该修改既有代码，只管添加新功能
- 重构
    - 重构时不再添加功能，只管改进程序结构
- 重构和添加新功能可交替进行

糟糕的代码：
- 重复的代码
- 过长的函数（难以理解）
- 发散式变化
    - 某个类因为不同的原因在不同的方向上发生变化
    - 发散式变化指的是“一个类受多个外界变化的影响”，其基本思想是把相对不变的和相对变化相隔离，即封装变化。
- **霰弹式修改**
    - 发生一次改变时，需要修改多个类的多个地方
    - 散弹式修改指的是“一种变化引发多个类的修改”，其基本思想是将变化率和变化内容相似的状态和行为放在同一个类中，即集中变化。
- **数据泥团**
    - 同样的两至三项数据频繁地一起出现在类和参数表中。
    - 代码声明了某些字段，并声明了处理这些字段的方法，然后又声明了更多的字段和更多的方法，如此继续。
    - 各组字段名以类似的子串开头或结束。
    - 如果项是类中的字段，则使用抽取类将其取至一个新类中；
    - 如果值共同出现在方法的签名中，则使用引入参数对象的重构方法以抽取新对象；
    - 查看这些项的使用：通常可以利用移动方法等重构技术，从而将这些使用移至新的对象中。
- 幼稚的数据类
    - 类仅有字段构成，或者只有简单的赋值方法和取值方法构成。

1. **抽取方法**：
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228151111.png)
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228151137.png)
2. **引入解释性变量**：
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228151242.png)
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228151255.png)
3. **简化条件表达式**
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211229211757.png)
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211229211839.png)
## 5.2 软件测试
### 软件测试概述 
#### 软件缺陷术语 
术语解释：
- 错误（Error）：在软件生存期内的不希望或不可接受的人为错误，其结果是导致软件缺陷的产生。
- 缺陷（Defect）：软件缺陷是存在于软件产品之中的那些不希望或不可接受的偏差，其结果是软件运行于某一特定条件时出现故障。
- 故障（Fault）：软件运行过程中出现的一种不希望或不可接受的内部状态，若无适当措施（容错）加以及时处理，便产生软件失效。
- 失效（Failure）：软件运行时产生的一种不希望或不可接受的外部行为结果。
- 缺陷激活故障，故障演变为失效
#### 软件测试概念 
IEEE：测试是使用人工和自动手段来运行或检测某个系统的过程，其目的在于检验系统是否满足规定的需求或弄清预期结果与实际结果之间的差别。
- 该定义明确提出了**软件测试以“检验是否满足需求”为目标**。

**软件测试的两种思维**
- 正向思维：验证软件正常工作
- 逆向思维：假定软件有缺陷

软件测试的目的
- 直接目标：发现软件错误
- 期望目标：检查系统是否满足需求
- 附带目标：改进软件过程

测试的局限性
- 测试的不彻底性
- 测试的不完备性
- 测试作用的间接性

**用Venn Diagram来理解测试**：
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228153934.png)
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228154012.png)
#### 软件测试基本原则 
**缺陷的集群性**：
- 软件错误具有聚集性，对存在错误的部分应重点测试。

**杀虫剂悖论：**
- 用同样的测试用例多次重复进行测试，最后将不再能够发现新的缺陷。
- **测试用例需要定期评审和修改，同时要不断增加新的不同测试用例来测试软件的不同部分，从而发现更多潜在的缺陷**
#### 软件测试团队 
软件测试团队的任务：
- 软件测试与质量保证合二为一

举例：微软研发团队：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228154455.png)
### 软件测试策略
#### 软件测试对象 
**软件测试并不等于程序测试，应贯穿于软件定义与开发的各个阶段**。

**测试对象包括**：
- 需求规格说明
- 设计规格说明
- 源程序
#### 软件测试过程 
- 计划
    - 识别测试需求
    - 分析质量风险
    - 拟定测试方案
    - 制定测试计划
- 准备
    - 组织测试团队
    - 设计测试用例
    - 开发工具和脚本
    - 准备测试数据
- 执行
    - 获得测试版本
    - 执行和实施测试
    - 记录测试结果
    - 跟踪和管理缺陷
- 报告
    - 分析测试结果
    - 评价测试工作
    - 提交测试报告

#### 软件测试类型 
- 测试对象角度（**单元、集成、系统、验收、回归**）
    - 单元测试
        - 单元测试（Unit Testing）是对软件基本组成单元进行的测试，其测试对象是软件设计的最小单位（模块或者类）。
        - 单元测试一般由编写该单元代码的开发人员执行，用于检测被测代码的功能是否正确。
        - 单元测试环境
            - 驱动模块(driver)：模拟被测模块的上一级模块，接收测试数据，把这些数据传送给所测模块，最后再输出实际测试结果；
            - 桩模块(stub)：模拟被测单元需调用的其他函数接口，模拟实现子函数的某些功能
    - 集成测试
        - 集成测试（Integration Testing）是在单元测试的基础上，将所有模块按照总体设计的要求组装成为子系统或系统进行的测试。
        - 一次性集成方式：分别测试每个单元，再一次性将所有单元组装在一起进行测试。
        - 渐增式集成方式：先对某几个单元进行测试，然后将这些单元逐步组装成较大的系统，在组装过程中边连接边测试
        - 集成测试的对象是模块间的接口，其目的是找出在模块接口上，包括系统体系结构上的问题。
        - **整体集成方式(非增量式集成)**
            - 把所有模块按设计要求一次全部组装起来，然后进行整体测试
            - 优点：
                - 效率高，所需人力资源少；
                - 测试用例数目少，工作量低；
                - 简单，易行；
            - 缺点：
                - 可能发现大量的错误，难以进行错误定位和修改；
                - 即使测试通过，也会遗漏很多错误；
                - 测试和修改过程中，新旧错误混杂，带来调试困难；
        - **自顶向下的增量集成**：
            - 从主控模块开始，按软件的控制层次结构，以深度优先或广度优先的策略，逐步把各个模块集成在一起。
            - 优点：能尽早地对程序的主要控制和决策机制进行检验，因此较早地发现错误；较少需要驱动模块；
            - 缺点：所需的桩模块数量巨大；在测试较高层模块时，低层处理采用桩模块替代，不能反映真实情况，重要数据不能及时回送到上层模块，因此测试并不充分；
        - **自底向上的集成测试**：
            - 从软件结构最底层的模块开始组装测试
            - 优点：不用桩模块，测试用例的设计亦相对简单；
            - 缺点：程序最后一个模块加入时才具有整体形象，难以尽早建立信心。
    - 系统测试：
        - 系统测试（System Testing）是在实际运行环境或模拟实际运行环境下，针对系统的非功能特性所进行的测试，包括负载测试、性能测试、压力测试、恢复测试、安全测试和可靠性测试等。
        - **恢复测试(Recovery Testing)**
            - 恢复测试是检验系统从软件或者硬件失败中恢复的能力，即采用各种人工干预方式使软件出错，而不能正常工作，从而检验系统的恢复能力。
            - 恢复性测试的例子
                - 当供电出现问题时的恢复
                - 恢复程序的执行
                - 对选择的文件和数据进行恢复
                - 恢复处理日志方面的能力
                - 通过切换到一个并行系统来进行恢复
        - **安全性测试(Security Testing)**：
            - 安全性测试检查系统对非法侵入的防范能力。
            - 安全性测试期间，测试人员假扮非法入侵者，采用各种办法试图突破防线。
            - 安全性测试的例子
                - 想方设法截取或破译口令
                - 专门定做软件破坏系统的保护机制
                - 故意导致系统失败，企图趁恢复之机非法进入
                - 试图通过浏览非保密数据，推导所需信息
        - **压力测试(Press Testing)**：
            - 压力测试是检查系统在资源超负荷情况下的表现，特别是对系统的处理时间有什么影响。
            - 压力测试的例子
                - 对于一个固定输入速率(如每分钟120 个单词)的单词处理响应时间
                - 在一个非常短的时间内引入超负荷的数据容量
                - 成千上万的用户在同一时间从网上登录到系统
                - 引入需要大量内存资源的操作
                - 压力测试采用边界值和错误猜测方法，且需要工具的支持。
        - 性能测试(Performance Testing)
            - 在实际应用的环境下系统性能的表现
            - 常与压力测试一起进行
    - 验收测试：
        - 验收测试是在软件产品完成了功能测试和系统测试之后、产品发布之前所进行的软件测试活动，其目的是验证软件的功能和性能是否能够满足用户所期望的要求
    - 回归测试：
        - 在软件生命周期中的任何一个阶段，只要软件发生了改变，就可能给该软件带来问题。
        - 为了验证修改的正确性及其影响就需要进行回归测试。
- 测试技术角度
    - 黑盒测试（功能测试）
        - 又称功能测试，它将测试对象看做一个黑盒子，完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。
    - 白盒测试（结构测试）
        - 又称结构测试，它把测试对象看做一个透明的盒子，允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。

- 程序执行角度
    - 静态测试
        - 静态测试：通过人工分析或程序正确性证明的方式来确认程序正确性。
    - 动态测试
        - 动态测试：通过动态分析和程序测试等方法来检查程序执行状态，以确认程序是否有问题。
- 人工干预角度
    - 手工测试
        - 手工测试：测试人员根据测试大纲中所描述的测试步骤和方法，手工地输入测试数据并记录测试结果。
    - 自动化测试
        - 自动化测试：相对于手工测试而言，主要是通过所开发的软件测试工具、脚本等手段，按照测试工程师的预定计划对软件产品进行的自动测试。
    - **自动化测试只是对手工测试的一种补充，但绝不能代替手工测试，二者有各自的特点。**
        - 在系统功能逻辑测试、验收测试、适用性测试、涉及物理交互性测试时，多采用黑盒测试的手工测试方法；
        - 单元测试、集成测试、系统负载或性能、稳定性、可靠性测试等比较适合采用自动化测试；
        - 对那种不稳定软件的测试、开发周期很短的软件、一次性的软件等不适合自动化测试；
        - 工具本身并没有想象力和灵活性，一般自动化测试只能发现15~30%的缺陷，而手工测试可以发现70~85%的缺陷；自动化测试工具在进行功能测试时，其准确的含义是回归测试工具

**测试的V模型**：![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228163103.png)

#### 测试用例
设计良好的测试用例：
- 降低软件测试成本
- 保证测试工作质量
- 评估和检验测试效果

测试用例(testing case)：
- 测试用例是为特定的目的而设计的一组测试输入、执行条件和预期的结果。
- 测试用例是执行的最小测试实体。
- 测试用例就是设计一个场景，使软件程序在这种场景下，必须能够正常运行并且达到程序所设计的执行结果。

测试用例的特征：
- 最有可能抓住错误的；
- 不是重复的、多余的；
- 一组相似测试用例中最有效的；
- 既不是太简单，也不是太复杂。

测试用例的重要性：
- 指导人们系统地进行测试
    - 临时性发挥也许会有灵感出现，但是多数情况下会感觉思维混乱，甚至一些功能根
    本没有测到而另一些功能已经重复测过几遍。
    - 测试用例可以帮助你理清头绪，进行比较系统的测试，不会有太多的重复，也不会
    让你的测试工作产生遗漏。
- 有效发现缺陷，提高测试效率
    - 测试不可能是完备的而且受到时间约束，测试用例可以帮助你分清先后主次，从而更有效地组织测试工作。
    - 编写测试用例之后需要标识重要程度和优先级，以便在时间紧迫的情况下有重点地开展测试工作。
- 作为评估和检验的度量标准
    - 测试用例的通过率和软件缺陷的数量是检验软件质量的量化标准，通过对测试用例的分析和改进可以逐步完善软件质量，不断提高测试的水平。
    - 测试用例也可以用于衡量测试人员的工作量、进度和效率，从而更有效地管理和规划测试工作。
- 积累和传递测试的经验与知识
    - 测试用例不是简单地描述一种具体实现，而是描述处理具体问题的思路。设计和维护测试用例有助于人们不断积累经验和知识，通过复用测试用例可以做到任何人实现无品质差异的测试。

**测试用例设计要求**：
- 具有代表性和典型性
- 寻求系统设计和功能设计的弱点
- 既有正确输入也有错误或异常输入
- 考虑用户实际的诸多使用场景
## 5.3 白盒测试
**测试的技术**就是设计一组测试用例
- 执行每个软件构件的内部逻辑和接口
- 测试程序的输入和输出域以发现程序功能、行为和性能方面的错误

**利用“白盒”测试用例设计技术执行程序内部逻辑**

白盒测试(又称为“结构测试”或“逻辑驱动测试”) 
- 把测试对象看做一个透明的盒子，它允许测试人员利用程序内部的逻辑结构及有关信息，设计或选择测试用例，对程序所有逻辑路径进行测试。

目的：
- 白盒测试主要对程序模块进行如下的检查：
- 对模块的每一个独立的执行路径至少测试一次；
- 对所有的逻辑判定的每一个分支(真与假)都至少测试一次；
- 在循环的边界和运行界限内执行循环体；
- 测试内部数据结构的有效性；
- **错误隐藏在角落里，聚集在边界处**

过程：
--------------5.3p11
### 白盒测试方案
白盒测试方案技术之一：逻辑覆盖
- 语句覆盖
- 判定覆盖(分支覆盖)
- 条件覆盖
- 判定/条件覆盖
- 条件组合覆盖

![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228215912.png)
![](https://raw.githubusercontent.com/QizhengZou/Drawing_bed/main/20211228215932.png)

白盒测试方案技术之二：控制结构测试
- 基本路径测试
    - 
## 5.4 黑盒测试
黑盒测试方法 (等价类测试和边界值测试都是面向数据的测试)
- 等价类测试 
    - 等价类：将程序的输入划分为若干个数据类，从中生成测试用例。并合理地假定“测试某等价类的代表值就等于对这一类其它值的测试”。
    - 等价类划分原则：
        - 分而不交：划分出的任意两个等价类之间不存在交集->测试无冗余
        - 合而不变：所有等价类的并集仍然是原始的输入域->测试无漏洞
        - 类内等价：任意一个等价类中，所有数据相互“等价”->以一代全
    - **PDF上几个例子p28**
- 边界值测试 
    - 经过长期的测试工作经验表明，在输入域的边界或边界附近，常常会发现大量缺陷
    - 边界值测试倾向于选择系统边界或边界附近的数据来设计测试用例
- 场景法测试
    - 基本流:系统从初始态到终止态的最主要的业务流程。测试中至少要确保系统基本流的执行是完全正确的。
        - 完整的业务流程
    - 备选流:备选事件流，以基本流为基础，在基本流所经过的每个判定节点处满足的不同触发条件而导致的其他事件流
        - 仅为业务流程的执行片段
    - 例子ATM机取款见PDF
## 5.5 变异测试
## 5.6 性能测试

