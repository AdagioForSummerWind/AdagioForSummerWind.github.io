<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Algorithm_binaryTree - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Algorithm_binaryTree" />
<meta property="og:description" content="学习代码随想录笔记 二叉树 理论基础 一般主要会碰到满二叉树以及完全二叉树。 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/algorithm_binarytree/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-06T08:21:45+08:00" />
<meta property="article:modified_time" content="2022-10-08T19:55:40+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Algorithm_binaryTree"/>
<meta name="twitter:description" content="学习代码随想录笔记 二叉树 理论基础 一般主要会碰到满二叉树以及完全二叉树。 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/algorithm_binarytree/" /><link rel="prev" href="https://jefofrank.xyz/algorithm_stackandqueue/" /><link rel="next" href="https://jefofrank.xyz/algorithm_backtracking/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Algorithm_binaryTree",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/algorithm_binarytree\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "data structure","wordcount":  12476 ,
        "url": "https:\/\/jefofrank.xyz\/algorithm_binarytree\/","datePublished": "2022-01-06T08:21:45+08:00","dateModified": "2022-10-08T19:55:40+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Algorithm_binaryTree</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/coding/"><i class="far fa-folder fa-fw"></i>Coding</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-01-06 08:21:45">2022-01-06 08:21:45</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 12476 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 25 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#理论基础">理论基础</a></li>
    <li><a href="#递归遍历">递归遍历</a></li>
    <li><a href="#迭代遍历">迭代遍历</a></li>
    <li><a href="#统一迭代">统一迭代</a></li>
    <li><a href="#层序遍历">层序遍历</a>
      <ul>
        <li><a href="#102二叉树的层序遍历">102.二叉树的层序遍历</a></li>
        <li><a href="#107二叉树的层次遍历ii">107.二叉树的层次遍历II</a></li>
        <li><a href="#199二叉树的右视图">199.二叉树的右视图</a></li>
        <li><a href="#637二叉树的层平均值">637.二叉树的层平均值</a></li>
        <li><a href="#429n叉树的层序遍历">429.N叉树的层序遍历</a></li>
        <li><a href="#515在每个树行中找最大值">515.在每个树行中找最大值</a></li>
        <li><a href="#116填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针</a></li>
        <li><a href="#117填充每个节点的下一个右侧节点指针ii">117.填充每个节点的下一个右侧节点指针II</a></li>
        <li><a href="#104二叉树的最大深度">104.二叉树的最大深度</a></li>
        <li><a href="#111二叉树的最小深度">111.二叉树的最小深度</a></li>
      </ul>
    </li>
    <li><a href="#翻转二叉树">翻转二叉树</a></li>
    <li><a href="#对称二叉树">对称二叉树</a></li>
    <li><a href="#最大深度">最大深度</a></li>
    <li><a href="#最小深度">最小深度</a></li>
    <li><a href="#完全二叉树的节点个数">完全二叉树的节点个数</a></li>
    <li><a href="#平衡二叉树">平衡二叉树</a></li>
    <li><a href="#二叉树的所有路径">二叉树的所有路径</a></li>
    <li><a href="#二叉树的递归回溯">二叉树的递归+回溯</a></li>
    <li><a href="#左叶子之和">左叶子之和</a></li>
    <li><a href="#找树左下角的值">找树左下角的值</a></li>
    <li><a href="#路径总和">路径总和</a></li>
    <li><a href="#从中序后序遍历序列构造二叉树">从中序、后序遍历序列构造二叉树</a></li>
    <li><a href="#最大二叉树">最大二叉树</a></li>
    <li><a href="#合并二叉树">合并二叉树</a></li>
    <li><a href="#二叉搜索树">二叉搜索树</a>
      <ul>
        <li><a href="#搜索">搜索</a></li>
        <li><a href="#验证">验证</a></li>
        <li><a href="#最小绝对差">最小绝对差</a></li>
        <li><a href="#众数">众数</a></li>
        <li><a href="#二叉树最近公共祖先">二叉树最近公共祖先</a></li>
        <li><a href="#二叉搜索树的最近公共祖先">二叉搜索树的最近公共祖先</a></li>
        <li><a href="#插入操作">插入操作</a></li>
        <li><a href="#删除节点">删除节点</a></li>
        <li><a href="#修剪">修剪</a></li>
        <li><a href="#将有序数组转化为二叉搜索树">将有序数组转化为二叉搜索树</a></li>
        <li><a href="#把二叉搜索树转化为累加树">把二叉搜索树转化为累加树</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p>学习<a href="https://programmercarl.com/" target="_blank" rel="noopener noreffer">代码随想录</a>笔记</p>
</blockquote>
<h1 id="二叉树">二叉树</h1>
<h2 id="理论基础">理论基础</h2>
<p>一般主要会碰到满二叉树以及完全二叉树。</p>
<p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在<strong>该层最左边</strong>的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1  个节点。</p>
<p>优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。</p>
<p>二叉搜索树：</p>
<ul>
<li>与前面两个树不同，该树有节点权值。</li>
<li>有序树，左节点 &lt; 中节点 &lt; 右节点</li>
</ul>
<p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>
<p>二叉树可以链式存储，也可以顺序存储。</p>
<p>深度优先遍历</p>
<ul>
<li>前序遍历（递归法，迭代法）</li>
<li>中序遍历（递归法，迭代法）</li>
<li>后序遍历（递归法，迭代法）</li>
</ul>
<p>广度优先遍历</p>
<ul>
<li>层次遍历（迭代法）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TreeNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Val</span> <span class="kt">int</span>
    <span class="nx">Left</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="nx">Right</span> <span class="o">*</span><span class="nx">TreeNode</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="递归遍历">递归遍历</h2>
<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p>写递归还是得有<strong>方法论</strong>。</p>
<ul>
<li>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li>确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li>确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ul>
<p>前序遍历：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">traversal</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nx">traversal</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">pre</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)(</span><span class="nx">res</span> <span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>中序遍历：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">traversal</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nx">traversal</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>后序遍历:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">(</span><span class="nx">res</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">traversal</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nx">traversal</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="迭代遍历">迭代遍历</h2>
<p>迭代法前序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">ans</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ans</span>
	<span class="p">}</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Back</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>

        <span class="nx">ans</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>


<span class="kd">func</span> <span class="nf">preorderTraver</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法后序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">ans</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>

	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">ans</span>
	<span class="p">}</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Back</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>

        <span class="nx">ans</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">reverse</span><span class="p">(</span><span class="nx">ans</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">l</span> <span class="p">&lt;</span> <span class="nx">r</span> <span class="p">{</span>
        <span class="nx">a</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="p">=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">r</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
        <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="p">=</span> <span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">r</span><span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法中序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">ans</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">ans</span>
    <span class="p">}</span>

    <span class="nx">st</span> <span class="o">:=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">root</span>

    <span class="k">for</span> <span class="nx">cur</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">cur</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">st</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Back</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="nx">ans</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ans</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
            <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="统一迭代">统一迭代</h2>
<p>迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</p>
<p>使用迭代法实现先中后序遍历，很难写出统一的代码，不像是递归法，实现了其中的一种遍历方式，其他两种只要稍稍改一下节点顺序就可以了。</p>
<p><strong>要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法</strong></p>
<p>前序遍历统一迭代法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="cm">/**
</span><span class="cm"> type Element struct {
</span><span class="cm">    // 元素保管的值
</span><span class="cm">    Value interface{}
</span><span class="cm">    // 内含隐藏或非导出字段
</span><span class="cm">}
</span><span class="cm">
</span><span class="cm">func (l *List) Back() *Element 
</span><span class="cm">前序遍历：中左右
</span><span class="cm">压栈顺序：右左中
</span><span class="cm"> **/</span>
<span class="kd">func</span> <span class="nf">preorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span><span class="c1">//栈
</span><span class="c1"></span>    <span class="nx">res</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//结果集
</span><span class="c1"></span>    <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="k">for</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">e</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="c1">//弹出元素
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">// 如果为空，则表明是需要处理中间节点
</span><span class="c1"></span>            <span class="nx">e</span><span class="p">=</span><span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span><span class="c1">//弹出元素（即中间节点）
</span><span class="c1"></span>            <span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="c1">//删除中间节点
</span><span class="c1"></span>            <span class="nx">node</span><span class="p">=</span><span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="c1">//将中间节点加入到结果集中
</span><span class="c1"></span>            <span class="k">continue</span><span class="c1">//继续弹出栈中下一个节点
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">node</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
        <span class="c1">//压栈顺序：右左中
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="c1">//中间节点压栈后再压入nil作为中间节点的标志符
</span><span class="c1"></span>        <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>

<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>中序遍历统一迭代法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
 <span class="c1">//中序遍历：左中右
</span><span class="c1"></span> <span class="c1">//压栈顺序：右中左
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
       <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">stack</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span><span class="c1">//栈
</span><span class="c1"></span>    <span class="nx">res</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//结果集
</span><span class="c1"></span>    <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="k">for</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">e</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">// 如果为空，则表明是需要处理中间节点
</span><span class="c1"></span>            <span class="nx">e</span><span class="p">=</span><span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span><span class="c1">//弹出元素（即中间节点）
</span><span class="c1"></span>            <span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="c1">//删除中间节点
</span><span class="c1"></span>            <span class="nx">node</span><span class="p">=</span><span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="c1">//将中间节点加入到结果集中
</span><span class="c1"></span>            <span class="k">continue</span><span class="c1">//继续弹出栈中下一个节点
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">node</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
        <span class="c1">//压栈顺序：右中左
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="c1">//中间节点压栈后再压入nil作为中间节点的标志符
</span><span class="c1"></span>        <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>后序遍历统一迭代法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//后续遍历：左右中
</span><span class="c1">//压栈顺序：中右左
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">postorderTraversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span><span class="c1">//栈
</span><span class="c1"></span>    <span class="nx">res</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//结果集
</span><span class="c1"></span>    <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="k">for</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">e</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">// 如果为空，则表明是需要处理中间节点
</span><span class="c1"></span>            <span class="nx">e</span><span class="p">=</span><span class="nx">stack</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span><span class="c1">//弹出元素（即中间节点）
</span><span class="c1"></span>            <span class="nx">stack</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="c1">//删除中间节点
</span><span class="c1"></span>            <span class="nx">node</span><span class="p">=</span><span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="c1">//将中间节点加入到结果集中
</span><span class="c1"></span>            <span class="k">continue</span><span class="c1">//继续弹出栈中下一个节点
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">node</span> <span class="p">=</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
        <span class="c1">//压栈顺序：中右左
</span><span class="c1"></span>        <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span><span class="c1">//中间节点压栈后再压入nil作为中间节点的标志符
</span><span class="c1"></span>        <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="层序遍历">层序遍历</h2>
<h3 id="102二叉树的层序遍历">102.二叉树的层序遍历</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm">102. 二叉树的层序遍历
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//防止为空
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">res</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">tmpArr</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span> <span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span><span class="c1">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span><span class="c1">//出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmpArr</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmpArr</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="c1">//将值加入本层切片中
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmpArr</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="nx">tmpArr</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//清空层的数据
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="107二叉树的层次遍历ii">107.二叉树的层次遍历II</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm">107. 二叉树的层序遍历 II
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">levelOrderBottom</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmp</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//反转结果集
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span><span class="nx">res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]=</span><span class="nx">res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span><span class="o">-</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="199二叉树的右视图">199.二叉树的右视图</h3>
<p><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">rightSideView</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="kd">var</span> <span class="nx">finaRes</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">finaRes</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="p">[]</span><span class="kt">int</span><span class="p">{}</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmp</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//取每一层的最后一个元素
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">finaRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">finaRes</span><span class="p">,</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">finaRes</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="637二叉树的层平均值">637.二叉树的层平均值</h3>
<p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/**
</span><span class="cm">637. 二叉树的层平均值
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">averageOfLevels</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">float64</span> <span class="p">{</span>
    <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="kd">var</span> <span class="nx">finRes</span> <span class="p">[]</span><span class="kt">float64</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//防止为空
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">finRes</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">tmpArr</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span> <span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span><span class="c1">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span><span class="c1">//出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmpArr</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmpArr</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="c1">//将值加入本层切片中
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmpArr</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="nx">tmpArr</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//清空层的数据
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//计算每层的平均值
</span><span class="c1"></span>    <span class="nx">length</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>
        <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">sum</span><span class="o">+=</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span>
        <span class="p">}</span>
        <span class="nx">tmp</span><span class="o">:=</span><span class="nb">float64</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span>
        <span class="nx">finRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">finRes</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span><span class="c1">//将平均值放入结果集合
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">finRes</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="429n叉树的层序遍历">429.N叉树的层序遍历</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//结果集
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span><span class="c1">//记录当前层的数量
</span><span class="c1"></span>        <span class="kd">var</span> <span class="nx">tmp</span> <span class="p">[]</span><span class="kt">int</span>
        <span class="k">for</span> <span class="nx">T</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">T</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">T</span><span class="o">++</span><span class="p">{</span><span class="c1">//该层的每个元素：一添加到该层的结果集中；二找到该元素的下层元素加入到队列中，方便下次使用
</span><span class="c1"></span>            <span class="nx">myNode</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span>
            <span class="nx">tmp</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmp</span><span class="p">,</span><span class="nx">myNode</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
            <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">myNode</span><span class="p">.</span><span class="nx">Children</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">myNode</span><span class="p">.</span><span class="nx">Children</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmp</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="515在每个树行中找最大值">515.在每个树行中找最大值</h3>
<p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/**
</span><span class="cm">515. 在每个树行中找最大值
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">largestValues</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="kt">int</span><span class="p">{}</span>
    <span class="kd">var</span> <span class="nx">finRes</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//防止为空
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">finRes</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">tmpArr</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="c1">//层次遍历
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span> <span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span><span class="c1">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span><span class="c1">//出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmpArr</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmpArr</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="c1">//将值加入本层切片中
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmpArr</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="nx">tmpArr</span><span class="p">=[]</span><span class="kt">int</span><span class="p">{}</span><span class="c1">//清空层的数据
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//找到每层的最大值
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">finRes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">finRes</span><span class="p">,</span><span class="nf">max</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">...</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">finRes</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">vals</span><span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">max</span><span class="o">:=</span><span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Inf</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="c1">//负无穷
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">vals</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">val</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="p">{</span>
            <span class="nx">max</span> <span class="p">=</span> <span class="nx">val</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">max</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="116填充每个节点的下一个右侧节点指针">116.填充每个节点的下一个右侧节点指针</h3>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/**
</span><span class="cm">116. 填充每个节点的下一个右侧节点指针
</span><span class="cm">117. 填充每个节点的下一个右侧节点指针 II
</span><span class="cm"> */</span>

<span class="kd">func</span> <span class="nf">connect</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
   <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//防止为空
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">tmpArr</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span> <span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span><span class="c1">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span><span class="c1">//出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmpArr</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmpArr</span><span class="p">,</span><span class="nx">node</span><span class="p">)</span><span class="c1">//将值加入本层切片中
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmpArr</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="nx">tmpArr</span><span class="p">=[]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{}</span><span class="c1">//清空层的数据
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//遍历每层元素,指定next
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">Next</span><span class="p">=</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="117填充每个节点的下一个右侧节点指针ii">117.填充每个节点的下一个右侧节点指针II</h3>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/**
</span><span class="cm">116. 填充每个节点的下一个右侧节点指针
</span><span class="cm">117. 填充每个节点的下一个右侧节点指针 II
</span><span class="cm"> */</span>

<span class="kd">func</span> <span class="nf">connect</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
   <span class="nx">res</span><span class="o">:=</span><span class="p">[][]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//防止为空
</span><span class="c1"></span>        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">tmpArr</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span> <span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span><span class="c1">//保存当前层的长度，然后处理当前层（十分重要，防止添加下层元素影响判断层中元素的个数）
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">Node</span><span class="p">)</span><span class="c1">//出队列
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">tmpArr</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">tmpArr</span><span class="p">,</span><span class="nx">node</span><span class="p">)</span><span class="c1">//将值加入本层切片中
</span><span class="c1"></span>        <span class="p">}</span>
        <span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">tmpArr</span><span class="p">)</span><span class="c1">//放入结果集
</span><span class="c1"></span>        <span class="nx">tmpArr</span><span class="p">=[]</span><span class="o">*</span><span class="nx">Node</span><span class="p">{}</span><span class="c1">//清空层的数据
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="c1">//遍历每层元素,指定next
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">j</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">j</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="nx">j</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">].</span><span class="nx">Next</span><span class="p">=</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="104二叉树的最大深度">104.二叉树的最大深度</h3>
<p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">ans</span><span class="o">:=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">ans</span><span class="o">++</span><span class="c1">//记录深度，其他的是层序遍历的板子
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">ans</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="111二叉树的最小深度">111.二叉树的最小深度</h3>
<p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener noreffer">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">go：

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func minDepth(root *TreeNode) int {
    ans:=0
    if root==nil{
        return 0
    }
    queue:=list.New()
    queue.PushBack(root)
    for queue.Len()&gt;0{
        length:=queue.Len()
        for i:=0;i&lt;length;i++{
            node:=queue.Remove(queue.Front()).(*TreeNode)
            if node.Left==nil&amp;&amp;node.Right==nil{//当前节点没有左右节点，则代表此层是最小层
                return ans+1//返回当前层 ans代表是上一层
            }
            if node.Left!=nil{
                queue.PushBack(node.Left)
            }
            if node.Right!=nil{
                queue.PushBack(node.Right)
            }
        }
        ans++//记录层数
        

    }
    return ans+1
}
</code></pre></td></tr></table>
</div>
</div><h2 id="翻转二叉树">翻转二叉树</h2>
<p>二叉树，当然是左右翻转。</p>
<p>递归版本的前序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">temp</span><span class="o">:=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nx">temp</span>
    
    <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
    <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>递归版本的后序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span><span class="c1">//遍历左节点
</span><span class="c1"></span>    <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span><span class="c1">//遍历右节点
</span><span class="c1"></span>    <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="c1">//交换
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代版本的前序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="o">:=</span><span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{}</span>
    <span class="nx">node</span><span class="o">:=</span><span class="nx">root</span>
    <span class="k">for</span> <span class="nx">node</span><span class="o">!=</span><span class="kc">nil</span><span class="o">||</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">node</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="c1">//交换
</span><span class="c1"></span>            <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">node</span><span class="p">)</span>
            <span class="nx">node</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span>
        <span class="nx">node</span><span class="p">=</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">node</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代版本的后序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="nx">stack</span><span class="o">:=</span><span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{}</span>
    <span class="nx">node</span><span class="o">:=</span><span class="nx">root</span>
    <span class="kd">var</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="k">for</span> <span class="nx">node</span><span class="o">!=</span><span class="kc">nil</span><span class="o">||</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">node</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">node</span><span class="p">)</span>
            <span class="nx">node</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span>
        <span class="nx">node</span><span class="p">=</span><span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">stack</span><span class="p">=</span><span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="o">||</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="nx">prev</span><span class="p">{</span>
            <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="c1">//交换
</span><span class="c1"></span>            <span class="nx">prev</span><span class="p">=</span><span class="nx">node</span>
            <span class="nx">node</span><span class="p">=</span><span class="kc">nil</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="nx">stack</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span><span class="nx">node</span><span class="p">)</span>
            <span class="nx">node</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>层序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">invertTree</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">node</span><span class="o">:=</span><span class="nx">root</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">e</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="nx">e</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">e</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nx">e</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">e</span><span class="p">.</span><span class="nx">Left</span><span class="c1">//交换
</span><span class="c1"></span>            <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">e</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="对称二叉树">对称二叉树</h2>
<p>检查二叉树是否镜像对称。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="c1">// 递归
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">defs</span><span class="p">(</span><span class="nx">left</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">right</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">if</span> <span class="nx">left</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">defs</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">defs</span><span class="p">(</span><span class="nx">right</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">left</span><span class="p">.</span><span class="nx">Right</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">defs</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 迭代
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isSymmetric</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">queue</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">;</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">left</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nx">right</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">2</span><span class="p">:];</span>
        <span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">left</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">};</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">left</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">left</span><span class="p">.</span><span class="nx">Right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="最大深度">最大深度</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * definition for a binary tree node.
</span><span class="cm"> * type treenode struct {
</span><span class="cm"> *     val int
</span><span class="cm"> *     left *treenode
</span><span class="cm"> *     right *treenode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">max</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 递归
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">treenode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">),</span> <span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 遍历
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">treenode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">levl</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">treenode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">);</span> <span class="nx">l</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">;</span><span class="nx">l</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span><span class="nx">l</span><span class="o">--</span> <span class="p">{</span>
            <span class="nx">node</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:];</span>
        <span class="p">}</span>
        <span class="nx">levl</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">l</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">levl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="最小深度">最小深度</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">min</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span> <span class="p">&lt;</span> <span class="nx">b</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 递归
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">min</span><span class="p">(</span><span class="nf">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">),</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 迭代
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">minDepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">dep</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">root</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">);</span> <span class="nx">l</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">{</span>
        <span class="nx">dep</span><span class="o">++</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">;</span> <span class="nx">l</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">l</span><span class="o">--</span> <span class="p">{</span>
            <span class="nx">node</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">dep</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
                <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:];</span>
        <span class="p">}</span>
        <span class="nx">l</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">);</span>
    <span class="p">}</span> 
    <span class="k">return</span> <span class="nx">dep</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="完全二叉树的节点个数">完全二叉树的节点个数</h2>
<p>递归版本</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="c1">//本题直接就是求有多少个节点，无脑存进数组算长度就行了。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">+=</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">+=</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>利用完全二叉树特性的递归解法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">leftH</span><span class="p">,</span> <span class="nx">rightH</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="nx">leftNode</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span>
    <span class="nx">rightNode</span> <span class="o">:=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
    <span class="k">for</span> <span class="nx">leftNode</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">leftNode</span> <span class="p">=</span> <span class="nx">leftNode</span><span class="p">.</span><span class="nx">Left</span>
        <span class="nx">leftH</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">rightNode</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">rightNode</span> <span class="p">=</span> <span class="nx">rightNode</span><span class="p">.</span><span class="nx">Right</span>
        <span class="nx">rightH</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">leftH</span> <span class="o">==</span> <span class="nx">rightH</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="nx">leftH</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">+</span> <span class="nf">countNodes</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="平衡二叉树">平衡二叉树</h2>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">isBalanced</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nf">isBalanced</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">){</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="nx">LeftH</span><span class="o">:=</span><span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="nx">RightH</span><span class="o">:=</span><span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="nx">LeftH</span><span class="o">-</span><span class="nx">RightH</span><span class="p">)&gt;</span><span class="mi">1</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span><span class="kt">int</span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">),</span><span class="nf">maxdepth</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span> <span class="kt">int</span><span class="p">)</span><span class="kt">int</span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span><span class="p">&gt;</span><span class="nx">b</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">abs</span><span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span><span class="kt">int</span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">a</span><span class="p">&lt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="nx">a</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="二叉树的所有路径">二叉树的所有路径</h2>
<p>递归法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">travel</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span>
    <span class="nx">travel</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">v</span> <span class="o">:=</span> <span class="nx">s</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
            <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span> <span class="o">+</span> <span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#34;-&gt;&#34;</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">travel</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
	<span class="nx">stack</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{}</span>
	<span class="nx">paths</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">root</span><span class="p">)</span>
		<span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span>
		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">path</span> <span class="o">:=</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="nx">paths</span> <span class="p">=</span> <span class="nx">paths</span><span class="p">[:</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">path</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">))</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
			<span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="nx">path</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="o">+</span><span class="s">&#34;-&gt;&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
			<span class="nx">paths</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="nx">path</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span><span class="o">+</span><span class="s">&#34;-&gt;&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="二叉树的递归回溯">二叉树的递归+回溯</h2>
<p>100.相同的树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
   	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">case</span> <span class="nx">p</span> <span class="o">==</span> <span class="kc">nil</span> <span class="o">||</span> <span class="nx">q</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">:</span>
		<span class="k">fallthrough</span>
	<span class="k">case</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Val</span> <span class="o">!=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Val</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">isSameTree</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">q</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>257.二叉的所有路径</p>
<p>递归法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">result</span> <span class="o">*</span><span class="p">[]</span><span class="kt">string</span><span class="p">,</span><span class="nx">pathStr</span> <span class="kt">string</span><span class="p">){</span>
    <span class="c1">//判断是否为第一个元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pathStr</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">pathStr</span><span class="p">=</span><span class="nx">pathStr</span><span class="o">+</span><span class="s">&#34;-&gt;&#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">pathStr</span><span class="p">=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//判断是否为叶子节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="o">*</span><span class="nx">result</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">,</span><span class="nx">pathStr</span><span class="p">)</span>
        <span class="k">return</span> 
    <span class="p">}</span>
    <span class="c1">//左右
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">result</span><span class="p">,</span><span class="nx">pathStr</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">result</span><span class="p">,</span><span class="nx">pathStr</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>回溯法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">binaryTreePaths</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">string</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">string</span>
    <span class="kd">var</span> <span class="nx">path</span>   <span class="p">[]</span><span class="kt">int</span>
    <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">result</span> <span class="o">*</span><span class="p">[]</span><span class="kt">string</span><span class="p">,</span><span class="nx">path</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
    <span class="o">*</span><span class="nx">path</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">,</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
    <span class="c1">//判断是否为叶子节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nx">pathStr</span><span class="o">:=</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">((</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">pathStr</span><span class="p">=</span><span class="nx">pathStr</span><span class="o">+</span><span class="s">&#34;-&gt;&#34;</span><span class="o">+</span><span class="nx">strconv</span><span class="p">.</span><span class="nf">Itoa</span><span class="p">((</span><span class="o">*</span><span class="nx">path</span><span class="p">)[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">}</span>
        <span class="o">*</span><span class="nx">result</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">,</span><span class="nx">pathStr</span><span class="p">)</span>
        <span class="k">return</span> 
    <span class="p">}</span>
    <span class="c1">//左右
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">result</span><span class="p">,</span><span class="nx">path</span><span class="p">)</span>
        <span class="o">*</span><span class="nx">path</span><span class="p">=(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1">//回溯到上一个节点（因为traversal会加下一个节点值到path中）
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">result</span><span class="p">,</span><span class="nx">path</span><span class="p">)</span>
        <span class="o">*</span><span class="nx">path</span><span class="p">=(</span><span class="o">*</span><span class="nx">path</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="左叶子之和">左叶子之和</h2>
<p>递归法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span>  <span class="nx">res</span> <span class="kt">int</span>
    <span class="nf">findLeft</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findLeft</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="kt">int</span><span class="p">){</span>
    <span class="c1">//左节点
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="o">*</span><span class="nx">res</span><span class="o">+</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Val</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">findLeft</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">findLeft</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sumOfLeftLeaves</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span>  <span class="nx">res</span> <span class="kt">int</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">res</span><span class="p">=</span><span class="nx">res</span><span class="o">+</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Val</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="找树左下角的值">找树左下角的值</h2>
<p>给定一个二叉树，在树的最后一行找到最左边的值。</p>
<p>递归法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="kd">var</span> <span class="nx">maxDeep</span> <span class="kt">int</span> <span class="c1">// 全局变量 深度
</span><span class="c1"></span> <span class="kd">var</span>  <span class="nx">value</span>  <span class="kt">int</span> <span class="c1">//全局变量 最终值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
     <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//需要提前判断一下（不要这个if的话提交结果会出错，但执行代码不会。防止这种情况出现，故先判断是否只有一个节点）
</span><span class="c1"></span>         <span class="k">return</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span>
     <span class="p">}</span>
    <span class="nf">findLeftValue</span> <span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">maxDeep</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">value</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findLeftValue</span> <span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">deep</span> <span class="kt">int</span><span class="p">){</span>
     <span class="c1">//最左边的值在左边
</span><span class="c1"></span>     <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
         <span class="k">if</span> <span class="nx">deep</span><span class="p">&gt;</span><span class="nx">maxDeep</span><span class="p">{</span>
             <span class="nx">value</span><span class="p">=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span>
             <span class="nx">maxDeep</span><span class="p">=</span><span class="nx">deep</span>
         <span class="p">}</span>
     <span class="p">}</span>
    <span class="c1">//递归
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nx">deep</span><span class="o">++</span>
        <span class="nf">findLeftValue</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">deep</span><span class="p">)</span>
        <span class="nx">deep</span><span class="o">--</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nx">deep</span><span class="o">++</span>
        <span class="nf">findLeftValue</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">deep</span><span class="p">)</span>
        <span class="nx">deep</span><span class="o">--</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findBottomLeftValue</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">queue</span><span class="o">:=</span><span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nx">gradation</span> <span class="kt">int</span>
    <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()&gt;</span><span class="mi">0</span><span class="p">{</span>
        <span class="nx">length</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span>
        <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nx">length</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
            <span class="nx">node</span><span class="o">:=</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">queue</span><span class="p">.</span><span class="nf">Front</span><span class="p">()).(</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">i</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span><span class="nx">gradation</span><span class="p">=</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
                <span class="nx">queue</span><span class="p">.</span><span class="nf">PushBack</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">gradation</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="路径总和">路径总和</h2>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和</p>
<p>路径总和</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">//递归法
</span><span class="c1"></span><span class="cm">/**
</span><span class="cm"> * definition for a binary tree node.
</span><span class="cm"> * type treenode struct {
</span><span class="cm"> *     val int
</span><span class="cm"> *     left *treenode
</span><span class="cm"> *     right *treenode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">haspathsum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">treenode</span><span class="p">,</span> <span class="nx">targetsum</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">flage</span> <span class="kt">bool</span> <span class="c1">//找没找到的标志
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">flage</span>
    <span class="p">}</span>
    <span class="nf">pathsum</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">targetsum</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">flage</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">flage</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">pathsum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">treenode</span><span class="p">,</span> <span class="nx">sum</span> <span class="kt">int</span><span class="p">,</span><span class="nx">targetsum</span> <span class="kt">int</span><span class="p">,</span><span class="nx">flage</span> <span class="o">*</span><span class="kt">bool</span><span class="p">){</span>
    <span class="nx">sum</span><span class="o">+=</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">sum</span><span class="o">==</span><span class="nx">targetsum</span><span class="p">{</span>
        <span class="o">*</span><span class="nx">flage</span><span class="p">=</span><span class="kc">true</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="o">!=</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="p">!(</span><span class="o">*</span><span class="nx">flage</span><span class="p">){</span><span class="c1">//左节点不为空且还没找到
</span><span class="c1"></span>        <span class="nf">pathsum</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">targetsum</span><span class="p">,</span><span class="nx">flage</span><span class="p">)</span>
    <span class="p">}</span> 
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="o">!=</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="p">!(</span><span class="o">*</span><span class="nx">flage</span><span class="p">){</span><span class="c1">//右节点不为空且没找到
</span><span class="c1"></span>        <span class="nf">pathsum</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span><span class="nx">sum</span><span class="p">,</span><span class="nx">targetsum</span><span class="p">,</span><span class="nx">flage</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>113 递归法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * definition for a binary tree node.
</span><span class="cm"> * type treenode struct {
</span><span class="cm"> *     val int
</span><span class="cm"> *     left *treenode
</span><span class="cm"> *     right *treenode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">pathsum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">treenode</span><span class="p">,</span> <span class="nx">targetsum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[][]</span><span class="kt">int</span><span class="c1">//最终结果
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">result</span>
    <span class="p">}</span>
    <span class="kd">var</span> <span class="nx">sumnodes</span> <span class="p">[]</span><span class="kt">int</span><span class="c1">//经过路径的节点集合
</span><span class="c1"></span>    <span class="nf">haspathsum</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">sumnodes</span><span class="p">,</span><span class="nx">targetsum</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">haspathsum</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">treenode</span><span class="p">,</span><span class="nx">sumnodes</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">targetsum</span> <span class="kt">int</span><span class="p">,</span><span class="nx">result</span> <span class="o">*</span><span class="p">[][]</span><span class="kt">int</span><span class="p">){</span>
    <span class="o">*</span><span class="nx">sumnodes</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">sumnodes</span><span class="p">,</span><span class="nx">root</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="c1">//叶子节点
</span><span class="c1"></span>        <span class="nx">fmt</span><span class="p">.</span><span class="nb">println</span><span class="p">(</span><span class="o">*</span><span class="nx">sumnodes</span><span class="p">)</span>
        <span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>
        <span class="kd">var</span> <span class="nx">number</span> <span class="kt">int</span>
        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="o">*</span><span class="nx">sumnodes</span><span class="p">{</span><span class="c1">//求该路径节点的和
</span><span class="c1"></span>            <span class="nx">sum</span><span class="o">+=</span><span class="nx">v</span>
            <span class="nx">number</span><span class="p">=</span><span class="nx">k</span>
        <span class="p">}</span>
        <span class="nx">tempnodes</span><span class="o">:=</span><span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span><span class="nx">number</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="c1">//新的nodes接受指针里的值，防止最终指针里的值发生变动，导致最后的结果都是最后一个sumnodes的值
</span><span class="c1"></span>        <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">v</span><span class="o">:=</span><span class="k">range</span> <span class="o">*</span><span class="nx">sumnodes</span><span class="p">{</span>
            <span class="nx">tempnodes</span><span class="p">[</span><span class="nx">k</span><span class="p">]=</span><span class="nx">v</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">sum</span><span class="o">==</span><span class="nx">targetsum</span><span class="p">{</span>
            <span class="o">*</span><span class="nx">result</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">result</span><span class="p">,</span><span class="nx">tempnodes</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">haspathsum</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">left</span><span class="p">,</span><span class="nx">sumnodes</span><span class="p">,</span><span class="nx">targetsum</span><span class="p">,</span><span class="nx">result</span><span class="p">)</span>
        <span class="o">*</span><span class="nx">sumnodes</span><span class="p">=(</span><span class="o">*</span><span class="nx">sumnodes</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">sumnodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">haspathsum</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">right</span><span class="p">,</span><span class="nx">sumnodes</span><span class="p">,</span><span class="nx">targetsum</span><span class="p">,</span><span class="nx">result</span><span class="p">)</span>
        <span class="o">*</span><span class="nx">sumnodes</span><span class="p">=(</span><span class="o">*</span><span class="nx">sumnodes</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">sumnodes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="c1">//回溯
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="从中序后序遍历序列构造二叉树">从中序、后序遍历序列构造二叉树</h2>
<p>106 从中序与后序遍历序列构造二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">inorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">postorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">inorder</span><span class="p">)&lt;</span><span class="mi">1</span><span class="o">||</span><span class="nb">len</span><span class="p">(</span><span class="nx">postorder</span><span class="p">)&lt;</span><span class="mi">1</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
    <span class="c1">//先找到根节点（后续遍历的最后一个就是根节点）
</span><span class="c1"></span>    <span class="nx">nodeValue</span><span class="o">:=</span><span class="nx">postorder</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">postorder</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1">//从中序遍历中找到一分为二的点，左边为左子树，右边为右子树
</span><span class="c1"></span>    <span class="nx">left</span><span class="o">:=</span><span class="nf">findRootIndex</span><span class="p">(</span><span class="nx">inorder</span><span class="p">,</span><span class="nx">nodeValue</span><span class="p">)</span>
    <span class="c1">//构造root
</span><span class="c1"></span>    <span class="nx">root</span><span class="o">:=&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="nx">nodeValue</span><span class="p">,</span>
                <span class="nx">Left</span><span class="p">:</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">inorder</span><span class="p">[:</span><span class="nx">left</span><span class="p">],</span><span class="nx">postorder</span><span class="p">[:</span><span class="nx">left</span><span class="p">]),</span><span class="c1">//将后续遍历一分为二，左边为左子树，右边为右子树
</span><span class="c1"></span>                <span class="nx">Right</span><span class="p">:</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">inorder</span><span class="p">[</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="nx">postorder</span><span class="p">[</span><span class="nx">left</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">postorder</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findRootIndex</span><span class="p">(</span><span class="nx">inorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span><span class="nx">target</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">){</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">inorder</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">target</span><span class="o">==</span><span class="nx">inorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
            <span class="k">return</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>105 从前序与中序遍历序列构造二叉树</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">preorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">inorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">preorder</span><span class="p">)&lt;</span><span class="mi">1</span><span class="o">||</span><span class="nb">len</span><span class="p">(</span><span class="nx">inorder</span><span class="p">)&lt;</span><span class="mi">1</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
    <span class="nx">left</span><span class="o">:=</span><span class="nf">findRootIndex</span><span class="p">(</span><span class="nx">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nx">inorder</span><span class="p">)</span>
    <span class="nx">root</span><span class="o">:=&amp;</span><span class="nx">TreeNode</span><span class="p">{</span>
        <span class="nx">Val</span><span class="p">:</span> <span class="nx">preorder</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="nx">Left</span><span class="p">:</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">preorder</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="nx">inorder</span><span class="p">[:</span><span class="nx">left</span><span class="p">]),</span>
        <span class="nx">Right</span><span class="p">:</span> <span class="nf">buildTree</span><span class="p">(</span><span class="nx">preorder</span><span class="p">[</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span><span class="nx">inorder</span><span class="p">[</span><span class="nx">left</span><span class="o">+</span><span class="mi">1</span><span class="p">:])}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findRootIndex</span><span class="p">(</span><span class="nx">target</span> <span class="kt">int</span><span class="p">,</span><span class="nx">inorder</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">inorder</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">target</span><span class="o">==</span><span class="nx">inorder</span><span class="p">[</span><span class="nx">i</span><span class="p">]{</span>
            <span class="k">return</span> <span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="最大二叉树">最大二叉树</h2>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
<span class="kd">func</span> <span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)&lt;</span><span class="mi">1</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
    <span class="c1">//首选找到最大值
</span><span class="c1"></span>    <span class="nx">index</span><span class="o">:=</span><span class="nf">findMax</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span>
    <span class="c1">//其次构造二叉树
</span><span class="c1"></span>    <span class="nx">root</span><span class="o">:=&amp;</span><span class="nx">TreeNode</span><span class="p">{</span>
        <span class="nx">Val</span><span class="p">:</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span>
        <span class="nx">Left</span><span class="p">:</span><span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nx">index</span><span class="p">]),</span><span class="c1">//左半边
</span><span class="c1"></span>        <span class="nx">Right</span><span class="p">:</span><span class="nf">constructMaximumBinaryTree</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:]),</span><span class="c1">//右半边
</span><span class="c1"></span>        <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">findMax</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">){</span>
    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]&gt;</span><span class="nx">nums</span><span class="p">[</span><span class="nx">index</span><span class="p">]{</span>
            <span class="nx">index</span><span class="p">=</span><span class="nx">i</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="合并二叉树">合并二叉树</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="cm">/**
</span><span class="cm"> * Definition for a binary tree node.
</span><span class="cm"> * type TreeNode struct {
</span><span class="cm"> *     Val int
</span><span class="cm"> *     Left *TreeNode
</span><span class="cm"> *     Right *TreeNode
</span><span class="cm"> * }
</span><span class="cm"> */</span>
 <span class="c1">//前序遍历（递归遍历，跟105 106差不多的思路）
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">t1</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">t2</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">value</span> <span class="kt">int</span> 
    <span class="kd">var</span> <span class="nx">nullNode</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="c1">//空node，便于遍历
</span><span class="c1"></span>    <span class="nx">nullNode</span><span class="p">=</span><span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span>
        <span class="nx">Val</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
        <span class="nx">Left</span><span class="p">:</span><span class="kc">nil</span><span class="p">,</span>
        <span class="nx">Right</span><span class="p">:</span><span class="kc">nil</span><span class="p">}</span>
    <span class="k">switch</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">t1</span><span class="o">==</span><span class="kc">nil</span><span class="o">&amp;&amp;</span><span class="nx">t2</span><span class="o">==</span><span class="kc">nil</span><span class="p">:</span> <span class="k">return</span> <span class="kc">nil</span><span class="c1">//终止条件
</span><span class="c1"></span>        <span class="k">default</span> <span class="p">:</span> <span class="c1">//如果其中一个节点为空，则将该节点置为nullNode，方便下次遍历
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">t1</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">value</span><span class="p">=</span><span class="nx">t2</span><span class="p">.</span><span class="nx">Val</span>
            <span class="nx">t1</span><span class="p">=</span><span class="nx">nullNode</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">t2</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">value</span><span class="p">=</span><span class="nx">t1</span><span class="p">.</span><span class="nx">Val</span>
            <span class="nx">t2</span><span class="p">=</span><span class="nx">nullNode</span>
        <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
            <span class="nx">value</span><span class="p">=</span><span class="nx">t1</span><span class="p">.</span><span class="nx">Val</span><span class="o">+</span><span class="nx">t2</span><span class="p">.</span><span class="nx">Val</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">root</span><span class="o">:=&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="c1">//构造新的二叉树
</span><span class="c1"></span>        <span class="nx">Val</span><span class="p">:</span> <span class="nx">value</span><span class="p">,</span>
        <span class="nx">Left</span><span class="p">:</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">t1</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">t2</span><span class="p">.</span><span class="nx">Left</span><span class="p">),</span>
        <span class="nx">Right</span><span class="p">:</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">t1</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">t2</span><span class="p">.</span><span class="nx">Right</span><span class="p">)}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>

<span class="c1">// 前序遍历简洁版
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">root1</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">root2</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root1</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">root2</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root2</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">root1</span>
    <span class="p">}</span>
    <span class="nx">root1</span><span class="p">.</span><span class="nx">Val</span> <span class="o">+=</span> <span class="nx">root2</span><span class="p">.</span><span class="nx">Val</span>
    <span class="nx">root1</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">root1</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">root2</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
    <span class="nx">root1</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">root1</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">root2</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">root1</span>
<span class="p">}</span>

<span class="c1">// 迭代版本
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="nx">root1</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">root2</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="nx">queue</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">root1</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root2</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root2</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root1</span>
    <span class="p">}</span>
    <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">root1</span><span class="p">)</span>
    <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">root2</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">size</span><span class="o">:=</span><span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">);</span><span class="nx">size</span><span class="p">&gt;</span><span class="mi">0</span><span class="p">;</span><span class="nx">size</span><span class="p">=</span><span class="nb">len</span><span class="p">(</span><span class="nx">queue</span><span class="p">){</span>
        <span class="nx">node1</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="nx">node2</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">queue</span> <span class="p">=</span> <span class="nx">queue</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="nx">node1</span><span class="p">.</span><span class="nx">Val</span> <span class="o">+=</span> <span class="nx">node2</span><span class="p">.</span><span class="nx">Val</span>
        <span class="c1">// 左子树都不为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">node1</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node2</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
            <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">node1</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
            <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">node2</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 右子树都不为空
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">node1</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span><span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node2</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
            <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">node1</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
            <span class="nx">queue</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">queue</span><span class="p">,</span><span class="nx">node2</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="c1">// 树 1 的左子树为 nil，直接接上树 2 的左子树
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">node1</span><span class="p">.</span><span class="nx">Left</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
            <span class="nx">node1</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">node2</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span>
        <span class="c1">// 树 1 的右子树为 nil，直接接上树 2 的右子树
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">node1</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
            <span class="nx">node1</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">node2</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root1</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="二叉搜索树">二叉搜索树</h2>
<h3 id="搜索">搜索</h3>
<p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<p>递归法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="c1">//递归法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">searchBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="o">||</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="o">==</span><span class="nx">val</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">val</span><span class="p">{</span>
        <span class="k">return</span> <span class="nf">searchBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">searchBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">val</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="c1">//迭代法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">searchBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">root</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">val</span><span class="p">{</span>
            <span class="nx">root</span><span class="p">=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">val</span><span class="p">{</span>
            <span class="nx">root</span><span class="p">=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="验证">验证</h3>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kn">import</span> <span class="s">&#34;math&#34;</span>

<span class="kd">func</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 二叉搜索树也可以是空树
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="c1">// 由题目中的数据限制可以得出min和max
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">check</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">math</span><span class="p">.</span><span class="nx">MinInt64</span><span class="p">,</span><span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt64</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">check</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nx">max</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">min</span> <span class="o">&gt;=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="o">||</span> <span class="nx">max</span> <span class="o">&lt;=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>
    <span class="c1">// 分别对左子树和右子树递归判断，如果左子树和右子树都符合则返回true
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">check</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nb">int64</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">),</span><span class="nx">max</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">check</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">min</span><span class="p">,</span><span class="nb">int64</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">))</span>
<span class="p">}</span>


<span class="c1">// 中序遍历解法
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">isValidBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 保存上一个指针
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="kd">var</span> <span class="nx">travel</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nx">travel</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
        <span class="nx">leftRes</span> <span class="o">:=</span> <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="c1">// 当前值小于等于前一个节点的值，返回false
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">prev</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="o">&lt;=</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
        <span class="nx">prev</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nx">rightRes</span> <span class="o">:=</span> <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">leftRes</span> <span class="o">&amp;&amp;</span> <span class="nx">rightRes</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">travel</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="最小绝对差">最小绝对差</h3>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p>中序遍历，然后计算最小差值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">res</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nf">findMIn</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">res</span><span class="p">)</span>
    <span class="nx">min</span><span class="o">:=</span><span class="mi">1000000</span><span class="c1">//一个比较大的值
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span><span class="o">:=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="p">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span><span class="nx">i</span><span class="o">++</span><span class="p">{</span>
        <span class="nx">tempValue</span><span class="o">:=</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">-</span><span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">tempValue</span><span class="p">&lt;</span><span class="nx">min</span><span class="p">{</span>
            <span class="nx">min</span><span class="p">=</span><span class="nx">tempValue</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>
<span class="c1">//中序遍历
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">findMIn</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">res</span> <span class="o">*</span><span class="p">[]</span><span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span><span class="p">}</span>
    <span class="nf">findMIn</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
    <span class="o">*</span><span class="nx">res</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">res</span><span class="p">,</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
    <span class="nf">findMIn</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">res</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 中序遍历的同时计算最小值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">getMinimumDifference</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// 保留前一个节点的指针
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="c1">// 定义一个比较大的值
</span><span class="c1"></span>    <span class="nx">min</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">MaxInt64</span>
    <span class="kd">var</span> <span class="nx">travel</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span>
    <span class="nx">travel</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span> 
        <span class="p">}</span>
        <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">prev</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="o">-</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">min</span> <span class="p">{</span>
            <span class="nx">min</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="o">-</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Val</span>
        <span class="p">}</span>
        <span class="nx">prev</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">travel</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">min</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="众数">众数</h3>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>暴力法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findMode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">history</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">maxValue</span> <span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">maxIndex</span> <span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">result</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">history</span><span class="p">=</span><span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>
    <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="nx">history</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">value</span><span class="o">:=</span><span class="k">range</span> <span class="nx">history</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">value</span><span class="p">&gt;</span><span class="nx">maxValue</span><span class="p">{</span>
            <span class="nx">maxValue</span><span class="p">=</span><span class="nx">value</span>
            <span class="nx">maxIndex</span><span class="p">=</span><span class="nx">k</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">k</span><span class="p">,</span><span class="nx">value</span><span class="o">:=</span><span class="k">range</span> <span class="nx">history</span><span class="p">{</span>
        <span class="k">if</span> <span class="nx">value</span><span class="o">==</span><span class="nx">history</span><span class="p">[</span><span class="nx">maxIndex</span><span class="p">]{</span>
            <span class="nx">result</span><span class="p">=</span><span class="nb">append</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="nx">k</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">history</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">){</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">history</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">value</span><span class="p">,</span><span class="nx">ok</span><span class="o">:=</span><span class="nx">history</span><span class="p">[</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">];</span><span class="nx">ok</span><span class="p">{</span>
        <span class="nx">history</span><span class="p">[</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">]=</span><span class="nx">value</span><span class="o">+</span><span class="mi">1</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="nx">history</span><span class="p">[</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">]=</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nf">traversal</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">history</span><span class="p">)</span>
    <span class="p">}</span> 
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>计数法，不使用额外空间，利用二叉树性质，中序遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">findMode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
    <span class="nx">res</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">count</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nx">max</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="kd">var</span> <span class="nx">prev</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="kd">var</span> <span class="nx">travel</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> 
    <span class="nx">travel</span> <span class="p">=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">node</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">return</span>
        <span class="p">}</span>
        <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">prev</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">prev</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
            <span class="nx">count</span><span class="o">++</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">count</span> <span class="p">=</span> <span class="mi">1</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">count</span> <span class="o">&gt;=</span> <span class="nx">max</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">max</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="nx">res</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">res</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nx">max</span> <span class="p">=</span> <span class="nx">count</span>
        <span class="p">}</span>
        <span class="nx">prev</span> <span class="p">=</span> <span class="nx">node</span>
        <span class="nf">travel</span><span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nf">travel</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">res</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉树最近公共祖先">二叉树最近公共祖先</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先（可以是自己）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="c1">// check
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="c1">// 相等 直接返回root节点即可
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="nx">p</span> <span class="o">||</span> <span class="nx">root</span> <span class="o">==</span> <span class="nx">q</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="c1">// Divide
</span><span class="c1"></span>    <span class="nx">left</span> <span class="o">:=</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span>
    <span class="nx">right</span> <span class="o">:=</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span>

    <span class="c1">// Conquer
</span><span class="c1"></span>    <span class="c1">// 左右两边都不为空，则根节点为祖先
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">left</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">right</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="二叉搜索树的最近公共祖先">二叉搜索树的最近公共祖先</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">递归法</span><span class="err">：</span>

<span class="c1">//利用BSL的性质（前序遍历有序）
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">Val</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">q</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span><span class="c1">//当前节点的值大于给定的值，则说明满足条件的在左边
</span><span class="c1"></span>        <span class="k">return</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">p</span><span class="p">,</span><span class="nx">q</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">Val</span><span class="o">&amp;&amp;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">q</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span><span class="c1">//当前节点的值小于各点的值，则说明满足条件的在右边
</span><span class="c1"></span>        <span class="k">return</span> <span class="nf">lowestCommonAncestor</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">p</span><span class="p">,</span><span class="nx">q</span><span class="p">)</span>
    <span class="p">}</span><span class="k">else</span> <span class="p">{</span><span class="k">return</span> <span class="nx">root</span><span class="p">}</span><span class="c1">//当前节点的值在给定值的中间（或者等于），即为最深的祖先
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="插入操作">插入操作</h3>
<p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">递归法</span>

<span class="kd">func</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">root</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="nx">val</span><span class="p">}</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&gt;</span> <span class="nx">val</span> <span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span> <span class="nx">val</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>迭代法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">insertIntoBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span><span class="nx">val</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">node</span> <span class="o">:=</span> <span class="nx">root</span>
    <span class="kd">var</span> <span class="nx">pnode</span> <span class="o">*</span><span class="nx">TreeNode</span>
    <span class="k">for</span> <span class="nx">node</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">val</span> <span class="p">&gt;</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
            <span class="nx">pnode</span> <span class="p">=</span> <span class="nx">node</span>
            <span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">pnode</span> <span class="p">=</span> <span class="nx">node</span>
            <span class="nx">node</span> <span class="p">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">val</span> <span class="p">&gt;</span> <span class="nx">pnode</span><span class="p">.</span><span class="nx">Val</span> <span class="p">{</span>
        <span class="nx">pnode</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="nx">val</span><span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">pnode</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">Val</span><span class="p">:</span> <span class="nx">val</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="删除节点">删除节点</h3>
<p>搜索树的节点删除要比节点增加复杂的多。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// 递归版本
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">key</span><span class="p">&lt;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">=</span><span class="nf">deleteNode</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">key</span><span class="p">&gt;</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">{</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nf">deleteNode</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">root</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
    <span class="p">}</span>
    <span class="nx">minnode</span><span class="o">:=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
    <span class="k">for</span> <span class="nx">minnode</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nx">minnode</span><span class="p">=</span><span class="nx">minnode</span><span class="p">.</span><span class="nx">Left</span>
    <span class="p">}</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">=</span><span class="nx">minnode</span><span class="p">.</span><span class="nx">Val</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nf">deleteNode1</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deleteNode1</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span><span class="o">*</span><span class="nx">TreeNode</span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="nx">pRight</span><span class="o">:=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
        <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="kc">nil</span>
        <span class="k">return</span> <span class="nx">pRight</span>
    <span class="p">}</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">=</span><span class="nf">deleteNode1</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
<span class="c1">// 迭代版本
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">deleteOneNode</span><span class="p">(</span><span class="nx">target</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">target</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">target</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Right</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Left</span>
	<span class="p">}</span>
	<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Right</span>
	<span class="k">for</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span>
	<span class="p">}</span>
	<span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Left</span>
	<span class="k">return</span> <span class="nx">target</span><span class="p">.</span><span class="nx">Right</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
	<span class="c1">// 特殊情况处理
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">root</span>
	<span class="p">}</span>
	<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">root</span>
	<span class="kd">var</span> <span class="nx">pre</span> <span class="o">*</span><span class="nx">TreeNode</span>
	<span class="k">for</span> <span class="nx">cur</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>
		<span class="nx">pre</span> <span class="p">=</span> <span class="nx">cur</span>
		<span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&gt;</span> <span class="nx">key</span> <span class="p">{</span>
			<span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pre</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">deleteOneNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// pre 要知道是删除左孩子还有右孩子
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Left</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
		<span class="nx">pre</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nf">deleteOneNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Right</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Val</span> <span class="o">==</span> <span class="nx">key</span> <span class="p">{</span>
		<span class="nx">pre</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nf">deleteOneNode</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="修剪">修剪</h3>
<p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 递归
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">low</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">low</span><span class="p">{</span><span class="c1">//如果该节点值小于最小值，则该节点更换为该节点的右节点值，继续遍历
</span><span class="c1"></span>        <span class="nx">right</span><span class="o">:=</span><span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">right</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">high</span><span class="p">{</span><span class="c1">//如果该节点的值大于最大值，则该节点更换为该节点的左节点值，继续遍历
</span><span class="c1"></span>        <span class="nx">left</span><span class="o">:=</span><span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">left</span>
    <span class="p">}</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">=</span><span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
    <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">low</span><span class="p">,</span><span class="nx">high</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>

<span class="c1">// 迭代
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">trimBST</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span> <span class="nx">low</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">high</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="c1">// 处理 root，让 root 移动到[low, high] 范围内，**注意**是左闭右闭
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">root</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&lt;</span><span class="nx">low</span><span class="o">||</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="p">&gt;</span><span class="nx">high</span><span class="p">){</span>
        <span class="k">if</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">low</span><span class="p">{</span>
            <span class="nx">root</span> <span class="p">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="nx">root</span> <span class="p">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">root</span>
    <span class="c1">// 此时 root 已经在[low, high] 范围内，处理左孩子元素小于 low 的情况（左节点是一定小于 root.Val，因此天然小于 high）
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">cur</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span><span class="o">!=</span><span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&lt;</span> <span class="nx">low</span><span class="p">{</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span><span class="p">.</span><span class="nx">Right</span>
        <span class="p">}</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Left</span>
    <span class="p">}</span>
    <span class="nx">cur</span> <span class="p">=</span> <span class="nx">root</span>
    <span class="c1">// 此时 root 已经在[low, high] 范围内，处理右孩子大于 high 的情况
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">cur</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">{</span>
        <span class="k">for</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span><span class="o">!=</span><span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Val</span> <span class="p">&gt;</span> <span class="nx">high</span><span class="p">{</span>
            <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span><span class="p">.</span><span class="nx">Left</span>
        <span class="p">}</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">Right</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="将有序数组转化为二叉搜索树">将有序数组转化为二叉搜索树</h3>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">递归</span><span class="err">（</span><span class="nx">隐含回溯</span><span class="err">）</span>

<span class="kd">func</span> <span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span><span class="c1">//终止条件，最后数组为空则可以返回
</span><span class="c1"></span>    <span class="nx">root</span><span class="o">:=&amp;</span><span class="nx">TreeNode</span><span class="p">{</span><span class="nx">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span><span class="kc">nil</span><span class="p">,</span><span class="kc">nil</span><span class="p">}</span><span class="c1">//按照BSL的特点，从中间构造节点
</span><span class="c1"></span>    <span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">=</span><span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">])</span><span class="c1">//数组的左边为左子树
</span><span class="c1"></span>    <span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">=</span><span class="nf">sortedArrayToBST</span><span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">nums</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span><span class="c1">//数字的右边为右子树
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="把二叉搜索树转化为累加树">把二叉搜索树转化为累加树</h3>
<p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>弄一个sum暂存其和值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"> <span class="c1">//右中左
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bstToGst</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
     <span class="kd">var</span> <span class="nx">sum</span> <span class="kt">int</span>
     <span class="nf">RightMLeft</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span><span class="o">&amp;</span><span class="nx">sum</span><span class="p">)</span>
     <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">RightMLeft</span><span class="p">(</span><span class="nx">root</span> <span class="o">*</span><span class="nx">TreeNode</span><span class="p">,</span><span class="nx">sum</span> <span class="o">*</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">TreeNode</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">root</span><span class="o">==</span><span class="kc">nil</span><span class="p">{</span><span class="k">return</span> <span class="kc">nil</span><span class="p">}</span><span class="c1">//终止条件，遇到空节点就返回
</span><span class="c1"></span>    <span class="nf">RightMLeft</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Right</span><span class="p">,</span><span class="nx">sum</span><span class="p">)</span><span class="c1">//先遍历右边
</span><span class="c1"></span>    <span class="nx">temp</span><span class="o">:=*</span><span class="nx">sum</span><span class="c1">//暂存总和值
</span><span class="c1"></span>    <span class="o">*</span><span class="nx">sum</span><span class="o">+=</span><span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="c1">//将总和值变更
</span><span class="c1"></span>    <span class="nx">root</span><span class="p">.</span><span class="nx">Val</span><span class="o">+=</span><span class="nx">temp</span><span class="c1">//更新节点值
</span><span class="c1"></span>    <span class="nf">RightMLeft</span><span class="p">(</span><span class="nx">root</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span><span class="nx">sum</span><span class="p">)</span><span class="c1">//遍历左节点
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">root</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-10-08 19:55:40&nbsp;<a class="git-hash" href="https://github.com/dillonzq/LoveIt/commit/08d4d6cf8a78e5a1cb353b041919a9e49a704d6a" target="_blank" title="commit by JF-011101(2838264218@qq.com) 08d4d6cf8a78e5a1cb353b041919a9e49a704d6a: feat">
                                    <i class="fas fa-hashtag fa-fw"></i>08d4d6c</a></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/algorithm_binarytree/" data-title="Algorithm_binaryTree" data-hashtags="data structure"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/algorithm_binarytree/" data-hashtag="data structure"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/algorithm_binarytree/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/algorithm_binarytree/" data-title="Algorithm_binaryTree"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/algorithm_binarytree/" data-title="Algorithm_binaryTree"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/algorithm_binarytree/" data-title="Algorithm_binaryTree"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/data-structure/">data structure</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/algorithm_stackandqueue/" class="prev" rel="prev" title="Algorithm_stackAndQueue"><i class="fas fa-angle-left fa-fw"></i>Algorithm_stackAndQueue</a>
            <a href="/algorithm_backtracking/" class="next" rel="next" title="Algorithm_backTracking">Algorithm_backTracking<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
