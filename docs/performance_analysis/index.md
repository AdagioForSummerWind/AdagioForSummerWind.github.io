# Performance_analysis

# 算法性能分析
## 03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。

### 为什么需要复杂度分析？

你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫事后统计法。但是，这种统计方法有非常大的局限性。

1. 测试结果非常依赖测试环境
2. 测试结果受数据规模的影响很大

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是我们今天要讲的时间、空间复杂度分析方法。


### 时间复杂度分析

 只关注循环执行次数最多的一段代码

 加法法则：总复杂度等于量级最大的那段代码的复杂度

乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 空间复杂度分析

时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。





## 时间复杂度
- 时间复杂度是定性描述算法运行时间的函数。
- 实际情况中会因为数据用例、数据规模不同而变化，一般讨论一般情况。
- 时间复杂度$O(log(n))$并不以某一个确定的数为底数，因为可以通过乘以某个对数常数达到换底数的效果。

递归算法的时间复杂度：递归次数*每次递归的时间复杂度（操作的次数）
## 空间复杂度分析
空间复杂度：程序运行时占用内存的大小，受很多因素的影响，比如编译器的内存对齐，编程语言容器的底层实现等

递归算法的空间复杂度：递归深度*每次递归的空间复杂度
- 递归所需的空间都被压到调用栈里，一次递归结束，这个栈就是就是把本次递归的数据弹出去。所以这个栈最大的长度就是递归的深度。
## 算法复杂度主方法
主方法亦可称为主定理。适用于求那些用分治法以及有递推关系式的算法的复杂度。

假设有递推关系式：$T(n)=aT(n/b)+f(n)$ 
- n是问题规模
- a为递推的子问题数量
- n/b是每个子问题的规模，假设每个子问题规模一致
- f(n)为递推以外进行的计算工作
- T(n)为非负整数

分类讨论：
- 若$f(n)=O(n^{log_b(a-e)}),e>0$
    - 则$T(n)=Θ(n^{log_b(a)})$
- 若$f(n)=Θ(n^{log_b(a)})$
    - 则$T(n)=Θ(n^{log_b(a)}log(n))$
- 若$f(n)=Ω(n^{log_b(a+e)}),e>0$，且对于某个常数c < 1和所有充分大的n有$af(n/b)<=cf(n)$，
    - 则$T(n)=Θ(f(n))$

不是很容易记忆。下面有一种简化的版本：

若算法运行时间$T(n)<=aT(n/b)+O(n^d)$
- a>=1是子问题的个数，b>=1是输入规模减小的倍数，d>=0是递归过程之外的步骤的时间复杂度指数，则：
- ![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220303125128.png)
## 代码的内存消耗
每种语言都有着自己的内存管理方式。
### 内存对齐

对于各种基本数据类型来说，它的变量的内存地址值必须是其类型本身大小的整数倍。在go里面，对于结构体而言，它的变量的内存地址，只要是它最长字段长度与系统对齐系数两者之间较小的那个的整数倍就可以了。但对于结构体类型来说，我们还要让它每个字段的内存地址都严格满足内存对齐要求。

举个例子：
```go
type T struct {
    b byte

    i int64
    u uint16
}
```
- 64bit平台系统对齐系数是8
- 计算过程：sum=1+7+8+2+6
- 第一个阶段是对齐结构体的各个字段:
    - 首先，我们看第一个字段 b 是长度 1 个字节的 byte 类型变量，这样字段 b 放在任意地址上都可以被 1 整除，所以我们说它是天生对齐的。我们用一个 sum 来表示当前已经对齐的内存空间的大小，这个时候 sum=1；
    - 接下来，我们看第二个字段 i，它是一个长度为 8 个字节的 int64 类型变量。按照内存对齐要求，它应该被放在可以被 8 整除的地址上。但是，如果把 i 紧邻 b 进行分配，当 i 的地址可以被 8 整除时，b 的地址就无法被 8 整除。这个时候，我们需要在 b 与 i 之间做一些填充，使得 i 的地址可以被 8 整除时，b 的地址也始终可以被 8 整除，于是我们在 i 与 b 之间填充了 7 个字节，此时此刻 sum=1+7+8；
    - 再下来，我们看第三个字段 u，它是一个长度为 2 个字节的 uint16 类型变量，按照内存对其要求，它应该被放在可以被 2 整除的地址上。有了对其的 i 作为基础，我们现在知道将 u 与 i 相邻而放，是可以满足其地址的对齐要求的。i 之后的那个字节的地址肯定可以被 8 整除，也一定可以被 2 整除。于是我们把 u 直接放在 i 的后面，中间不需要填充，此时此刻，sum=1+7+8+2。
- 结构体 T 的所有字段都已经对齐了，开始第二个阶段，也就是对齐整个结构体:
    - 结构体的内存地址为 min（结构体最长字段的长度，系统内存对齐系数）的整数倍，那么这里结构体 T 最长字段为 i，它的长度为 8，而 64bit 系统上的系统内存对齐系数一般为 8，两者相同，我们取 8 就可以了。那么整个结构体的对齐系数就是 8。
    - 在尾部填充6字节原因：
        - 结构体 T 的对齐系数是 8，那么我们就要保证每个结构体 T 的变量的内存地址，都能被 8 整除。如果我们只分配一个 T 类型变量，不再继续填充，也可能保证其内存地址为 8 的倍数。但如果考虑我们分配的是一个元素为 T 类型的数组，数组是元素连续存储的一种类型，元素 T[1]的地址为 T[0]地址 +T 的大小 (18)，显然无法被 8 整除，这将导致 T[1]及后续元素的地址都无法对齐，这显然不能满足内存对齐的要求。

所以，**定义结构体时，一定要**注意**结构体中字段顺序，尽量合理排序，降低结构体对内存空间的占用。**

前面例子中的内存填充部分，是由编译器自动完成的。不过，有些时候，为了保证某个字段的内存地址有更为严格的约束，我们也会做主动填充。比如 runtime 包中的 mstats 结构体定义就采用了主动填充：
```go
// $GOROOT/src/runtime/mstats.go
type mstats struct {
    ... ...
    // Add an uint32 for even number of size classes to align below fields
    // to 64 bits for atomic operations on 32 bit platforms.
    _ [1 - _NumSizeClasses%2]uint32 // 这里做了主动填充,通常我们会通过空标识符来进行主动填充

    last_gc_nanotime uint64 // last gc (monotonic time)
    last_heap_inuse  uint64 // heap_inuse at mark termination of the previous GC
    ... ...
}
```
为什么会有内存对齐？
- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。
- **硬件原因**：经过内存对齐后，CPU访问内存的速度大大提升

CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。

只要可以跨平台的编程语言都需要做内存对齐，不做内存对齐会使运行速度下降，因为寻址访存次数多了。现在的编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。
### go语言的内存管理
显然，go的内存管理内部机制建立于操作系统以及机器硬件如何管理内存之上的。尽可能扬长避短。

介绍一下和开发者关系较大的操作系统内存管理机制。
暂停
