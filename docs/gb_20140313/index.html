<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Gb_20140313 - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Gb_20140313" />
<meta property="og:description" content="Go Concurrency Patterns: Pipelines and cancellation Sameer Ajmani
13 March 2014
Introduction Go’s concurrency primitives make it easy to construct streaming data pipelines that make efficient use of I/O and multiple CPUs. This article presents examples of such pipelines, highlights subtleties that arise when operations fail, and introduces techniques for dealing with failures cleanly.
What is a pipeline? There’s no formal definition of a pipeline in Go; it’s just one of many kinds of concurrent programs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/gb_20140313/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-24T09:08:12+08:00" />
<meta property="article:modified_time" content="2022-10-29T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Gb_20140313"/>
<meta name="twitter:description" content="Go Concurrency Patterns: Pipelines and cancellation Sameer Ajmani
13 March 2014
Introduction Go’s concurrency primitives make it easy to construct streaming data pipelines that make efficient use of I/O and multiple CPUs. This article presents examples of such pipelines, highlights subtleties that arise when operations fail, and introduces techniques for dealing with failures cleanly.
What is a pipeline? There’s no formal definition of a pipeline in Go; it’s just one of many kinds of concurrent programs."/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/gb_20140313/" /><link rel="prev" href="https://jefofrank.xyz/gb_20140224/" /><link rel="next" href="https://jefofrank.xyz/gb_20140324/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Gb_20140313",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/gb_20140313\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "go official blogs","wordcount":  3335 ,
        "url": "https:\/\/jefofrank.xyz\/gb_20140313\/","datePublished": "2022-10-24T09:08:12+08:00","dateModified": "2022-10-29T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Gb_20140313</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/2022/"><i class="far fa-folder fa-fw"></i>2022</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-10-24 09:08:12">2022-10-24 09:08:12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3335 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#what-is-a-pipeline">What is a pipeline?</a></li>
    <li><a href="#squaring-numbers">Squaring numbers</a></li>
    <li><a href="#fan-out-fan-in">Fan-out, fan-in</a></li>
    <li><a href="#stopping-short">Stopping short</a></li>
    <li><a href="#explicit-cancellation">Explicit cancellation</a></li>
    <li><a href="#digesting-a-tree">Digesting a tree</a></li>
    <li><a href="#parallel-digestion">Parallel digestion</a></li>
    <li><a href="#bounded-parallelism">Bounded parallelism</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="go-concurrency-patterns-pipelines-and-cancellation">Go Concurrency Patterns: Pipelines and cancellation</h1>
<p>Sameer Ajmani<br>
13 March 2014</p>
<h2 id="introduction">Introduction</h2>
<p>Go’s concurrency primitives make it easy to construct streaming data pipelines that make efficient use of I/O and multiple CPUs. This article presents examples of such pipelines, highlights subtleties that arise when operations fail, and introduces techniques for dealing with failures cleanly.</p>
<h2 id="what-is-a-pipeline">What is a pipeline?</h2>
<p>There’s no formal definition of a pipeline in Go; it’s just one of many kinds of concurrent programs. Informally, a pipeline is a series of <em>stages</em> connected by channels, where each stage is a group of goroutines running the same function. In each stage, the goroutines</p>
<ul>
<li>receive values from <em>upstream</em> via <em>inbound</em> channels</li>
<li>perform some function on that data, usually producing new values</li>
<li>send values <em>downstream</em> via <em>outbound</em> channels</li>
</ul>
<p>Each stage has any number of inbound and outbound channels, except the first and last stages, which have only outbound or inbound channels, respectively. The first stage is sometimes called the <em>source</em> or <em>producer</em>; the last stage, the <em>sink</em> or <em>consumer</em>.</p>
<p>We’ll begin with a simple example pipeline to explain the ideas and techniques. Later, we’ll present a more realistic example.</p>
<h2 id="squaring-numbers">Squaring numbers</h2>
<p>Consider a pipeline with three stages.</p>
<p>The first stage, <code>gen</code>, is a function that converts a list of integers to a channel that emits the integers in the list. The <code>gen</code> function starts a goroutine that sends the integers on the channel and closes the channel when all the values have been sent:</p>
<p>func gen(nums &hellip;int) &lt;-chan int {
out := make(chan int)
go func() {
for _, n := range nums {
out &lt;- n
}
close(out)
}()
return out
}</p>
<p>The second stage, <code>sq</code>, receives integers from a channel and returns a channel that emits the square of each received integer. After the inbound channel is closed and this stage has sent all the values downstream, it closes the outbound channel:</p>
<p>func sq(in &lt;-chan int) &lt;-chan int {
out := make(chan int)
go func() {
for n := range in {
out &lt;- n * n
}
close(out)
}()
return out
}</p>
<p>The <code>main</code> function sets up the pipeline and runs the final stage: it receives values from the second stage and prints each one, until the channel is closed:</p>
<p>func main() {
// Set up the pipeline.
c := gen(2, 3)
out := sq(c)</p>
<pre><code>// Consume the output.
fmt.Println(&lt;-out) // 4
fmt.Println(&lt;-out) // 9
</code></pre>
<p>}</p>
<p>Since <code>sq</code> has the same type for its inbound and outbound channels, we can compose it any number of times. We can also rewrite <code>main</code> as a range loop, like the other stages:</p>
<p>func main() {
// Set up the pipeline and consume the output.
for n := range sq(sq(gen(2, 3))) {
fmt.Println(n) // 16 then 81
}
}</p>
<h2 id="fan-out-fan-in">Fan-out, fan-in</h2>
<p>Multiple functions can read from the same channel until that channel is closed; this is called <em>fan-out</em>. This provides a way to distribute work amongst a group of workers to parallelize CPU use and I/O.</p>
<p>A function can read from multiple inputs and proceed until all are closed by multiplexing the input channels onto a single channel that’s closed when all the inputs are closed. This is called <em>fan-in</em>.</p>
<p>We can change our pipeline to run two instances of <code>sq</code>, each reading from the same input channel. We introduce a new function, <em>merge</em>, to fan in the results:</p>
<p>func main() {
in := gen(2, 3)</p>
<pre><code>// Distribute the sq work across two goroutines that both read from in.
c1 := sq(in)
c2 := sq(in)

// Consume the merged output from c1 and c2.
for n := range merge(c1, c2) {
    fmt.Println(n) // 4 then 9, or 9 then 4
}
</code></pre>
<p>}</p>
<p>The <code>merge</code> function converts a list of channels to a single channel by starting a goroutine for each inbound channel that copies the values to the sole outbound channel. Once all the <code>output</code> goroutines have been started, <code>merge</code> starts one more goroutine to close the outbound channel after all sends on that channel are done.</p>
<p>Sends on a closed channel panic, so it’s important to ensure all sends are done before calling close. The <a href="https://go.dev/pkg/sync/#WaitGroup" target="_blank" rel="noopener noreffer"><code>sync.WaitGroup</code></a> type provides a simple way to arrange this synchronization:</p>
<p>func merge(cs &hellip;&lt;-chan int) &lt;-chan int {
var wg sync.WaitGroup
out := make(chan int)</p>
<pre><code>// Start an output goroutine for each input channel in cs.  output
// copies values from c to out until c is closed, then calls wg.Done.
output := func(c &lt;-chan int) {
    for n := range c {
        out &lt;- n
    }
    wg.Done()
}
wg.Add(len(cs))
for \_, c := range cs {
    go output(c)
}

// Start a goroutine to close out once all the output goroutines are
// done.  This must start after the wg.Add call.
go func() {
    wg.Wait()
    close(out)
}()
return out
</code></pre>
<p>}</p>
<h2 id="stopping-short">Stopping short</h2>
<p>There is a pattern to our pipeline functions:</p>
<ul>
<li>stages close their outbound channels when all the send operations are done.</li>
<li>stages keep receiving values from inbound channels until those channels are closed.</li>
</ul>
<p>This pattern allows each receiving stage to be written as a <code>range</code> loop and ensures that all goroutines exit once all values have been successfully sent downstream.</p>
<p>But in real pipelines, stages don’t always receive all the inbound values. Sometimes this is by design: the receiver may only need a subset of values to make progress. More often, a stage exits early because an inbound value represents an error in an earlier stage. In either case the receiver should not have to wait for the remaining values to arrive, and we want earlier stages to stop producing values that later stages don’t need.</p>
<p>In our example pipeline, if a stage fails to consume all the inbound values, the goroutines attempting to send those values will block indefinitely:</p>
<pre><code>// Consume the first value from the output.
out := merge(c1, c2)
fmt.Println(&lt;-out) // 4 or 9
return
// Since we didn't receive the second value from out,
// one of the output goroutines is hung attempting to send it.
</code></pre>
<p>}</p>
<p>This is a resource leak: goroutines consume memory and runtime resources, and heap references in goroutine stacks keep data from being garbage collected. Goroutines are not garbage collected; they must exit on their own.</p>
<p>We need to arrange for the upstream stages of our pipeline to exit even when the downstream stages fail to receive all the inbound values. One way to do this is to change the outbound channels to have a buffer. A buffer can hold a fixed number of values; send operations complete immediately if there’s room in the buffer:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">c := make(chan int, 2) // buffer size 2
c &lt;- 1  // succeeds immediately
c &lt;- 2  // succeeds immediately
c &lt;- 3  // blocks until another goroutine does &lt;-c and receives 1
</code></pre></td></tr></table>
</div>
</div><p>When the number of values to be sent is known at channel creation time, a buffer can simplify the code. For example, we can rewrite <code>gen</code> to copy the list of integers into a buffered channel and avoid creating a new goroutine:</p>
<p>func gen(nums &hellip;int) &lt;-chan int {
out := make(chan int, len(nums))
for _, n := range nums {
out &lt;- n
}
close(out)
return out
}</p>
<p>Returning to the blocked goroutines in our pipeline, we might consider adding a buffer to the outbound channel returned by <code>merge</code>:</p>
<p>func merge(cs &hellip;&lt;-chan int) &lt;-chan int {
var wg sync.WaitGroup
out := make(chan int, 1) // enough space for the unread inputs
// &hellip; the rest is unchanged &hellip;</p>
<p>While this fixes the blocked goroutine in this program, this is bad code. The choice of buffer size of 1 here depends on knowing the number of values <code>merge</code> will receive and the number of values downstream stages will consume. This is fragile: if we pass an additional value to <code>gen</code>, or if the downstream stage reads any fewer values, we will again have blocked goroutines.</p>
<p>Instead, we need to provide a way for downstream stages to indicate to the senders that they will stop accepting input.</p>
<h2 id="explicit-cancellation">Explicit cancellation</h2>
<p>When <code>main</code> decides to exit without receiving all the values from <code>out</code>, it must tell the goroutines in the upstream stages to abandon the values they’re trying to send. It does so by sending values on a channel called <code>done</code>. It sends two values since there are potentially two blocked senders:</p>
<p>func main() {
in := gen(2, 3)</p>
<pre><code>// Distribute the sq work across two goroutines that both read from in.
c1 := sq(in)
c2 := sq(in)

// Consume the first value from output.
done := make(chan struct{}, 2)
out := merge(done, c1, c2)
fmt.Println(&lt;-out) // 4 or 9

// Tell the remaining senders we're leaving.
done &lt;- struct{}{}
done &lt;- struct{}{}
</code></pre>
<p>}</p>
<p>The sending goroutines replace their send operation with a <code>select</code> statement that proceeds either when the send on <code>out</code> happens or when they receive a value from <code>done</code>. The value type of <code>done</code> is the empty struct because the value doesn’t matter: it is the receive event that indicates the send on <code>out</code> should be abandoned. The <code>output</code> goroutines continue looping on their inbound channel, <code>c</code>, so the upstream stages are not blocked. (We’ll discuss in a moment how to allow this loop to return early.)</p>
<p>func merge(done &lt;-chan struct{}, cs &hellip;&lt;-chan int) &lt;-chan int {
var wg sync.WaitGroup
out := make(chan int)</p>
<pre><code>// Start an output goroutine for each input channel in cs.  output
// copies values from c to out until c is closed or it receives a value
// from done, then output calls wg.Done.
output := func(c &lt;-chan int) {
    for n := range c {
        select {
        case out &lt;- n:
        case &lt;-done:
        }
    }
    wg.Done()
}
// ... the rest is unchanged ...
</code></pre>
<p>This approach has a problem: <em>each</em> downstream receiver needs to know the number of potentially blocked upstream senders and arrange to signal those senders on early return. Keeping track of these counts is tedious and error-prone.</p>
<p>We need a way to tell an unknown and unbounded number of goroutines to stop sending their values downstream. In Go, we can do this by closing a channel, because <a href="https://go.dev/ref/spec#Receive_operator" target="_blank" rel="noopener noreffer">a receive operation on a closed channel can always proceed immediately, yielding the element type’s zero value.</a></p>
<p>This means that <code>main</code> can unblock all the senders simply by closing the <code>done</code> channel. This close is effectively a broadcast signal to the senders. We extend <em>each</em> of our pipeline functions to accept <code>done</code> as a parameter and arrange for the close to happen via a <code>defer</code> statement, so that all return paths from <code>main</code> will signal the pipeline stages to exit.</p>
<p>func main() {
// Set up a done channel that&rsquo;s shared by the whole pipeline,
// and close that channel when this pipeline exits, as a signal
// for all the goroutines we started to exit.
done := make(chan struct{})
defer close(done)</p>
<pre><code>in := gen(done, 2, 3)

// Distribute the sq work across two goroutines that both read from in.
c1 := sq(done, in)
c2 := sq(done, in)

// Consume the first value from output.
out := merge(done, c1, c2)
fmt.Println(&lt;-out) // 4 or 9

// done will be closed by the deferred call. 
</code></pre>
<p>}</p>
<p>Each of our pipeline stages is now free to return as soon as <code>done</code> is closed. The <code>output</code> routine in <code>merge</code> can return without draining its inbound channel, since it knows the upstream sender, <code>sq</code>, will stop attempting to send when <code>done</code> is closed. <code>output</code> ensures <code>wg.Done</code> is called on all return paths via a <code>defer</code> statement:</p>
<p>func merge(done &lt;-chan struct{}, cs &hellip;&lt;-chan int) &lt;-chan int {
var wg sync.WaitGroup
out := make(chan int)</p>
<pre><code>// Start an output goroutine for each input channel in cs.  output
// copies values from c to out until c or done is closed, then calls
// wg.Done.
output := func(c &lt;-chan int) {
    defer wg.Done()
    for n := range c {
        select {
        case out &lt;- n:
        case &lt;-done:
            return
        }
    }
}
// ... the rest is unchanged ...
</code></pre>
<p>Similarly, <code>sq</code> can return as soon as <code>done</code> is closed. <code>sq</code> ensures its <code>out</code> channel is closed on all return paths via a <code>defer</code> statement:</p>
<p>func sq(done &lt;-chan struct{}, in &lt;-chan int) &lt;-chan int {
out := make(chan int)
go func() {
defer close(out)
for n := range in {
select {
case out &lt;- n * n:
case &lt;-done:
return
}
}
}()
return out
}</p>
<p>Here are the guidelines for pipeline construction:</p>
<ul>
<li>stages close their outbound channels when all the send operations are done.</li>
<li>stages keep receiving values from inbound channels until those channels are closed or the senders are unblocked.</li>
</ul>
<p>Pipelines unblock senders either by ensuring there’s enough buffer for all the values that are sent or by explicitly signalling senders when the receiver may abandon the channel.</p>
<h2 id="digesting-a-tree">Digesting a tree</h2>
<p>Let’s consider a more realistic pipeline.</p>
<p>MD5 is a message-digest algorithm that’s useful as a file checksum. The command line utility <code>md5sum</code> prints digest values for a list of files.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">% md5sum *.go
d47c2bbc28298ca9befdfbc5d3aa4e65  bounded.go
ee869afd31f83cbb2d10ee81b2b831dc  parallel.go
b88175e65fdcbc01ac08aaf1fd9b5e96  serial.go
</code></pre></td></tr></table>
</div>
</div><p>Our example program is like <code>md5sum</code> but instead takes a single directory as an argument and prints the digest values for each regular file under that directory, sorted by path name.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">% go run serial.go .
d47c2bbc28298ca9befdfbc5d3aa4e65  bounded.go
ee869afd31f83cbb2d10ee81b2b831dc  parallel.go
b88175e65fdcbc01ac08aaf1fd9b5e96  serial.go
</code></pre></td></tr></table>
</div>
</div><p>The main function of our program invokes a helper function <code>MD5All</code>, which returns a map from path name to digest value, then sorts and prints the results:</p>
<p>func main() {
// Calculate the MD5 sum of all files under the specified directory,
// then print the results sorted by path name.
m, err := MD5All(os.Args[1])
if err != nil {
fmt.Println(err)
return
}
var paths []string
for path := range m {
paths = append(paths, path)
}
sort.Strings(paths)
for _, path := range paths {
fmt.Printf(&quot;%x  %s\n&quot;, m[path], path)
}
}</p>
<p>The <code>MD5All</code> function is the focus of our discussion. In <a href="https://go.dev/blog/pipelines/serial.go" target="_blank" rel="noopener noreffer">serial.go</a>, the implementation uses no concurrency and simply reads and sums each file as it walks the tree.</p>
<p>// MD5All reads all the files in the file tree rooted at root and returns a map
// from file path to the MD5 sum of the file&rsquo;s contents.  If the directory walk
// fails or any read operation fails, MD5All returns an error.
func MD5All(root string) (map[string][md5.Size]byte, error) {
m := make(map[string][md5.Size]byte)
err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
if err != nil {
return err
}
if !info.Mode().IsRegular() {
return nil
}
data, err := ioutil.ReadFile(path)
if err != nil {
return err
}
m[path] = md5.Sum(data)
return nil
})
if err != nil {
return nil, err
}
return m, nil
}</p>
<h2 id="parallel-digestion">Parallel digestion</h2>
<p>In <a href="https://go.dev/blog/pipelines/parallel.go" target="_blank" rel="noopener noreffer">parallel.go</a>, we split <code>MD5All</code> into a two-stage pipeline. The first stage, <code>sumFiles</code>, walks the tree, digests each file in a new goroutine, and sends the results on a channel with value type <code>result</code>:</p>
<p>type result struct {
path string
sum  [md5.Size]byte
err  error
}</p>
<p><code>sumFiles</code> returns two channels: one for the <code>results</code> and another for the error returned by <code>filepath.Walk</code>. The walk function starts a new goroutine to process each regular file, then checks <code>done</code>. If <code>done</code> is closed, the walk stops immediately:</p>
<p>func sumFiles(done &lt;-chan struct{}, root string) (&lt;-chan result, &lt;-chan error) {
// For each regular file, start a goroutine that sums the file and sends
// the result on c.  Send the result of the walk on errc.
c := make(chan result)
errc := make(chan error, 1)
go func() {
var wg sync.WaitGroup
err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
if err != nil {
return err
}
if !info.Mode().IsRegular() {
return nil
}
wg.Add(1)
go func() {
data, err := ioutil.ReadFile(path)
select {
case c &lt;- result{path, md5.Sum(data), err}:
case &lt;-done:
}
wg.Done()
}()
// Abort the walk if done is closed.
select {
case &lt;-done:
return errors.New(&ldquo;walk canceled&rdquo;)
default:
return nil
}
})
// Walk has returned, so all calls to wg.Add are done.  Start a
// goroutine to close c once all the sends are done.
go func() {
wg.Wait()
close(c)
}()
// No select needed here, since errc is buffered.
errc &lt;- err
}()
return c, errc
}</p>
<p><code>MD5All</code> receives the digest values from <code>c</code>. <code>MD5All</code> returns early on error, closing <code>done</code> via a <code>defer</code>:</p>
<p>func MD5All(root string) (map[string][md5.Size]byte, error) {
// MD5All closes the done channel when it returns; it may do so before
// receiving all the values from c and errc.
done := make(chan struct{})
defer close(done)</p>
<pre><code>c, errc := sumFiles(done, root)

m := make(map\[string\]\[md5.Size\]byte)
for r := range c {
    if r.err != nil {
        return nil, r.err
    }
    m\[r.path\] = r.sum
}
if err := &lt;-errc; err != nil {
    return nil, err
}
return m, nil
</code></pre>
<p>}</p>
<h2 id="bounded-parallelism">Bounded parallelism</h2>
<p>The <code>MD5All</code> implementation in <a href="https://go.dev/blog/pipelines/parallel.go" target="_blank" rel="noopener noreffer">parallel.go</a> starts a new goroutine for each file. In a directory with many large files, this may allocate more memory than is available on the machine.</p>
<p>We can limit these allocations by bounding the number of files read in parallel. In <a href="https://go.dev/blog/pipelines/bounded.go" target="_blank" rel="noopener noreffer">bounded.go</a>, we do this by creating a fixed number of goroutines for reading files. Our pipeline now has three stages: walk the tree, read and digest the files, and collect the digests.</p>
<p>The first stage, <code>walkFiles</code>, emits the paths of regular files in the tree:</p>
<p>func walkFiles(done &lt;-chan struct{}, root string) (&lt;-chan string, &lt;-chan error) {
paths := make(chan string)
errc := make(chan error, 1)
go func() {
// Close the paths channel after Walk returns.
defer close(paths)
// No select needed for this send, since errc is buffered.
errc &lt;- filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
if err != nil {
return err
}
if !info.Mode().IsRegular() {
return nil
}
select {
case paths &lt;- path:
case &lt;-done:
return errors.New(&ldquo;walk canceled&rdquo;)
}
return nil
})
}()
return paths, errc
}</p>
<p>The middle stage starts a fixed number of <code>digester</code> goroutines that receive file names from <code>paths</code> and send <code>results</code> on channel <code>c</code>:</p>
<p>func digester(done &lt;-chan struct{}, paths &lt;-chan string, c chan&lt;- result) {
for path := range paths {
data, err := ioutil.ReadFile(path)
select {
case c &lt;- result{path, md5.Sum(data), err}:
case &lt;-done:
return
}
}
}</p>
<p>Unlike our previous examples, <code>digester</code> does not close its output channel, as multiple goroutines are sending on a shared channel. Instead, code in <code>MD5All</code> arranges for the channel to be closed when all the <code>digesters</code> are done:</p>
<pre><code>// Start a fixed number of goroutines to read and digest files.
c := make(chan result)
var wg sync.WaitGroup
const numDigesters = 20
wg.Add(numDigesters)
for i := 0; i &lt; numDigesters; i++ {
    go func() {
        digester(done, paths, c)
        wg.Done()
    }()
}
go func() {
    wg.Wait()
    close(c)
}()
</code></pre>
<p>We could instead have each digester create and return its own output channel, but then we would need additional goroutines to fan-in the results.</p>
<p>The final stage receives all the <code>results</code> from <code>c</code> then checks the error from <code>errc</code>. This check cannot happen any earlier, since before this point, <code>walkFiles</code> may block sending values downstream:</p>
<pre><code>m := make(map\[string\]\[md5.Size\]byte)
for r := range c {
    if r.err != nil {
        return nil, r.err
    }
    m\[r.path\] = r.sum
}
// Check whether the Walk failed.
if err := &lt;-errc; err != nil {
    return nil, err
}
return m, nil
</code></pre>
<p>}</p>
<h2 id="conclusion">Conclusion</h2>
<p>This article has presented techniques for constructing streaming data pipelines in Go. Dealing with failures in such pipelines is tricky, since each stage in the pipeline may block attempting to send values downstream, and the downstream stages may no longer care about the incoming data. We showed how closing a channel can broadcast a “done” signal to all the goroutines started by a pipeline and defined guidelines for constructing pipelines correctly.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://go.dev/talks/2012/concurrency.slide#1" target="_blank" rel="noopener noreffer">Go Concurrency Patterns</a> (<a href="https://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank" rel="noopener noreffer">video</a>) presents the basics of Go’s concurrency primitives and several ways to apply them.</li>
<li><a href="https://blog.golang.org/advanced-go-concurrency-patterns" target="_blank" rel="noopener noreffer">Advanced Go Concurrency Patterns</a> (<a href="http://www.youtube.com/watch?v=QDDwwePbDtw" target="_blank" rel="noopener noreffer">video</a>) covers more complex uses of Go’s primitives, especially <code>select</code>.</li>
<li>Douglas McIlroy’s paper <a href="https://swtch.com/~rsc/thread/squint.pdf" target="_blank" rel="noopener noreffer">Squinting at Power Series</a> shows how Go-like concurrency provides elegant support for complex calculations.</li>
</ul>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-10-29 00:00:00</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/gb_20140313/" data-title="Gb_20140313" data-hashtags="go official blogs"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/gb_20140313/" data-hashtag="go official blogs"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/gb_20140313/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/gb_20140313/" data-title="Gb_20140313"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/gb_20140313/" data-title="Gb_20140313"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/gb_20140313/" data-title="Gb_20140313"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/go-official-blogs/">go official blogs</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/gb_20140224/" class="prev" rel="prev" title="Gb_20140224"><i class="fas fa-angle-left fa-fw"></i>Gb_20140224</a>
            <a href="/gb_20140324/" class="next" rel="next" title="Gb_20140324">Gb_20140324<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
