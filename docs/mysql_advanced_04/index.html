<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>Mysql_advanced_04 - 绿叶律动</title><meta name="Description" content="绿叶律动"><meta property="og:title" content="Mysql_advanced_04" />
<meta property="og:description" content="SQL必知必会 陈旸 2019-09-20 开篇词丨SQL可能是你掌握的最有用的技能 文章出现的图片请点击这里下载高清大图。 尽管技术人员或多或少地会使用 SQL，但不同" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jefofrank.xyz/mysql_advanced_04/" /><meta property="og:image" content="https://jefofrank.xyz/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-08T09:42:10+08:00" />
<meta property="article:modified_time" content="2022-10-08T19:55:40+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://jefofrank.xyz/logo.png"/>

<meta name="twitter:title" content="Mysql_advanced_04"/>
<meta name="twitter:description" content="SQL必知必会 陈旸 2019-09-20 开篇词丨SQL可能是你掌握的最有用的技能 文章出现的图片请点击这里下载高清大图。 尽管技术人员或多或少地会使用 SQL，但不同"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://jefofrank.xyz/mysql_advanced_04/" /><link rel="prev" href="https://jefofrank.xyz/mysql_advanced_03/" /><link rel="next" href="https://jefofrank.xyz/mysql_advanced_05/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Mysql_advanced_04",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/jefofrank.xyz\/mysql_advanced_04\/"
        },"image": ["https:\/\/jefofrank.xyz\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "mysql","wordcount":  29637 ,
        "url": "https:\/\/jefofrank.xyz\/mysql_advanced_04\/","datePublished": "2021-12-08T09:42:10+08:00","dateModified": "2022-10-08T19:55:40+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/jefofrank.xyz\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="绿叶律动"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/jf-011101" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">Mysql_advanced_04</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/jf-011101" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/advanced-learning/"><i class="far fa-folder fa-fw"></i>Advanced learning</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-12-08 09:42:10">2021-12-08 09:42:10</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 29637 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 60 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#开篇词丨sql可能是你掌握的最有用的技能">开篇词丨SQL可能是你掌握的最有用的技能</a></li>
    <li><a href="#语法基础">语法基础</a></li>
    <li><a href="#01丨了解sql一门半衰期很长的语言">01丨了解SQL：一门半衰期很长的语言</a></li>
    <li><a href="#02丨dbms的前世今生">02丨DBMS的前世今生</a></li>
    <li><a href="#03丨学会用数据库的方式思考sql是如何执行的">03丨学会用数据库的方式思考SQL是如何执行的</a></li>
    <li><a href="#04丨使用ddl创建数据库数据表时需要注意什么">04丨使用DDL创建数据库&amp;数据表时需要注意什么？</a></li>
    <li><a href="#05丨检索数据你还在select--么">05丨检索数据：你还在SELECT * 么？]</a></li>
    <li><a href="#06丨数据过滤sql数据过滤都有哪些方法">06丨数据过滤：SQL数据过滤都有哪些方法？</a></li>
    <li><a href="#07丨什么是sql函数为什么使用sql函数可能会带来问题">07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？</a></li>
    <li><a href="#08丨什么是sql的聚集函数如何利用它们汇总表的数据">08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？</a></li>
    <li><a href="#09丨子查询子查询的种类都有哪些如何提高子查询的性能">09丨子查询：子查询的种类都有哪些，如何提高子查询的性能？</a></li>
    <li><a href="#10丨常用的sql标准有哪些在sql92中是如何使用连接的">10丨常用的SQL标准有哪些，在SQL92中是如何使用连接的？</a></li>
    <li><a href="#11丨sql99是如何使用连接的与sql92的区别是什么">11丨SQL99是如何使用连接的，与SQL92的区别是什么？</a></li>
    <li><a href="#12丨视图在sql中的作用是什么它是怎样工作的">12丨视图在SQL中的作用是什么，它是怎样工作的？</a></li>
    <li><a href="#13丨什么是存储过程在实际项目中用得多么">13丨什么是存储过程，在实际项目中用得多么？</a></li>
    <li><a href="#14丨什么是事务处理如何使用commit和rollback进行操作">14丨什么是事务处理，如何使用COMMIT和ROLLBACK进行操作？</a></li>
    <li><a href="#15丨初识事务隔离隔离的级别有哪些它们都解决了哪些异常问题">15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？</a></li>
    <li><a href="#16丨游标当我们需要逐条处理数据时该怎么做">16丨游标：当我们需要逐条处理数据时，该怎么做？</a></li>
    <li><a href="#17丨如何使用python操作mysql">17丨如何使用Python操作MySQL？</a></li>
    <li><a href="#18丨sqlalchemy如何使用python-orm框架来操作mysql">18丨SQLAlchemy：如何使用Python ORM框架来操作MySQL？</a></li>
    <li><a href="#19丨基础篇总结如何理解查询优化通配符以及存储过程">19丨基础篇总结：如何理解查询优化、通配符以及存储过程？</a>
      <ul>
        <li><a href="#关于各种-dbms-的介绍">关于各种 DBMS 的介绍</a>
          <ul>
            <li><a href="#答疑-1">答疑 1</a></li>
          </ul>
        </li>
        <li><a href="#关于查询优化">关于查询优化</a>
          <ul>
            <li><a href="#答疑-1-1">答疑 1</a></li>
            <li><a href="#答疑-2">答疑 2</a></li>
          </ul>
        </li>
        <li><a href="#关于通配符的解释">关于通配符的解释</a>
          <ul>
            <li><a href="#答疑-4">答疑 4</a></li>
            <li><a href="#答疑-5">答疑 5</a></li>
            <li><a href="#答疑-6">答疑 6</a></li>
            <li><a href="#答疑-7">答疑 7</a></li>
          </ul>
        </li>
        <li><a href="#关于存储过程">关于存储过程</a>
          <ul>
            <li><a href="#答疑-1-2">答疑 1</a></li>
            <li><a href="#答疑-2-1">答疑 2</a></li>
          </ul>
        </li>
        <li><a href="#关于事务处理">关于事务处理</a>
          <ul>
            <li><a href="#答疑-1-3">答疑 1</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#性能优化">性能优化</a></li>
    <li><a href="#20丨当我们思考数据库调优的时候都有哪些维度可以选择">20丨当我们思考数据库调优的时候，都有哪些维度可以选择？</a>
      <ul>
        <li><a href="#我们该如何思考和分析数据库调优这件事">我们该如何思考和分析数据库调优这件事</a></li>
      </ul>
    </li>
    <li><a href="#21丨范式设计数据表的范式有哪些3nf指的是什么">21丨范式设计：数据表的范式有哪些，3NF指的是什么？</a></li>
    <li><a href="#22丨反范式设计3nf有什么不足为什么有时候需要反范式设计">22丨反范式设计：3NF有什么不足，为什么有时候需要反范式设计？</a></li>
    <li><a href="#23丨索引的概览用还是不用索引这是一个问题">23丨索引的概览：用还是不用索引，这是一个问题</a></li>
    <li><a href="#24丨索引的原理我们为什么用b树来做索引">24丨索引的原理：我们为什么用B+树来做索引？</a></li>
    <li><a href="#25丨hash索引的底层原理是什么">25丨Hash索引的底层原理是什么？</a></li>
    <li><a href="#26丨索引的使用原则如何通过索引让sql查询效率最大化">26丨索引的使用原则：如何通过索引让SQL查询效率最大化？</a></li>
    <li><a href="#27丨从数据页的角度理解b树查询">27丨从数据页的角度理解B+树查询</a></li>
    <li><a href="#28丨从磁盘io的角度理解sql查询的成本">28丨从磁盘I/O的角度理解SQL查询的成本</a></li>
    <li><a href="#29丨为什么没有理想的索引">29丨为什么没有理想的索引？</a></li>
    <li><a href="#30丨锁悲观锁和乐观锁是什么">30丨锁：悲观锁和乐观锁是什么？</a></li>
    <li><a href="#31丨为什么大部分rdbms都会支持mvcc">31丨为什么大部分RDBMS都会支持MVCC？</a></li>
    <li><a href="#32丨查询优化器是如何工作的">32丨查询优化器是如何工作的？</a></li>
    <li><a href="#33丨如何使用性能分析工具定位sql执行慢的原因">33丨如何使用性能分析工具定位SQL执行慢的原因？</a></li>
    <li><a href="#34丨答疑篇关于索引以及缓冲池的一些解惑">34丨答疑篇：关于索引以及缓冲池的一些解惑</a>
      <ul>
        <li><a href="#关于索引b-树索引和-hash-索引以及索引原则">关于索引（B+ 树索引和 Hash 索引，以及索引原则）</a>
          <ul>
            <li><a href="#什么是自适应-hash-索引">什么是自适应 Hash 索引？</a></li>
            <li><a href="#什么是联合索引的最左原则">什么是联合索引的最左原则？</a></li>
            <li><a href="#hash-索引与-b-树索引是在建索引的时候手动指定的吗">Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</a></li>
          </ul>
        </li>
        <li><a href="#关于缓冲池">关于缓冲池</a>
          <ul>
            <li><a href="#缓冲池和查询缓存是一个东西吗">缓冲池和查询缓存是一个东西吗？</a></li>
          </ul>
        </li>
        <li><a href="#其他">其他</a></li>
      </ul>
    </li>
    <li><a href="#35丨数据库主从同步的作用是什么如何解决数据不一致问题">35丨数据库主从同步的作用是什么，如何解决数据不一致问题？</a></li>
    <li><a href="#36丨数据库没有备份没有使用binlog的情况下如何恢复数据">36丨数据库没有备份，没有使用Binlog的情况下，如何恢复数据？</a></li>
    <li><a href="#37丨sql注入你的sql是如何被注入的">37丨SQL注入：你的SQL是如何被注入的？</a></li>
    <li><a href="#认识dbms">认识DBMS</a></li>
    <li><a href="#38丨如何在excel中使用sql语言">38丨如何在Excel中使用SQL语言？</a></li>
    <li><a href="#39丨websql如何在h5中存储一个本地数据库">39丨WebSQL：如何在H5中存储一个本地数据库？</a></li>
    <li><a href="#40丨sqlite为什么微信用sqlite存储聊天记录">40丨SQLite：为什么微信用SQLite存储聊天记录？</a></li>
    <li><a href="#41丨初识redisredis为什么会这么快">41丨初识Redis：Redis为什么会这么快？</a></li>
    <li><a href="#42丨如何使用redis来实现多用户抢票问题">42丨如何使用Redis来实现多用户抢票问题</a></li>
    <li><a href="#43丨如何使用redis搭建玩家排行榜">43丨如何使用Redis搭建玩家排行榜？</a></li>
    <li><a href="#44丨dbms篇总结和答疑用sqlite做词云">44丨DBMS篇总结和答疑：用SQLite做词云</a>
      <ul>
        <li><a href="#关于-excelsql">关于 Excel+SQL</a>
          <ul>
            <li><a href="#答疑-1关于-mysql-for-excel-的安装">答疑 1：关于 mysql-for-excel 的安装</a></li>
          </ul>
        </li>
        <li><a href="#关于-websql">关于 WebSQL</a></li>
        <li><a href="#关于-sqlite">关于 SQLite</a></li>
        <li><a href="#关于-redis">关于 Redis</a></li>
      </ul>
    </li>
    <li><a href="#sql项目实战">SQL项目实战</a></li>
    <li><a href="#45丨数据清洗如何使用sql对数据进行清洗">45丨数据清洗：如何使用SQL对数据进行清洗？</a></li>
    <li><a href="#46丨数据集成如何对各种数据库进行集成和转换">46丨数据集成：如何对各种数据库进行集成和转换？</a></li>
    <li><a href="#47丨如何利用sql对零售数据进行分析">47丨如何利用SQL对零售数据进行分析？</a></li>
    <li><a href="#结束语--互联网的下半场是数据驱动的时代">结束语 | 互联网的下半场是数据驱动的时代</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="sql必知必会">SQL必知必会</h1>
<p>陈旸 2019-09-20</p>
<h2 id="开篇词丨sql可能是你掌握的最有用的技能">开篇词丨SQL可能是你掌握的最有用的技能</h2>
<p>文章出现的图片请点击<a href="https://github.com/cystanford/SQL-XMind" target="_blank" rel="noopener noreffer">这里</a>下载高清大图。</p>
<p>尽管技术人员或多或少地会使用 SQL，但不同的人编写出来的 SQL 的效率是不同的，比如说一份好的 SQL 执行计划就会尽量减少 I/O 操作，因为 I/O 是 DBMS 最容易出现瓶颈的地方，可以说数据库操作中有大量的时间都花在了 I/O 上。</p>
<p>此外，你还需要考虑如何降低 CPU 的计算量，在 SQL 语句中使用 GROUP BY、ORDER BY 等这些语句会消耗大量的 CPU 计算资源，因此我们需要从全局出发，不仅需要考虑数据库的 I/O 性能，还需要考虑 CPU 计算、内存使用情况等。</p>
<p>比如 EXISTS 查询和 IN 查询在某些情况下可以得到相同的结果，但是具体执行起来，哪个效率更高呢？假设我把这个模式抽象为下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">SELECT * FROM A WHERE cc IN (SELECT cc FROM B)


SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)
</code></pre></td></tr></table>
</div>
</div><p>在查询过程中，我们需要判断表 A 和表 B 的大小。如果在有索引的情况下，表 A 比表 B 大，那么 IN 子查询的效率比 EXISTS 子查询效率高。当然，SQL 的实用和强大远远不止体现在 IT 技术领域，在产品和运营方面，SQL 更是发挥了它强大的威力。</p>
<p>不论是产品经理、运营人员，还是开发人员、数据分析师，你都可以用到 SQL 语言。它就像一把利剑，除了可以提高你的工作效率之外，还能扩大你的工作视野。</p>
<p>如果你没有 SQL 基础，我希望这个专栏可以帮助你彻底理解 SQL，从而开启你的数据之旅，比如如何用 SQL 检索数据、过滤数据，如何使用 SQL 函数、子查询……考虑到在实际工作中，你还会接触到不同的关系型数据库管理系统，我还会讲解 SQL 在不同的数据库管理系统中是如何使用的。</p>
<p>即使对于有 SQL 基础的同学来说，面对同样的 SQL 语句，查询效率可能千差万别。在你实际工作的时候，如何快速定位 SQL 的性能问题，并找到正确的优化方案会让你的价值倍增。</p>
<p>数据是 SQL 的生命力，你不用担心面对干巴巴的 SQL 语言而感到无从下手，为了避免纸上谈兵，让你在工作中更容易、更熟练地使用 SQL，我特意为专栏建了一个王者荣耀数据库和 NBA 球员数据库。这些数据库既是我在讲解 SQL 时要用到的事例，也是你课后练习的素材。</p>
<ol>
<li>
<p>基础篇SQL 的语法非常简单，就像英语一样，但它的功能却很强大，可以帮助我们对数据实现索引、排序、分组等功能。但是这些命令在不同的数据库管理系统中的使用却有所差异，因此在专栏中，我不仅会重点讲解 SQL 本身的语法，还会讲解这些语法在类似 MySQL、Oracle、SQL Server 等不同的数据库管理系统中是如何使用的。</p>
</li>
<li>
<p>进阶篇很多人在写 SQL 的时候都会遇到这样的问题：“同样都是用 SQL 查询数据，为什么我写的语句要比别人的慢？”事实上，就是因为 SQL 语法简单，导致很多人写的时候不拘小节，比如搞混了关键词的顺序，这就在无意中降低了 SQL 的执行效率。在这一部分，我会讲解在实际工作中，使用 SQL 经常会遇到的问题，以及如何使用工具进行分析，快速定位性能问题及解决方案。</p>
</li>
<li>
<p>高级篇在大数据的时代，诞生了很多适用于不同场景的数据库管理系统，既有基于 SQL 的关系型数据库，比如 Oracle、MySQL、SQL Server、Access、WebSQL、SQLite 等，也有 NoSQL 非关系型数据库，比如 MongoDB、Redis 等。在这一部分中，我会讲一讲各种主流数据库管理系统的使用。</p>
</li>
<li>
<p>实战篇以上几个部分是在帮你梳理 SQL 的知识体系，但只有学会用 SQL 系统地进行项目实战，你才能真正地学以致用，让 SQL 为你的工作助力。在这一部分中，我会结合数据分析的项目，为你讲解 SQL 的实战案例，比如如何用 SQL 做数据清洗、数据集成等。如果你是一名程序员，那么会用 SQL 无疑是你的基本技能；如果你是产品经理或者运营人员，那么 SQL 将会为你打开一个全新的世界，让你从不一样的视角看待数据，利用数据。我希望这个专栏可以带你走进 SQL 的世界，让你掌握它的基础语法，学会分析性能问题，一步步精通 SQL。这时你会发现，原本毫无规则、抽象的数据仿佛一下子具象了，变得会说话了，它会告诉你数据之间彼此的关联、背后所代表的含义……</p>
</li>
</ol>
<h2 id="语法基础">语法基础</h2>
<h2 id="01丨了解sql一门半衰期很长的语言">01丨了解SQL：一门半衰期很长的语言</h2>
<p>总结
今天我带你初步了解了 SQL 语言，当然，SQL 再简单，也还是需要你一步一步，从点滴做起，先掌握基本的 DDL、DML、DCL 和 DQL 语法，再了解不同的 DBMS 中的 SQL 语法差异，然后再来看如何优化，提升 SQL 的效率。要想写出高性能的 SQL，首先要了解它的原理，其次就是做大量的练习。SQL 的价值在于通用性强（市场需求普遍），半衰期长（一次学习终身受用），入门不难。实际上，很多事情的价值都可以按照这三点来进行判断，比如一个产品的市场价值。如果你是一名产品经理，你是喜欢通用性更强的产品，还是喜欢更个性的产品。今天的文章只是简单预热，你可能也会有一些感悟，不妨说说你对一个产品或者语言的市场价值的理解。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/9f/d2/9f72d7f01aace4c991d9774a81d051d2.jpg?wh=2418x1708"
        data-srcset="https://static001.geekbang.org/resource/image/9f/d2/9f72d7f01aace4c991d9774a81d051d2.jpg?wh=2418x1708, https://static001.geekbang.org/resource/image/9f/d2/9f72d7f01aace4c991d9774a81d051d2.jpg?wh=2418x1708 1.5x, https://static001.geekbang.org/resource/image/9f/d2/9f72d7f01aace4c991d9774a81d051d2.jpg?wh=2418x1708 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/9f/d2/9f72d7f01aace4c991d9774a81d051d2.jpg?wh=2418x1708"
        title="img" /></p>
<h2 id="02丨dbms的前世今生">02丨DBMS的前世今生</h2>
<p>今天我们简单梳理了 DBMS 的发展。1974 年，SEQUEL 论文发表，1979 年，第一个商用关系型数据库 Oracle 2 诞生，1995 年，MySQL 开源数据库诞生，如今，NoSQL 得到了发展，并且围绕 SQL 标准展开的 DBMS 竞赛从来没有停止过。在这段发展史中，既有 SQL 阵营，又有 NoSQL 阵营，既有商业数据库软件，又有开源产品，在不同的应用场景下，同一家公司也会有不同的 DBMS 布局。如果说不同的 DBMS 代表了不同公司的利益，那么作为使用者的我们更应该注重的是这些 DBMS 的使用场景。比如 Oracle 作为市场占有率最高的商用数据库软件，适合大型的跨国企业，而针对轻量级的桌面数据库，我们采用 Access 就可以了。对于免费开源的产品来说，可以选用 MySQL 或者 MariaDB。同时在 NoSQL 阵营中，我们也需要了解键值型、文档型、搜索引擎、列式数据库和图形数据库的区别。</p>
<h2 id="03丨学会用数据库的方式思考sql是如何执行的">03丨学会用数据库的方式思考SQL是如何执行的</h2>
<p>总结
我们在使用 SQL 的时候，往往只见树木，不见森林，不会注意到它在各种数据库软件中是如何执行的，今天我们从全貌的角度来理解这个问题。你能看到不同的 RDBMS 之间有相同的地方，也有不同的地方。相同的地方在于 Oracle 和 MySQL 都是通过解析器→优化器→执行器这样的流程来执行 SQL 的。但 Oracle 和 MySQL 在进行 SQL 的查询上面有软件实现层面的差异。Oracle 提出了共享池的概念，通过共享池来判断是进行软解析，还是硬解析。而在 MySQL 中，8.0 以后的版本不再支持查询缓存，而是直接执行解析器→优化器→执行器的流程，这一点从 MySQL 中的 show profile 里也能看到。同时 MySQL 的一大特色就是提供了各种存储引擎以供选择，不同的存储引擎有各自的使用场景，我们可以针对每张表选择适合的存储引擎。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/02/f1/02719a80d54a174dec8672d1f87295f1.jpg?wh=3341*1671"
        data-srcset="https://static001.geekbang.org/resource/image/02/f1/02719a80d54a174dec8672d1f87295f1.jpg?wh=3341*1671, https://static001.geekbang.org/resource/image/02/f1/02719a80d54a174dec8672d1f87295f1.jpg?wh=3341*1671 1.5x, https://static001.geekbang.org/resource/image/02/f1/02719a80d54a174dec8672d1f87295f1.jpg?wh=3341*1671 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/02/f1/02719a80d54a174dec8672d1f87295f1.jpg?wh=3341*1671"
        title="img" /></p>
<h2 id="04丨使用ddl创建数据库数据表时需要注意什么">04丨使用DDL创建数据库&amp;数据表时需要注意什么？</h2>
<p>总结</p>
<p>今天我们学习了 DDL 的基础语法，比如如何对数据库和数据库表进行定义，也了解了使用 Navicat 可视化管理工具来辅助我们完成数据表的设计，省去了手写 SQL 的工作量。在创建数据表的时候，除了对字段名及数据类型进行定义以外，我们考虑最多的就是关于字段的约束，我介绍了 7 种常见的约束，它们都是数据表设计中会用到的约束：主键、外键、唯一性、NOT NULL、DEFAULT、CHECK 约束等。当然，了解了如何操作创建数据表之后，你还需要动脑思考，怎样才能设计出一个好的数据表？设计的原则都有哪些？针对这个，我整理出了“三少一多”原则，在实际使用过程中，你需要灵活掌握，因为这个原则并不是绝对的，有时候我们需要牺牲数据的冗余度来换取数据处理的效率。<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/80/c1/80aecedfad59aad06cc08bb9bca721c1.jpg?wh=3296*2313"
        data-srcset="https://static001.geekbang.org/resource/image/80/c1/80aecedfad59aad06cc08bb9bca721c1.jpg?wh=3296*2313, https://static001.geekbang.org/resource/image/80/c1/80aecedfad59aad06cc08bb9bca721c1.jpg?wh=3296*2313 1.5x, https://static001.geekbang.org/resource/image/80/c1/80aecedfad59aad06cc08bb9bca721c1.jpg?wh=3296*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/80/c1/80aecedfad59aad06cc08bb9bca721c1.jpg?wh=3296*2313"
        title="img" /></p>
<h2 id="05丨检索数据你还在select--么">05丨检索数据：你还在SELECT * 么？]</h2>
<p>总结
今天我对 SELECT 的基础语法进行了讲解，SELECT 是 SQL 的基础。但不同阶段看 SELECT 都会有新的体会。当你第一次学习的时候，关注的往往是如何使用它，或者语法是否正确。再看的时候，可能就会更关注 SELECT 的查询效率，以及不同 DBMS 之间的差别。在我们的日常工作中，很多人都可以写出 SELECT 语句，但是执行的效率却相差很大。产生这种情况的原因主要有两个，一个是习惯的培养，比如大部分初学者会经常使用SELECT *，而好的习惯则是只查询所需要的列；另一个对 SQL 查询的执行顺序及查询效率的关注，比如当你知道只有 1 条记录的时候，就可以使用LIMIT 1来进行约束，从而提升查询效率。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/a8/c88258e72728957b43dc2441d3f381a8.jpg?wh=3341*1493"
        data-srcset="https://static001.geekbang.org/resource/image/c8/a8/c88258e72728957b43dc2441d3f381a8.jpg?wh=3341*1493, https://static001.geekbang.org/resource/image/c8/a8/c88258e72728957b43dc2441d3f381a8.jpg?wh=3341*1493 1.5x, https://static001.geekbang.org/resource/image/c8/a8/c88258e72728957b43dc2441d3f381a8.jpg?wh=3341*1493 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/a8/c88258e72728957b43dc2441d3f381a8.jpg?wh=3341*1493"
        title="img" /></p>
<h2 id="06丨数据过滤sql数据过滤都有哪些方法">06丨数据过滤：SQL数据过滤都有哪些方法？</h2>
<p>总结
今天我对 SQL 语句中的 WHERE 子句进行了讲解，你可以使用比较运算符、逻辑运算符和通配符这三种方式对检索条件进行过滤。比较运算符是对数值进行比较，不同的 DBMS 支持的比较运算符可能不同，你需要事先查阅相应的 DBMS 文档。逻辑运算符可以让我们同时使用多个 WHERE 子句，你需要注意的是 AND 和 OR 运算符的执行顺序。通配符可以让我们对文本类型的字段进行模糊查询，不过检索的代价也是很高的，通常都需要用到全表扫描，所以效率很低。只有当 LIKE 语句后面不用通配符，并且对字段进行索引的时候才不会对全表进行扫描。你可能认为学习 SQL 并不难，掌握这些语法就可以对数据进行筛选查询。但实际工作中不同人写的 SQL 语句的查询效率差别很大，保持高效率的一个很重要的原因，就是要避免全表扫描，所以我们会考虑在 WHERE 及 ORDER BY 涉及到的列上增加索引。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/fb/50/fbd79c2c90a58891b498e7f29d935050.jpg?wh=3341*1713"
        data-srcset="https://static001.geekbang.org/resource/image/fb/50/fbd79c2c90a58891b498e7f29d935050.jpg?wh=3341*1713, https://static001.geekbang.org/resource/image/fb/50/fbd79c2c90a58891b498e7f29d935050.jpg?wh=3341*1713 1.5x, https://static001.geekbang.org/resource/image/fb/50/fbd79c2c90a58891b498e7f29d935050.jpg?wh=3341*1713 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/fb/50/fbd79c2c90a58891b498e7f29d935050.jpg?wh=3341*1713"
        title="img" /></p>
<h2 id="07丨什么是sql函数为什么使用sql函数可能会带来问题">07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？</h2>
<p>总结
函数对于一门语言的重要性毋庸置疑，我们在写 Python 代码的时候，会自己编写函数，也会使用 Python 内置的函数。在 SQL 中，使用函数的时候需要格外留意。不过如果工程量不大，使用的是同一个 DBMS 的话，还是可以使用函数简化操作的，这样也能提高代码效率。只是在系统集成，或者在多个 DBMS 同时存在的情况下，使用函数的时候就需要慎重一些。比如CONCAT()是字符串拼接函数，在 MySQL 和 Oracle 中都有这个函数，但是在这两个 DBMS 中作用却不一样，CONCAT函数在 MySQL 中可以连接多个字符串，而在 Oracle 中CONCAT函数只能连接两个字符串，如果要连接多个字符串就需要用（||）连字符来解决。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/8c/c9/8c5e316b466e8fa65789a9c6a220ebc9.jpg?wh=3341*1309"
        data-srcset="https://static001.geekbang.org/resource/image/8c/c9/8c5e316b466e8fa65789a9c6a220ebc9.jpg?wh=3341*1309, https://static001.geekbang.org/resource/image/8c/c9/8c5e316b466e8fa65789a9c6a220ebc9.jpg?wh=3341*1309 1.5x, https://static001.geekbang.org/resource/image/8c/c9/8c5e316b466e8fa65789a9c6a220ebc9.jpg?wh=3341*1309 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/8c/c9/8c5e316b466e8fa65789a9c6a220ebc9.jpg?wh=3341*1309"
        title="img" /></p>
<h2 id="08丨什么是sql的聚集函数如何利用它们汇总表的数据">08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？</h2>
<p>总结
今天我对 SQL 的聚集函数进行了讲解。通常我们还会对数据先进行分组，然后再使用聚集函数统计不同组的数据概况，比如数据行数、平均值、最大值、最小值以及求和等。我们也可以使用 HAVING 对分组进行过滤，然后通过 ORDER BY 按照某个字段的顺序进行排序输出。有时候你能看到在一条 SELECT 语句中，可能会包括多个子句，用 WHERE 进行数据量的过滤，用 GROUP BY 进行分组，用 HAVING 进行分组过滤，用 ORDER BY 进行排序……
你要记住，在 SELECT 查询中，关键字的顺序是不能颠倒的，它们的顺序是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...
</code></pre></td></tr></table>
</div>
</div><p>另外需要注意的是，使用 GROUP BY 进行分组，如果想让输出的结果有序，可以在 GROUP BY 后使用 ORDER BY。因为 GROUP BY 只起到了分组的作用，排序还是需要通过 ORDER BY 来完成。</p>
<h2 id="09丨子查询子查询的种类都有哪些如何提高子查询的性能">09丨子查询：子查询的种类都有哪些，如何提高子查询的性能？</h2>
<p>总结
今天我讲解了子查询的使用，按照子查询执行的次数，我们可以将子查询分成关联子查询和非关联子查询，其中非关联子查询与主查询的执行无关，只需要执行一次即可，而关联子查询，则需要将主查询的字段值传入子查询中进行关联查询。同时，在子查询中你可能会使用到 EXISTS、IN、ANY、ALL 和 SOME 等关键字。在某些情况下使用 EXISTS 和 IN 可以得到相同的效果，具体使用哪个执行效率更高，则需要看字段的索引情况以及表 A 和表 B 哪个表更大。同样，IN、ANY、ALL、SOME 这些关键字是用于集合比较的，SOME 是 ANY 的别名，当我们使用 ANY 或 ALL 的时候，一定要使用比较操作符。最后，我讲解了如何使用子查询作为计算字段，把子查询的结果作为主查询的列。SQL 中，子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p>
<p>我今天讲解了子查询的使用，其中讲到了 EXISTS 和 IN 子查询效率的比较，当查询字段进行了索引时，主表 A 大于从表 B，使用 IN 子查询效率更高，相反主表 A 小于从表 B 时，使用 EXISTS 子查询效率更高，同样，如果使用 NOT IN 子查询和 NOT EXISTS 子查询，在什么情况下，哪个效率更高呢？</p>
<h2 id="10丨常用的sql标准有哪些在sql92中是如何使用连接的">10丨常用的SQL标准有哪些，在SQL92中是如何使用连接的？</h2>
<p>总结
今天我讲解了常用的 SQL 标准以及 SQL92 中的连接操作。SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。也正是在这两个标准发布之后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用。除此以外，我们使用的主流 RDBMS，比如 MySQL、Oracle、SQL Sever、DB2、PostgreSQL 等都支持 SQL 语言，也就是说它们的使用符合大部分 SQL 标准，但很难完全符合，因为这些数据库管理系统都在 SQL 语言的基础上，根据自身产品的特点进行了扩充。即使这样，SQL 语言也是目前所有语言中半衰期最长的，在 1992 年，Windows3.1 发布，SQL92 标准也同时发布，如今我们早已不使用 Windows3.1 操作系统，而 SQL92 标准却一直持续至今。当然我们也要注意到 SQL 标准的变化，以及不同数据库管理系统使用时的差别，比如 Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/e4/0d/e473b216f11cfa7696371bfeadba220d.jpg?wh=3341*1410"
        data-srcset="https://static001.geekbang.org/resource/image/e4/0d/e473b216f11cfa7696371bfeadba220d.jpg?wh=3341*1410, https://static001.geekbang.org/resource/image/e4/0d/e473b216f11cfa7696371bfeadba220d.jpg?wh=3341*1410 1.5x, https://static001.geekbang.org/resource/image/e4/0d/e473b216f11cfa7696371bfeadba220d.jpg?wh=3341*1410 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/e4/0d/e473b216f11cfa7696371bfeadba220d.jpg?wh=3341*1410"
        title="img" /></p>
<h2 id="11丨sql99是如何使用连接的与sql92的区别是什么">11丨SQL99是如何使用连接的，与SQL92的区别是什么？</h2>
<p>总结
连接可以说是 SQL 中的核心操作，通过两篇文章的学习，你已经从多个维度对连接进行了了解。同时，我们对 SQL 的两个重要标准 SQL92 和 SQL99 进行了学习，在我们需要进行外连接的时候，建议采用 SQL99 标准，这样更适合阅读。此外我还想强调一下，我们在进行连接的时候，使用的关系型数据库管理系统，之所以存在关系是因为各种数据表之间存在关联，它们并不是孤立存在的。在实际工作中，尤其是做业务报表的时候，我们会用到 SQL 中的连接操作（JOIN），因此我们需要理解和熟练掌握 SQL 标准中连接的使用，以及不同 DBMS 中对连接的语法规范。剩下要做的，就是通过做练习和实战来增强你的经验了，做的练习多了，也就自然有感觉了。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/44/5b/443181aea770ba5844efac6b02e02c5b.jpg?wh=3341*1819"
        data-srcset="https://static001.geekbang.org/resource/image/44/5b/443181aea770ba5844efac6b02e02c5b.jpg?wh=3341*1819, https://static001.geekbang.org/resource/image/44/5b/443181aea770ba5844efac6b02e02c5b.jpg?wh=3341*1819 1.5x, https://static001.geekbang.org/resource/image/44/5b/443181aea770ba5844efac6b02e02c5b.jpg?wh=3341*1819 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/44/5b/443181aea770ba5844efac6b02e02c5b.jpg?wh=3341*1819"
        title="img" /></p>
<h2 id="12丨视图在sql中的作用是什么它是怎样工作的">12丨视图在SQL中的作用是什么，它是怎样工作的？</h2>
<p>总结
今天我讲解了视图的使用，包括创建，修改和删除视图。使用视图有很多好处，比如安全、简单清晰。</p>
<p>安全性：虚拟表是基于底层数据表的，我们在使用视图时，一般不会轻易通过视图对底层数据进行修改，即使是使用单表的视图，也会受到限制，比如计算字段，类型转换等是无法通过视图来对底层数据进行修改的，这也在一定程度上保证了数据表的数据安全性。同时，我们还可以针对不同用户开放不同的数据查询权限，比如人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。简单清晰：视图是对 SQL 查询的封装，它可以将原本复杂的 SQL 查询简化，在编写好查询之后，我们就可以直接重用它而不必要知道基本的查询细节。同时我们还可以在视图之上再嵌套视图。这样就好比我们在进行模块化编程一样，不仅结构清晰，还提升了代码的复用率。</p>
<p>另外，我们也需要了解到视图是虚拟表，本身不存储数据，如果想要通过视图对底层数据表的数据进行修改也会受到很多限制，通常我们是把视图用于查询，也就是对 SQL 查询的一种封装。那么它和临时表又有什么区别呢？在实际工作中，我们可能会见到各种临时数据。比如你可能会问，如果我在做一个电商的系统，中间会有个购物车的功能，需要临时统计购物车中的商品和金额，那该怎么办呢？这里就需要用到临时表了，临时表是真实存在的数据表，不过它不用于长期存放数据，只为当前连接存在，关闭连接后，临时表就会自动释放。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/8a/30/8afa99e7d1ac1de2c802cf0c61004b30.jpg?wh=3341*1916"
        data-srcset="https://static001.geekbang.org/resource/image/8a/30/8afa99e7d1ac1de2c802cf0c61004b30.jpg?wh=3341*1916, https://static001.geekbang.org/resource/image/8a/30/8afa99e7d1ac1de2c802cf0c61004b30.jpg?wh=3341*1916 1.5x, https://static001.geekbang.org/resource/image/8a/30/8afa99e7d1ac1de2c802cf0c61004b30.jpg?wh=3341*1916 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/8a/30/8afa99e7d1ac1de2c802cf0c61004b30.jpg?wh=3341*1916"
        title="img" /></p>
<h2 id="13丨什么是存储过程在实际项目中用得多么">13丨什么是存储过程，在实际项目中用得多么？</h2>
<p>关于存储过程使用的争议
尽管存储过程有诸多优点，但是对于存储过程的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？我们得从存储过程的特点来找答案。你能看到存储过程有很多好处。
首先存储过程可以一次编译多次使用。存储过程只在创造时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。其次它可以减少开发工作量。将代码封装成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以重复使用，在减少开发工作量的同时，还能保证代码的结构清晰。还有一点，存储过程的安全性强，我们在设定存储过程的时候可以设置对用户的使用权限，这样就和视图一样具有较强的安全性。最后它可以减少网络传输量，因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。同时在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可。</p>
<p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<p>它的可移植性差，存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。其次调试困难，只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。此外，存储过程的版本管理也很困难，比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。最后它不适合高并发的场景，高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就不适用了。了解了存储过程的优缺点之后，我想说的是，存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg?wh=2376*2313"
        data-srcset="https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg?wh=2376*2313, https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg?wh=2376*2313 1.5x, https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg?wh=2376*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/54/9f/54a0d3b0c0e5336c1da6fc84c909a49f.jpg?wh=2376*2313"
        title="img" /></p>
<h2 id="14丨什么是事务处理如何使用commit和rollback进行操作">14丨什么是事务处理，如何使用COMMIT和ROLLBACK进行操作？</h2>
<p>总结
关于 SQL 中的事务处理，内容相对比较多，因此我会采用两节来进行讲解。今天我们对事务的概念进行了理解，并进行了简单的事务操作。我们在做数据库操作的时候，可能会失败，但正是因为有事务的存在，即使在数据库操作失败的情况下，也能保证数据的一致性。同样，多个应用程序访问数据库的时候，事务可以提供隔离，保证事务之间不被干扰。最后，事务一旦提交，结果就会是永久性的，这就意味着，即使系统崩溃了，数据库也可以对数据进行恢复。在使用事务的过程中，我们会采用控制流语句对事务进行操作，不过在实际操作中，不一定每次使用 COMMIT 或 ROLLBACK 都会成功，你还需要知道当前系统的事务执行方式，也就是一些常用的参数情况，比如 MySQL 中的 autocommit 和 completion_type 等。事务是数据库区别于文件系统的重要特性之一，当我们有了事务就会让数据库始终保持一致性，同时我们还能通过事务的机制恢复到某个时间点，这样可以保证已提交到数据库的修改不会因为系统崩溃而丢失。</p>
<h2 id="15丨初识事务隔离隔离的级别有哪些它们都解决了哪些异常问题">15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？</h2>
<p>总结
我们今天只是简单讲解了 4 种隔离级别，以及对应的要解决的三种异常问题。我会在优化篇这一模块里继续讲解隔离级别以及锁的使用。你能看到，标准的价值在于，即使是不同的 RDBMS 都需要达成对异常问题和隔离级别定义的共识。这就意味着一个隔离级别的实现满足了下面的两个条件：</p>
<p>正确性：只要能满足某一个隔离级别，一定能解决这个隔离级别对应的异常问题。与实现无关：实际上 RDBMS 种类很多，这就意味着有多少种 RDBMS，就有多少种锁的实现方式，因此它们实现隔离级别的原理可能不同，然而一个好的标准不应该限制其实现的方式。</p>
<p>隔离级别越低，意味着系统吞吐量（并发程度）越大，但同时也意味着出现异常问题的可能性会更大。在实际使用过程中我们往往需要在性能和正确性上进行权衡和取舍，没有完美的解决方案，只有适合与否。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/aa/fb/aa2ae6682a571676b686509623a2a7fb.jpg?wh=3341*1688"
        data-srcset="https://static001.geekbang.org/resource/image/aa/fb/aa2ae6682a571676b686509623a2a7fb.jpg?wh=3341*1688, https://static001.geekbang.org/resource/image/aa/fb/aa2ae6682a571676b686509623a2a7fb.jpg?wh=3341*1688 1.5x, https://static001.geekbang.org/resource/image/aa/fb/aa2ae6682a571676b686509623a2a7fb.jpg?wh=3341*1688 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/aa/fb/aa2ae6682a571676b686509623a2a7fb.jpg?wh=3341*1688"
        title="img" /></p>
<h2 id="16丨游标当我们需要逐条处理数据时该怎么做">16丨游标：当我们需要逐条处理数据时，该怎么做？</h2>
<p>总结
今天我们讲解了如何在 SQL 中使用游标，游标实际上是面向过程的思维方式，与面向集合的思维方式不同的地方在于，游标更加关注“如何执行”。我们可以通过游标更加精细、灵活地查询和管理想要的数据行。有的时候，我们需要找特定数据，用 SQL 查询写起来会比较困难，比如两表或多表之间的嵌套循环查找，如果用 JOIN 会非常消耗资源，效率也可能不高，而用游标则会比较高效。虽然在处理某些复杂的数据情况下，使用游标可以更灵活，但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行加锁，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源，造成内存不足，这是因为游标是在内存中进行的处理。如果有游标的替代方案，我们可以采用替代方案。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/dc/11/dca1fadf6625b9699c25104e74fb8d11.jpg?wh=3341*2066"
        data-srcset="https://static001.geekbang.org/resource/image/dc/11/dca1fadf6625b9699c25104e74fb8d11.jpg?wh=3341*2066, https://static001.geekbang.org/resource/image/dc/11/dca1fadf6625b9699c25104e74fb8d11.jpg?wh=3341*2066 1.5x, https://static001.geekbang.org/resource/image/dc/11/dca1fadf6625b9699c25104e74fb8d11.jpg?wh=3341*2066 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/dc/11/dca1fadf6625b9699c25104e74fb8d11.jpg?wh=3341*2066"
        title="img" /></p>
<h2 id="17丨如何使用python操作mysql">17丨如何使用Python操作MySQL？</h2>
<p>总结
我今天讲解了如何使用 Python 来操作 MySQL，这里我们使用的是官方提供的 mysql-connector，当然除了它之外，还有很多库可以进行选择。在使用基于 DB API 规范的协议时，重点需要掌握 Connection 和 Cursor 这两个对象，Connection 就是对数据库的连接进行管理，而 Cursor 是对数据库的游标进行管理，通过它们，我们可以执行具体的 SQL 语句，以及处理复杂的数据。用 Python 操作 MySQL，还有很多种姿势，mysql-connector 只是其中一种，实际上还有另外一种方式，就是采用 ORM 框架。ORM 的英文是 Object Relational Mapping，也就是采用对象关系映射的模式，使用这种模式可以将数据库中各种数据表之间的关系映射到程序中的对象。这种模式可以屏蔽底层的数据库的细节，不需要我们与复杂的 SQL 语句打交道，直接采用操作对象的形式操作就可以。不过如果应用数据实体少，其实没有必要使用 ORM 框架，针对少量对象的管理，自己实现起来也很简单，比如本篇文章中我讲到的采用官方提供的 mysql-connector 驱动的方式来实现 CRUD。引入一个框架的学习成本很高，代码膨胀也很厉害，所以如果是相对简单的操作，完全可以自己动手来实现。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/96/d2/96cf0463992b9843ba02bb7f65cb4ed2.jpg?wh=3341*1512"
        data-srcset="https://static001.geekbang.org/resource/image/96/d2/96cf0463992b9843ba02bb7f65cb4ed2.jpg?wh=3341*1512, https://static001.geekbang.org/resource/image/96/d2/96cf0463992b9843ba02bb7f65cb4ed2.jpg?wh=3341*1512 1.5x, https://static001.geekbang.org/resource/image/96/d2/96cf0463992b9843ba02bb7f65cb4ed2.jpg?wh=3341*1512 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/96/d2/96cf0463992b9843ba02bb7f65cb4ed2.jpg?wh=3341*1512"
        title="img" /></p>
<h2 id="18丨sqlalchemy如何使用python-orm框架来操作mysql">18丨SQLAlchemy：如何使用Python ORM框架来操作MySQL？</h2>
<p>总结
今天我们使用 SQLAlalchemy 对 MySQL 进行了操作，你能看到这些实现并不复杂，只是需要事先掌握一些使用方法，尤其是如何创建 seesion 对象，以及如何通过 session 对象来完成对数据的增删改查等操作。建议你把文章里的代码都跑一遍，在运行的过程中一定会有更深入的体会。当然除了学习掌握 SQLAlalchemy 这个 Python ORM 工具以外，我还希望你能了解到 ORM 的价值和不足。如果项目本身不大，那么自己动手写 SQL 语句会比较简单，你可以不使用 ORM 工具，而是直接使用上节课讲到的 mysql-connector。但是随着项目代码量的增加，为了在业务逻辑层与数据库底层进行松耦合，采用 ORM 框架是更加适合的。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/6c/f3/6cffd2ac3be05210ace5cd753ee4aff3.jpg?wh=3341*2164"
        data-srcset="https://static001.geekbang.org/resource/image/6c/f3/6cffd2ac3be05210ace5cd753ee4aff3.jpg?wh=3341*2164, https://static001.geekbang.org/resource/image/6c/f3/6cffd2ac3be05210ace5cd753ee4aff3.jpg?wh=3341*2164 1.5x, https://static001.geekbang.org/resource/image/6c/f3/6cffd2ac3be05210ace5cd753ee4aff3.jpg?wh=3341*2164 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/6c/f3/6cffd2ac3be05210ace5cd753ee4aff3.jpg?wh=3341*2164"
        title="img" /></p>
<h2 id="19丨基础篇总结如何理解查询优化通配符以及存储过程">19丨基础篇总结：如何理解查询优化、通配符以及存储过程？</h2>
<h3 id="关于各种-dbms-的介绍">关于各种 DBMS 的介绍</h3>
<h4 id="答疑-1">答疑 1</h4>
<p>文章中有句话不太理解，“列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I/O”，可以解释一些“降低系统 I/O”是什么意思吗？</p>
<p><strong>解答</strong></p>
<p>行式存储是把一行的数据都串起来进行存储，然后再存储下一行。同样，列式存储是把一列的数据都串起来进行存储，然后再存储下一列。这样做的话，相邻数据的数据类型都是一样的，更容易压缩，压缩之后就自然降低了 I/O。我们还需要从数据处理的需求出发，去理解行式存储和列式存储。数据处理可以分为 OLTP（联机事务处理）和 OLAP（联机分析处理）两大类。OLTP 一般用于处理客户的事务和进行查询，需要随时对数据表中的记录进行增删改查，对实时性要求高。OLAP 一般用于市场的数据分析，通常数据量大，需要进行复杂的分析操作，可以对大量历史数据进行汇总和分析，对实时性要求不高。那么对于 OLTP 来说，由于随时需要对数据记录进行增删改查，更适合采用行式存储，因为一行数据的写入会同时修改多个列。传统的 RDBMS 都属于行式存储，比如 Oracle、SQL Server 和 MySQL 等。对于 OLAP 来说，由于需要对大量历史数据进行汇总和分析，则适合采用列式存储，这样的话汇总数据会非常快，但是对于插入（INSERT）和更新（UPDATE）会比较麻烦，相比于行式存储性能会差不少。所以说列式存储适合大批量数据查询，可以降低 I/O，但如果对实时性要求高，则更适合行式存储。</p>
<h3 id="关于查询优化">关于查询优化</h3>
<h4 id="答疑-1-1">答疑 1</h4>
<p>在 MySQL 中统计数据表的行数，可以使用三种方式：SELECT COUNT(<em>)、SELECT COUNT(1)和SELECT COUNT(具体字段)，使用这三者之间的查询效率是怎样的？之前看到说是：SELECT COUNT(</em>)＞ SELECT COUNT(1)＞ SELECT COUNT(具体字段)。</p>
<p><strong>解答</strong></p>
<p>在 MySQL InnoDB 存储引擎中，COUNT(<em>)和COUNT(1)都是对所有结果进行COUNT。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 子句，则是对数据表的数据行数进行统计。因此COUNT(</em>)和COUNT(1)本质上并没有区别，执行的复杂度都是O(N)，也就是采用全表扫描，进行循环 + 计数的方式进行统计。如果是 MySQL MyISAM 存储引擎，统计数据表的行数只需要O(1)的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了row_count值，而一致性则由表级锁来保证。因为 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，只维护一个row_count变量，因此需要采用扫描全表，进行循环 + 计数的方式来完成统计。需要注意的是，在实际执行中，COUNT(<em>)和COUNT(1)的执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的。另外在 InnoDB 引擎中，如果采用COUNT(</em>)和COUNT(1)来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引）。对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。然而如果想要查找具体的行，那么采用主键索引的效率更高。如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。这里我总结一下：</p>
<p>一般情况下，三者执行的效率为 COUNT(<em>)= COUNT(1)&gt; COUNT(字段)。我们尽量使用COUNT(</em>)，当然如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。如果要统计COUNT(<em>)，尽量在数据表上建立二级索引，系统会自动采用key_len小的二级索引进行扫描，这样当我们使用SELECT COUNT(</em>)的时候效率就会提升，有时候可以提升几倍甚至更高。</p>
<h4 id="答疑-2">答疑 2</h4>
<p>在 MySQL 中，LIMIT关键词是最后执行的，如果可以确定只有一条结果，那么就起不到查询优化的效果了吧，因为LIMIT是对最后的结果集过滤，如果结果集本来就只有一条，那就没有什么用了。</p>
<p><strong>解答</strong></p>
<p>如果你可以确定结果集只有一条，那么加上LIMIT 1的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。这里指的查询优化针对的是会扫描全表的 SQL 语句，如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。</p>
<h3 id="关于通配符的解释">关于通配符的解释</h3>
<p>关于查询语句中通配符的使用理解，我举了一个查询英雄名除了第一个字以外，包含“太”字的英雄都有谁的例子，使用的 SQL 语句是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">SQL&gt; SELECT name FROM heros WHERE name LIKE &#39;_%太%&#39;
</code></pre></td></tr></table>
</div>
</div><p>（<em>）匹配任意一个字符，（%） 匹配大于等于 0 个任意字符。所以通配符'</em>%太%&lsquo;说明在第一个字符之后需要有“太”字，这里就不能匹配上“太乙真人”，但是可以匹配上“东皇太一”。如果数据表中有“太乙真人太太”，那么结果集中也可以匹配到。另外，单独的LIKE &lsquo;%&lsquo;无法查出 NULL 值，比如：SELECT * FROM heros WHERE role_assist LIKE &lsquo;%'。</p>
<h4 id="答疑-4">答疑 4</h4>
<p>可以理解在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？这个时候已经通过 WHERE 条件过滤得到了数据，已经不需要再筛选过滤数据了，只需要根据字段排序就好了。</p>
<p><strong>解答</strong></p>
<p>在 MySQL 中，支持两种排序方式，分别是 FileSort 和 Index 排序。在 Index 排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。而 FileSort 排序则一般在内存中进行排序，占用 CPU 较多。如果待排结果较大，会产生临时文件 I/O 到磁盘进行排序的情况，效率较低。所以使用 ORDER BY 子句时，应该尽量使用 Index 排序，避免使用 FileSort 排序。当然你可以使用 explain 来查看执行计划，看下优化器是否采用索引进行排序。优化建议：</p>
<p>SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，在 ORDER BY 子句避免使用 FileSort 排序。当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引。无法使用 Index 时，需要对 FileSort 方式进行调优。</p>
<h4 id="答疑-5">答疑 5</h4>
<p>ORDER BY 是对分的组排序还是对分组中的记录排序呢？</p>
<p><strong>解答</strong></p>
<p>ORDER BY 就是对记录进行排序。如果你在 ORDER BY 前面用到了 GROUP BY，实际上这是一种分组的聚合方式，已经把一组的数据聚合成为了一条记录，再进行排序的时候，相当于对分的组进行了排序。</p>
<h4 id="答疑-6">答疑 6</h4>
<p>请问下关于 SELECT 语句内部的执行步骤。</p>
<p><strong>解答</strong></p>
<p>一条完整的 SELECT 语句内部的执行顺序是这样的：</p>
<p>FROM 子句组装数据（包括通过 ON 进行连接）；WHERE 子句进行条件筛选；GROUP BY 分组 ；使用聚集函数进行计算；HAVING 筛选分组；计算所有的表达式；SELECT 的字段；ORDER BY 排序；LIMIT 筛选。</p>
<h4 id="答疑-7">答疑 7</h4>
<p>不太理解哪种情况下应该使用 EXISTS，哪种情况应该用 IN。选择的标准是看能否使用表的索引吗？</p>
<p><strong>解答</strong></p>
<p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。比如下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"> SELECT * FROM A WHERE cc IN (SELECT cc FROM B)
 SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)
</code></pre></td></tr></table>
</div>
</div><p>当 A 小于 B 时，用 EXISTS。因为 EXISTS 的实现，相当于外表循环，实现的逻辑类似于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"> for i in A
     for j in B
         if j.cc == i.cc then ...
</code></pre></td></tr></table>
</div>
</div><p>当 B 小于 A 时用 IN，因为实现的逻辑类似于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"> for i in B
     for j in A
         if j.cc == i.cc then ...
</code></pre></td></tr></table>
</div>
</div><p>哪个表小就用哪个表来驱动，A 表小就用 EXISTS，B 表小就用 IN。</p>
<h3 id="关于存储过程">关于存储过程</h3>
<h4 id="答疑-1-2">答疑 1</h4>
<p>在使用存储过程声明变量时，都支持哪些数据类型呢？</p>
<p><strong>解答</strong></p>
<p>不同的 DBMS 对数据类型的定义不同，你需要查询相关的 DBMS 文档。以 MySQL 为例，常见的数据类型可以分成三类，分别是数值类型、字符串类型和日期／时间类型。</p>
<h4 id="答疑-2-1">答疑 2</h4>
<p>“IN 参数必须在调用存储过程时指定”的含义是什么？我查询了 MySQL 的存储过程定义，可以不包含 IN 参数。当存储过程的定义语句里有 IN 参数时，存储过程的语句中必须用到这个参数吗?</p>
<p><strong>解答</strong></p>
<p>如果存储过程定义了 IN 参数，就需要在调用的时候传入。当然在定义存储过程的时候，如果不指定参数类型，就默认是 IN 类型的参数。因为 IN 参数在存储过程中是默认值，可以省略不写。比如下面两种定义方式都是一样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="k">CREATE</span><span class="w"> </span><span class="k">PROCEDURE</span><span class="w"> </span><span class="o">`</span><span class="n">add_num</span><span class="o">`</span><span class="p">(</span><span class="k">IN</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="kt">INT</span><span class="p">)</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="k">CREATE</span><span class="w"> </span><span class="k">PROCEDURE</span><span class="w"> </span><span class="o">`</span><span class="n">add_num</span><span class="o">`</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="kt">INT</span><span class="p">)</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>在存储过程中的语句里，不一定要用到 IN 参数，只是在调用的时候需要传入这个。另外 IN 参数在存储过程中进行了修改，也不会进行返回的。如果想要返回参数，需要使用 OUT，或者 INOUT 参数类型。</p>
<h3 id="关于事务处理">关于事务处理</h3>
<h4 id="答疑-1-3">答疑 1</h4>
<p>如果INSERT INTO test SELECT &lsquo;关羽&rsquo;;之后没有执行 COMMIT，结果应该是空。但是我执行出来的结果是&rsquo;关羽&rsquo;，为什么 ROLLBACK 没有全部回滚？</p>
<p>代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"> CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;
 BEGIN;
 INSERT INTO test SELECT &#39;关羽&#39;;
 BEGIN;
 INSERT INTO test SELECT &#39;张飞&#39;;
 INSERT INTO test SELECT &#39;张飞&#39;;
 ROLLBACK;
 SELECT * FROM test;
</code></pre></td></tr></table>
</div>
</div><p><strong>解答</strong></p>
<p>先解释下连续 BEGIN 的情况。在 MySQL 中 BEGIN 用于开启事务，如果是连续 BEGIN，当开启了第一个事务，还没有进行 COMMIT 提交时，会直接进行第二个事务的 BEGIN，这时数据库会隐式地 COMMIT 第一个事务，然后再进入到第二个事务。为什么 ROLLBACK 没有全部回滚呢？因为 ROLLBACK 是针对当前事务的，在 BEGIN 之后已经开启了第二个事务，当遇到 ROLLBACK 的时候，第二个事务都进行了回滚，也就得到了第一个事务执行之后的结果即“关羽”。关于事务的 ACID，以及我们使用 COMMIT 和 ROLLBACK 来控制事务的时候，有一个容易出错的地方。在一个事务的执行过程中可能会失败。遇到失败的时候是进行回滚，还是将事务执行过程中已经成功操作的来进行提交，这个逻辑是需要开发者自己来控制的。这里开发者可以决定，如果遇到了小错误是直接忽略，提交事务，还是遇到任何错误都进行回滚。如果我们强行进行 COMMIT，数据库会将这个事务中成功的操作进行提交，它会认为你觉得已经是 ACID 了（就是你认为可以做 COMMIT 了，即使遇到了一些小问题也是可以忽略的）。我在今天的文章里重点解答了一些问题，还有一些未解答的会留在评论里进行回复。最后出一道思考题吧。请你自己写出下面操作的运行结果（你可以把它作为一道笔试题，自己写出结果，再与实际的运行结果进行比对）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">DROP TABLE IF EXISTS test;
CREATE TABLE test(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;
BEGIN;
INSERT INTO test SELECT &#39;关羽&#39;;
BEGIN;
INSERT INTO test SELECT &#39;张飞&#39;;
INSERT INTO test SELECT &#39;张飞&#39;;
COMMIT;
SELECT * FROM test;
</code></pre></td></tr></table>
</div>
</div><h2 id="性能优化">性能优化</h2>
<h2 id="20丨当我们思考数据库调优的时候都有哪些维度可以选择">20丨当我们思考数据库调优的时候，都有哪些维度可以选择？</h2>
<h3 id="我们该如何思考和分析数据库调优这件事">我们该如何思考和分析数据库调优这件事</h3>
<p>做任何事情之前，我们都需要确认目标。在数据库调优中，我们的目标就是响应时间更快，吞吐量更大。利用宏观的监控工具和微观的日志分析可以帮我们快速找到调优的思路和方式。虽然每个人的情况都不一样，但我们同样需要对数据库调优这件事有一个整体的认知。在思考数据库调优的时候，可以从三个维度进行考虑。</p>
<p><strong>首先，选择比努力更重要。</strong></p>
<p>在进行 SQL 调优之前，可以先选择 DBMS 和数据表的设计方式。你能看到，不同的 DBMS 直接决定了后面的操作方式，数据表的设计方式也直接影响了后续的 SQL 查询语句。</p>
<p><strong>另外，你可以把 SQL 查询优化分成两个部分，逻辑查询优化和物理查询优化。</strong></p>
<p>虽然 SQL 查询优化的技术有很多，但是大方向上完全可以分成逻辑查询优化和物理查询优化两大块。逻辑查询优化就是通过 SQL 等价变换提升查询效率，直白一点就是说，换一种查询写法执行效率可能更高。物理查询优化则是通过索引和表连接方式等技术来进行优化，这里重点需要掌握索引的使用。</p>
<p><strong>最后，我们可以通过外援来增强数据库的性能。</strong></p>
<p>单一的数据库总会遇到各种限制，不如取长补短，利用外援的方式。另外通过对数据库进行垂直或者水平切分，突破单一数据库或数据表的访问限制，提升查询的性能。本篇文章中涉及到的概念和知识点比较多，也有可能出现纰漏，不过没有关系，我会在在后续的文章中陆续进行讲解。希望这篇文章可以让你站在一个宏观的角度对数据库的调优有系统性的认知，对今后的工作有一些启发。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/d3/b0/d3bc10314c3532f053304a00765183b0.jpg?wh=2408*2313"
        data-srcset="https://static001.geekbang.org/resource/image/d3/b0/d3bc10314c3532f053304a00765183b0.jpg?wh=2408*2313, https://static001.geekbang.org/resource/image/d3/b0/d3bc10314c3532f053304a00765183b0.jpg?wh=2408*2313 1.5x, https://static001.geekbang.org/resource/image/d3/b0/d3bc10314c3532f053304a00765183b0.jpg?wh=2408*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/d3/b0/d3bc10314c3532f053304a00765183b0.jpg?wh=2408*2313"
        title="img" /></p>
<h2 id="21丨范式设计数据表的范式有哪些3nf指的是什么">21丨范式设计：数据表的范式有哪些，3NF指的是什么？</h2>
<p>总结
我们今天讲解了数据表设计的三种范式。关系型数据库的设计都是基于关系模型的，在关系模型中存在着 4 种键，这些键的核心作用就是标识。在这些概念的基础上，我又讲了 1NF，2NF 和 3NF。我们经常会与这三种范式打交道，利用它们建立冗余度小、结构合理的数据库。有一点需要注意的是，这些范式只是提出了设计的标准，实际上设计数据表时，未必要符合这些原则。一方面是因为这些范式本身存在一些问题，可能会带来插入，更新，删除等的异常情况（这些会在下一讲举例说明），另一方面，它们也可能降低会查询的效率。这是为什么呢？因为范式等级越高，设计出来的数据表就越多，进行数据查询的时候就可能需要关联多张表，从而影响查询效率。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/e7/11/e775113e733020a7810196afd4f58711.jpg?wh=3341*1778"
        data-srcset="https://static001.geekbang.org/resource/image/e7/11/e775113e733020a7810196afd4f58711.jpg?wh=3341*1778, https://static001.geekbang.org/resource/image/e7/11/e775113e733020a7810196afd4f58711.jpg?wh=3341*1778 1.5x, https://static001.geekbang.org/resource/image/e7/11/e775113e733020a7810196afd4f58711.jpg?wh=3341*1778 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/e7/11/e775113e733020a7810196afd4f58711.jpg?wh=3341*1778"
        title="img" /></p>
<h2 id="22丨反范式设计3nf有什么不足为什么有时候需要反范式设计">22丨反范式设计：3NF有什么不足，为什么有时候需要反范式设计？</h2>
<p>总结
今天我们讲了 BCNF，它是基于 3NF 进行的改进。你能看到设计范式越高阶，数据表就会越精细，数据的冗余度也就越少，在一定程度上可以让数据库在内部关联上更好地组织数据。但有时候我们也需要采用反范进行优化，通过空间来换取时间。范式本身没有优劣之分，只有适用场景不同。没有完美的设计，只有合适的设计，我们在数据表的设计中，还需要根据需求将范式和反范式混合使用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/ac/fb/acbb07c269c85683cc981c7f677d32fb.jpg?wh=3341*1521"
        data-srcset="https://static001.geekbang.org/resource/image/ac/fb/acbb07c269c85683cc981c7f677d32fb.jpg?wh=3341*1521, https://static001.geekbang.org/resource/image/ac/fb/acbb07c269c85683cc981c7f677d32fb.jpg?wh=3341*1521 1.5x, https://static001.geekbang.org/resource/image/ac/fb/acbb07c269c85683cc981c7f677d32fb.jpg?wh=3341*1521 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/ac/fb/acbb07c269c85683cc981c7f677d32fb.jpg?wh=3341*1521"
        title="img" /></p>
<h2 id="23丨索引的概览用还是不用索引这是一个问题">23丨索引的概览：用还是不用索引，这是一个问题</h2>
<p>总结
使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索引时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）。在实际工作中，我们还需要基于需求和数据本身的分布情况来确定是否使用索引，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/7c/57/7c46394b6a09ba83befe2d18e466c957.jpg?wh=3341*2086"
        data-srcset="https://static001.geekbang.org/resource/image/7c/57/7c46394b6a09ba83befe2d18e466c957.jpg?wh=3341*2086, https://static001.geekbang.org/resource/image/7c/57/7c46394b6a09ba83befe2d18e466c957.jpg?wh=3341*2086 1.5x, https://static001.geekbang.org/resource/image/7c/57/7c46394b6a09ba83befe2d18e466c957.jpg?wh=3341*2086 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/7c/57/7c46394b6a09ba83befe2d18e466c957.jpg?wh=3341*2086"
        title="img" /></p>
<h2 id="24丨索引的原理我们为什么用b树来做索引">24丨索引的原理：我们为什么用B+树来做索引？</h2>
<p>总结
磁盘的 I/O 操作次数对索引的使用效率至关重要。虽然传统的二叉树数据结构查找数据的效率高，但很容易增加磁盘 I/O 操作的次数，影响索引使用的效率。因此在构造索引的时候，我们更倾向于采用“矮胖”的数据结构。B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树，B+ 树在查询性能上更稳定，在磁盘页大小相同的情况下，树的构造更加矮胖，所需要进行的磁盘 I/O 次数更少，更适合进行关键字的范围查询。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/92/90/922bfe97e007d24f4467f5af4e1a0790.jpg?wh=2766*2313"
        data-srcset="https://static001.geekbang.org/resource/image/92/90/922bfe97e007d24f4467f5af4e1a0790.jpg?wh=2766*2313, https://static001.geekbang.org/resource/image/92/90/922bfe97e007d24f4467f5af4e1a0790.jpg?wh=2766*2313 1.5x, https://static001.geekbang.org/resource/image/92/90/922bfe97e007d24f4467f5af4e1a0790.jpg?wh=2766*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/92/90/922bfe97e007d24f4467f5af4e1a0790.jpg?wh=2766*2313"
        title="img" /></p>
<h2 id="25丨hash索引的底层原理是什么">25丨Hash索引的底层原理是什么？</h2>
<p>总结
我今天讲了 Hash 索引的底层原理，你能看到 Hash 索引存在着很多限制，相比之下在数据库中 B+ 树索引的使用面会更广，不过也有一些场景采用 Hash 索引效率更高，比如在键值型（Key-Value）数据库中，Redis 存储的核心就是 Hash 表。另外 MySQL 中的 Memory 存储引擎支持 Hash 存储，如果我们需要用到查询的临时表时，就可以选择 Memory 存储引擎，把某个字段设置为 Hash 索引，比如字符串类型的字段，进行 Hash 计算之后长度可以缩短到几个字节。当字段的重复度低，而且经常需要进行等值查询的时候，采用 Hash 索引是个不错的选择。另外 MySQL 的 InnoDB 存储引擎还有个“自适应 Hash 索引”的功能，就是当某个索引值使用非常频繁的时候，它会在 B+ 树索引的基础上再创建一个 Hash 索引，这样让 B+ 树也具备了 Hash 索引的优点。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/88/90/8893fcfee2c8c374e9c7ae7e66f2cf90.jpg?wh=3341*2302"
        data-srcset="https://static001.geekbang.org/resource/image/88/90/8893fcfee2c8c374e9c7ae7e66f2cf90.jpg?wh=3341*2302, https://static001.geekbang.org/resource/image/88/90/8893fcfee2c8c374e9c7ae7e66f2cf90.jpg?wh=3341*2302 1.5x, https://static001.geekbang.org/resource/image/88/90/8893fcfee2c8c374e9c7ae7e66f2cf90.jpg?wh=3341*2302 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/88/90/8893fcfee2c8c374e9c7ae7e66f2cf90.jpg?wh=3341*2302"
        title="img" /></p>
<h2 id="26丨索引的使用原则如何通过索引让sql查询效率最大化">26丨索引的使用原则：如何通过索引让SQL查询效率最大化？</h2>
<p>总结
今天我们对索引的使用原则进行了梳理，使用好索引可以提升 SQL 查询的效率，但同时 也要注意索引不是万能的。为了避免全表扫描，我们还需要注意有哪些情况可能会导致索引失效，这时就需要进行查询重写，让索引发挥作用。实际工作中，查询的需求多种多样，创建的索引也会越来越多。这时还需要注意，我们要尽可能扩展索引，而不是新建索引，因为索引数量过多需要维护的成本也会变大，导致写效率变低。同时，我们还需要定期查询使用率低的索引，对于从未使用过的索引可以进行删除，这样才能让索引在 SQL 查询中发挥最大价值。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/81/f4/81147e99e2533126533500a087086ef4.jpg?wh=3341*2220"
        data-srcset="https://static001.geekbang.org/resource/image/81/f4/81147e99e2533126533500a087086ef4.jpg?wh=3341*2220, https://static001.geekbang.org/resource/image/81/f4/81147e99e2533126533500a087086ef4.jpg?wh=3341*2220 1.5x, https://static001.geekbang.org/resource/image/81/f4/81147e99e2533126533500a087086ef4.jpg?wh=3341*2220 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/81/f4/81147e99e2533126533500a087086ef4.jpg?wh=3341*2220"
        title="img" /></p>
<p>针对 product_comment 数据表，其中 comment_time 已经创建了普通索引。假设我想查询评论时间在 2018 年 10 月 1 日上午 10 点到 2018 年 10 月 2 日上午 10 点之间的评论，SQL 语句为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">SELECT comment_id, comment_text, comment_time FROM product_comment WHERE DATE(comment_time) &gt;= &#39;2018-10-01 10:00:00&#39; AND comment_time &lt;= &#39;2018-10-02 10:00:00&#39;
</code></pre></td></tr></table>
</div>
</div><p>你可以想一下这时候索引是否会失效，为什么？如果失效的话，要进行查询重写，应该怎样写？</p>
<h2 id="27丨从数据页的角度理解b树查询">27丨从数据页的角度理解B+树查询</h2>
<p>总结
今天我们学习了数据库中的基本存储单位，也就是页（Page），磁盘 I/O 都是基于页来进行读取的，在页之上还有区、段和表空间，它们都是更大的存储单位。我们在分配空间的时候会按照页为单位来进行分配，同一棵树上同一层的页与页之间采用双向链表，而在页里面，记录之间采用的单向链表的方式。链表这种数据结构的特点是增加、删除比较方便，所以在对记录进行删除的时候，有时候并不是真的删除了记录，而只是逻辑上的删除，也就是在标记为上标记为“已删除”。但链表还有个问题就是查找效率低，因此在页结构中还专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索提升效率。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c1/74/c127149aad62be7a1ee2c366757a2e74.jpg?wh=2272*2313"
        data-srcset="https://static001.geekbang.org/resource/image/c1/74/c127149aad62be7a1ee2c366757a2e74.jpg?wh=2272*2313, https://static001.geekbang.org/resource/image/c1/74/c127149aad62be7a1ee2c366757a2e74.jpg?wh=2272*2313 1.5x, https://static001.geekbang.org/resource/image/c1/74/c127149aad62be7a1ee2c366757a2e74.jpg?wh=2272*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c1/74/c127149aad62be7a1ee2c366757a2e74.jpg?wh=2272*2313"
        title="img" /></p>
<h2 id="28丨从磁盘io的角度理解sql查询的成本">28丨从磁盘I/O的角度理解SQL查询的成本</h2>
<p>总结
上一节我们了解到了页是数据库存储的最小单位，这一节我们了解了在数据库中是如何加载使用页的。SQL 查询是一个动态的过程，从页加载的角度来看，我们可以得到以下两点结论：</p>
<p>位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多 10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。</p>
<p>所以说，遇到 I/O 并不用担心，方法找对了，效率还是很高的。我们首先要考虑数据存放的位置，如果是经常使用的数据就要尽量放到缓冲池中，其次我们可以充分利用磁盘的吞吐能力，一次性批量读取数据，这样单个页的读取效率也就得到了提升。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/f2/77/f254372aac175d6ac571ebe9ec024777.jpg?wh=3341*1887"
        data-srcset="https://static001.geekbang.org/resource/image/f2/77/f254372aac175d6ac571ebe9ec024777.jpg?wh=3341*1887, https://static001.geekbang.org/resource/image/f2/77/f254372aac175d6ac571ebe9ec024777.jpg?wh=3341*1887 1.5x, https://static001.geekbang.org/resource/image/f2/77/f254372aac175d6ac571ebe9ec024777.jpg?wh=3341*1887 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/f2/77/f254372aac175d6ac571ebe9ec024777.jpg?wh=3341*1887"
        title="img" /></p>
<h2 id="29丨为什么没有理想的索引">29丨为什么没有理想的索引？</h2>
<p>总结
你能看到针对一条 SQL 查询来说，三星索引是个理想的方式，但实际运行起来我们要考虑更多维护的成本，在索引效率和索引维护之间进行权衡。</p>
<p>三星索引会让索引变宽，好处就是不需要进行回表查询，减少了磁盘 I/O 的次数，弊端就是会造成频繁的页分裂和页合并，对于数据的插入和更新来说，效率会降低不少。那我们该如何设计索引呢？首先一张表的索引个数不宜过多，否则一条记录的增加和修改，会因为过多的索引造成额外的负担。针对这个情况，当你需要新建索引的时候，首先考虑在原有的索引片上增加索引，也就是采用复合索引的方式，而不是新建一个新的索引。另外我们可以定期检查索引的使用情况，对于很少使用到的索引可以及时删除，从而减少索引数量。同时，在索引片中，我们也需要控制索引列的数量，通常情况下我们将 WHERE 里的条件列添加到索引中，而 SELECT 中的非条件列则不需要添加。除非 SELECT 中的非条件列数少，并且该字段会经常使用到。另外单列索引和复合索引的长度也需要控制，在 MySQL InnoDB 中，系统默认单个索引长度最大为 767 bytes，如果单列索引长度超过了这个限制，就会取前缀索引，也就是取前 255 字符。这实际上也是告诉我们，字符列会占用较大的空间，在数据表设计的时候，尽量采用数值类型替代字符类型，尽量避免用字符类型做主键，同时针对字符字段最好只建前缀索引。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/f4/f4/f417b01c6e4d560b2cbe3c54c6e9dbf4.jpg?wh=3341*2086"
        data-srcset="https://static001.geekbang.org/resource/image/f4/f4/f417b01c6e4d560b2cbe3c54c6e9dbf4.jpg?wh=3341*2086, https://static001.geekbang.org/resource/image/f4/f4/f417b01c6e4d560b2cbe3c54c6e9dbf4.jpg?wh=3341*2086 1.5x, https://static001.geekbang.org/resource/image/f4/f4/f417b01c6e4d560b2cbe3c54c6e9dbf4.jpg?wh=3341*2086 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/f4/f4/f417b01c6e4d560b2cbe3c54c6e9dbf4.jpg?wh=3341*2086"
        title="img" /></p>
<h2 id="30丨锁悲观锁和乐观锁是什么">30丨锁：悲观锁和乐观锁是什么？</h2>
<p>总结
今天我们讲解了数据库中锁的划分，你能看到从不同维度都可以对锁进行划分，需要注意的是，乐观锁和悲观锁并不是锁，而是锁的设计思想。既然有锁的存在，就有可能发生死锁的情况。死锁就是多个事务（如果是在程序层面就是多个进程）在执行过程中，因为竞争某个相同的资源而造成阻塞的现象。发生死锁，往往是因为在事务中，锁的获取是逐步进行的。我在文章中举了一个例子，在客户端 1 获取某数据行共享锁的同时，另一个客户端 2 也获取了该数据行的共享锁，这时任何一个客户端都没法对这个数据进行更新，因为共享锁会阻止其他事务对数据的更新，当某个客户端想要对锁定的数据进行更新的时候，就出现了死锁的情况。当死锁发生的时候，就需要一个事务进行回滚，另一个事务获取锁完成事务，然后将锁释放掉，很像交通堵塞时候的解决方案。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313"
        data-srcset="https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313, https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313 1.5x, https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/97/7f/9794e3a155edbf8d7b68a7ff8910fc7f.jpg?wh=3011*2313"
        title="img" /></p>
<p>我们都不希望出现死锁的情况，可以采取一些方法避免死锁的发生：如果事务涉及多个表，操作比较复杂，那么可以尽量一次锁定所有的资源，而不是逐步来获取，这样可以减少死锁发生的概率；如果事务需要更新数据表中的大部分数据，数据表又比较大，这时可以采用锁升级的方式，比如将行级锁升级为表级锁，从而减少死锁产生的概率；不同事务并发读写多张数据表，可以约定访问表的顺序，采用相同的顺序降低死锁发生的概率。</p>
<p>当然在数据库中，也有一些情况是不会发生死锁的，比如采用乐观锁的方式。另外在 MySQL MyISAM 存储引擎中也不会出现死锁，这是因为 MyISAM 总是一次性获得全部的锁，这样的话要么全部满足可以执行，要么就需要全部等待。</p>
<h2 id="31丨为什么大部分rdbms都会支持mvcc">31丨为什么大部分RDBMS都会支持MVCC？</h2>
<p>总结
今天关于 MVCC 的内容有些多，通过学习你应该能对采用 MVCC 这种乐观锁的方式来保证事务的隔离效果更有体会。我们需要记住，MVCC 的核心就是 Undo Log+ Read View，“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示。同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。MVCC 是一种机制，MySQL、Oracle、SQL Server 和 PostgreSQL 的实现方式均有不同，我们在学习的时候，更主要的是要理解 MVCC 的设计思想。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/4f/5a/4f1cb2414cae9216ee6b3a5fa19a855a.jpg?wh=2366*2313"
        data-srcset="https://static001.geekbang.org/resource/image/4f/5a/4f1cb2414cae9216ee6b3a5fa19a855a.jpg?wh=2366*2313, https://static001.geekbang.org/resource/image/4f/5a/4f1cb2414cae9216ee6b3a5fa19a855a.jpg?wh=2366*2313 1.5x, https://static001.geekbang.org/resource/image/4f/5a/4f1cb2414cae9216ee6b3a5fa19a855a.jpg?wh=2366*2313 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/4f/5a/4f1cb2414cae9216ee6b3a5fa19a855a.jpg?wh=2366*2313"
        title="img" /></p>
<h2 id="32丨查询优化器是如何工作的">32丨查询优化器是如何工作的？</h2>
<p>总结
我今天讲解了查询优化器，它在 RDBMS 中是个非常重要的角色。在优化器中会经历逻辑查询优化和物理查询优化阶段。最后我们只是简单梳理了下 CBO 的总代价是如何计算的，以及包括了哪些部分。CBO 的代价计算是个复杂的过程，细节很多，不同优化器的实现方式也不同。另外随着优化器的逐渐成熟，考虑的因素也会越来越多。在某些情况下 MySQL 还会把 RBO 和 CBO 组合起来一起使用。RBO 是个简单固化的模型，在 Oracle 8i 之前采用的就是 RBO，在优化器中一共包括了 15 种规则，输入的 SQL 会根据符合规则的情况得出相应的执行计划，在 Oracle 10g 版本之后就用 CBO 替代了 RBO。CBO 中需要传入的参数除了 SQL 查询以外，还包括了优化器参数、数据表统计信息和系统配置等，这实际上也导致 CBO 出现了一些缺陷，比如统计信息不准确，参数配置过高或过低，都会导致路径选择的偏差。除此以外，查询优化器还需要在优化时间和执行计划质量之间进行平衡，比如一个执行计划的执行时间是 10 秒钟，就没有必要花 1 分钟优化执行计划，除非该 SQL 使用频繁高，后续可以重复使用该执行计划。同样 CBO 也会做一些搜索空间的剪枝，以便在有效的时间内找到一个“最优”的执行计划。这里，其实也是在告诉我们，为了得到一个事物，付出的成本过大，即使最终得到了，有时候也是得不偿失的。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/1b/36/1be7b4fcd9ebdbfcc4f203a6c5e4a836.jpg?wh=3341*2298"
        data-srcset="https://static001.geekbang.org/resource/image/1b/36/1be7b4fcd9ebdbfcc4f203a6c5e4a836.jpg?wh=3341*2298, https://static001.geekbang.org/resource/image/1b/36/1be7b4fcd9ebdbfcc4f203a6c5e4a836.jpg?wh=3341*2298 1.5x, https://static001.geekbang.org/resource/image/1b/36/1be7b4fcd9ebdbfcc4f203a6c5e4a836.jpg?wh=3341*2298 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/1b/36/1be7b4fcd9ebdbfcc4f203a6c5e4a836.jpg?wh=3341*2298"
        title="img" /></p>
<h2 id="33丨如何使用性能分析工具定位sql执行慢的原因">33丨如何使用性能分析工具定位SQL执行慢的原因？</h2>
<p>总结
我今天梳理了 SQL 优化的思路，从步骤上看，我们需要先进行观察和分析，分析工具的使用在日常工作中还是很重要的。今天只介绍了常用的三种分析工具，实际上可以使用的分析工具还有很多。我在这里总结一下今天文章里提到的三种分析工具。我们可以通过慢查询日志定位执行慢的 SQL，然后通过 EXPLAIN 分析该 SQL 语句是否使用到了索引，以及具体的数据表访问方式是怎样的。我们也可以使用 SHOW PROFILE 进一步了解 SQL 每一步的执行时间，包括 I/O 和 CPU 等资源的使用情况。</p>
<h2 id="34丨答疑篇关于索引以及缓冲池的一些解惑">34丨答疑篇：关于索引以及缓冲池的一些解惑</h2>
<p>这篇文章是进阶篇的最后一篇，在这一模块中，我主要针对 SQL 运行的底层原理进行了讲解，其中还有很多问题没有回答，我总结了进阶篇中常见的一些问题，希望能对你有所帮助。下面的内容主要包括了索引原则、自适应 Hash、缓冲池机制和存储引擎等。</p>
<h3 id="关于索引b-树索引和-hash-索引以及索引原则">关于索引（B+ 树索引和 Hash 索引，以及索引原则）</h3>
<h4 id="什么是自适应-hash-索引">什么是自适应 Hash 索引？</h4>
<p>在回答这个问题前，让我们先回顾下 B+ 树索引和 Hash 索引：因为 B+ 树可以使用到范围查找，同时是按照顺序的方式对数据进行存储，因此很容易对数据进行排序操作，在联合索引中也可以利用部分索引键进行查询。这些情况下，我们都没法使用 Hash 索引，因为 Hash 索引仅能满足（=）（&lt;&gt;）和 IN 查询，不能使用范围查询。此外，Hash 索引还有一个缺陷，数据的存储是没有顺序的，在 ORDER BY 的情况下，使用 Hash 索引还需要对数据重新排序。而对于联合索引的情况，Hash 值是将联合索引键合并后一起来计算的，无法对单独的一个键或者几个索引键进行查询。MySQL 默认使用 B+ 树作为索引，因为 B+ 树有着 Hash 索引没有的优点，那么为什么还需要自适应 Hash 索引呢？这是因为 Hash 索引在进行数据检索的时候效率非常高，通常只需要 O(1) 的复杂度，也就是一次就可以完成数据的检索。虽然 Hash 索引的使用场景有很多限制，但是优点也很明显，所以 MySQL 提供了一个自适应 Hash 索引的功能（Adaptive Hash Index）。注意，这里的自适应指的是不需要人工来制定，系统会根据情况自动完成。什么情况下才会使用自适应 Hash 索引呢？如果某个数据经常被访问，当满足一定条件的时候，就会将这个数据页的地址存放到 Hash 表中。这样下次查询的时候，就可以直接找到这个页面的所在位置。需要说明的是自适应 Hash 索引只保存热数据（经常被使用到的数据），并非全表数据。因此数据量并不会很大，因此自适应 Hash 也是存放到缓冲池中，这样也进一步提升了查找效率。InnoDB 中的自适应 Hash 相当于“索引的索引”，采用 Hash 索引存储的是 B+ 树索引中的页面的地址。如下图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/69/e0/692193e1df655561619cb464201ba3e0.jpg?wh=757*574"
        data-srcset="https://static001.geekbang.org/resource/image/69/e0/692193e1df655561619cb464201ba3e0.jpg?wh=757*574, https://static001.geekbang.org/resource/image/69/e0/692193e1df655561619cb464201ba3e0.jpg?wh=757*574 1.5x, https://static001.geekbang.org/resource/image/69/e0/692193e1df655561619cb464201ba3e0.jpg?wh=757*574 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/69/e0/692193e1df655561619cb464201ba3e0.jpg?wh=757*574"
        title="img" /></p>
<p>你能看到，采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时候，通过自适应 Hash 索引可以明显提高数据的检索效率。我们来看下自适应 Hash 索引的原理。自适应 Hash 采用 Hash 函数映射到一个 Hash 表中，如下图所示，查找字典类型的数据非常方便。Hash 表是数组 + 链表的形式。通过 Hash 函数可以计算索引键值所对应的 bucket（桶）的位置，如果产生 Hash 冲突，就需要遍历链表来解决。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/a6/ae/a6d510f8ca80feef8cb21b5fe55ef0ae.jpg?wh=1030*575"
        data-srcset="https://static001.geekbang.org/resource/image/a6/ae/a6d510f8ca80feef8cb21b5fe55ef0ae.jpg?wh=1030*575, https://static001.geekbang.org/resource/image/a6/ae/a6d510f8ca80feef8cb21b5fe55ef0ae.jpg?wh=1030*575 1.5x, https://static001.geekbang.org/resource/image/a6/ae/a6d510f8ca80feef8cb21b5fe55ef0ae.jpg?wh=1030*575 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/a6/ae/a6d510f8ca80feef8cb21b5fe55ef0ae.jpg?wh=1030*575"
        title="img" /></p>
<p>我们可以通过innodb_adaptive_hash_index变量来查看是否开启了自适应 Hash，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">mysql&gt; show variables like &#39;%adaptive_hash_index&#39;;
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/70/99/70e9907a16ec51f03cb99295fafd0899.png?wh=1286*392"
        data-srcset="https://static001.geekbang.org/resource/image/70/99/70e9907a16ec51f03cb99295fafd0899.png?wh=1286*392, https://static001.geekbang.org/resource/image/70/99/70e9907a16ec51f03cb99295fafd0899.png?wh=1286*392 1.5x, https://static001.geekbang.org/resource/image/70/99/70e9907a16ec51f03cb99295fafd0899.png?wh=1286*392 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/70/99/70e9907a16ec51f03cb99295fafd0899.png?wh=1286*392"
        title="img" /></p>
<p>我来总结一下，InnoDB 本身不支持 Hash 索引，但是提供自适应 Hash 索引，不需要用户来操作，存储引擎会自动完成。自适应 Hash 是 InnoDB 三大关键特性之一，另外两个分别是插入缓冲和二次写。</p>
<h4 id="什么是联合索引的最左原则">什么是联合索引的最左原则？</h4>
<p>关于联合索引的最左原则，读者 @老毕 给出了一个非常形象的解释：</p>
<p>假设我们有 x、y、z 三个字段，创建联合索引（x, y, z）之后，我们可以把 x、y、z 分别类比成“百分位”、“十分位”和“个位”。查询“x=9 AND y=8 AND z=7”的过程，就是在一个由小到大排列的数值序列中寻找“987”，可以很快找到。查询“y=8 AND z=7”，就用不上索引了，因为可能存在 187、287、387、487………这样就必须扫描所有数值。我在这个基础上再补充说明一下。</p>
<p>查询“z=7 AND y=8 AND x=9”的时候，如果三个字段 x、y、z 在条件查询的时候是乱序的，但采用的是等值查询（=）或者是 IN 查询，那么 MySQL 的优化器可以自动帮我们调整为可以使用联合索引的形式。当我们查询“x=9 AND y&gt;8 AND z=7”的时候，如果建立了 (x,y,z) 顺序的索引，这时候 z 是用不上索引的。这是因为 MySQL 在匹配联合索引最左前缀的时候，如果遇到了范围查询，比如（&lt;）（&gt;）和 between 等，就会停止匹配。索引列最多作用于一个范围列，对于后面的 Z 来说，就没法使用到索引了。通过这个我们也可以知道，联合索引的最左前缀匹配原则针对的是创建的联合索引中的顺序，如果创建了联合索引（x,y,z），那么这个索引的使用顺序就很重要了。如果在条件语句中只有 y 和 z，那么就用不上联合索引。此外，SQL 条件语句中的字段顺序并不重要，因为在逻辑查询优化阶段会自动进行查询重写。最后你需要记住，如果我们遇到了范围条件查询，比如（&lt;）（&lt;=）（&gt;）（&gt;=）和 between 等，那么范围列后的列就无法使用到索引了。</p>
<h4 id="hash-索引与-b-树索引是在建索引的时候手动指定的吗">Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？</h4>
<p>如果使用的是 MySQL 的话，我们需要了解 MySQL 的存储引擎都支持哪些索引结构，如下图所示（参考来源 <a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" target="_blank" rel="noopener noreffer">https://dev.mysql.com/doc/refman/8.0/en/create-index.html</a>）。如果是其他的 DBMS，可以参考相关的 DBMS 文档。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/f7/38/f7706327f9ebc7488653d69b4cd5f438.png?wh=1729*518"
        data-srcset="https://static001.geekbang.org/resource/image/f7/38/f7706327f9ebc7488653d69b4cd5f438.png?wh=1729*518, https://static001.geekbang.org/resource/image/f7/38/f7706327f9ebc7488653d69b4cd5f438.png?wh=1729*518 1.5x, https://static001.geekbang.org/resource/image/f7/38/f7706327f9ebc7488653d69b4cd5f438.png?wh=1729*518 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/f7/38/f7706327f9ebc7488653d69b4cd5f438.png?wh=1729*518"
        title="img" /></p>
<p>你能看到，针对 InnoDB 和 MyISAM 存储引擎，都会默认采用 B+ 树索引，无法使用 Hash 索引。InnoDB 提供的自适应 Hash 是不需要手动指定的。如果是 Memory/Heap 和 NDB 存储引擎，是可以进行选择 Hash 索引的。</p>
<h3 id="关于缓冲池">关于缓冲池</h3>
<h4 id="缓冲池和查询缓存是一个东西吗">缓冲池和查询缓存是一个东西吗？</h4>
<p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种数据的缓存，如下图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/0e/dc/0eb57c0d0ea7611b16ac6efa76771bdc.jpg?wh=742*334"
        data-srcset="https://static001.geekbang.org/resource/image/0e/dc/0eb57c0d0ea7611b16ac6efa76771bdc.jpg?wh=742*334, https://static001.geekbang.org/resource/image/0e/dc/0eb57c0d0ea7611b16ac6efa76771bdc.jpg?wh=742*334 1.5x, https://static001.geekbang.org/resource/image/0e/dc/0eb57c0d0ea7611b16ac6efa76771bdc.jpg?wh=742*334 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/0e/dc/0eb57c0d0ea7611b16ac6efa76771bdc.jpg?wh=742*334"
        title="img" /></p>
<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典信息等。我们之前讲过使用缓冲池技术的原因。这里重新回顾一下。InnoDB 存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间 I/O 效率的差值，我们就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘 I/O。“频次 * 位置”这个原则，可以帮我们对 I/O 访问效率进行优化。首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有 200G，但是内存只有 16G，缓冲池大小只有 1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。了解了缓冲池的作用之后，我们还需要了解缓冲池的另一个特性：预读。缓冲池的作用就是提升 I/O 效率，而我们进行读取数据的时候存在一个“局部性原理”，也就是说我们使用了一些数据，大概率还会使用它周围的一些数据，因此采用“预读”的机制提前加载，可以减少未来可能的磁盘 I/O 操作。那么什么是查询缓存呢？</p>
<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。这就意味着查询匹配的鲁棒性大大降低，只有相同的查询操作才会命中查询缓存。因此 MySQL 的查询缓存命中率不高，在 MySQL8.0 版本中已经弃用了查询缓存功能。查看是否使用了查询缓存，使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">show variables like &#39;%query_cache%&#39;;
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/cb/c7/cb590bd0aac9751401943487534360c7.png?wh=1091*378"
        data-srcset="https://static001.geekbang.org/resource/image/cb/c7/cb590bd0aac9751401943487534360c7.png?wh=1091*378, https://static001.geekbang.org/resource/image/cb/c7/cb590bd0aac9751401943487534360c7.png?wh=1091*378 1.5x, https://static001.geekbang.org/resource/image/cb/c7/cb590bd0aac9751401943487534360c7.png?wh=1091*378 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/cb/c7/cb590bd0aac9751401943487534360c7.png?wh=1091*378"
        title="img" /></p>
<p>缓冲池并不等于查询缓存，它们的共同点都是通过缓存的机制来提升效率。但缓冲池服务于数据库整体的 I/O 操作，而查询缓存服务于 SQL 查询和查询结果集的，因为命中条件苛刻，而且只要数据表发生变化，查询缓存就会失效，因此命中率低。</p>
<h3 id="其他">其他</h3>
<p>很多人对 InnoDB 和 MyISAM 的取舍存在疑问，到底选择哪个比较好呢？我们需要先了解 InnoDB 和 MyISAM 各自的特点。InnoDB 支持事务和行级锁，是 MySQL 默认的存储引擎；MyISAM 只支持表级锁，不支持事务，更适合读取数据库的情况。如果是小型的应用，需要大量的 SELECT 查询，可以考虑 MyISAM；如果是事务处理应用，需要选择 InnoDB。这两种引擎各有特点，当然你也可以在 MySQL 中，针对不同的数据表，可以选择不同的存储引擎。最后给大家提供一下专栏中学习资料的下载。</p>
<p>如果你想导入文章中的“product_comment”表结构和数据，点击<a href="https://github.com/cystanford/product_comment" target="_blank" rel="noopener noreffer">这里</a>即可。你也可以在<a href="https://pan.baidu.com/s/1LBEAm50DDP9AjErLtGplLg" target="_blank" rel="noopener noreffer">网盘</a>里下载，提取码为 32ep。关于文章中涉及到的思维导图，点击<a href="https://github.com/cystanford/SQL-XMind" target="_blank" rel="noopener noreffer">这里</a>下载即可。</p>
<h2 id="35丨数据库主从同步的作用是什么如何解决数据不一致问题">35丨数据库主从同步的作用是什么，如何解决数据不一致问题？</h2>
<p>总结
我今天讲解了数据库的主从同步，如果你的目标仅仅是数据库的高并发，那么可以先从 SQL 优化，索引以及 Redis 缓存数据库这些方面来考虑优化，然后再考虑是否采用主从架构的方式。在主从架构的配置中，如果想要采取读写分离的策略，我们可以自己编写程序，也可以通过第三方的中间件来实现。自己编写程序的好处就在于比较自主，我们可以自己判断哪些查询在从库上来执行，针对实时性要求高的需求，我们还可以考虑哪些查询可以在主库上执行。同时，程序直接连接数据库，减少了中间件层，相当于减少了性能损耗。采用中间件的方法有很明显的优势，功能强大，使用简单。但因为在客户端和数据库之间增加了中间件层会有一些性能损耗，同时商业中间件也是有使用成本的。我们也可以考虑采取一些优秀的开源工具，比如 MaxScale。它是 MariaDB 开发的 MySQL 数据中间件。比如在下图中，使用 MaxScale 作为数据库的代理，通过路由转发完成了读写分离。同时我们也可以使用 MHA 工具作为强一致的主从切换工具，从而完成 MySQL 的高可用架构。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/39/94/392a43c1d483392349c165f9f9f1d994.jpg?wh=970*379"
        data-srcset="https://static001.geekbang.org/resource/image/39/94/392a43c1d483392349c165f9f9f1d994.jpg?wh=970*379, https://static001.geekbang.org/resource/image/39/94/392a43c1d483392349c165f9f9f1d994.jpg?wh=970*379 1.5x, https://static001.geekbang.org/resource/image/39/94/392a43c1d483392349c165f9f9f1d994.jpg?wh=970*379 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/39/94/392a43c1d483392349c165f9f9f1d994.jpg?wh=970*379"
        title="img" /></p>
<h2 id="36丨数据库没有备份没有使用binlog的情况下如何恢复数据">36丨数据库没有备份，没有使用Binlog的情况下，如何恢复数据？</h2>
<p>总结
我们刚才人工恢复了损坏的 ibd 文件中的数据，虽然没有 100% 找回，但是相比于束手无措来说，已经是不幸中的万幸，至少我们还可以把正确的数据页中的记录成功备份出来，尽可能恢复原有的数据表。在这个过程中相信你应该对 ibd 文件，以及 InnoDB 自身的强制恢复（Force Recovery）机制有更深的了解。数据表损坏，以及人为的误删除都不是我们想要看到的情况，但是我们不能指望运气，或者说我们不能祈祷这些事情不会发生。在遇到这些情况的时候，应该通过机制尽量保证数据库的安全稳定运行。这个过程最主要的就是应该及时备份，并且开启二进制日志，这样当有误操作的时候就可以通过数据库备份以及 Binlog 日志来完成数据恢复。同时采用延迟备份的策略也可以尽量抵御误操作。总之，及时备份是非常有必要的措施，同时我们还需要定时验证备份文件的有效性，保证备份文件可以正常使用。如果你遇到了数据库 ibd 文件损坏的情况，并且没有采用任何的备份策略，可以尝试使用 InnoDB 的强制恢复机制，启动 MySQL 并且将损坏的数据表转储到 MyISAM 数据表中，尽可能恢复已有的数据。总之机制比人为更靠谱，我们要为长期的运营做好充足的准备。一旦发生了误操作这种紧急情况，不要慌张，及时采取对应的措施才是最重要的。</p>
<h2 id="37丨sql注入你的sql是如何被注入的">37丨SQL注入：你的SQL是如何被注入的？</h2>
<p>总结
在今天的内容中，我使用了 sqli-labs 注入平台作为实验数据，使用了 SQLmap 工具自动完成 SQL 注入。SQL 注入的方法还有很多，我们今天讲解的只是其中一个方式。你如果对 SQL 注入感兴趣，也可以对 sqli-labs 中其他例子进行学习，了解更多 SQL 注入的方法。在这个过程中，最主要的是理解 SQL 注入的原理。在日常工作中，我们需要对用户提交的内容进行验证，以防止 SQL 注入。当然很多时候我们都在使用编程框架，这些框架已经极大地降低了 SQL 注入的风险，但是只要有 SQL 拼接的地方，这种风险就可能存在。总之，代码规范性对于 Web 安全来说非常重要，尽量不要采用直接拼接的方式进行查询。同时在 Web 上线之后，还需要将生产环境中的错误提示信息关闭，以减少被 SQL 注入的风险。此外我们也可以采用第三方的工具，比如 SQLmap 来对 Web 应用进行检测，以增强 Web 安全性。</p>
<h2 id="认识dbms">认识DBMS</h2>
<h2 id="38丨如何在excel中使用sql语言">38丨如何在Excel中使用SQL语言？</h2>
<p>总结
我们今天讲解了如何在 Excel 中使用 SQL 进行查询，在这个过程中你应该对”SQL 定义了查询的标准“更有体会。SQL 使得各种工具可以遵守 SQL 语言的标准（当然也有各自的方言）。如果你已经是个 SQL 高手，你会发现原来 SQL 和 Excel 还可以如此“亲密”。Excel 作为使用人数非常多的办公软件，提供了 SQL 查询会让我们操作起来非常方便。如果你还没有使用过 Excel 的这些功能，那么就赶快来用一下吧。SQL 作为一门结构化查询语言，具有很好的通用性，你还在其他工具中使用过 SQL 语言吗？如果有的话可以分享一下你的体会。</p>
<h2 id="39丨websql如何在h5中存储一个本地数据库">39丨WebSQL：如何在H5中存储一个本地数据库？</h2>
<p>总结
今天我讲解了如何在浏览器中通过 WebSQL 来操作本地存储，如果想使用 SQL 来管理和查询本地存储，我们可以使用 WebSQL，通过三个核心的方法就可以方便让我们对数据库的连接，事务处理，以及 SQL 语句的执行来进行操作。我在 Github 上提供了操作的 HTML 代码，如果还没有使用过 WebSQL 就快来使用下吧。我今天讲到了本地存储，在浏览器中包括了 Cookies、Local Storage、Session Storage、WebSQL 和 IndexedDB 这 5 种形式的本地存储，你能说下它们之间的区别么？</p>
<h2 id="40丨sqlite为什么微信用sqlite存储聊天记录">40丨SQLite：为什么微信用SQLite存储聊天记录？</h2>
<p>总结
我今天讲了有关 SQLite 的内容。在使用 SQLite 的时候，需要注意 SQLite 有自己的方言，比如在进行表连接查询的时候不支持 RIGHT JOIN，需要将其转换成 LEFT JOIN 等。同时，我们在使用 execute() 方法的时候，尽量采用带有参数的 SQL 语句，以免被 SQL 注入攻击。学习完今天的内容后，不如试试用 SQL 查询来查找本地的聊天记录吧。</p>
<h2 id="41丨初识redisredis为什么会这么快">41丨初识Redis：Redis为什么会这么快？</h2>
<p>总结
NoSQL 数据库种类非常多，了解 Redis 是非常有必要的，在实际工作中，我们也经常将 RDBMS 和 Redis 一起使用，优势互补。作为常见的 NoSQL 数据库，Redis 支持的数据类型比 Memcached 丰富得多，在 I/O 性能上，Redis 采用的是单线程 I/O 复用模型，而 Memcached 是多线程，可以利用多核优势。而且在持久化上，Redis 提供了两种持久化的模式，可以让数据永久保存，这是 Memcached 不具备的。</p>
<h2 id="42丨如何使用redis来实现多用户抢票问题">42丨如何使用Redis来实现多用户抢票问题</h2>
<p>总结
今天我讲解了 Redis 的事务机制，Redis 事务是一系列 Redis 命令的集合，事务中的所有命令都会按照顺序进行执行，并且在执行过程中不会受到其他客户端的干扰。不过在事务的执行中，Redis 可能会遇到下面两种错误的情况：首先是语法错误，也就是在 Redis 命令入队时发生的语法错误。Redis 在事务执行前不允许有语法错误，如果出现，则会导致事务执行失败。如官方文档所说，通常这种情况在生产环境中很少出现，一般会发生在开发环境中，如果遇到了这种语法错误，就需要开发人员自行纠错。第二个是执行时错误，也就是在事务执行时发生的错误，比如处理了错误类型的键等，这种错误并非语法错误，Redis 只有在实际执行中才能判断出来。不过 Redis 不提供回滚机制，因此当发生这类错误时 Redis 会继续执行下去，保证其他命令的正常执行。在事务处理中，我们需要通过锁的机制来解决共享资源并发访问的情况。在 Redis 中提供了 WATCH+MULTI 的乐观锁方式。我们之前了解过乐观锁是一种思想，它是通过程序实现的锁机制，在数据更新的时候进行判断，成功就执行，不成功就失败，不需要等待其他事务来释放锁。事实上，在在 Redis 的设计中，处处体现了这种乐观、简单的设计理念。</p>
<p>最后我们一起思考两个问题吧。Redis 既然是单线程程序，在执行事务过程中按照顺序执行，为什么还会用 WATCH+MULTI 的方式来实现乐观锁的并发控制呢？我们在进行抢票模拟的时候，列举了两个 Redis 客户端的例子，当 WATCH 的键 ticket 发生改变的时候，事务就会被打断。这里我将客户端 2 的 SET ticket 设置为 1，也就是 ticket 的数值没有发生变化，请问此时客户端 1 和客户端 2 的执行结果是怎样的，为什么？</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/d4/44/d4bb30f5d415ea93980c465e4f110544.png?wh=899*421"
        data-srcset="https://static001.geekbang.org/resource/image/d4/44/d4bb30f5d415ea93980c465e4f110544.png?wh=899*421, https://static001.geekbang.org/resource/image/d4/44/d4bb30f5d415ea93980c465e4f110544.png?wh=899*421 1.5x, https://static001.geekbang.org/resource/image/d4/44/d4bb30f5d415ea93980c465e4f110544.png?wh=899*421 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/d4/44/d4bb30f5d415ea93980c465e4f110544.png?wh=899*421"
        title="img" /></p>
<h2 id="43丨如何使用redis搭建玩家排行榜">43丨如何使用Redis搭建玩家排行榜？</h2>
<p>总结
今天我们使用 MySQL 和 Redis 搭建了排行榜，根据相同分数的处理方式，我们可以把排行榜分成并列排行榜和严格排行榜。虽然 MySQL 和 Redis 都可以搭建排行榜，但两者还是有区别的。MySQL 擅长存储数据，而对于数据的运算来说则效率不高，比如统计排行榜的排名，通常还是需要使用后端语言（比如 Python、PHP、Java 等）再进行统计。而 Redis 本身提供了丰富的排行榜统计功能，不论是增加、删除玩家，还是对某个玩家的分数进行调整，Redis 都可以对排行榜实时更新，对于游戏的实时排名来说，这还是很重要的。在 Redis 中还集成了 Lua 脚本语言，通过 Lua 我们可以更加灵活地扩展 Redis 的功能，同时在 Redis 中使用 Lua 语言，还可以对 Lua 脚本进行复用，减少网络开销，编写代码也更具有模块化。此外 Redis 在调用 Lua 脚本的时候，会将它作为一个整体，也就是说中间如果有其他的 Redis 命令是不会被插入进去的，也保证了 Lua 脚本执行过程中不会被其他命令所干扰。</p>
<p>我们今天使用 Redis 对 10 万名玩家的数据进行了排行榜的统计，相比于用 RDBMS 实现排行榜来说，使用 Redis 进行统计都有哪些优势呢？我们使用了 Lua 脚本模拟了 10 万名玩家的数据，其中玩家的分数 score 分成了两个部分，整数部分为实际的得分，小数部分为注册时间。例子中给出的严格排行榜是在分数相同的情况下，按照注册时间的长短进行的排名，注册时间长的排名靠前。如果我们将规则进行调整，同样是在分数相同的情况下，如果注册时间长的排名靠后，又该如何编写代码呢？</p>
<h2 id="44丨dbms篇总结和答疑用sqlite做词云">44丨DBMS篇总结和答疑：用SQLite做词云</h2>
<p>在认识 DBMS 篇中，我们讲解了 Excel+SQL、WebSQL、SQLite 以及 Redis 的使用，这些 DBMS 有自己适用的领域，我们可以根据需求选择适合的 DBMS。我总结了一些大家常见的问题，希望能对你有所帮助。</p>
<h3 id="关于-excelsql">关于 Excel+SQL</h3>
<h4 id="答疑-1关于-mysql-for-excel-的安装">答疑 1：关于 mysql-for-excel 的安装</h4>
<p>Excel 是我们常用的办公软件，使用 SQL 做数据分析的同学也可以使用 Excel+SQL 作为报表工具，通过它们提取一些指定条件的数据，形成数据透视表或者数据透视图。但是有同学在安装 mysql-for-excel-1.3.8.msi 时报错，这里感谢同学莫弹弹给出了解答。解决这个问题的办法是在安装时需要 Visual Studio 2010 Tools for Office Runtime 才能运行。它的下载链接在这里： <a href="https://www.microsoft.com/zh-CN/download/confirmation.aspx?id=56961" target="_blank" rel="noopener noreffer">https://www.microsoft.com/zh-CN/download/confirmation.aspx?id=56961</a></p>
<h3 id="关于-websql">关于 WebSQL</h3>
<p>我在讲解 WebSQL 操作本地存储时，可以使用浏览器中的 Clear Storage 功能。有同学问到：这里只能用户手动删除才可以吗？事实上，除了在浏览器里手动删除以外，我们完全可以通过程序来控制本地的 SQLite。使用 executeSql 函数即可，在 executeSql 函数后面有两个 function，分别代表成功之后的调用，以及执行失败的调用。比如想要删除本地 SQLite 的 heros 数据表，可以写成下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">tx.executeSql(&#34;DROP TABLE heros&#34;,[], 
function(tx, result) {alert(&#39;Drop 成功&#39;);},
function(tx, error) {alert(&#39;Drop 失败&#39; + error.message);});
</code></pre></td></tr></table>
</div>
</div><p>第二个问题是，Session 是什么概念呢？HTTP 请求不是无状态的吗？我在文章中讲到过 SessionStorage，这里的 Session 指的就是一个会话周期的数据，当我们关闭浏览器窗口的时候，SessionStorage 存储的数据就会被清空。相比之下 localStorage 存储的时间没有限制，一年之后数据依然可以存在。HTTP 本身是一个无状态的连接协议，想要保持客户端与服务器之间的交互，可以使用两种交互存储方式，即 Cookie 和 Session。Cookie 是通过客户端保存的数据，也就是可以保存服务器发送给客户端的信息，存储在浏览器中。一般来说，在服务器上也存在一个 Session，这个是通过服务器来存储的状态信息，这时会将浏览器与服务器之间的一系列交互称为一个 Session。这种情况下，Session 会存储在服务器端。不过我们讲解的 sessionStorage 是本地存储的解决方式，它存放在浏览器里，借用了 session 会话的概念，它指的是在本地存储过程中的一种临时存储方案，数据只有在同一个 session 会话中的页面才能访问，而且当 session 结束后数据也会释放掉。</p>
<h3 id="关于-sqlite">关于 SQLite</h3>
<p>第一个问题关于 SQLite 查找微信本地的聊天记录，有同学说可以导出聊天记录做个词云。这是个不错的 idea，我们既然有了 SQLite，完全可以动手做个数据分析，做个词云展示。我在《数据分析 45 讲》里讲到过词云的制作方法，这里使用 Python+SQLite 查询，将微信的聊天记录做个词云，具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">import sqlite3
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import jieba
import os
import re
 
# 去掉停用词
def remove_stop_words(f):
     stop_words = [&#39;你好&#39;, &#39;已添加&#39;, &#39;现在&#39;, &#39;可以&#39;, &#39;开始&#39;, &#39;聊天&#39;, &#39;当前&#39;, &#39;群聊&#39;, &#39;人数&#39;, &#39;过多&#39;, &#39;显示&#39;, &#39;群成员&#39;, &#39;昵称&#39;, &#39;信息页&#39;, &#39;关闭&#39;, &#39;参与人&#39;, &#39;还有&#39;, &#39;嗯&#39;]
     for stop_word in stop_words:
           f = f.replace(stop_word, &#39;&#39;)
     return f
 
# 生成词云
def create_word_cloud(f):
     print(&#39;根据微信聊天记录，生成词云!&#39;)
     # 设置本地的simhei字体文件位置
     FONT_PATH = os.environ.get(&#34;FONT_PATH&#34;, os.path.join(os.path.dirname(__file__), &#34;simhei.ttf&#34;))
     f = remove_stop_words(f)
     cut_text = &#34; &#34;.join(jieba.cut(f,cut_all=False, HMM=True))
     wc = WordCloud(
           font_path=FONT_PATH,
           max_words=100,
           width=2000,
           height=1200,
    )
     wordcloud = wc.generate(cut_text)
     # 写词云图片
     wordcloud.to_file(&#34;wordcloud.jpg&#34;)
     # 显示词云文件
     plt.imshow(wordcloud)
     plt.axis(&#34;off&#34;)
     plt.show()
 
def get_content_from_weixin():
     # 创建数据库连接
     conn = sqlite3.connect(&#34;weixin.db&#34;)
     # 获取游标
     cur = conn.cursor()
     # 创建数据表
     # 查询当前数据库中的所有数据表
     sql = &#34;SELECT name FROM sqlite_master WHERE type = &#39;table&#39; AND name LIKE &#39;Chat\_%&#39; escape &#39;\\\&#39;&#34;
     cur.execute(sql)
     tables = cur.fetchall()
     content = &#39;&#39;
     for table in tables:
         sql = &#34;SELECT Message FROM &#34; + table[0]
         print(sql)
         cur.execute(sql)
         temp_result = cur.fetchall()
         for temp in temp_result:
              content = content + str(temp)
     # 提交事务 
     conn.commit()
     # 关闭游标
     cur.close()
     # 关闭数据库连接
     conn.close()
     return content
content = get_content_from_weixin()
# 去掉HTML标签里的内容
pattern = re.compile(r&#39;&lt;[^&gt;]+&gt;&#39;,re.S)
content = pattern.sub(&#39;&#39;, content)
# 将聊天记录生成词云
create_word_cloud(content)
</code></pre></td></tr></table>
</div>
</div><p>运行结果：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c0/6b/c01ef48d13e80b5742248b9cf58cfb6b.png?wh=1727*1033"
        data-srcset="https://static001.geekbang.org/resource/image/c0/6b/c01ef48d13e80b5742248b9cf58cfb6b.png?wh=1727*1033, https://static001.geekbang.org/resource/image/c0/6b/c01ef48d13e80b5742248b9cf58cfb6b.png?wh=1727*1033 1.5x, https://static001.geekbang.org/resource/image/c0/6b/c01ef48d13e80b5742248b9cf58cfb6b.png?wh=1727*1033 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c0/6b/c01ef48d13e80b5742248b9cf58cfb6b.png?wh=1727*1033"
        title="img" /></p>
<p>你在<a href="https://github.com/cystanford/SQLite" target="_blank" rel="noopener noreffer">Github</a>上也可以找到相应的代码，这个结果图是我运行自己的微信聊天记录得出的。</p>
<p>我来讲解下代码中相关模块的作用。首先是create_word_cloud函数，通过聊天内容 f，展示出词云。这里会用到 WordCloud 类，通过它配置本地的 simhei 字体（因为需要显示中文），设置显示的最大词数max_words=100，图片的尺寸 width 和 height。第二个是remove_stop_words函数，用来设置停用词，也就是不需要统计的单词，这里我设置了一些，不过从结果中，你能看到我们需要更多的停用词，要不会统计出一些没有意义的词汇，比如“撤回”“一条”等。第三个是get_content_from_weixin函数。这里我们通过访问 SQLite 来访问微信聊天记录，首先需要查询数据表都有哪些，在微信的本地存储里每个数据表对应着一个聊天对象，然后我们对这些数据表中的 message 字段进行提取。最后，因为统计出来的聊天记录会包括大量的 HTML 标签，这里我们还需要采用正则表达式匹配的方式将 content 中的 HTML 标签去掉，然后调用create_word_cloud函数生成词云，结果就是文稿中的图片所示啦。</p>
<p>第二个问题是，Navicat 如何导入weixin.db呢？</p>
<p>事实上，使用 Navicat 导入weixin.db非常简单。首先我们需要创建 SQLite 连接，然后从本地选择数据库文件，这里选中weixin.db。然后就导入到 Navicat 中了，你在左侧可以看到 weixin 的连接，然后打开 main 数据库就可以看到聊天记录的数据表了。我制作了演示视频，可以看下。</p>
<h3 id="关于-redis">关于 Redis</h3>
<p>第一个问题，MongoDB、Redis 之间有什么区别？实际使用时应该怎么选择呢？</p>
<p>Redis 是 Key-Value 数据库，数据存放在内存中，查询和写入都是在内存中进行操作。当然 Redis 也支持持久化，但持久化只是 Redis 的功能之一，并不是 Redis 的强项。通常，你可以把 Redis 称之为缓存，它支持的数据类型丰富，包括字符串、哈希、列表、集合、有序集合，同时还支持基数统计、地理空间以及索引半径查询、数据流等。MongoDB 面向文档数据库，功能强大，是非关系型数据库中最像 RDBMS 的，处理增删改查也可以增加条件。在存储方式上，Redis 将数据放在内存中，通过 RDB 或者 AOF 方式进行持久化。而 MongoDB 实际上是将数据存放在磁盘上的，只是通过 mmap 调用，将数据映射到内存中，你可以将 mmap 理解为加速的方式。mmap 调用可以使得对普通文件的操作像是在内存中进行读写一样，这是因为它将文件映射到调用进程的地址空间中，实现了文件所在的磁盘物理地址与进程空间的虚拟地址一一映射的关系，这样就可以直接在内存中进行操作，然后写完之后同步一下就可以存放到文件中，效率非常高。不过在使用选择的时候，我们还是将 MongoDB 归为数据库，而将 Redis 归为缓存。总的来说，Redis 就像一架飞机，查询以及写入性能极佳，但是存储的数据规模有限。MongoDB 就像高铁，在处理货物（数据）的功能上强于 Redis，同时能承载的数据量远高于 Redis，但是查询及写入的效率不及 Redis。</p>
<p>第三个问题是，我们能否用 Redis 中的 DECR 实现多用户抢票问题？当然是可以的，在专栏文章中我使用了 WATCH+MULTI 的乐观锁方式，主要是讲解这种乐观锁的实现方式。我们也可以使用 Redis 中的 DECR 命令，对相应的 KEY 值进行减 1，操作是原子性的，然后我们判断下 DECR 之后的数值即可，当减 1 之后大于等于 0 证明抢票成功，否则小于 0 则说明抢票失败。这里我给出了相应的代码，你也可以在<a href="https://github.com/cystanford/Redis" target="_blank" rel="noopener noreffer">Github</a>上下载。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 抢票模拟，使用DECR原子操作
import redis
import threading
# 创建连接池
pool = redis.ConnectionPool(host = &#39;127.0.0.1&#39;, port=6379, db=0)
# 初始化 redis
r = redis.StrictRedis(connection_pool = pool)

# 设置KEY
KEY=&#34;ticket_count&#34;
# 模拟第i个用户进行抢购
def sell(i):
    # 使用decr对KEY减1
    temp = r.decr(KEY)
    if temp &gt;= 0:
        print(&#39;用户 {} 抢票成功，当前票数 {}&#39;.format(i, temp))
    else:
        print(&#39;用户 {} 抢票失败，票卖完了&#39;.format(i))

if __name__ == &#34;__main__&#34;:
    # 初始化5张票
    r.set(KEY, 5)  
    # 设置8个人抢票
    for i in range(8):
        t = threading.Thread(target=sell, args=(i,))
        t.start()
</code></pre></td></tr></table>
</div>
</div><p>最后有些同学感觉用 Redis，最终还是需要结合程序以及 MySQL 来处理，因为排行榜展示在前端还是需要用户名的，光给个用户 id 不知道是谁，除非 Redis 有序集合的 member 包含了用户 id 和 name。这里，排行榜中如果要显示用户名称，需要放到有序集合中，这样就不需要再通过 MySQL 查询一次。这种需要实时排名计算的，通过 Redis 解决更适合。如果是排行榜生成之后，用户想看某一个用户具体的信息，比如地区、战绩、使用英雄情况等，可以通过 MySQL 来进行查询。而对于热点数据使用 Redis 进行缓存，可以解决高并发情况下的数据库读压力。所以你能看到 Redis 通常可以作为 MySQL 的缓存，它存储的数据量有限，适合存储热点数据，可以解决读写效率要求很高的请求。而 MySQL 则作为数据库，提供持久化功能，并通过主从架构提高数据库服务的高可用性。</p>
<h2 id="sql项目实战">SQL项目实战</h2>
<h2 id="45丨数据清洗如何使用sql对数据进行清洗">45丨数据清洗：如何使用SQL对数据进行清洗？</h2>
<p>总结
在数据清洗过程中，你能看到通过 SQL 来进行数据概览的查询还是很方便的，但是使用 SQL 做数据清洗，会有些繁琐，这时你可以采用存储过程对数据进行逐一处理，当然你也可以使用后端语言，比如使用 Python 来做具体的数据清洗。在进行数据探索的过程中，我们可能也会使用到数据可视化，如果不采用 Python 进行可视化，你也可以选择使用 Excel 自带的数据透视图来进行可视化的呈现，它会让你对数据有个更直观的认识。今天讲解的数据清洗的实例比较简单，实际上数据清洗是个反复的过程，有时候我们需要几天时间才能把数据完整清洗好。你在工作中，会使用哪些工具进行数据清洗呢？另外，数据缺失问题在数据清洗中非常常见，我今天列举了三种填充数据缺失的方式，分别是删除、均值和高频的方式。实际上缺失值的处理方式不局限于这三种，你可以思考下，如果数据量非常大，某个字段的取值分布也很广，那么对这个字段中的缺失值该采用哪种方式来进行数据填充呢？</p>
<h2 id="46丨数据集成如何对各种数据库进行集成和转换">46丨数据集成：如何对各种数据库进行集成和转换？</h2>
<p>总结
今天我们讲解了数据集成的作用，以及 ETL 的原理。在实际工作中，因为数据源可能是不同的 DBMS，因此我们往往会使用第三方工具来帮我们完成数据集成的工作，Kettle 作为免费开源的工作，在 ETL 工作中被经常使用到。它支持多种 RDBMS 和非关系型数据库，比如 MySQL、Oracle、SQLServer、DB2、PostgreSQL、MongoDB 等。不仅如此，Kettle 易于配置和使用，通过可视化界面我们可以设置好想要进行转换的数据源，并且还可以通过 JOB 作业进行定时，这样就可以按照每周每日等频率进行数据集成。通过今天的两个 Kettle 实例，相信你对 Kettle 使用有一定的了解，你之前都用过哪些 ETL 工具，不妨说说你的经历？第二个实例中，我们将交易类型分成了“对公客户发生的交易”以及“对私客户发生的交易”。如果我们的需求是分成 4 种交易类型，包括“公对公交易”、“公对私交易”、“私对公交易”以及“私对私交易”，那么该如何使用 Kettle 完成这个转换呢？</p>
<h2 id="47丨如何利用sql对零售数据进行分析">47丨如何利用SQL对零售数据进行分析？</h2>
<p>总结
通过 SQL 完成机器学习往往还是需要使用到 Python，因为数据分析是 Python 的擅长。通过今天的学习你应该能体会到采用 SQL 工具作为数据查询和分析的入口是一种数据全栈的思路，对于开发人员来说降低了数据分析的技术门槛。如果你想要对机器学习或者数据分析算法有更深入的理解，也可以参考我的《数据分析实战 45 讲》专栏，相信在当今的数据时代，我们的业务增长会越来越依靠于 SQL 引擎 +AI 引擎。我在文章中举了一个购物篮分析的例子，如下图所示，其中（牛奶、面包、尿布）的支持度是多少呢？</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/a1/e6/a1767ae691f2c18d02f8009a687ba1e6.png?wh=850*361"
        data-srcset="https://static001.geekbang.org/resource/image/a1/e6/a1767ae691f2c18d02f8009a687ba1e6.png?wh=850*361, https://static001.geekbang.org/resource/image/a1/e6/a1767ae691f2c18d02f8009a687ba1e6.png?wh=850*361 1.5x, https://static001.geekbang.org/resource/image/a1/e6/a1767ae691f2c18d02f8009a687ba1e6.png?wh=850*361 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/a1/e6/a1767ae691f2c18d02f8009a687ba1e6.png?wh=850*361"
        title="img" /></p>
<h2 id="结束语--互联网的下半场是数据驱动的时代">结束语 | 互联网的下半场是数据驱动的时代</h2>
<p>越基础的内容，越重要</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-10-08 19:55:40&nbsp;<a class="git-hash" href="https://github.com/dillonzq/LoveIt/commit/08d4d6cf8a78e5a1cb353b041919a9e49a704d6a" target="_blank" title="commit by JF-011101(2838264218@qq.com) 08d4d6cf8a78e5a1cb353b041919a9e49a704d6a: feat">
                                    <i class="fas fa-hashtag fa-fw"></i>08d4d6c</a></span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://jefofrank.xyz/mysql_advanced_04/" data-title="Mysql_advanced_04" data-hashtags="mysql"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://jefofrank.xyz/mysql_advanced_04/" data-hashtag="mysql"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://jefofrank.xyz/mysql_advanced_04/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://jefofrank.xyz/mysql_advanced_04/" data-title="Mysql_advanced_04"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://jefofrank.xyz/mysql_advanced_04/" data-title="Mysql_advanced_04"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://jefofrank.xyz/mysql_advanced_04/" data-title="Mysql_advanced_04"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/mysql/">mysql</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/mysql_advanced_03/" class="prev" rel="prev" title="Mysql_advanced_03"><i class="fas fa-angle-left fa-fw"></i>Mysql_advanced_03</a>
            <a href="/mysql_advanced_05/" class="next" rel="next" title="Mysql_advanced_05">Mysql_advanced_05<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.89.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021 - 2022</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/jf-011101" target="_blank">Jefo</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span><span class="icp-splitter">&nbsp;|&nbsp;</span><br class="icp-br"/>
                    <span class="icp"><a href="https://beian.miit.gov.cn/">赣ICP备2022007470号-1</a></span></br>
                <span id="busuanzi_container_site_pv">
                    访问量 <span id="busuanzi_value_site_pv"></span> 次
                </span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_uv">
                    访客数 <span id="busuanzi_value_site_uv"></span> 人次
                </span>
                </br><script>
                    function siteTime() {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = 2021;
                        var startMonth = 3;
                        var startDate = 27;
                        var startHour = 19;
                        var startMinute = 15;
                        var startSecond = 11;
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);
                        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                            minutes);
                        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                            diffMinutes * minutes) / seconds);
                        if (startYear == todayYear) {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffDays + " 天 " + diffHours +
                                " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        } else {
                            
                            document.getElementById("sitetime").innerHTML = "已安全运行 " + diffYears + " 年 " + diffDays +
                                " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                        }
                    }
                    setInterval(siteTime, 1000);
                </script>
                    <span id="sitetime">载入运行时间...</span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@7.0.4/dist/typeit.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"data":{"id-1":"绿叶律动","id-2":"绿叶律动"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF-2","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
