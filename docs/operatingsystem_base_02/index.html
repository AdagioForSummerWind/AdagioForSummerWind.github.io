<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>OperatingSystem_base_02 - Jefo</title><meta name="Description" content="Jefo"><meta property="og:title" content="OperatingSystem_base_02" />
<meta property="og:description" content="王道考研操作系统笔记 进程管理 进程与线程 进程概念 进程引入 在计算机操作系统中，进程是资源分配的基本单位（与线程的主要区别），也是独立运行的基本单" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qizhengzou.github.io/operatingsystem_base_02/" /><meta property="og:image" content="https://qizhengzou.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-10T13:14:32+08:00" />
<meta property="article:modified_time" content="2021-11-22T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://qizhengzou.github.io/logo.png"/>

<meta name="twitter:title" content="OperatingSystem_base_02"/>
<meta name="twitter:description" content="王道考研操作系统笔记 进程管理 进程与线程 进程概念 进程引入 在计算机操作系统中，进程是资源分配的基本单位（与线程的主要区别），也是独立运行的基本单"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://qizhengzou.github.io/operatingsystem_base_02/" /><link rel="prev" href="https://qizhengzou.github.io/operatingsystem_base_01/" /><link rel="next" href="https://qizhengzou.github.io/operatingsystem_base_03/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "OperatingSystem_base_02",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/qizhengzou.github.io\/operatingsystem_base_02\/"
        },"image": ["https:\/\/qizhengzou.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "operating system","wordcount":  33098 ,
        "url": "https:\/\/qizhengzou.github.io\/operatingsystem_base_02\/","datePublished": "2021-11-10T13:14:32+08:00","dateModified": "2021-11-22T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/qizhengzou.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Jefo"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Jefo</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/qizhengzou" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Jefo"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Jefo</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/qizhengzou" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">OperatingSystem_base_02</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/school-courses/"><i class="far fa-folder fa-fw"></i>School courses</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-11-10 13:14:32">2021-11-10 13:14:32</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 33098 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 67 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#进程与线程">进程与线程</a>
      <ul>
        <li><a href="#进程概念">进程概念</a>
          <ul>
            <li><a href="#进程引入">进程引入</a></li>
            <li><a href="#进程的定义以及描述">进程的定义以及描述</a></li>
          </ul>
        </li>
        <li><a href="#进程的状态与转换">进程的状态与转换</a></li>
        <li><a href="#进程控制">进程控制</a></li>
        <li><a href="#线程概念与多线程模型">线程概念与多线程模型</a></li>
        <li><a href="#进程通信共享存储系统消息传递系统管道通信">进程通信:共享存储系统、消息传递系统、管道通信.</a></li>
      </ul>
    </li>
    <li><a href="#处理器调度">处理器调度</a>
      <ul>
        <li><a href="#处理器的三层调度">处理器的三层调度</a></li>
        <li><a href="#调度的基本准则">调度的基本准则</a></li>
        <li><a href="#进程调度">进程调度</a></li>
        <li><a href="#典型调度算法">典型调度算法：</a></li>
      </ul>
    </li>
    <li><a href="#同步与互斥">同步与互斥</a>
      <ul>
        <li><a href="#进程同步的基本概念">进程同步的基本概念</a></li>
        <li><a href="#实现临界区互斥的基本方法软件实现方法硬件实现方法">实现临界区互斥的基本方法：软件实现方法、硬件实现方法。</a></li>
        <li><a href="#信号量">信号量</a></li>
        <li><a href="#经典同步问题生产者消费者问题读者写者问题哲学家进餐问题">经典同步问题：生产者消费者问题、读者写者问题、哲学家进餐问题。</a></li>
        <li><a href="#管程">管程</a></li>
      </ul>
    </li>
    <li><a href="#死锁">死锁</a>
      <ul>
        <li><a href="#死锁概念">死锁概念</a></li>
        <li><a href="#死锁产生原因和必要条件">死锁产生原因和必要条件</a></li>
        <li><a href="#死锁处理策略">死锁处理策略</a></li>
        <li><a href="#死锁预防">死锁预防</a></li>
        <li><a href="#死锁避免系统安全状态银行家算法">死锁避免：系统安全状态、银行家算法。</a></li>
        <li><a href="#死锁检测和解除">死锁检测和解除</a></li>
        <li><a href="#死锁与饿死">死锁与饿死</a></li>
      </ul>
    </li>
    <li><a href="#习题">习题</a></li>
    <li><a href="#答案">答案</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p>王道考研操作系统笔记</p>
</blockquote>
<h1 id="进程管理">进程管理</h1>
<h2 id="进程与线程">进程与线程</h2>
<h3 id="进程概念">进程概念</h3>
<h4 id="进程引入">进程引入</h4>
<p>在计算机操作系统中，进程是资源分配的基本单位（与线程的主要区别），也是独立运行的基本单位。</p>
<ul>
<li>程序的顺序执行：
<ul>
<li>顺序性。处理器的操作严格按照程序所规定的顺序执行，即每一个操作必须在下一个操作开始之前结束。</li>
<li>封闭性。程序一旦开始运行，其执行结果不受外界因素影响。因为程序在运行时独占系统的各种资源，所以这些资源的状态(除初始状态外)只有本程序才能改变。</li>
<li>可再现性。 只要程序执行时的初始条件和执行环境相同，当程序重复执行时，都将获得相同的结果(即程序的执行结果与时间无关)。</li>
</ul>
</li>
<li>程序的并发执行
<ul>
<li>程序的并发执行是指若千个程序(或程序段)同时在系统中运行，这些程序(或程序段)的执行在时间上是重叠的，即一个程序( 或程序段)的执行尚未结束，另一个程序(或程序段)的执行已经开始。程序的并发执行虽然提高了系统的处理能力和资源利用率，但也带来了一些新问题，产生了一些与顺序执行时不同的特征:</li>
<li>间断性。程序在并发执行时，由于它们共享资源或为完成同一项任务而相互合作,致使并发程序之间形成了相互制约关系。这种相互制约关系将导致并发程序具有“执行一暂停执行一执行”这种间断性的活动规律。</li>
<li>失去封闭性。程序在并发执行时，多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行失去封闭性。这样一个程序在执行时， 必然会受到其他程序影响，例如，当处理器被某程序占用时，其他程序必须等待。</li>
<li>不可再现性。程序并发执行时，由于失去了封闭性，也将导致失去其运行结果的可再现性。</li>
</ul>
</li>
</ul>
<h4 id="进程的定义以及描述">进程的定义以及描述</h4>
<p>在多道程序环境下，程序的并发执行破坏了程序的封闭性和可再现性，使得程序和计算不再一一对应，程序活动不再处于一个封闭系统中，程序的运行出现了许多新的特征。在这种情况下，程序这种静态概念已经不能如实地反映程序活动的这些特征，为此引入了一个新的概念：进程。</p>
<ul>
<li>进程的定义，进程的概念从提出之后，许多人都对进程有过各式各样的定义，这里给出几种比较容易理解又能反映进程实质的定义:
<ul>
<li>进程是程序，在处理器上的一次执行过程。</li>
<li>进程是可以和别的进程并行执行的计算。</li>
<li>进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位。</li>
<li>进程可定义为一个数据结构及能在其上进行操作的一个程序。</li>
<li>进程是一个程序关于某个数据集合在处理器上顺序执行所发生的活动。</li>
<li>上述这些描述从不同角度对进程进行了阐述，尽管各有侧重，但本质是相同的。</li>
</ul>
</li>
<li>进程的特征，进程具有以下几个基本特征:
<ul>
<li>动态性。 进程是程序在处理器上的一次执行过程，因而是动态的。动态特性还表现在它因创建而产生，由调度而执行，因得不到资源而暂停，最后因撤销而消亡。</li>
<li>并发性。 并发性是指多个进程同时存在于内存中，能在一段时间内同时运行。引入进程的目的是使程序能与其他程序并发执行，以提高资源利用率。</li>
<li>独立性。进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。</li>
<li>异步性。异步性是指进程以各自独立的、不可预知的速度向前推进。</li>
<li>结构特征。为了描述和记录进程的运动变化过程，并使之能正确运行，应为每个进程配置一个进程控制块(Process Control Block, PCB)。 这样从结构上看，每个进程都由程序段、数据段和一个进程控制块组成。</li>
</ul>
</li>
<li>进程和程序的关系，进程和程序是两个密切相关但又有所不同的概念,它们在以下几个方面存在区别和联系：
<ul>
<li>进程是动态的，程序是静止的。进程是程序的执行，每个进程包含了程序段和数据段以及进程控制块(PCB)，而程序是有序代码的集合，无执行含义。</li>
<li>进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可以长久保存。</li>
<li>进程与程序的组成不同。进程的组成包括程序段、数据段和进程控制块。</li>
<li>通过多次执行， 一个程序可以产生多个不同的进程;通过调用关系，一个进程可以执行多个程序。进程可创建其他进程，而程序不能形成新的程序。</li>
<li>进程具有并行特性(独立性、异步性)，程序则没有。</li>
</ul>
</li>
<li>什么是进程映像?进程映像与进程的关系是什么?
<ul>
<li>由程序段、相关数据段和PCB三部分构成了进程映像，也叫进程实体。进程映像是静态的，进程是动态的，进程是进程实体的运行过程。</li>
</ul>
</li>
<li>进程和作业的区别：
<ul>
<li>作业是用户需要计算机完成某项任务而要求计算机所做工作的集合。一个作业的完成要经过作业提交、作业收容、作业执行和作业完成4个阶段。而进程是已提交完毕的作业的执行过程，是资源分配的基本单位。两者的主要区别如下:</li>
<li>作业是用户向计算机提交任务的任务实体。在用户向计算机提交作业之后，系统将它放入外存中的作业等待队列中等待执行;而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。</li>
<li>一个作业可 由多个进程组成，且必须至少由一个进程组成，但一个进程不能构成多个作业。</li>
<li>作业的概念主要用在批处理系统中。像UNIX这样的分时系统则没有作业的概念;而进程的概念则用在几乎所有的多道程序系统中。</li>
</ul>
</li>
<li>进程的组成
<ul>
<li>进程控制块(PCB)。每个进程均有一个PCB,它是一个既能标识进程的存在、又能刻画执行瞬间特征的数据机构。当进程被创建时，系统为它申请和构造一个相应的PCB。</li>
<li>程序段。 程序段是进程中能被进程调度程序调度到CPU.上执行的程序代码段，能实现相应的特定功能。</li>
<li>数据段。 一个进程的数据段可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或结果数据。系统根据PCB感知进程的存在。PCB是进程存在的唯一标志。一般来说，根据操作系统的要求不同，PCB所包含的内容多少会有些不同，但通常都包括下面所列出的内容。</li>
<li>进程标识符 (PID)。 每个进程都有唯一的进程标识符，以区别于系统内部的其他进程。在创建进程时，由系统为进程分配唯一的进程标识号。 在Windows 7系统下，打开任务管理器，依次单击“查看”→“选择列”，勾选“PID (进程标识符)”，即可在任务管理器中查看到进程PID信息，通常是纯数字。这里看到的PID是内部标识符，为了区别于外部标识符。</li>
<li>进程当前状态。说明进程的当前状态，以作为进程调度程序分配处理器的依据。</li>
<li>进程队列指针。用于记录PCB队列中下一个PCB的地址。系统中的PCB可能组织成多个队列，如就绪队列、阻塞队列等。</li>
<li>程序和数据地址。指出进程的程序和数据所在的地址。</li>
<li>进程优先级。反映进程要求CPU的紧迫程度。优先级高的进程可以优先获得处理器。</li>
<li>CPU现场保护区。当进程因某种原因释放处理器时，CPU现场信息(如指令计数器、状态寄存器、通用寄存器等)被保存在PCB的该区域中，以便该进程重新获得处理器后能继续执行。</li>
<li>通信信息。 记录进程在执行过程中与别的进程所发生的信息交换情况。</li>
<li>家族联系。有的系统允许进程创建子进程，从而形成一个进程家族树。 在PCB中，本进程与家族的关系是必须指明的，如它的子进程与父进程的标识。</li>
<li>占有资源清单。进程所需资源及当前已分配资源清单。</li>
<li>在一个系统中，通常存在着很多进程，有的处于就绪状态，有的处于阻塞状态，而且阻塞的原因各不相同。为了方便进程的调度和管理，需要将各进程的PCB用适当的方法组织起来。目前常用的组织方式有链接方式和索引方式。</li>
</ul>
</li>
<li>为什么说PCB是进程存在的唯一标志?
<ul>
<li>首先来看PCB的作用:</li>
<li>PCB是系统为每个进程定义的一个数据结构，其作用是使程序(含数据)能独立运行;PCB使一个在多道程序环境下不能独立运行的程序(含数据)成为一个能独立运行的基本单位，一个能与其他进程并发执行的进程，因此PCB是为了保证程序的并发执行。创建进程,实质上是创建进程的PCB;而撤销进程，实质上是撤销进程的PCB。</li>
<li>其次来解释为什么PCB是进程存在的唯一标志。</li>
<li>在系统调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存地址，找到其程序和数据:进程在执行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也都需要访问PCB; 当进程由于某种原因而暂停执行时，又需将其断点的处理机环境保存在PCB中。可见，在进程的整个生命期中，系统总是通过PCB对进程进行控制的，亦即系统是根据进程的PCB感知该进程的存在的，所以，PCB是进程存在的唯一标志。</li>
</ul>
</li>
</ul>
<h3 id="进程的状态与转换">进程的状态与转换</h3>
<ul>
<li>进程的5种基本状态
<ul>
<li>在进程的运行过程中，由于系统中多个进程的并发运行及相互制约的结果，使得进程的状态不断发生变化。通常，一个运行中的进程至少可划分为5种基本状态。</li>
<li>就绪状态。进程已获得了除处理器以外的所有资源，一旦获得处理器，就可以立即执行，此时进程所处的状态为就绪状态。</li>
<li>执行状态(运行状态)。当一个进程获得必要的资源并正在CPU上执行时，该进程所处的状态为执行状态。</li>
<li>阻塞状态(等待状态)。正在执行的进程，由于发生某事件而暂时无法执行下去(如等待I/O完成)，此时进程所处的状态为阻塞状态。当进程处于阻塞状态时，即使把处理器分配给该进程，它也无法运行。</li>
<li>创建状态。进程正在被创建，尚未转到就绪状态。申请空白的PCB,并向PCB中填写一些控制和管理进程的信息;然后由系统为该进程分配运行时所需的资源;最后把该进程转入就绪状态。</li>
<li>结束状态。进程正在从系统中消失，可能是正常结束或其他原因中断退出运行。</li>
</ul>
</li>
<li>进程状态的相互转换：
<ul>
<li>状态转化的典型原因：
<ul>
<li>就绪状态→执行状态。一个进程被进程调度程序选中。</li>
<li>执行状态→阻塞状态。请求并等待某个事件发生。</li>
<li>执行状态→就绪状态。时间片用完或在抢占式调度中有更高优先级的进程变为就绪状态。</li>
<li>阻塞状态→就绪状态。进程因为等待的某个条件发生而被唤醒。</li>
</ul>
</li>
<li>从上述的状态转换的原因可以得出以下结论:
<ul>
<li>进程状态的转换并非都是可逆的，进程既不能从阻塞状态变为执行状态，也不能从就绪状态变为阻塞状态。</li>
<li>进程之间的状态转换并非都是主动的，在很多情况下都是被动的，只有从执行状态到阻塞状态是程序的自我行为( 因事件而主动调用阻塞原语)，其他都是被动的。例如，从执行状态到就绪状态，通常是由时钟中断引起的(时间片用完);从阻塞状态到就绪状态，是上一个使用处理器的进程把一个阻塞进程唤醒的。</li>
<li>进程状态的唯一性。一个具体的进程在任何一个指定的时刻必须且只能处于一种状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程控制">进程控制</h3>
<p>进程控制的职责是对系统中的所有进程实施有效的管理，其功能包括进程的创建、进程的撤销、进程阻塞与唤醒等。这些功能一般是由操作系统的内核来实现的。</p>
<ul>
<li>进程创建原语
<ul>
<li>在多道程序环境中，只有进程才可以在系统中运行。为了使一个程序能运行，必须为它创建进程。导致进程创建的事件有用户登录、作业调度和请求服务。
<ul>
<li>用户登录。 在分时系统中，用户在终端输入登录信息，系统检测并通过之后就会为该终端用户建立新进程并插入到就绪队列。</li>
<li>作业调度。 在批处理系统中，当作业调度程序按一定的算法调度到某个作业时，便将该作业装入内存，为其分配资源并创建进程，并插入到就绪队列。</li>
<li>请求服务。 基于进程的需要，由其自身创建一个新进程并完成特定任务。</li>
</ul>
</li>
<li>进程创建是通过创建原语实现的。其主要操作过程如下。
<ul>
<li>先向系统申请一个空闲PCB，并指定唯一的进程标识符(PID)。</li>
<li>为新进程分配必要的资源。</li>
<li>将新进程的PCB初始化。为新进程的PCB填入进程名、家族信息、程序数据地址、优先级等信息。</li>
<li>将新进程的PCB插入到就绪队列。</li>
</ul>
</li>
</ul>
</li>
<li>进程的撤销
<ul>
<li>一个进程在完成其任务后应予以撤销，以便及时释放它所占用的各类资源。撤销原语可采用两种策略:一种是只撤销一个具有指定标识符的进程;另一种是撤销指定进程及其所有子孙进程。导致进程撤销的事件有进程正常结束、进程异常结束及外界干预等。</li>
<li>撤销原语的功能是撤销一个进程， 其主要操作过程如下:
<ul>
<li>先从PCB集合中找到被撤销进程的PCB。</li>
<li>若被撤销进程正处于执行状态，则应立即停止该进程的执行，设置重新调度标志，以便进程撤销后将处理器分配给其他进程。</li>
<li>对后一种撤销策略，若被撤销进程有子孙进程，还应将该进程的子孙进程予以撤销。</li>
<li>回收被撤销进程所占有的资源，或者归还给父进程，或者归还给系统。最后，回收它的PCB。</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞与唤醒
<ul>
<li>阻塞原语(P原语)的功能是将进程由执行状态转为阻塞状态，而唤醒原语(V原语)的功能则是将进程由阻塞状态变为就绪状态。当一个进程期待的某一事件尚未出现时，该进程调用阻塞原语将自己阻塞起来。★注:注意此处是由该进程自身调用原语阻塞自己的，是一种主动行为。</li>
<li>阻塞原语的主要操作过程如下:
<ul>
<li>首先停止当前进程的运行。因该进程正处于执行状态，故应中断处理器。</li>
<li>保存该进程的CPU现场以便之后可以重新调用该进程并从中断点开始执行。</li>
<li>停止运行该进程， 将进程状态由执行状态改为阻塞状态，然后将该进程插入到相应事件的等待队列中。</li>
<li>转到进程调度程序，从就绪队列中选择个新的进程投入运行。</li>
</ul>
</li>
<li>对处于阻塞状态的进程，当该进程期待的事件出现时，由发现者进程调用唤醒原语将阻塞的进程唤醒，使其进入就绪状态。</li>
<li>注:此处是由发现者进程调用唤醒原语而不是被阻塞进程本身调用，因此唤醒对于阻塞进程是一种被动行为。</li>
<li>唤醒原语的主要操作过程如下:
<ul>
<li>将被唤醒进程从相应的等待队列中移出。</li>
<li>将状态改为就绪 并插入相应的就绪队列。</li>
</ul>
</li>
<li>应当注意的是:一个进程由执行状态变为阻塞状态，是由这个进程自已调用阻塞原语去完成的:而进程由阻塞状态转变为就绪状态，则是由另一个发现者进程调用唤醒原语实现的，一般这个发现者进程与被唤醒进程是合作的并发进程。</li>
</ul>
</li>
<li>进程切换
<ul>
<li>进程切换是指处理器从一个进程的运行转到另一个进程的运行，这个过程中，进程的运行环境产生了实质性的变化。</li>
<li>进程切换的过程如下:
<ul>
<li>保存处理器上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应队列，如就绪、某事件的阻塞队列等。</li>
<li>选择另一个进程执行， 更新其PCB.</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理器上下文。</li>
</ul>
</li>
<li>★注:注意此处与调度的区别，调度是决定将系统资源分配给哪个进程，进程切换是实际分配系统资源。另外需要注意进程切换一定会产生中断，进行处理器模式切换，即从用户态进入内核态，之后又回到用户态;但处理器模式切换不一定产生进程切换，如系统调用同样会从用户态进入内核态，之后回到用户态，但在逻辑上，仍然是同一进程占用处理器执行。</li>
</ul>
</li>
</ul>
<h3 id="线程概念与多线程模型">线程概念与多线程模型</h3>
<p>线程是近年来操作系统领域出现的一种非常重要的技术，其重要程度丝毫不亚于进程。线程的引入提高了程序并发执行的程度，从而进一步提高了系统吞吐量。</p>
<ul>
<li>线程的概念
<ul>
<li>线程的引入
<ul>
<li>如果说在操作系统中引入进程的目的是使多个程序并发执行，以改善资源利用率及提高系统吞吐量，那么，在操作系统中再引入线程，则是为了减少程序并发执行时所付出的时空开销，使操作系统具有更好的并发性。为了说明这一点， 下面来回顾一下进程的两个基本属性。</li>
<li>进程是一个拥有资源的独立单元。</li>
<li>进程同时又是一个可以被处理器独立调度和分配的单元。</li>
<li>上述两个属性构成了程序并发执行的基础。然而，为了使进程能并发执行，操作系统还必须进行一系列的操作，如创建进程、撤销进程和进程切换。在进行这些操作时，操作系统要为进程分配资源及回收资源，为运行进程保存现场信息，这些工作都需要付出较多的时空开销。正因如此，在系统中不宜设置过多的进程，进程切换的频率也不宜太高，这就限制了系统并发程度的进一步提高。</li>
<li>为了使多个程序更好地并发执行，并尽量减少操作系统的开销，不少操作系统研究者考虑将进程的两个基本属性分离开来，分别交由不同的实体来实现。为此，操作系统设计者引入了线程，让线程去完成第二个基本属性的任务，而进程只完成第一个基本属性的任务。</li>
</ul>
</li>
<li>线程的定义
<ul>
<li>线程的定义与进程类似，存在多种不同的提法。这些提法可以相互补充对线程的理解。
<ul>
<li>线程是进程内的一个执行单元，比进程更小。</li>
<li>线程是进程内 的一个可调度实体。</li>
<li>线程是程序 (或进程)中相对独立的一个控制流序列。</li>
<li>线程本身不能单独运行，只能包含在进程中，只能在进程中执行。</li>
</ul>
</li>
<li>综上所述，不妨将线程定义为:线程是进程内一个相对独立的、可调度的执行单元。线程自己基本.上不拥有资源，只拥有一点在运行时必不可少的资源(如程序计数器、一组 寄存器和栈)，但它可以与同属一个进程的其他线程共享进程拥有的全部资源。多线程是指一个进程中有多个线程，这些线程共享该进程资源。这些线程驻留在相同的地址空间中，共享数据和文件。如果一个线程修改了一个数据项，其他线程可以了解和使用此结果数据。一个线程打开并读一个文件时， 同一进程中的其他线程也可以同时读此文件。</li>
</ul>
</li>
<li>线程的实现
<ul>
<li>在操作系统中有多种方式可实现对线程的支持。最自然的方法是由操作系统内核提供线程的控制机制。在只有进程概念的操作系统中，可由用户程序利用函数库提供线程的控制机制。还有一种做法是同时在操作系统内核和用户程序两个层次上提供线程控制机制。</li>
<li>内核级线程是指依赖于内核，由操作系统内核完成创建和撤销工作的线程。在支持内核级线程的操作系统中，内核维护进程和线程的上下文信息并完成线程切换工作。一个内核级线程由于IO操作而阻塞时，不会影响其他线程的运行。这时，处理器时间片分配的对象是线程，所以有多个线程的进程将获得更多处理器时间。</li>
<li>用户级线程是指不依赖于操作系统核心，由应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制的线程。由于用户级线程的维护电应用进程完成，不需要操作系统内核了解用户级线程的存在，因此可用于不支持内核级线程的多进程操作系统，甚至是单用户操作系统。用户级线程切换不需要内核特权，用户级线程调度算法可针对应用优化。许多应用软件都有自己的用户级线程。由于用户级线程的调度在应用进程内部进行，通常采用非抢占式和更简单的规则，也无须用户态/核心态切换，因此速度特别快。当然，由于操作系统内核不了解用户线程的存在，当一个线程阻塞时，整个进程都必须等待。这时处理器时间片是分配给进程的，当进程内有多个线程时，每个线程的执行时间相对减少。</li>
<li>有些操作系统提供了，上述两种方法的组合实现。在这种系统中，内核支持多线程的建立、调度与管理;同时，系统中又提供使用线程库的便利，允许用户应用程序建立、调度和管理用户级的线程。由于同时提供内核线程控制机制和用户线程库，因此可以很好地将内核级线程和用户级线程的优点结合起来。</li>
</ul>
</li>
</ul>
</li>
<li>线程与进程的比较
<ul>
<li>由于进程与线程密切相关，因此有必要对进程与线程的异同进行比较。</li>
<li>调度。在传统的操作系统中， 拥有资源和独立调度的基本单位都是进程。而在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程的线程中，将会引起进程切换。</li>
<li>拥有资源。 不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源( 也有一点必不可少的资源，并非什么资源都没有)，但线程可以访问其隶属进程的系统资源。</li>
<li>并发性。 在引入线程的操作系统中，不仅进程之间可以并发执行，而且同一进程内的多个线程之间也可以并发执行。这使得操作系统具有更好的并发性，大大提高了系统的吞吐量。</li>
<li>系统开销。由于创建进程或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及整个当前进程CPU环境的保存及新调度到进程的CPU环境的设置;而线程切换时，只需保存和设置少量寄存器内容，因此开销很小。另外，由于同一进程内的多个线程共享进程的地址空间，因此，多线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。</li>
</ul>
</li>
<li>多线程模型
<ul>
<li>有些系统同时支持用户级线程和内核级线程，因此根据用户级线程和内核级线程连接方式的不同产生了3种不同的多线程模型。</li>
<li>多对一模型。多对一模型将多个用户级线程映射到一个内核级线程上。在采用该模型的系统中，线程在用户空间进行管理，效率相对较高。但是，由于多个用户级线程映射到一个内核级线程，只要一个用户级线程阻塞，就会导致整个进程阻塞。而且由于系统只能识别一个线程(内核级线程)，因此即使有多处理器，该进程的若千个用户级线程也只能同时运行一个，不能并行执行。</li>
<li>一对一模型。一对一模型将内核级线程与用户级线程一对应。这样做的好处是当一个线程阻塞时，不影响其他线程的运行，因此一对一模型的并发性比多对一模型要好。而且这样做之后，在多处理器上可以实现多线程并行。这种模型的缺点是创建一个用户级线程时需要创建一个相应的内核级线程。</li>
<li>多对多模型。 多对多模型将多个用户级线程映射到多个内核级线程( 内核级线程数不多于用户级线程数，内核级线程数根据具体情况确定)。采用这样的模型可以打破前两种模型对用户级线程的限制，不仅可以使多个用户级线程真正意义上并行执行，而且不会限制用户级线程的数量。用户可以自由创建所需的用户级线程，多个内核级线程根据需要调用用户级线程，当一个用户级线程阻塞时，可以调度执行其他线程。</li>
</ul>
</li>
</ul>
<h3 id="进程通信共享存储系统消息传递系统管道通信">进程通信:共享存储系统、消息传递系统、管道通信.</h3>
<p>进程通信是指进程之间的信息交换。进程的互斥与同步就是一种进程间的通信方式。由于进程互斥与同步交换的信息量较少且效率较低，因此称这两种进程通信方式为低级进程通信方式。相应地，也可以将P、V原语称为两条低级进程通信原语。目前，高级进程通信方式可以分为3大类:共享存储器系统、消息传递系统和管道通信系统。</p>
<ul>
<li>共享存储器系统
<ul>
<li>为了传输大量数据，在存储器中划出一块共享存储区，多个进程可以通过对共享存储区进行读写来实现通信。在通信前，进程向系统申请建立一个共享存储区，并指定该共享存储区的关键字。若该共享存储区已经建立，则将该共享存储区的描述符返回给申请者。然后，申请者把获得的共享存储区附接到进程上。这样，进程便可以像读写普通存储器一样读写共享存储区了。</li>
</ul>
</li>
<li>消息传递系统
<ul>
<li>在消息传递系统中，进程间以消息为单位交换数据，用户直接利用系统提供的一组通信命令(原语)来实现通信。操作系统隐藏了通信的实现细节，简化了通信程序，得到了广泛应用。根据实现方式不同，消息传递系统可以分为以下两类。</li>
<li>直接通信方式。发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</li>
<li>间接通信方式。发送进程把消息发送到某个中间实体(通常称为信箱)中，接收进程从中取得消息。这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，与之相应的通信系统称为电子邮件系统。</li>
</ul>
</li>
<li>管道通信系统
<ul>
<li>管道是用于连接读进程和写进程以实现它们之间通信的共享文件。向管道提供输入的发送进程(即写进程)以字符流形式将大量的数据送入管道，而接收管道输出的进程(即读进程)可以从管道中接收数据。</li>
<li>注:管道是一个共享文件，不能单纯地从字面上仅将管道理解为一个传输通道。</li>
</ul>
</li>
</ul>
<h2 id="处理器调度">处理器调度</h2>
<p>调度是操作系统的一个基本功能，几乎所有资源在使用前都需要调度。由于CPU是计算机的首要资源，因此调度设计均围绕如何能够高效利用CPU展开。在多道程序环境下，一个作业从提交到执行，通常都要经历多级调度，如高级调度、中级调度和低级调度。而系统的运行性能在很大程度上都取决于调度，因此调度便成为多道程序的关键。在不同操作系统中，所采用的调度层次不完全相同。在一些系统中仅采用一级调度，而在另一些系统中则可能采用两级或三级调度，在执行调度时所采用的调度算法也可能不同。图2-5给出了调度层次的示意图，由此可以看出，一个作业从提交开始直到完成，往往要经历三级调度。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122150024.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122150024.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122150024.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122150024.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122150024.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122150024.png" /></p>
<h3 id="处理器的三层调度">处理器的三层调度</h3>
<ul>
<li>高级调度(作业调度)：
<ul>
<li>高级调度又称为宏观调度、作业调度或者长程调度,其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多 个，给它们分配内存、输入/输出设备等必要资源，并建立相应的进程，以使该作业具有获得竞争处理器的权利(作业是用户在一次运算过程或一次事务处理中要求计算机所做工作的总和)。作业调度的运行频率较低，通常为几分钟一次。在批处理系统或通用操作系统中的批处理部分，新提交的作业先存放在磁盘上,因此需要通过作业调度将它们分批装入内存。而在其他类型的操作系统中，通常不需要配置作业调度。</li>
<li>每次执行作业调度时，我们都需要解决两个问题:第一，调度程序必须决定操作系统可以接纳多少个作业;第二，调度程序必须决定接纳哪些作业。下面简单分析一下这两个问题。作业调度每次要接纳多少个作业进入内存取决于多道程序的并发程度，即允许有多少个作业同时在内存中运行。当内存中可以同时运行的作业太多时，可能会影响到系统的服务质量，如导致周转时间太长。而当内存中同时运行的作业太少时，又会导致系统资源利用率和吞吐量下降。因此，多道程序的并发程度应根据系统的规模和运行速度来确定。应将哪些作业从外存调入内存取决于所采取的调度算法。最简单的调度算法是先来先服务调度算法，它将最早进入外存的作业最先调入内存;较常用的一种调度算法是短作业优先调度算法，它将外存上执行时间最短的作业最先调入内存;此外还有其他调度算法。</li>
</ul>
</li>
<li>中级调度
<ul>
<li>中级调度又称为中程调度或者交换调度，引入中级调度是为了提高内存利用率和系统吞吐量，其主要任务是按照给定的原则和策略，将处于外存对换区中的具备运行条件的进程调入内存，并将其状态修改为就绪状态，挂在就绪队列上等待;或者将处于内存中的暂时不能运行的进程交换到外存对换区，将此时的进程状态称为挂起状态。中级调度主要涉及内存管理与扩充(其实中级调度可以理解为在换页时将页面在外存与内存之间调度),因此会在存储管理部分对其进行介绍。</li>
</ul>
</li>
<li>低级调度(进程调度)
<ul>
<li>低级调度又称为微观调度、进程调度或者短程调度，其主要任务是按照某种策略和方法从就绪队列中选取一个进程，将处理器分配给它。进程调度的运行频率很高，一般隔几十毫秒要运行一次。后面将对此进行详细讲解。</li>
</ul>
</li>
<li>注:由于作业调度与进程调度有时候容易混淆，特总结高级调度(作业调度)与低级调度(进程调度)的区别如下:
<ul>
<li>作业调度为进程被调用做准备，进程调度使进程被调用。换言之，作业调度的结果是为作业创建进程，而进程调度的结果是进程被执行。</li>
<li>作业调度次数少，进程调度频率高。</li>
<li>有的系统可以不设置作业调度，但进程调度必须有。</li>
</ul>
</li>
</ul>
<h3 id="调度的基本准则">调度的基本准则</h3>
<p>不同调度算法有不同的调度策略，这也决定了调度算法对不同类型的作业影响不同。在选择调度算法时，我们必须考虑不同算法的特性。为了衡量调度算法的性能，人们提出了一些评价标准。</p>
<ul>
<li>CPU利用率
<ul>
<li>CPU是系统最重要、也是最昂贵的资源，其利用率是评价调度算法的重要指标。在批处理以及实时系统中，一般要求 CPU的利用率要达到比较高的水平，不过对于PC和某些不强调利用率的系统来说，CPU利用率并不是最主要的。</li>
</ul>
</li>
<li>系统吞吐量
<ul>
<li>系统吞吐量表示单位时间内CPU完成作业的数量。对长作业来说，由于它要占用较长的CPU处理时间，因此会导致系统吞吐量下降;而对短作业来说，则相反。</li>
</ul>
</li>
<li>响应时间
<ul>
<li>相对于系统吞吐量和CPU利用率来说，响应时间是比较面向用户的。在交互系统中，尤其在多用户系统中，多个用户同时对系统进行操作，都要求在一定时间内得到响应，不能使某些用户的进程长期得不到调用。因此，从用户角度看，调度策略要保证尽量短的响应时间，使响应时间在用户的接受范围内。</li>
</ul>
</li>
<li>周转时间
<ul>
<li>从每个作业的角度来看，完成该作业的时间是至关重要的，通常用周转时间或者带权周转时间来衡量。</li>
<li>周转时间
<ul>
<li>周转时间是指作业从提交至完成的时间间隔，包括等待时间和执行时间。周转时间T;用公式表示为作业i的周转时间T=作业i的完成时间-作业i的提交时间</li>
</ul>
</li>
<li>平均周转时间
<ul>
<li>平均周转时间是指多个作业(例如n个作业)周转时间的平均值。平均周转时间T用公式表示为T= (T+T2+&hellip;+Tn) /n</li>
</ul>
</li>
<li>带权周转时间
<ul>
<li>带权周转时间是指作业周转时间与运行时间的比。作业i的带权周转时间w;用公式表示为W:=作业i的周转时间/作业i的运行时间</li>
</ul>
</li>
<li>平均带权周转时间
<ul>
<li>与平均周转时间类似，平均带权周转时间是多个作业的带权周转时间的平均值。公式略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="进程调度">进程调度</h3>
<p>在多道程序系统中，用户进程数往往多于处理器数，这将导致用户进程争夺处理器。此外，系统进程同样需要使用处理器。因此，系统需要按照一定的策略动态地把处理器分配给就绪队列中的某个进程，以便使之执行。处理器分配的任务由进程调度程序完成。</p>
<ul>
<li>进程调度的功能
<ul>
<li>记录系统中所有进程的有关情况以及状态特征。为了实现进程调度，进程管理模块必须将系统中各进程的执行情况和状态特征记录在各个进程的PCB中，同时还应根据各个进程的状态特征和资源需求等信息将进程的PCB组织成相应的队列，并依据运行情况将进程的PCB在不同状态队列之间转换。进程调度模块通过PCB的变化来掌握系统中所有进程的执行情况和状态特征。</li>
<li>选择获得处理器的进程。按照一定的策略选择一个处于就绪状态的进程，使其获得处理器执行。根据不同的系统设计目标，有各种各样的选择策略。例如，先来先服务调度算法、时间片轮转调度算法等。这些选择策略决定了调度算法的性能。</li>
<li>处理器分配。当正在运行的进程由于某种原因要放弃处理器时，进程调度程序应保护当前运行进程的CPU现场，将其状态由运行变成就绪或阻塞，并插入到相应队列中去;同时恢复程序还应根据一定原则从就绪队列中挑选出一个进程， 把该进程从就绪队列中移出，恢复其CPU现场，并将其状态改为运行。</li>
</ul>
</li>
<li>引起进程调度的原因
<ul>
<li>当前运行进程运行结束。因任务完成而正常结束，或者因出现错误而异常结束。</li>
<li>当前运行进程因某种原因，比如I/O请求、P操作、阻塞原语等，从运行状态进入阻塞状态。</li>
<li>执行完系统调用等系统程序后返回用户进程，这时可以看作系统进程执行完毕，从而可以调度一个新的用户进程。</li>
<li>在采用抢占调度方式的系统中，一个具有更高优先级的进程要求使用处理器，则使当前运行进程进入就绪队列(这与调度方式有关)。</li>
<li>在分时系统中，分配给该进程的时间片已用完(这与系统类型有关)。</li>
</ul>
</li>
<li>不能进行进程调度的情况
<ul>
<li>处理中断的过程中。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程， 不应被剥夺处理器资源。</li>
<li>在操作系统内核程序临界区中。进程进入临界区后，需要独占式地访问共享数据,理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</li>
<li>其他需要完全屏蔽中断的原子操作过程中。如加锁、解锁、中断现场保护、恢复等原子操作。原子操作不可再分，必须一次完成，不能进行进程切换。</li>
</ul>
</li>
<li>进程调度的方式
<ul>
<li>进程调度方式是指当某一个进程 正在处理器上执行时，若有某个更为重要或紧迫的进程需要进行处理(即有优先级更高的进程进入就绪队列)，此时应如何分配处理器。通常有以下两种进程调度方式:</li>
<li>抢占方式。 又称为可剥夺方式。这种调度方式是指当一个进程正在处理器上执行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在执行的进程，将处理器分配给新进程。</li>
<li>非抢占方式。 又称为不可剥夺方式。这种方式是指当某一个进程正在处理器上执行时，即使有某个优先级更高的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或因发生某种事件而进入完成或阻塞状态时，才把处理器分配给新进程。</li>
</ul>
</li>
</ul>
<h3 id="典型调度算法">典型调度算法：</h3>
<p>进程调度的核心问题是采用什么样的算法将处理器分配给进程。下面介绍几种常用的进程调度算法。标题括号中的内容表示该调度算法的适用范围。</p>
<ul>
<li>先来先服务调度算法(作业调度、进程调度)
<ul>
<li>先来先服务调度算法(FCFS)是一种最简单的调度算法，可以用于作业调度与进程调度。其基本思想是按照进程进入就绪队列的先后次序来分配处理器。先来先服务调度算法采用非抢占的调度方式，即一旦一个进程(或作业)占有处理器，它就一直运行下去，直到该进程(或作业)完成其工作或因等待某一事件而不能继续执行时才释放处理器。</li>
<li>从表面上看，先来先服务调度算法对于所有进程(或作业)是公平的，即按照它们到来的先后次序进行服务。但假设有等数量的长进程(10t) 和短进程(t), 因为数量相等，所以谁先到的概率也相等。当长进程先来时，短进程的等待时间为10t,而当短进程先来时，长进程的等待时间仅为t。所以说先来先服务调度算法有利于长进程(作业),不利于短进程(作业)。</li>
<li>现在，先来先服务调度算法已经很少作为主要的调度策略，尤其是不能作为分时系统和实时系统的主要调度策略，但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程或作业按照先来先服务原则进行处理。</li>
</ul>
</li>
<li>短作业优先调度算法(作业调度、进程调度)
<ul>
<li>短作业优先(SJF)调度算法用于进程调度时被称为短进程优先调度算法，该算法既可以用于作业调度，也可以用于进程调度。</li>
<li>短作业(或进程)优先调度算法的基本思想就是把处理器分配给最快完成的作业(或进程)。</li>
<li>在作业调度中，短作业优先调度算法每次从后备作业队列中选择估计运行时间最短的一个或几个作业调入内存，分配资源，创建进程并放入就绪队列。</li>
<li>在进程调度中，短进程优先调度算法每次从就绪队列中选择估计运行时间最短的进程，将处理器分配给它，使该进程运行并直到完成或因某种原因阻塞才释放处理器。</li>
<li>可以证明，在所有作业同时到达时，SJF 调度算法是最佳算法，平均周转时间最短(如果短进程先执行，长进程等待时间较长进程先执行的情况要短很多，因此平均等待时间最短,而进程运行时间是确定不变的)。但该算法很显然对长作业不利，当有很多短作业不断进入就绪队列时，长作业会因长期得不到调度而产生“饥饿&quot;现象(“饥饿”现象是指在一段时间内，进程得不到调度执行或得不到所需资源)。</li>
</ul>
</li>
<li>优先级调度算法(作业调度、进程调度)
<ul>
<li>优先级调度算法是一种常用的进程调度算法，既可用于作业调度，也可用于进程调度。其基本思想是把处理器分配给优先级最高的进程。 该算法的核心问题是如何确定进程的优先级。</li>
<li>进程的优先级用于表示进程的重要性，即运行的优先性。进程优先级通常分为两种:
<ul>
<li>静态优先级和动态优先级。</li>
</ul>
</li>
<li>静态优先级是在创建进程时确定的，确定之后在整个进程运行期间不再改变。确定静态优先级的依据有以下几种:
<ul>
<li>按进程类确定。 通常，系统中有两类进程，即系统进程和用户进程。系统中各进程的运行速度以及系统资源的利用率在很大程度上依赖于系统进程。例如，若系统中某种共享输入输出设备由一个系统进程管理，那么使用这种设备的所有进程的运行速度都依赖于这一个系统进程。所以，系统进程的优先级应高于用户进程。在批处理与分时结合的系统中，为了保证分时用户的响应时间，前台作业的进程优先级应高于后台作业的进程。</li>
<li>按作业的资源要求确定。 根据作业要求系统提供的资源，比如处理器时间、内存大小、I0设备的类型及数量等来确定作业的优先级。由于作业的执行时间事先难以确定，因此只能根据用户提出的估计时间来确定。进程所申请的资源越多，估计的运行时间越长，进程的优先级越低。</li>
<li>按用户类型和要求确定。计算机系统的用户可按不同标准分类，但通常与用户类型和收费标准有关。用户的收费标准越高，则该用户作业对应进程的优先级也越高，例如租用服务器，租金越贵的服务器在该服务器提供商的所有服务器中的优先级越高。</li>
</ul>
</li>
<li>动态优先级是指在创建进程时，根据进程的特点及相关情况确定一个优先级，在进程运行过程中再根据情况的变化调整优先级。确定动态优先级的依据有以下几种:
<ul>
<li>根据进程占有CPU时间的长短来决定。一个进程占用CPU的时间越长，则优先级越低，再次获得调度的可能性就越小;反之，一个进程占用CPU的时间越短，则优先级越高，再次获得调度的可能性就越大。</li>
<li>根据就绪进程等待CPU时间的长短来决定。一个就绪进程在就绪队列中等待的时间越长，则优先级越高，获得调度的可能性就越大:反之，一个就绪进程在就绪队列中等待的时间越短，则优先级越低，获得调度的可能性就越小。</li>
</ul>
</li>
<li>基于优先级的调度算法还可以按调度方式的不同分为非抢占优先级调度算法和抢占优先级调度算法。
<ul>
<li>非抢占优先级调度算法的实现思想是系统一旦将处理器分配给就绪队列中优先级最高的进程，该进程便会一直运行下去， 直到由于其自身原因(任务完成或申请设备等)主动让出处理器时，才将处理器分配给另一个当前优先级最高的进程。</li>
<li>抢占优先级调度算法的实现思想是将处理器分配给优先级最高的进程，并使之运行。在进程运行过程中，一旦出现了另个优先级更高的进程(如一个更高优先级进程因等待的事件发生而变为就绪状态)，进程调度程序就停止当前的进程，而将处理器分配给新出现的优先级更高的进程。</li>
</ul>
</li>
<li>★注;在优先级相同的情况下，通常按照先来先服务或者短作业优先的顺序执行。</li>
</ul>
</li>
<li>时间片轮转调度算法(进程调度)
<ul>
<li>在分时系统中，进程调度通常采用时间片轮转调度算法。在时间片轮转调度算法中，系统将所有就緒进程按到达时间的先后次序排成一个队列，进程调度程序总是选择队列中的第一个进程执行，并规定执行一定时间， 称为时间片(例如100ms)。当该进程用完这一时间片时(即使进程并未执行结束)，系统将它送至就绪队列队尾，再把处理器分配给下一个就绪进程。这样，处于就绪队列中的进程就可以依次轮流获得一个时间片 的处理时间，然后重新回到队列尾部排队等待执行，如此不断循环，直至完成。</li>
<li>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片设置得太大，所有进程都能在一个时间片内执行完毕，那么时间片轮转调度算法就退化为先来先服务调度算法:如果时间片设置得太小，那么处理器将在进程之间频繁切换，处理器真正用于运行用户进程的时间将减少。因此，时间片的大小应设置适当。</li>
<li>时间片的大小通常由以下因素确定:</li>
<li>系统的响应时间。分时系统必须满足系统对响应时间的要求，系统响应时间与时间片的关系可以表示为：T=Nxq，其中，T为系统的响应时间，q为时间片的大小，N为就绪队列中的进程数。根据这个关系可以得知，若系统中的进程数一定，时间片的大小与系统响应时间成正比。</li>
<li>就绪队列中的进程数目。在响应时间固定的情况下，就绪队列中的进程数与时间片的大小成反比。</li>
<li>系统的处理能力。通常要求用户键入的常用命令能够在一个时间片内处理完毕。因此，计算机的速度越快，单位时间内可处理的命令就越多，时间片就可以越小。</li>
</ul>
</li>
<li>高响应比优先调度算法(作业调度)
<ul>
<li>高响应比优先调度算法综合了先来先服务与短作业优先两种调度算法的特点，即考虑了作业的等待时间和作业的运行时间两个因素，弥补了之前两种调度算法只考虑其中一个因素的不足。</li>
<li>高响应比优先调度算法主要用于作业调度。其基本思想是每次进行作业调度时，先计算就绪队列中的每个作业的响应比，挑选响应比最高的作业投入运行。响应比的计算公式为：响应比=作业响应时间/估计运行时间，即，响应比= (作业等待时间+估计运行时间) /估计运行时间</li>
<li>从公式可以看出，该算法有利于短作业(作业等待时间相同时，估计运行时间越短，响应比越高)，同时考虑长作业(只要作业等待时间足够长，响应比就会变为最高)。该算法对于短作业和长作业都有考虑，但由于要计算每个后备作业的响应比，因此增加了系统开销。</li>
</ul>
</li>
<li>多级队列调度算法(进程调度)
<ul>
<li>多级队列调度算法的基本思想是根据进程的性质或类型，将就绪队列划分为若千个独立的队列，每个进程固定地分属于一个队列。每个队列采用一种调度算法，不同的队列可以采用不同的调度算法。例如，为交互型任务设置一个就绪队列，该队列采用时间片轮转调度算法;再如，为批处理任务另外设置一个就绪队列，该队列采用先来先服务调度算法。</li>
</ul>
</li>
<li>多级反馈队列调度算法(进程调度)
<ul>
<li>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展。通过动态调整进程优先级和时间片的大小，多级反馈队列调度算法可兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程;为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程;同时，也不必事先估计进程的执行时间。</li>
<li>首先，应设置多个就绪队列，并为每个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列的优先级次之，其余队列的优先级逐次降低。</li>
<li>其次，每个队列中的进程执行时间片的大小也各不相同，进程所在队列的优先级越高，其相应的时间片就越短。通常，第(i+1)队列的时间片是第i队列时间片的两倍。</li>
<li>再次，当一个新进程进入系统时，应先将其放入第一个队列末尾，按先来先服务的原则排队等待调度。当轮到该进程执行时，如能在此时间片完成，便可准备撤离系统;如果该进程在一个时间片结束时尚未完成，调度程序便将该进程转入第二个队列的末尾，再同样按照先来先服务原则等待调度执行;如果该进程在第二个队列中运行一个时间片后仍未完成，再以同样方法转入第三个队列。如此下去，最后一个队列中使用时间片轮转调度算法。</li>
<li>最后，仅当第一个队列空闲时，调度程序才调度第二个队列中的进程运行;仅当第一个至第(i-1)个队列均为空时，才会调度第i个队列中的进程运行。当处理器正在为第i个队列中的某进程服务时，若又有新进程进入优先级较高的队列中，则此时新进程将抢占正在运行进程的处理器，即由调度程序把正在执行的进程放回第i个队列末尾，并重新将处理器分配给新进程。</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211213195825.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211213195825.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211213195825.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211213195825.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211213195825.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211213195825.png" /></p>
<h2 id="同步与互斥">同步与互斥</h2>
<h3 id="进程同步的基本概念">进程同步的基本概念</h3>
<p>接下来进入到本章的关键部分进程同步。 在学习进程同步之前，先介绍一些关键的概念。</p>
<ul>
<li>两种形式的制约关系
<ul>
<li>间接相互制约关系(互斥)
<ul>
<li>若某一进程要求使用某种资源，而该资源正被另一进程使用，并且该资源不允许两个进程同时使用，那么该进程只好等待已占用资源的进程释放资源后再使用。这种制约关系的基本形式是“进程一资源一进程 ”。</li>
<li>这种制约关系源于多个同种进程需要互斥地共享某种系统资源(比如打印机),互斥是设置在同种进程之间以达到互斥地访问资源的目的(比如在生产者~消费者问题中，生产者与生产者之间需要互斥地访问缓冲池)。</li>
</ul>
</li>
<li>直接相互制约关系(同步)
<ul>
<li>某一进程若收不到另一进程给它提供的必要信息就不能继续运行下去，这种情况表明了两个进程之间在某些点上要交换信息，相互交流运行情况。这种制约关系的基本形式是“进程-进程”。</li>
<li>这种制约主要源于进程间的合作，同步设置在不同进程之间以达到多种进程间的同步(比如在生产者.消费者问题中，生产者就可以生产产品并放入缓冲池，消费者从缓冲池取走产品进行消费，若生产者没有生产产品，则消费者无法进行消费)。</li>
</ul>
</li>
<li>注:区分互斥与同步只需记住，只要是同类进程即为互斥关系，不同类进程即为同步关系，例如消费者与消费者就是互斥关系，消费者和生产者就是同步关系。</li>
</ul>
</li>
<li>临界资源与临界区
<ul>
<li>进程在运行过程中，一般会与其他进程共享资源，而有些资源的使用具有排他性。把同时仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机、绘图机等。</li>
<li>为了保证临界资源的正确使用,我们可以把临界资源的访问过程分成4部分。这4部分都属于要访问临界资源的进程，是进程中的一部分代码。
<ul>
<li>进入区。为了进入临界区使用临界资源，在进入区要检查是否可以进入临界区;如果可以进入临界区，通常设置相应的正在访问临界区”标志，以阻止其他进程同时进入临界区。</li>
<li>临界区。进程中用于访问临界资源的代码，又称临界段。</li>
<li>退出区。临界区后用于将“正在访问临界区”标志清除的部分。</li>
<li>剩余区。进程中除上述3部分以外的其他部分。</li>
</ul>
</li>
<li>临界资源和临界区是两个比较容易混淆的概念，有人可能会理解为临界区就是临界资源所在地址，这样理解显然是错误的。简单来说，临界资源是一种系统资源，需要不同进程互斥访问，而临界区则是每个进程中访问临界资源的一段代码，是属于对应进程的，临界区前后需要设置进入区和退出区以进行检查和恢复。临界区和临界资源是不同的，临界资源是必须互斥访问的资源，这种资源同时只能被一个进程所使用，但需要这种资源的进程不止一个，因此需要对使用临界资源的进程进行管理，这也就产生了临界区的概念。</li>
<li>这里还要弄清楚一个概念:每个进程的临界区代码可以不相同。临界区代码由于要访问临界资源，因此要在进入临界区之前(也就是执行临界区代码之前)进行检查，至于每个进程对临界资源进行怎样的操作，这和临界资源及互斥同步管理是无关的，比如，磁带机是明显的临界资源，有两个进程都要对其进行操作，A要写磁带前半部分，B要读磁带后半部分，这两个进程对磁带操作的部分就是这两个进程各自的临界区，不能同时执行，但内容是不相同的，不可认为临界资源相同，访问这些资源的代码也是相同的。</li>
</ul>
</li>
<li>互斥的概念与要求
<ul>
<li>根据互斥的定义，当一个进程进入临界区使用临界资源时，另一个进程必须等待，直到占用该临界资源的进程退出临界区后，才允许新的进程访问该临界资源。为了禁止两个进程同时进入临界区，软件算法或同步机构都应遵循以下准则。</li>
<li>空闲让进。当没有进程处于临界区时，可以允许一个请求进入临界区的进程立即进入自己的临界区。</li>
<li>忙则等待。当已有进程进入其临界区时，其他试图进入临界区的进程必须等待。</li>
<li>有限等待。对要求访问临界资源的进程，应保证能在有限的时间内进入自己的临界区。让权等待。当一个进程因为某些原因不能进入自己的临界区时，应释放处理器给其他进程。</li>
</ul>
</li>
<li>同步的概念与实现机制
<ul>
<li>一般来说，一个进程相对另一个进程的运行速度是不确定的。也就是说，进程之间是在异步环境下运行的。但是相互合作的进程需要在某些关键点上协调它们的工作。所谓进程同步，是指多个相互合作的进程在一些关键点上可能需要互相等待或互相交换信息，这种相互制约关系称为进程同步。也可以用信号量同步（后面详细介绍）</li>
</ul>
</li>
</ul>
<h3 id="实现临界区互斥的基本方法软件实现方法硬件实现方法">实现临界区互斥的基本方法：软件实现方法、硬件实现方法。</h3>
<p>互斥既可以用软件方法实现，也可以用硬件方法实现。</p>
<ul>
<li>软件方法
<ul>
<li>对临界区互斥访问技术的研究始于20世纪60年代，早期主要从软件方法上进行研究，下面介绍这些软件方法。它们有的是正确的，有的是不正确的。介绍这些方法是为了说明用软件方法解决互斥和同步问题的困难性和复杂性。</li>
<li>例如，有两个进程Po和PI，互斥地共享某个资源。Po和PI是循环进程，它们执行一个无限循环程序,每次使用资源一个有限的时间间隔。</li>
<li>算法1:设置一个公用整型变量turn,用来表示允许进入临界区的进程标识。若turm为0,则允许进程Po进入临界区;否则循环检查该变量，直到turm变为本进程标识;在退出区，修改允许进入进程的标识turn为1。进程PI的算法与此类似。两个进程的程序结构如下:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">int turn=0;
P0:{
    Do{
        while(turn!=0); //turn不为0时循环检查，直到为0（进入区）
        进程P0的临界区代码CS0; //临界区
        turn=1; //退出区
        进程P0的其他代码；
    }
    while(true) //循环执行这段代码
}
P1:{
    Do{
        while(turn!=1); //进入区
        进程P1的临界区代码CS1; //临界区
        turn=0; //退出区
        进程P1的其他代码；
    }
    while(true)
}
</code></pre></td></tr></table>
</div>
</div><ul>
<li>此方法可以保证互斥访问临界资源，但存在的问题是强制两个进程以交替次序进入临界区，很容易造成资源利用不充分。例如，当进程Po退出临界区后将turn置为1,以便允许进程P1进入临界区，但如果进程P1暂时并未要求访问该临界资源，而Po又想再次访问临界资源，则它将无法进入临界区。可见，此算法不能保证实现“空闲让进”准则。</li>
<li>算法2:设置标志数组flag[]表示进程是否在临界区中执行，初值均为假。在每个进程访问该临界资源之前，先检查另一个进程是否在临界区中，若不在，则修改本进程的临界区标志为真并进入临界区，在退出区修改本进程临界区标志为假。两进程的程序结构如下:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">enum boolean{false,true}; //设置数据元素类型
boolean flag[2]={false,false}; //设置标志数组
P0:{
    Do{
        while flag[1]; //flag[1]为真表示P!在访问临界区，P0等待（进入区）
        flag[0]=true; //进入区
        进程P0的临界区代码CS0; //临界区
        flag[0]=false; //退出区
        进程P0的其他代码；
    }
    while(true)
}
P1:{
    Do{
        while flag[0]; //flag[0]为真表示P0在访问临界区，P1等待（进入区）
        flag[1]=true; //进入区
        进程P1的临界区代码CS1; //临界区
        flag[1]=false; //退出区
        进程P1的其他代码；
    }
    while(true)
}
</code></pre></td></tr></table>
</div>
</div><ul>
<li>此算法解决了“空闲让进”的问题，但又出现了新问题，即当两个进程都未进入临界区时，它们各自的访问标志都为false,若此时刚好两个进程同时都想进入临界区，并且都发现对方的标志值为false (当两进程交替执行了检查语句后，都满足flag[]=false 的条件)，于是两个进程同时进入了各自的临界区，这就违背了临界区的访问规则“忙则等待”。</li>
<li>算法3:本算法仍然设置标志数组flag[],但标志用来表示进程是否希望进入临界区，每个进程在访问临界资源之前，先将自己的标志设置为真，表示希望进入临界区，然后检查另一个进程的标志。若另一个进程的标志为真，则进程等待;反之，则进入临界区。</li>
<li>此算法可以有效防止两进程同时进入临界区，但存在两个进程都进不了临界区的问题，即当两个进程同时想进入临界区时，它们分别将自己的标志位设置为true, 并且同时去检查对方的状态，发现对方也要进入临界区，于是都阻塞自己，结果导致两者都无法进入临界区，造成“死等”现象，这就违背了“有限等待”的准则。</li>
<li>算法4:本算法的思想是算法3和算法1的结合。标志数组flag[]表示进程是否希望进入临界区或是否在临界区中执行。此外，还设置了一个turn变量，用于表示允许进入临界区的进程标识。</li>
<li>至此，算法4可以完全正常工作，利用flag[]解决临界资源的互斥访问，而利用turm 解决“饥饿”现象。</li>
<li>注:.上述内容中，前3个算法分别违背了4个准则中的“空闲让进”“忙则等待”和“有限等待”准则，对于让权等待则没有具体涉及。下面简单介绍一种违背“让权等待”准则的情况一“忙等”。 所谓“忙等”，是指“不让权”的等待，也就是说，进程因为某事件的发生而无法继续执行时，仍然不释放处理器，并通过不断执行循环检测指令来等待该事件的完成以便能够继续执行。“忙等”的主要缺点是浪费CPU的时间，另外还可能引起预料不到的后果，例如，某个采取高优先权调度且不剥夺的系统，目 前两个进程共享某个临界资源，进程A的优先级高，进程B的优先级低，此时B正在访问临界资源(即处于临界区内),而A也要进入自己的临界区，由于A的优先级较高，B所等待的事件可能会因A的存在而迟迟得不到处理，而B又一直占用处理器，因此两进程都无法向前推进，导致“忙等”。从上面的软件实现方法可以看出，对于两个进程间的互斥，最主要的问题就是标志的检查和修改不能作为一个整体来执行，因此容易导致无法保证互斥访问的问题。</li>
</ul>
</li>
<li>硬件方法
<ul>
<li>完全利用软件方法实现进程互斥有很大的局限性，现在已经很少单独采用软件方法。硬件方法的主要思想是用一条指令完成标志的检查和修改这两个操作，因而保证了检查操作与修改操作不被打断;或通过中断屏蔽的方式来保证检查和修改作为一个整体执行。</li>
<li>硬件方法主要有两种: 一种是中断屏蔽;另一种是硬件指令。在计算机组成原理中会详细讲解中断与指令，操作系统中涉及较少，因此不展开叙述。</li>
<li>与前面的软件实现方法相比，由于硬件方法采用处理器指令能够很好地把检查和修改操作结合成一个不可分割的整体，因此具有明显的优点。具体而言，硬件方法的优点体现在以下几个方面:
<ul>
<li>适用范围广。硬件方法适用于任何数目的进程，在单处理器和多处理器环境中完全相同。</li>
<li>简单。硬件方法的标志设置简单，含义明确，容易验证其正确性。</li>
<li>支持多个临界区。当一个进程内有多个临界区时，只需为每个临界区设立一个布尔变量。</li>
</ul>
</li>
<li>硬件方法有诸多优点，但也有一些自身无法克服的缺点。这些缺点主要包括进程在等待进入临界区时要耗费处理器时间，不能实现“让权等待”(需要软件配合进行判断);进入临界区的进程的选择算法用硬件实现有一些缺陷，可能会使一些进程一直选不上，从而导致“饥饿”现象。</li>
</ul>
</li>
</ul>
<h3 id="信号量">信号量</h3>
<p>虽然前面讲解的软件及硬件方法都可以解决互斥问题，但它们都存在缺点。软件方法的算法太复杂，效率不高、不直观，而且存在“忙等”现象(在进入区时会持续检测标志变量)。就硬件方法而言，对于用户进程，中断屏蔽方法不是一种合适的互斥机制;硬件指令方法有不能实现“让权等待”等缺点。</p>
<p>荷兰著名的计算机科学家Djkstra于1965年提出了一个同步机构，称为信号量，其基本思想是在多个相互合作的进程之间使用简单的信号来同步。</p>
<ul>
<li>信号量及同步原语
<ul>
<li>信号量是一个确定的二元组(s, q),其中s是一个具有非负初值的整型变量, q是一个初始状态为空的队列。整型变量s表示系统中某类资源的数目，当其值大于0时，表示系统中当前可用资源的数目;当其值小于0时，其绝对值表示系统中因请求该类资源而被阻塞的进程数目。除信号量的初值外，信号量的值仅能由P操作(又称为wait操作)和V操作(又称为signal 操作)改变。操作系统利用它的状态对进程和资源进行管理。</li>
<li>一个信号量的建立必须经过说明，即应该准确说明s的意义和初值(★注:这个初值不是一个负值)。每个信号量都有相应的一个队列，在建立信号量时队列为空。</li>
<li>设s为一个信号量，P(s)执行时主要完成以下动作:先执行s=s-1;若s≥0，则该进程继续运行;若s&lt;0，则阻塞该进程，并将它插入该信号量的等待队列中。</li>
<li>V(s)执行时主要完成下述动作:先执行s=s+1;若s&gt;0，则该进程继续执行;若s≤0,则从该信号量等待队列中移出第一个 进程，使其变为就绪状态并插入就绪队列，然后再返回原进程继续执行。</li>
<li>注: P、V操作均为不可分割的原子操作，这保证了对信号量进行操作过程中不会被打断或阻塞。P操作相当于申请资源，V操作相当于释放资源。P操作和V操作在系统中一定是成对出现的，但未必在一个进程中，可以分布在不同进程中。</li>
</ul>
</li>
<li>信号量的分类
<ul>
<li>整型信号量
<ul>
<li>整型信号量是一个整型量s，除初始化外，仅能通过标准的原子操作P和V来访问。整型信号量引入了P、V操作，但是在进行P操作时，若无可用资源，则进程持续对该信号量进行测试，存在“忙等”现象，未遵循“让权等待”准则。</li>
</ul>
</li>
<li>记录型信号量(资源信号量)
<ul>
<li>为了解决整型信号量存在的“忙等”问题，添加了链表结构，用于链接所有等待该资源的进程，记录型信号量正是因采用了记录型的数据结构而得名。当进程对信号量进行P操作时，若此时无剩余资源可用，则进程自我阻塞，放弃处理器，并插入到等待链表中。可见，该机制遵循“让权等待”准则。当进程对信号量进行V操作时，若链表中仍有等待该资源的进程，则唤醒链表中的第一个等待进程。如果信号量初值为1,表示该资源为同时只允许一个进程访问的临界资源。由于AND型信号量与信号量集近年来在考试中从未涉及，而且这两项的内容就是对前面两种信号量的一种扩充，因此可以略过，不必在此浪费时间。</li>
</ul>
</li>
</ul>
</li>
<li>信号量的应用
<ul>
<li>信号量可以用来实现进程互斥和描述前趋关系，前趋关系不是考查重点。这里只介绍实现进程同步与互斥的简单例子。</li>
<li>实现进程同步
<ul>
<li>假设存在并发进程Pr和P2。P1中有一条语句SI, P2中有一条语句S2，要求SI必须在S2之前执行。这种同步问题使用信号量就能很好解决。</li>
</ul>
</li>
<li>实现进程互斥
<ul>
<li>假设有进程PI和P2，两者有各自的临界区，但系统要求同时只能有一个进程进入自己的临界区。这里使用信号量可以很方便地解决临界区的互斥进入。设置信号量N,初值为1 (即可用资源数为1)，只需要将临界区放在P(N)和V(N)之间即可实现两进程的互斥进入。</li>
<li>若有两个或者多个进程需要互斥访问某资源，可以设置一个初值为1的信号量，在这些进程的访问资源的代码前后分别对该信号量进行P操作和V操作，即可保证进程对该资源的互斥访问。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="经典同步问题生产者消费者问题读者写者问题哲学家进餐问题">经典同步问题：生产者消费者问题、读者写者问题、哲学家进餐问题。</h3>
<ul>
<li>生产者消费者问题
<ul>
<li>生产者消费者问题是著名的进程同步问题。它描述的是一组生产者向一组消费者提供产品，他们共享一个有界缓冲区，生产者向其中投入产品，消费者从中取走产品。这个问题是许多相互合作进程的一种抽象。 例如，在输入时，输入进程是生产者，计算进程是消费者;在输出时，计算进程是生产者，打印进程是消费者。</li>
<li>为解决这一问题， 应当设置两个同步信号量: 一个说明空缓冲区数目，用empty表示，初值为有界缓冲区大小n;另一个说明满缓冲区数目(即产品数目),用full表示，初值为0。此外，还需要设置一个互斥信号量mutex,初值为1,以保证多个生产者或者多个消费者互斥地访问缓冲池。</li>
<li>生产者~消费者问题的同步程序结构描述如下:
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222150.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222150.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222150.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222150.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222150.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222150.png" /></li>
<li>特别注意如下内容:
<ul>
<li>Pf(ul)/P(empty)与 P(mutex)的顺序不可颠倒，必须先对资源信号量进行P操作，再对互斥信号量进行P操作，否则会导致死锁。例如，此时缓冲区已满，而生产者先P (mutex),取得缓冲池访问权，再P (empty)， 此时由于缓冲池已满，empty=0， 导致P (empty)失败，生产者进程无法继续推进，始终掌握缓冲池访问权无法释放，因而消费者进程无法取出产品，导致死锁。而V(ull)/V(empty)与V(mutex)的顺序则没有要求，其顺序可以颠倒。这个问题可以延伸到几乎所有关于P、V操作的习题中，在有多个信号量同时存在的情况下，P操作往往是不能颠倒顺序的，必须先对资源信号量进行P操作，再对互斥信号量进行P操作，这样可以在占有信号量访问权时保证有资源可以使用，否则会产生占用使用权而无资源可用的“死，等”现象。</li>
<li>关于 mutex互斥信号量的设置是否必要的问题。在生产者和消费者都唯一的问题中，生产者与消费者是同步关系，生产者与消费者之间使用empty与full两个资源信号量进行同步，一定满足“放完才能取”的条件，因此此时互斥信号量mutex可以去掉。但在多生产者和多消费者的情况下，需要保证多个生产者或者多个消费者互斥地访问缓冲池，否则会导致出错。例如，两个生产者执行了P (empty)操作，此时第一个生产者执行bffr(in)=nextp, 这时第二个生产者也执行这条语句，由于第一个生产 者没有来得及执行in=(in+1)% n,即没有使指针后移，导致第二个生产者的数据覆盖掉了第一个生产者的数据，而不是放在了第一个数据的下一个缓冲区，接下来两个进程分别执行一次后移指针操作，这样就导致了有一个空缓冲区(本来应当放置第二个数据的缓冲区)被当作已有数据缓冲区对待，从而出错。因此，在多生产者或多消费者的情况下，必须设置mutex互斥信号量，以保证对缓冲池的互斥访问。
<ul>
<li>这里可记住一点: 只要有多个同类进程(同类进程是指使用同一个记录型信号量的进程，比如若干消费者进程都在使用empty信号量)，就一定需要互斥信号量;若同类进程只有一个，则记录型信号量即可完成进程同步。换句话说，互斥信号量就是给同类进程准备的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>读者写者问题
<ul>
<li>在读者-写者问题中，有一个许多进程共享的数据区，这个数据区可以是一个文件或者主存的一块空间，有一些只读取这个数据区的进程(读者)和一些只往数据区写数据的进程(写者)。此外还需要满足以下条件:</li>
<li>任意多个读者可以同时读这个文件。</li>
<li>一次只能有一个写者可以往文件中写(写者必须互斥)。</li>
<li>如果一个写者正在进行操作，禁止任何读进程读文件和其他任何写进程写文件。</li>
<li>需要分多种情况实现该问题:读者优先、公平情况和写者优先。</li>
<li>读者优先算法
<ul>
<li>一个读者试图进行读操作时，如果这时正有其他读者在进行读操作，他可以直接开始读操作，而不需要等待。由于只要有读者在进行读操作，写者就不能够写，但后续读者可以直接进行读操作，因此只要读者陆续到来，读者一到就能 够开始读操作，而写者进程只能等待所有读者都退出才能够进行写操作，这就是读者优先。要解决此问题，需要设置如下几个信号量:设置记录读者数量的整型变量readcount,初值为0，当其值大于0时，表明有读者存在，写者不能进行写操作;设置互斥信号量rmutex,初值为1,用于保证多个读者进程对于readcount 的互斥访问;设置互斥信号量mutex，初值为1，用于控制写者进程对于数据区的互斥访问。算法如下:
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222745.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222745.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222745.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222745.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222745.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222745.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222806.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222806.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222806.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222806.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222806.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222806.png" /></li>
</ul>
</li>
<li>公平情况算法(按照到达顺序进行操作)
<ul>
<li>进程的执行顺序完全按照到达顺序，即一个读者试图进行读操作时，如果有写者正等待进行写操作或正在进行写操作，后续读者要等待先到达的写者完成写操作后才开始读操作。要解决此问题，跟读者优先算法相比，需要增设一个信号量wmutex, ，其初值为1，用于表示是否存在正在写或者等待的写者，若存在，则禁止新读者进入。算法如下:
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222927.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222927.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222927.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222927.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222927.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222927.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222953.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222953.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222953.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222953.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222953.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122222953.png" /></li>
<li>★注:在本算法中，由于存在互斥信号量wmutex,因此当第一个写者到来时， 就会占用该信号量，从而阻止了后续其他读者的进入请求，只有当之前申请写操作的写者进入数据区完成写操作之后，才会释放wmutex信号量，后续读者才能够进入(实际上在这个算法中,将读写两种进程放在平等的地位，完全按照进程到达的顺序来执行。设置wmutex信号量的目的在于控制进程按照顺序来进行操作，避免读进程的优先)。</li>
</ul>
</li>
<li>写者优先算法
<ul>
<li>有的书把公平情况算法也叫作写者优先，但并不是真正意义上的写者优先，只是按照到达顺序进行读写操作而已。若要实现真正的写者优先(即当写者和读者同时等待时，后续写者到达时可以插队到等待的读者之前，只要等待队列中有写者，不管何时到达，都优先于读者被唤醒)，则需要增设额外的信号量进行控制。为了达到这一目的，需要增设额外的一个信号量readable,用于控制写者到达时可以优先于读者进入临界区，当有写者到达时，只需要等待前面的写者写完就可以直接进入临界区，而不论读者是在该写者之前还是之后到达。另外，需要增设一个整数writecount 用于统计写者的数量。与之前的算法相比，wmutex的作用有所变化，现在是用于控制写者互斥访问writecount。算法如下:
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223157.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223157.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223157.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223157.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223157.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223157.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223224.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223224.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223224.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223224.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223224.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223224.png" />
本方法增设了readable 信号量，用于实现写者插队的目的。当第一个写者到达时，申请占用readable信号量，占用成功之后就一直占用，后续到达的读者进程会因申请不到readable信号量而阻塞，而后续写者到达时，由于不需要申请readable 信号量，因此就排在这个写者后面，从而达到插队的目的。直到所有写者都已经写完，最后一个写者释放了readable 信号量之后，读者才能够继续执行读操作。当新的写者到达时，继续占用readable 信号量，阻止后续的读者进行读操作，重复进行此过程。此算法真正实现了写者优先，新写者也可以优先于先到的等待读者占用数据区进行操作。</li>
</ul>
</li>
</ul>
</li>
<li>哲学家进餐问题
<ul>
<li>5个哲学家围绕一张圆桌而坐，桌子上放着5根筷子，每两个哲学家之间放一根;哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两根筷子，思考时则同时将两根筷子放回原处。哲学家进餐问题可以看作并发进程执行时处理临界资源的一个典型问题。筷子是临界资源，不能同时被两个哲学家一起用，因此使用一个信号量数组来表示筷子(哲学家按照编号逆时针围桌而坐，0号哲学家左手筷子为0号筷子，右手筷子为1号筷子，依次类推)。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223420.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223420.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223420.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223420.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223420.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223420.png" /></li>
<li>这种解法存在问题，会导致死锁(假如5个哲学家同时饥饿而各自拿左边的筷子时，会导致5根筷子均被占用，当他们试图拿右边的筷子时，都将因没有筷子而“无限等待”)。对于这种死锁问题，可以采用如下几种解决方法:1、最多只允许4个哲学家同时进餐。2、仅当一个哲学家左右两边的筷子同时可用时，他才可以拿起筷子。3、将哲学家编号，要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子。现给出最后一种方法的解法:规定奇数号的哲学家先拿左边筷子，然后拿右边筷子;偶数号的哲学家则相反。算法如下:
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223819.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223819.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223819.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223819.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223819.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223819.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223842.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223842.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223842.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223842.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223842.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122223842.png" /></li>
</ul>
</li>
<li>理发师问题
<ul>
<li>理发店有一位理发师、一把理发椅和若千供顾客等候用的凳子(这里假设有n个凳子)。若没有顾客，则理发师在理发椅上睡觉。当一个顾客到来时，他必须先叫醒理发师;若理发师正在给顾客理发，则如果有空凳子，该顾客等待;如果没有空凳子，顾客就离开。要为理发师和顾客各设计一段程序来描述其活动。对本题有两种思路:一种是将理发椅 与等待用的凳子分别看作两种不同的资源;另一种是将理发椅和凳子看成统一的一种椅子资源。具体实现略。</li>
</ul>
</li>
</ul>
<h3 id="管程">管程</h3>
<p>用信号量机制可以实现进程间的同步和互斥，但由于信号量的控制分布在整个程序中,其正确性分析很困难，使用不当还可能导致进程死锁。针对信号量机制中存在的这些问题，Dijkstra于1971年提出为每个共享资源设立一个“秘书”来管理对它的访问。一切来访者都要通过“秘书”，而“秘书”每次仅允许一个来访者(进程)访问共享资源。这样既便于系统管理共享资源，又能保证互斥访问和进程间同步。1973 年，Hanson 和Hoare又把“秘书”概念发展为管程概念。</p>
<p>管程定义了一个数据结构和能为并发进程所执行的一组操作 ，这组操作能同步进程和改变管程中的数据。由管程的定义可知，管程由局部于管程的共享数据结构说明、操作这些数据结构的一组过程以及对局部于管程的数据结构设置初值的语句组成(★注:此处的“局部于”的含义为这些数据结构仅定义在管程内部，其作用范围仅在管程范围内)。管程把分散在各个进程中互斥访问公共变量的临界区集中起来，提供对它们的保护。</p>
<p>管程有以下基本特征:</p>
<ul>
<li>局部于管程的数据只能被局部于管程内的过程所访问。</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据。</li>
<li>每次仅允许一个进程在管程内执行某个内部过程，即进程互斥地通过调用内部过程进入管程。其他想进入管程的过程必须等待，并阻塞在等待队列。由于管程是一个语言成分，因此管程的互斥访问完全由编译程序在编译时自动添加，而且保证正确。为实现进程间的同步，管程还必须包含若干用于同步的设施。例如，一个进程因调用管程内的过程而进入管程，在该过程执行过程中，若进程要求的某共享资源目前没有，则必须将该进程阻塞，于是必须有使该进程阻塞并且使它离开管程以便其他进程可以进入管程执行的设施;类似地，以后当被阻塞进程等待的条件得到满足时，必须使阻塞进程恢复运行，允许它重新进入管程并从断点(阻塞点)开始执行。
因此，在管程定义中还应包含以下支持同步的设施:局限于管程并仅能从管程内进行访问的若干条件变量，用于区别各种不同的等待原因。</li>
<li>在条件变量上进行操作的两个函数过程wait和signal。wait将调用此函数的进程阻塞在与该条件变量相关的队列中，并使管程可用，即允许其他进程进入管程。signal 唤醒在该条件变量上阻塞的进程，若有多个这样的进程，则选择其中的一个进程唤醒;若该条件变量上没有阻塞进程，则什么也不做。管程的signal 过程必须在wait过程调用之后调用。</li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="死锁概念">死锁概念</h3>
<p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题一死锁。当多个进程因竞争系统资源或相互通信而处于永久阻塞状态时，若无外力作用，这些进程都将无法向前推进。这些进程中的每一个进程， 均无限期地等待此组进程中某个其他进程占有的、自己永远无法得到的资源，这种现象称为死锁。</p>
<p>下面通过几个例子来说明死锁现象。</p>
<ul>
<li>某系统中只有一台打印机和一 台输入设备，进程PI正在占用输入设备，同时又提出了使用打印机的请求，但此时打印机正被进程P2占用。而P2在未释放打印机之前，又提出请求使用正被P1占用着的输入设备。这样，两个进程相互无休止地等待下去，均无法继续执行，此时两个进程陷入死锁状态。</li>
<li>在生产者-消费者问题中，若交换生产者进程中的两个P操作的顺序，则有可能出现死锁。改动后的生产者-消费者问题描述如下:<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122225334.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122225334.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122225334.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122225334.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122225334.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211122225334.png" /></li>
</ul>
<p>交换生产者进程中两个P操作的次序，一般情况下不会出现死锁，但在特殊情况下会出现死锁。例如，在某一时刻缓冲区中已装满了产品且缓冲区中没有进程工作(这时信号量full的值为n,信号量empty，的值为0,信号量mutex的值为1)， 若系统此时调度生产者进程运行，生产者进程生产了一个产品，执行P(mutex)并顺利进入临界区(这时mutex的值为0),随后它执行P(empty)时因没有空闲缓冲区而受阻等待，等待消费者进程进入缓冲区取走产品以释放出缓冲区;消费者进程执行P(ull)后再执行P(mutex)时，因缓冲区被生产者进程占据而无法进入。这样就形成了生产者进程在占有临界资源的情况下等待消费者进程取走产品，而消费者进程又无法进入临界区取走产品的僵局，此时两进程陷入死锁。</p>
<p>可以由死锁的定义和上述例子得到如下结论:</p>
<ul>
<li>参与死锁的进程至少有两个。</li>
<li>每个参与死锁的进程均等待资源。</li>
<li>参与死锁的进程中至少有两个进程占有资源。</li>
<li>死锁进程是系统中当前进程集合的一个子集。</li>
</ul>
<h3 id="死锁产生原因和必要条件">死锁产生原因和必要条件</h3>
<ul>
<li>资源分类
<ul>
<li>操作系统是一个资源管理程序，它负责分配不同类型的资源给进程使用。现代操作系统所管理的资源类型十分丰富，并且可以从不同的角度出发对其进行分类，例如，可以把资源分为可剥夺资源和不可剥夺资源。</li>
<li>可剥夺资源是指虽然资源占有者进程需要使用该资源，但另一个进程可以强行把该资源从占有者进程处剥夺来归自己使用。</li>
<li>不可剥夺资源是指除占有者进程不再需要使用该资源而主动释放资源，其他进程不得在占有者进程使用资源过程中强行剥夺。</li>
<li>一个资源是查属于可剥夺资源，完全取决于资源本身的性质，比如，打印机在一个打印任务未结束之前，是无法被其他打印任务剥夺的，因此它是不可剥夺资源;而主存和CPU却是可剥夺资源。</li>
<li>要研究资源分配，必须弄清资源的类型，资源的不同使用性质是引起系统死锁的原因，如对可剥夺资源的竞争不会引起进程死锁，而对其他类型资源的竞争则有可能导致死锁。</li>
</ul>
</li>
<li>死锁产生的原因
<ul>
<li>死锁产生的原因是竞争资源。若系统中只有一个进程在运行，所有资源为这个进程独享，则不会出现死锁现象。当系统中有多个进程并发执行时，若系统中的资源不足以同时满足所有进程的需要，则会引起进程对资源的竞争，从而可能导致死锁的产生。假定进程P1和P2分别申请到了资源A和资源B,现在进程P1又提出使用资源B的申请，由于资源B已被进程P2占有，因此进程PI阻塞;而进程P2可以继续运行，进程P2在运行中又提出使用资源A的申请，由于资源A已经被进程P1占有，因此进程P2阻塞。于是进程P1、P2都因资源得不到满足而进入阻塞状态，从而使进程陷入死锁。</li>
<li>虽然资源竞争可能导致死锁，但是资源竞争并不等于死锁，只有在进程运行过程中请求和释放资源的顺序不当时(即进程的推进顺序不当时)，才会导致死锁。</li>
<li>由此可知，死锁产生的原因是系统资源不足和进程推进顺序不当。系统资源不足是产生死锁的根本原因，设计操作系统的目的就是使并发进程共享系统资源。而进程推进顺序不当是产生死锁的重要原因，当系统资源刚好够进程使用时，进程的推进顺序不当就很容易导致进程彼此占有对方需要的资源，从而导致死锁。</li>
</ul>
</li>
<li>死锁产生的必要条件
<ul>
<li>从上面的论述中可以推出，死锁产生的必要条件有以下4条:</li>
<li>互斥条件。 进程要求对所分配的资源进行排他性控制，即在一段时间内某种资源仅为一个进程所占有。</li>
<li>不剥夺条件。 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放。</li>
<li>请求与保持条件。 进程每次申请它所需的一部分资源。 在等待分配新资源的同时，进程继续占有已经分配到的资源。请求与保持条件也称为部分分配条件。</li>
<li>环路等待条件。存在一种进程资源的循环等待链，而链中的每一个进程已经获得的资源同时被链中的下一个进程所请求。要产生死锁，这4个条件缺一不可，因此可以通过破坏其中的一个或几个条件来避免死锁的产生。</li>
</ul>
</li>
</ul>
<h3 id="死锁处理策略">死锁处理策略</h3>
<p>目前用于处理死锁的方法主要有以下4种:</p>
<ul>
<li>鸵鸟算法。像鸵鸟一样对死锁视而不见，即不理睬死锁。</li>
<li>预防死锁。通过设置某些限制条件，去破坏产生死锁的4个必要条件中的一个或几个来预防死锁的产生。</li>
<li>避免死锁。 在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁的产生。</li>
<li>检测及解除死锁。通过系统的检测机构及时检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ul>
<p>这里要注意区分后3种方法的不同之处。预防死锁是在调度方式上破坏死锁产生的必要条件，使系统无法产生死锁，例如采用可剥夺式的进程调度方法，优先级高的进程总能得到资源并完成运行，因此系统不会产生死锁;避免死锁是在动态分配过程中，预知系统是否会进入不安全状态，若该资源分配有可能产生死锁，则不进行这种分配，后面要讲到的银行家算法就是一种避免死锁的方法;而检测及解除死锁是一种比较被动的方法，是在检测到死锁已经发生之后进行处理，例如采用剥夺死锁进程的资源等方法强制进程释放资源或结束死锁进程来解除死锁状态。</p>
<p>这3种方法有着不同的特点，例如在不能够破坏死锁必要条件的情况下，就无法采用预防死锁的方法，只能采用其他方法;当系统进程过多，预测系统是否进入不安全状态的成本过高时，采用避免死锁的方法并不划算，不如等死锁发生后采用检测及解除死锁的方法。现实中的操作系统并非都采用以上3种处理方法，相反，很多操作系统认为死锁不可能发生，对死锁不进行任何处理(这种说法不够积极，即对死锁采用鸵鸟算法)，如UNIX。</p>
<p>★注:死锁避免和死锁预防不是同一个概念。</p>
<p>死锁预防和死锁避免采取的措施都是在死锁发生之前，但是它们之间还是有很大区别的。死锁预防对系统加的限制条件通常很严格，对系统的并发性会产生很大的副作用，此后不需要再运行什么算法来计算死锁发生的可能性;死锁避免对系统所加的限制条件则相对宽松，有利于进程的并发执行，但是死锁避免往往在资源被分配出去之前要计算分配之后系统是否安全。这里将死锁检测和死锁解除归为一种方法，有些资料上将这两种方法分开作为不同的解决死锁的策略，但也是有4种方法，不过是直接忽略了鸵鸟算法而已。</p>
<h3 id="死锁预防">死锁预防</h3>
<p>根据以上讨论，要想防止死锁的发生，只需破坏死锁产生的4个必要条件之一即可。 下面具体分析与这4个条件相关的技术。</p>
<ul>
<li>互斥条件
<ul>
<li>为了破坏互斥条件，就要允许多个进程同时访问资源。但是这会受到资源本身固有特性的限制，有些资源根本不能同时访问，只能互斥访问，如打印机就不允许多个进程在其运行期间交替打印数据，只能互斥使用。由此看来，通过破坏互斥条件来防止死锁的发生是不大可能的。</li>
</ul>
</li>
<li>不剥夺条件
<ul>
<li>为了破坏不剥夺条件，可以制定这样的策略:对于一个已经获得了某些资源的进程，若新的资源请求不能立即得到满足，则它必须释放所有已经获得的资源，以后需要资源时再重新申请。这就意味着一个进程已获得的资源在运行过程中可以被剥夺，从而破坏了不剥夺条件。该策略实现起来比较复杂，释放已获得资源可能造成前一段 工作的失效，重复申请和释放资源会增加系统开销，降低系统吞吐量。这种方法通常不会用于剥夺资源之后代价较大的场合，比如不会用于对打印机的分配，在一个进程正在打印时，不会采用剥夺的方法来解除死锁。</li>
</ul>
</li>
<li>请求与保持条件
<ul>
<li>为了破坏请求与保持条件，可以采用预先静态分配方法。预先静态分配法要求进程在其运行之前一次性申请所需要的全部资源，在它的资源未满足前，不投入运行。一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。这种方法既简单又安全，但降低了资源利用率，因为采用这种方法必须事先知道该作业(或进程)所需要的全部资源，即使有的资源只能在运行后期使用，甚至有的资源在正常运行中根本不用，也不得不预先统一申请， 结果导致系统资源不能充分利用。以打印机为例，一个作业可能只在最后完成时才需要打印计算结果，但在作业运行前就需要把打印机分配给它，那么在该作业的整个执行过程中打印机基本处于闲置状态。另外其他等待打印机的进程迟迟不能开始运行，导致其他进程产生“饥饿”现象。</li>
</ul>
</li>
<li>环路等待条件
<ul>
<li>为了破坏环路等待条件，可以采用有序资源分配法。有序资源分配法是将系统中的所有资源都按类型赋予一个编号( 例如打印机为1,磁带机为2)，要求每一个进程均严格按照编号递增的次序请求资源，同类资源一次申请完。 也就是说，只要进程提出请求资源R，则在以后的请求中只能请求排在R;后面的资源(i为资源编号),不能再请求编号排在R;前面的资源。对资源请求做了这种限制后，系统中不会再出现几个进程对资源的请求形成环路的情况。这种方法由于对各种资源编号后不宜修改，从而限制了新设备的增加;不同作业对资源使用的顺序也不会完全相同，即便系统对资源编号考虑到多数情况，但总会有与系统编号不符的作业，从而造成资源浪费;对资源按序使用也会增加程序编写的复杂性。</li>
</ul>
</li>
</ul>
<h3 id="死锁避免系统安全状态银行家算法">死锁避免：系统安全状态、银行家算法。</h3>
<p>预防死锁方法中所采用的几种策略，总的来说都施加了较强的限制条件，虽然实现起来较为简单，却严重损害了系统性能。在避免死锁的办法中，所施加的限制条件较弱，有可能获得较好的系统性能。在该方法中把系统的状态分为安全状态和不安全状态，只要能使系统始终处于安全状态，便可以避免死锁的发生。</p>
<ul>
<li>安全状态与不安全状态
<ul>
<li>在避免死锁的方法中，允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。若此次分配不会导致系统进入不安全状态，便将资源分配给进程，否则进程必须等待。</li>
<li>若在某一时刻，系统能按某种顺序来为每个进程分配其所需的资源，直至最大需求，使每个进程都可顺利完成，则称此时的系统状态为安全状态，称该序列为安全序列。若某一时刻系统中不存在这样的一个安全序列，则称此时的系统状态为不安全状态。需要注意的是, 安全序列在某一时刻可能并不唯一， 即可以同时存在多种安全序列。</li>
<li>虽然并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态;反之，只要系统处于安全状态，便可避免进入死锁状态。</li>
<li>注:以下两点是常犯的混淆性错误
<ul>
<li>不安全状态不是指系统中已经产生死锁。不安全状态是指系统可能发生死锁的状态，并不意味着系统已经发生死锁。</li>
<li>处于不安全状态的系统不会必然导致死锁。对系统进行安全性检测是根据进程的最大资源需求而定的，而实际运行过程中进程可能不需要那么多的资源，所以即使系统进入了不安全状态也不一定会导致死锁。而且实际系统运行过程中，有些占有资源但并没有执行完的进程可能主动放弃资源，这也会使得处于不安全状态的系统不产生死锁。死锁是不安全状态的真子集。</li>
</ul>
</li>
</ul>
</li>
<li>银行家算法
<ul>
<li>具有代表性的避免死锁算法是Djkstra给出的银行家算法。为实现银行家算法，系统中必须设置若千数据结构。假定系统中有n个进程(P1, P2，. Pn)、m类资源(R1, Rz, &hellip;Rm)，银行家算法中使用的数据结构如下:</li>
<li>可利用资源向量 Available。这是一个含有 m个元素的数组,其中Available[i]的值表示第i类资源的现有空闲数量，其初始值为系统中所配置的该类资源的数目，其数值随着该类资源的分配和回收而动态改变。</li>
<li>最大需求矩阵 Max。这是一个nxm的矩阵，它定义了系统中每一个进程对m类资源的最大需求数。Mx[)]i]的值 表示第i个进程对第j类资源的最大需求数。</li>
<li>分配矩阵 Allocation。这也是一个nxm的矩阵，它定义了系统中每一类资源当前已经分配给每一个 进程的资源数目。Allocation[i][]的值表示第i个进程当前拥有的第j类资源的数量。</li>
<li>需求矩阵Need。这同样是一个 nxm的矩阵，它定义了系统中每个进程还需要的各类资源数目(注意: 是“还需要”，不是“总需要”，这表示此矩阵也是变化的)。Need[i][]的值表示第i个进程还需要的第j类资源的数量。向量Need;是矩阵Need的第i行，是进程i的需求资源向量。</li>
<li>上述的nxm的“矩阵三兄弟”具有如下关系:Need[i][j]=Max[i]li]-Allocation[i]Di]银行家算法的描述如下:</li>
<li>定义Request;向量: Request 表示第i个进程向系统提出一次申请， 申请的各类资源的数量就是该向量的各个分量。当进程P;向系统发出资源请求后，系统进行如下操作:
<ul>
<li>1)若Request:≤Need;, 则跳至2)。否则报错，因为进程P;申请的资源数不应该超过它的需求数。</li>
<li>2)若Request:≤Available;,则跳至3)，否则P:进程需要等待，因为可用资源不够。</li>
<li>3)对P:进程所请求的资源进行预分配，修改以下向量:</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Available=Available-Request;
Allocation:=Allocation;+Request;
Need=Need;-Request;
</code></pre></td></tr></table>
</div>
</div><ul>
<li>4)对于修改后的向量调用安全性算法。若安全性算法返回系统处于安全状态，则按Request:表示的资源数量给P; 进程分配资源;若安全性算法返回系统处于不安全状态，则不分配给P:进程任何资源，让P:等待，并恢复3)中所改变的向量。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁检测和解除">死锁检测和解除</h3>
<p>暂略</p>
<h3 id="死锁与饿死">死锁与饿死</h3>
<p>死锁、饥饿、饿死通常是容易混淆的概念，这里特别说明一下。</p>
<p>在一个动态系统中，资源请求与释放是经常发生的进程行为。对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。资源分配策略可能是公平的，即能保证请求者在有限的时间内获得所需资源;资源分配策略也可能是不公平的，即不能保证等待时间上界的存在。在后一种情况下， 即使系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推进和响应带来明显影响时，则称此时发生了进程饥饿，当饥饿到一定程度， 进程所赋予的任务即使完成也不再具有实际意义时，称该进程被饿死。</p>
<p>考虑一台打印机分配的例子，当有多个进程需要打印文件时，系统按照短作业优先(SJF)的策略排序，该策略具有平均等待时间短的优点，似乎非常合理，但当短文件打印任务源源不断出现时，长文件的打印任务将被无限期推迟，导致饥饿以至饿死。</p>
<p>与饥饿相关的另外一个概念是活锁。在忙时等待条件下发生的饥饿，称为活锁，例如不公平的互斥算法。虽然此时进程仍然在执行，但有些进程由于无法调度执行，好像发生了死锁一样。</p>
<p>饿死与死锁有一定联系:二者都是由于竞争资源而引起的，但又有明显差别，主要表现在如下几个方面。</p>
<ul>
<li>从进程状态考虑， 死锁进程都处于等待状态;忙时等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死。</li>
<li>死锁进程等待的是永远不会被释放的资源;而饿死进程等待的是会被释放但却不会分配给自己的资源，表现为等待时间没有上界(排队等待或忙时等待)。</li>
<li>死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死。</li>
<li>死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。</li>
</ul>
<p>饥饿和饿死与资源分配策略有关，因而可从公平性方面考虑防止饥饿与饿死，以确保所有进程不被忽视，如多级反馈队列调度算法。</p>
<h2 id="习题">习题</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195525.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195525.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195525.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195525.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195525.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195525.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195548.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195548.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195548.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195548.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195548.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214195548.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200017.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200017.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200017.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200017.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200017.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200017.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200232.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200232.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200232.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200232.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200232.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200232.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200316.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200316.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200316.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200316.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200316.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200316.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200422.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200422.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200422.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200422.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200422.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200422.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200445.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200445.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200445.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200445.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200445.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200445.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200607.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200607.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200607.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200607.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200607.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214200607.png" /></p>
<p>多级反馈队列算法</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201025.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201025.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201025.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201025.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201025.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201025.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201156.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201156.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201156.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201156.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201156.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201156.png" /></p>
<p>管程：针对信号量机制中存在的某些问题，Dijkstra于1971年提出为每个共享资源设立一个“秘书”来管理对它的访问。一切来访者都要通过“秘书”，而“秘书”每次仅允许一个来访者(进程)访问共享资源。这样既便于系统管理共享资源，又能保证互斥访问和进程间同步。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201508.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201508.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201508.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201508.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201508.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201508.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201535.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201535.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201535.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201535.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201535.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201535.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201626.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201626.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201626.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201626.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201626.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214201626.png" />
进程调度是宏观的，以完整进程为单位。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202229.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202229.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202229.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202229.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202229.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202229.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202612.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202612.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202612.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202612.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202612.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202612.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202707.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202707.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202707.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202707.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202707.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214202707.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203128.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203128.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203128.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203128.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203128.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203128.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203212.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203212.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203212.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203212.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203212.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203212.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203952.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203952.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203952.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203952.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203952.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214203952.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214204027.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214204027.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214204027.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214204027.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214204027.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214204027.png" /></p>
<p>读写者问题：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205858.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205858.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205858.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205858.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205858.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205858.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205917.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205917.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205917.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205917.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205917.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205917.png" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205935.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205935.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205935.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205935.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205935.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214205935.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214210853.png"
        data-srcset="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214210853.png, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214210853.png 1.5x, https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214210853.png 2x"
        data-sizes="auto"
        alt="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214210853.png"
        title="https://raw.githubusercontent.com/QizhengZou/Image_hosting_rep/main/20211214210853.png" /></p>
<h2 id="答案">答案</h2>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-11-22 00:00:00</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://qizhengzou.github.io/operatingsystem_base_02/" data-title="OperatingSystem_base_02" data-hashtags="operating system"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://qizhengzou.github.io/operatingsystem_base_02/" data-hashtag="operating system"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://qizhengzou.github.io/operatingsystem_base_02/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://qizhengzou.github.io/operatingsystem_base_02/" data-title="OperatingSystem_base_02"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://qizhengzou.github.io/operatingsystem_base_02/" data-title="OperatingSystem_base_02"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://qizhengzou.github.io/operatingsystem_base_02/" data-title="OperatingSystem_base_02"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/operating-system/">operating system</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/operatingsystem_base_01/" class="prev" rel="prev" title="OperatingSystem_base_01"><i class="fas fa-angle-left fa-fw"></i>OperatingSystem_base_01</a>
            <a href="/operatingsystem_base_03/" class="next" rel="next" title="OperatingSystem_base_03">OperatingSystem_base_03<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
