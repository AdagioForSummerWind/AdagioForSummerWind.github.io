<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>K8s_base - Jefo</title><meta name="Description" content="Jefo"><meta property="og:title" content="K8s_base" />
<meta property="og:description" content="k8s入门实战 开篇词｜迎难而上，做云原生时代的弄潮儿 你好，我是罗剑锋，不过更愿意你称呼我“Chrono”。先来简单介绍一下我自己吧。作为一个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://qizhengzou.github.io/k8s_base/" /><meta property="og:image" content="https://qizhengzou.github.io/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-14T10:38:08+08:00" />
<meta property="article:modified_time" content="2022-07-14T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://qizhengzou.github.io/logo.png"/>

<meta name="twitter:title" content="K8s_base"/>
<meta name="twitter:description" content="k8s入门实战 开篇词｜迎难而上，做云原生时代的弄潮儿 你好，我是罗剑锋，不过更愿意你称呼我“Chrono”。先来简单介绍一下我自己吧。作为一个"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://qizhengzou.github.io/k8s_base/" /><link rel="prev" href="https://qizhengzou.github.io/middleware/" /><link rel="next" href="https://qizhengzou.github.io/k8s_advanced/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "K8s_base",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/qizhengzou.github.io\/k8s_base\/"
        },"image": ["https:\/\/qizhengzou.github.io\/images\/Apple-Devices-Preview.png"],"genre": "posts","keywords": "k8s","wordcount":  63067 ,
        "url": "https:\/\/qizhengzou.github.io\/k8s_base\/","datePublished": "2022-07-14T10:38:08+08:00","dateModified": "2022-07-14T00:00:00+00:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "Jefo","logo": "https:\/\/qizhengzou.github.io\/images\/avatar.png"},"author": {
                "@type": "Person",
                "name": "Jefo"
            },"description": ""
    }
    </script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-193031966-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-193031966-2');
</script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Jefo"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Jefo</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> All posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><a class="menu-item" href="/about/"> About </a><a class="menu-item" href="https://github.com/qizhengzou" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Jefo"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>Jefo</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="直接搜索更方便^-^" id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">All posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a class="menu-item" href="/about/" title="">About</a><a class="menu-item" href="https://github.com/qizhengzou" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">K8s_base</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Jefo</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/k8s/"><i class="far fa-folder fa-fw"></i>k8s</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2022-07-14 10:38:08">2022-07-14 10:38:08</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 63067 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 126 分钟&nbsp;<span id="busuanzi_container_page_pv">
                    <i class="far fa-eye fa-fw"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;次阅读量</span>
                </span>
            </div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#开篇词迎难而上做云原生时代的弄潮儿">开篇词｜迎难而上，做云原生时代的弄潮儿</a>
      <ul>
        <li><a href="#现在的-kubernetes">现在的 Kubernetes</a></li>
        <li><a href="#学习-kubernetes-有哪些难点">学习 Kubernetes 有哪些难点</a></li>
        <li><a href="#在这个专栏里你会怎么学习-kubernetes">在这个专栏里你会怎么学习 Kubernetes</a></li>
        <li><a href="#专栏的线性结构是什么样的">专栏的线性结构是什么样的</a></li>
      </ul>
    </li>
    <li><a href="#课前准备动手实践才是最好的学习方式">课前准备｜动手实践才是最好的学习方式</a>
      <ul>
        <li><a href="#选择什么样的实验环境">选择什么样的实验环境</a></li>
        <li><a href="#选择什么样的虚拟机软件">选择什么样的虚拟机软件</a></li>
        <li><a href="#选择哪种-linux-发行版">选择哪种 Linux 发行版</a></li>
        <li><a href="#如何配置虚拟机">如何配置虚拟机</a></li>
        <li><a href="#如何安装虚拟机">如何安装虚拟机</a></li>
        <li><a href="#有哪些常用的-linux-操作">有哪些常用的 Linux 操作</a></li>
        <li><a href="#小结">小结</a></li>
      </ul>
    </li>
    <li><a href="#入门">入门</a></li>
    <li><a href="#01初识容器">01｜初识容器</a>
      <ul>
        <li><a href="#docker-的诞生">Docker 的诞生</a></li>
        <li><a href="#docker-的形态">Docker 的形态</a></li>
        <li><a href="#docker-的安装">Docker 的安装</a></li>
        <li><a href="#docker-的使用">Docker 的使用</a></li>
        <li><a href="#docker-的架构">Docker 的架构</a></li>
        <li><a href="#小结-1">小结</a></li>
      </ul>
    </li>
    <li><a href="#02被隔离的进程一起来看看容器的本质">02｜被隔离的进程：一起来看看容器的本质</a>
      <ul>
        <li><a href="#容器到底是什么">容器到底是什么</a></li>
        <li><a href="#为什么要隔离">为什么要隔离</a></li>
        <li><a href="#与虚拟机的区别是什么">与虚拟机的区别是什么</a></li>
        <li><a href="#隔离是怎么实现的">隔离是怎么实现的</a></li>
        <li><a href="#小结-2">小结</a></li>
      </ul>
    </li>
    <li><a href="#03容器化的应用会了这些你就是docker高手">03｜容器化的应用：会了这些你就是Docker高手</a>
      <ul>
        <li><a href="#什么是容器化的应用">什么是容器化的应用</a></li>
        <li><a href="#常用的镜像操作有哪些">常用的镜像操作有哪些</a></li>
        <li><a href="#常用的容器操作">常用的容器操作</a></li>
        <li><a href="#小结-3">小结</a></li>
      </ul>
    </li>
    <li><a href="#04创建容器镜像如何编写正确高效的dockerfile">04｜创建容器镜像：如何编写正确、高效的Dockerfile</a>
      <ul>
        <li><a href="#镜像的内部机制是什么">镜像的内部机制是什么</a></li>
        <li><a href="#dockerfile-是什么">Dockerfile 是什么</a></li>
        <li><a href="#怎样编写正确高效的-dockerfile">怎样编写正确、高效的 Dockerfile</a></li>
        <li><a href="#docker-build-是怎么工作的">docker build 是怎么工作的</a></li>
        <li><a href="#小结-4">小结</a></li>
      </ul>
    </li>
    <li><a href="#05镜像仓库该怎样用好docker-hub这个宝藏">05｜镜像仓库：该怎样用好Docker Hub这个宝藏</a>
      <ul>
        <li><a href="#什么是镜像仓库registry">什么是镜像仓库（Registry）</a></li>
        <li><a href="#什么是-docker-hub">什么是 Docker Hub</a></li>
        <li><a href="#如何在-docker-hub-上挑选镜像">如何在 Docker Hub 上挑选镜像</a></li>
        <li><a href="#docker-hub-上镜像命名的规则是什么">Docker Hub 上镜像命名的规则是什么</a></li>
        <li><a href="#该怎么上传自己的镜像">该怎么上传自己的镜像</a></li>
        <li><a href="#离线环境该怎么办">离线环境该怎么办</a></li>
        <li><a href="#小结-5">小结</a></li>
      </ul>
    </li>
    <li><a href="#06打破次元壁容器该如何与外界互联互通">06｜打破次元壁：容器该如何与外界互联互通</a>
      <ul>
        <li><a href="#如何拷贝容器内的数据">如何拷贝容器内的数据</a></li>
        <li><a href="#如何共享主机上的文件">如何共享主机上的文件</a></li>
        <li><a href="#如何实现网络互通">如何实现网络互通</a></li>
        <li><a href="#如何分配服务端口号">如何分配服务端口号</a></li>
        <li><a href="#小结-6">小结</a></li>
      </ul>
    </li>
    <li><a href="#07实战演练玩转docker">07｜实战演练：玩转Docker</a>
      <ul>
        <li><a href="#容器技术要点回顾">容器技术要点回顾</a></li>
        <li><a href="#搭建私有镜像仓库">搭建私有镜像仓库</a></li>
        <li><a href="#搭建-wordpress-网站">搭建 WordPress 网站</a></li>
        <li><a href="#小结-7">小结</a></li>
      </ul>
    </li>
    <li><a href="#初级">初级</a></li>
    <li><a href="#09走近云原生如何在本机搭建小巧完备的kubernetes环境">09｜走近云原生：如何在本机搭建小巧完备的Kubernetes环境</a>
      <ul>
        <li><a href="#什么是容器编排">什么是容器编排</a></li>
        <li><a href="#什么是-kubernetes">什么是 Kubernetes</a>
          <ul>
            <li><a href="#什么是-minikube">什么是 minikube</a></li>
          </ul>
        </li>
        <li><a href="#如何搭建-minikube-环境">如何搭建 minikube 环境</a></li>
        <li><a href="#实际验证-minikube-环境">实际验证 minikube 环境</a></li>
        <li><a href="#小结-8">小结</a></li>
      </ul>
    </li>
    <li><a href="#10自动化的运维管理探究kubernetes工作机制的奥秘">10｜自动化的运维管理：探究Kubernetes工作机制的奥秘</a>
      <ul>
        <li><a href="#云计算时代的操作系统">云计算时代的操作系统</a></li>
        <li><a href="#kubernetes-的基本架构">Kubernetes 的基本架构</a></li>
        <li><a href="#节点内部的结构">节点内部的结构</a></li>
        <li><a href="#master-里的组件有哪些">Master 里的组件有哪些</a></li>
        <li><a href="#node-里的组件有哪些">Node 里的组件有哪些</a></li>
        <li><a href="#插件addons有哪些">插件（Addons）有哪些</a></li>
        <li><a href="#小结-9">小结</a></li>
      </ul>
    </li>
    <li><a href="#加餐kubernetes弃用docker是怎么回事">加餐｜Kubernetes“弃用Docker”是怎么回事？</a>
      <ul>
        <li><a href="#什么是-cri">什么是 CRI</a></li>
        <li><a href="#什么是-containerd">什么是 containerd</a></li>
        <li><a href="#正式弃用-docker">正式“弃用 Docker”</a></li>
        <li><a href="#docker-的未来">Docker 的未来</a></li>
      </ul>
    </li>
    <li><a href="#11yamlkubernetes世界里的通用语">11｜YAML：Kubernetes世界里的通用语</a>
      <ul>
        <li><a href="#声明式与命令式是怎么回事">声明式与命令式是怎么回事</a></li>
        <li><a href="#什么是-yaml">什么是 YAML</a></li>
        <li><a href="#什么是-api-对象">什么是 API 对象</a></li>
        <li><a href="#如何描述-api-对象">如何描述 API 对象</a></li>
        <li><a href="#如何编写-yaml">如何编写 YAML</a></li>
        <li><a href="#小结-10">小结</a></li>
      </ul>
    </li>
    <li><a href="#12pod如何理解这个kubernetes里最核心的概念">12｜Pod：如何理解这个Kubernetes里最核心的概念？</a>
      <ul>
        <li><a href="#为什么要有-pod">为什么要有 Pod</a></li>
        <li><a href="#为什么-pod-是-kubernetes-的核心对象">为什么 Pod 是 Kubernetes 的核心对象</a></li>
        <li><a href="#如何使用-yaml-描述-pod">如何使用 YAML 描述 Pod</a></li>
        <li><a href="#如何使用-kubectl-操作-pod">如何使用 kubectl 操作 Pod</a></li>
        <li><a href="#小结-11">小结</a></li>
      </ul>
    </li>
    <li><a href="#13jobcronjob为什么不直接用pod来处理业务">13｜Job/CronJob：为什么不直接用Pod来处理业务？</a>
      <ul>
        <li><a href="#为什么不直接使用-pod">为什么不直接使用 Pod</a></li>
        <li><a href="#为什么要有-jobcronjob">为什么要有 Job/CronJob</a></li>
        <li><a href="#如何使用-yaml-描述-job">如何使用 YAML 描述 Job</a></li>
        <li><a href="#如何在-kubernetes-里操作-job">如何在 Kubernetes 里操作 Job</a></li>
        <li><a href="#如何使用-yaml-描述-cronjob">如何使用 YAML 描述 CronJob</a></li>
        <li><a href="#小结-12">小结</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="k8s入门实战">k8s入门实战</h1>
<h2 id="开篇词迎难而上做云原生时代的弄潮儿">开篇词｜迎难而上，做云原生时代的弄潮儿</h2>
<p>你好，我是罗剑锋，不过更愿意你称呼我“Chrono”。先来简单介绍一下我自己吧。作为一个有着近二十年工作经验的“技术老兵”，我一直奋斗在开发第一线，从 Windows 到 Linux、从硬件到软件，从单机到集群、云，开发了各种形式的应用，也经历了许多大小不一的公司，现在是在 API 管理和微服务平台公司 Kong，基于 Nginx/OpenResty 研发 Kong Gateway、Kong ingress Controller 等产品。其实我应该算是极客时间的老朋友了，在 2019 年开了《透视 HTTP 协议》的课程，在 2020 年开了《C++ 实战笔记》的课程，然后因为工作上的事情比较多，“消失”了近两年的时间。不过这段日子里我倒没有“两耳不闻窗外事”，而是一直在关注业界的新技术新动向，所以今天，我再次回到了极客时间的这个大讲堂，想和你聊聊如今风头正劲的 Kubernetes。</p>
<h3 id="现在的-kubernetes">现在的 Kubernetes</h3>
<p>你一定听说过 Kubernetes 吧，也许更熟悉一点的，是许多人总挂在嘴边的缩写——“K8s”。自从 2013 年 Docker 诞生以来，容器一跃成为了 IT 界最热门的话题。而 Kubernetes 则趁着容器的“东风”，借助 Google 和 CNCF 的强力“背书”，击败了 Docker Swarm 和 Apache Mesos，成为了“容器编排”领域的王者至尊。</p>
<p>换一个更通俗易懂的说法，那就是：现在 Kubernetes 已经没有了实际意义上的竞争对手，它的地位就如同 Linux 一样，成为了事实上的云原生操作系统，是构建现代应用的基石。毕竟，现代应用是什么？是微服务，是服务网格，这些统统要围绕着容器来开发、部署和运行，而使用容器就必然要用到容器编排技术，在现在只有唯一的选项，那就是 Kubernetes。不管你是研发、测试、还是运维，不管你是前台、后台、还是中台，不管你用的是 C++、Java 还是 Python，不管你是搞数据库、区块链、还是人工智能，不管你是从事网站、电商、还是音视频，在这个“云原生”时代，Kubernetes 都是一个绕不过去的产品，是我们工作中迟早要面对的“坎儿”。</p>
<p>你也许会有疑惑：我现在的工作和“云”毫不沾边，而且 Kubernetes 都“火”了这么久，现在才开始学，会不会有点晚了？值不值呢？这里我就要引用一句老话了：“艺多不压身”，还有另一句：“机遇总是偏爱有准备的人”。“云原生”已经是现在 IT 界的普遍共识，是未来的大势所趋。也许这个“浪潮”暂时还没有打到你这里来，但一旦它真正来临，只有你提前做好了知识储备，才能够迎难而进，站上浪头成为“弄潮儿”，否则就可能会被“拍在沙滩上”。</p>
<p>我和你说一下我自己的亲身经历吧。早在 Docker 和 Kubernetes 发布之初，我就对它们有过关注。不过因为我的主要工作语言是 C/C++，而 Docker 和 Kubernetes 用的都是 Go，当时 Go 的性能还比较差（比如垃圾回收机制导致的著名 Stop the World），所以我只是简单了解了，没有去特别研究。过了几年，一个偶然的机会，我们要在客户的环境里部署自研应用，但依赖库差异太大，很难搞定。这个时候我又想起了 Docker，经过一个多星期的折腾，艰难地啃下了一大堆资料之后，总算是把系统正常上线了。虽然任务完成了，但也让我意识到自己从前对 Docker 的轻视是非常错误的，于是就痛下决心，开始从头、系统地学习整理容器知识，之后也就很自然地搭上了 Kubernetes 这条“大船”。再后来，我想换新工作，面试的时候 Boss 出了道“偏门”题，讲 Kubernetes 的容器和环境安全。虽然我不熟悉这个方向，但凭借着之前的积累，只用了一个晚上就赶出了 20 多页的 PPT，第二天面对几位评委侃侃而谈，最终顺利拿下了 Offer。</p>
<p>你看，如果我当时一味固执己见，只呆在自己的“舒适区”里，不主动去学习容器技术和 Kubernetes，当机遇不期而至的时候，很可能就会因为手足无措而错失了升职加薪的良机。所以也希望你不要犯我当初的错误，我们应当看清楚时代的走向，尽可能超前于时代，越早掌握 Kubernetes，将来自己成功的几率就越大。</p>
<h3 id="学习-kubernetes-有哪些难点">学习 Kubernetes 有哪些难点</h3>
<p>那么，我们应该怎么来学习 Kubernetes 呢？其实今天学习 Kubernetes 的难度，比起前几年来说，已经是极大地下降了，网上资料非常多，有博客、专题、视频等各种形式，而且 Kubernetes 为了推广自身，在官网上还放出了非常详细的教程和参考手册，只要你肯花时间，完全可以“自学成才”。不过，“理想很丰满，现实很骨感”。理论上讲，学习 Kubernetes 只要看资料就足够了，但实际情况却是学习起来仍然困难重重，我们会遇到很多意想不到的问题。</p>
<p>这是因为 Kubernetes 是一个分布式、集群化、云时代的系统，有许多新概念和新思维方式，和我们以往经验、认知的差异很大。我觉得，Kubernetes 技术栈的特点可以用四个字来概括，那就是“新、广、杂、深”。</p>
<p>“新”是指 Kubernetes 用到的基本上都是比较前沿、陌生的技术，而且版本升级很快，经常变来变去。“广”是指 Kubernetes 涉及的应用领域很多、覆盖面非常广，不太好找到合适的切入点或者突破口。“杂”是指 Kubernetes 的各种实现比较杂乱，谁都可以上来“掺和”一下，让人看的眼晕。“深”是指 Kubernetes 面对的每个具体问题和方向，都需要有很深的技术背景和底蕴，想要吃透很不容易。</p>
<p>这四个特点就导致 Kubernetes 的“门槛”相当高，学习曲线非常陡峭，学习成本非常昂贵，有可能花费了大量的时间和精力却南辕北辙、收效甚微，这点我确实是深有体会。比如在初学的过程中我就遇到过这些疑问，不知道你有没有同感：</p>
<p>Docker、Containerd、K8s、K3s、MicroK8s、Minikube……这么多项目，该如何选择？容器的概念太抽象了，怎么才能够快速准确地理解？镜像的命名稀奇古怪，里面的“bionic”“buster”等都是什么意思？不知道怎么搭建出 Kubernetes 环境，空有理论知识，无法联系实际。YAML 文件又长又乱，到哪里能找到说明，能否遵循什么简单规律写出来？Pod、Deployment、StatefulSet……这么多的对象，有没有什么内在的脉络和联系？</p>
<p>遗憾的是，这些问题很难在现有的 Kubernetes 资料里找到答案。我个人感觉，它们往往“站得太高”，没有为“零基础”的初学者考虑，总会预设一些前提，比如熟悉 Linux 系统、知道编程语言、了解网络技术等等，有时候还会因为版本过时而失效，或者是忽略一些关键的细节。这就让我们初学者经常“卡”在一些看似无关紧要却又非常现实的难点上，这样的点越积越多，最后就让人逐渐丧失了学习 Kubernetes 的信心和勇气。所以，我就想以自己的学习经历为基础，融合个人感悟、经验教训和心得技巧，整理出一个初学者面对 Kubernetes 这门新技术的入门路线和系统思路，让你在学习时有捷径可走，不再有迷茫和困惑，能快速高效地迈入 Kubernetes 的宏伟殿堂。</p>
<h3 id="在这个专栏里你会怎么学习-kubernetes">在这个专栏里你会怎么学习 Kubernetes</h3>
<p>讲到这里，你一定很想知道，这个专栏有什么特点，和别的课程有哪些不一样，结合刚才讲的 Kubernetes 技术栈四个特点“技术新、领域广、实现杂、方向深”，我来仔细说一说我的想法和考量。</p>
<p>第一，没有太多前提，不会 Go 你也可以学。在这门课里，我不会要求你学习 Go 语言，也不会去讲 Kubernetes 的源码。虽然是研发出身，但我并没有特别深入地了解 Go 语言，但是，我认为这反而是一个优势。因为面对 Kubernetes 的时候我和你是“平等”的，不会“下意识”地去从源码层次来讲解它的运行原理，更能够设身处地为你着想。</p>
<p>讲源码虽然会很透彻，但它的前置条件实在是太高了，不是所有的人都具备这个基础的。为了学习 Kubernetes 要先了解 Go 语言，有点“本末倒置”，如同钱钟书老先生所说：“如果你吃了个鸡蛋，觉得味道不错，何必去认识那个下蛋的母鸡呢?”（我觉得这方面也可以对比一下 Linux 操作系统，它是用 C 语言写的，但几乎没有人要求我们在学习 Linux 之前需要事先掌握 C 语言。）不过如果你真想做 Kubernetes 开发，等学会了 Kubernetes 的基本概念和用法，再回头去学 Go 语言也完全来得及。</p>
<p>第二，这个专栏我会定位在“入门”，也就是说，不会去讲那些高深的大道理和复杂的工作流程，语言也尽量朴素平实，少用专业术语和缩略词。毕竟 Kubernetes 系统涉及的领域太过庞大，对于初次接触的人来说直接“抠”内部细节不太合适，那样很容易会“跑偏”“钻牛角尖”。<strong>我觉得学习 Kubernetes 最好的方式是尽快建立一个全局观和大局观，等到你对这个陌生领域的全貌有了粗略但完整的认识之后，再挑选一个自己感兴趣的方向去研究，才是性价比最高的做法。</strong></p>
<p>而且前面也说过，Kubernetes 版本更新很快，有的功能点或许一段时间之后就成了废弃的特性（比如 ComponentStatus 在 1.19 被废弃、PodSecurityPolicy 在 1.21 被废弃），如果讲得太细，万一今后它过时无用，就实在是太尴尬了。</p>
<p>第三，课程会以实战为导向，强调眼手脑结合，鼓励你多动手、多实际操作，我认为这是这个课程最大的特点。Kubernetes 一般每年都会发布一个大版本，大版本又会有很多的小版本，每个版本都会持续改进功能特性，但一味求新，不符合当前的实际情况，毕竟生产环境里稳定是最重要的。所以，我就选择了今年（2022 年）初发布的 Kubernetes 1.23.3，它是最后一个支持 Docker 的大版本，承上启下，具有很多的新特性，同时也保留了足够的历史兼容性，非常适合用来学习 Kubernetes。</p>
<p>在课程里，我会先从 Docker 开始，陆续用 minikube、kubeadm 搭建单机和多机的 Kubernetes 集群环境，在讲解概念的同时，还会给出大量的 docker、kubectl 操作命令，让你能够看完课程后立即上手演练，用实际操作来强化学习效果。</p>
<p>第四，具体到每一节课上，我不会“贪大求全”，而是会“短小精悍”，做减法而不是加法，力争每节课只聚焦在一个知识点。</p>
<p>这是因为 Kubernetes 涉及的领域太广了，它的知识结构是网状的，之间的联系很密切，在学习时稍不注意就会跳跃到其他的地方，很容易“发散”“跑题”，导致思维不集中。所以我在讲解的时候会尽量克制，把每节课收束在一个相对独立的范围之内，不会有太多的外延话题，也不会机械地罗列 API、命令参数、属性字段（这些你都可以查阅 Kubernetes 文档），在讲解复杂的知识点时还会配上图片，让你能够精准地理解吸收知识。比如 Pod 等众多 API 对象之间的关系一直是学习 Kubernetes 的难点，单用文字很难解释清楚，所以我画了很多图，帮助你形象地理解它们的联系。就像这张：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/06/9d/0663d692b33c1dee5b08e486d271b69d.jpg?wh=1920x1661"
        data-srcset="https://static001.geekbang.org/resource/image/06/9d/0663d692b33c1dee5b08e486d271b69d.jpg?wh=1920x1661, https://static001.geekbang.org/resource/image/06/9d/0663d692b33c1dee5b08e486d271b69d.jpg?wh=1920x1661 1.5x, https://static001.geekbang.org/resource/image/06/9d/0663d692b33c1dee5b08e486d271b69d.jpg?wh=1920x1661 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/06/9d/0663d692b33c1dee5b08e486d271b69d.jpg?wh=1920x1661"
        title="img" /></p>
<p>因为每一讲都聚焦在一个知识点上，专栏的整个结构，我也梳理出了一条独特路线：把 Kubernetes 的知识点由网状结构简化成了线性结构，你可以在这条路线上循序渐进，由浅入深、由易到难地学习完整的 Kubernetes 知识体系。</p>
<h3 id="专栏的线性结构是什么样的">专栏的线性结构是什么样的</h3>
<p>从这些设想出发，我把专栏主要划分成了五个模块。</p>
<p>课前准备 在正式学习前首先有一节课前准备，这也是我写专栏的惯例了，会跟你说一下我们学习的实验环境，用虚拟机软件搭建出一个 Linux 系统，为零基础的同学扫除一些非常简单但是其他地方可能没有讲到的后顾之忧。</p>
<p>入门篇 我会用最流行的 Docker 来讲解 Kubernetes 的基础技术：容器，让你了解它的基本原理，熟悉常用的 Docker 命令，能够轻松地拉取、构建镜像，运行容器，能够使用容器在本机搭建开发测试环境。初级篇在具备了容器的知识之后，我们就可以来学习 Kubernetes 了，用的是单机环境 minikube。你会了解为什么容器会发展到容器编排，Kubernetes 解决了什么问题，它的基本架构是什么样子的，再学习 YAML 语言、核心对象 Pod，还有离线业务对象 Job/CronJob、配置信息对象 ConfigMap/Secret。</p>
<p>中级篇 我们会在“初级篇”的基础上更进一步，使用 kubeadm 搭建出一个多节点的集群，模拟真实的生产环境，并介绍 Kubernetes 里的 4 个重要概念：Deployment、DaemonSet、Service、Ingress。学习了这些对象，你就能够明白 Kubernetes 的优点、特点是什么，知道为什么它能够一统天下，成为云原生时代的操作系统。</p>
<p>高级篇 经过前面几个模块的学习，你就已经对 Kubernetes 有了比较全面的认识了，所以我会再讲解一些深层次知识点和高级应用技巧，包括持久化存储、有状态的对象、应用的滚动更新和自动伸缩、容器和节点的管理等等。</p>
<p>当然，这种纯线性学习也难免会有缺点，我也会用其他的形式来补充完善，让你的学习过程更丰富多样，比如每一讲后面的知识小贴士、互动答疑。在专栏的中后期，我还会为你准备一些“加餐”，讲讲 Kubernetes 相关的一些“花边逸闻”，比如 docker-compose、CNCF、API Gateway 等等，扩展一些虽然是外围但也很有实际意义的知识。前面说过要多动手实践，为了强化实战效果，每个模块的知识点学完后，我都会安排一节实战演练课和一节视频课：</p>
<p>实战课，我们会应用模块中学习的知识，来实战搭建 WordPress 网站，你可以跟着课程一路走下来，看着它如何从单机应用演变到集群里的高可用系统的。视频课，我会把这个模块里大部分重要的知识点都实机操作演示给你看，相信通过“文字 + 图片 + 音频 + 视频”的多种形式，你的学习一定会非常充实而满足。你的 Kubernetes 之旅马上就要开始了，我再送你一张课程的知识地图，希望你能够在今后的三个月里以它为伴，用努力与坚持去浇灌学习之花，收获丰硕的知识和喜悦之果！</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/0b/74/0b1cfcd69fa5fd1f9a0b9dc4c5d92d74.jpg?wh=3000x3803"
        data-srcset="https://static001.geekbang.org/resource/image/0b/74/0b1cfcd69fa5fd1f9a0b9dc4c5d92d74.jpg?wh=3000x3803, https://static001.geekbang.org/resource/image/0b/74/0b1cfcd69fa5fd1f9a0b9dc4c5d92d74.jpg?wh=3000x3803 1.5x, https://static001.geekbang.org/resource/image/0b/74/0b1cfcd69fa5fd1f9a0b9dc4c5d92d74.jpg?wh=3000x3803 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/0b/74/0b1cfcd69fa5fd1f9a0b9dc4c5d92d74.jpg?wh=3000x3803"
        title="img" /></p>
<h2 id="课前准备动手实践才是最好的学习方式">课前准备｜动手实践才是最好的学习方式</h2>
<p>如果你看过我的另外两个极客时间专栏（《透视 HTTP 协议》和《C++ 实战笔记》）就会知道，我一直都很强调实验环境的重要程度，毕竟计算机这门学科的实践性要大于理论性，而且有一个能够上手操作的实际环境，对学习理论也非常有帮助。落到我们的这个 Kubernetes 学习课上，实验环境更是必不可少的，因为和网络协议、编程语言不同，Kubernetes 是一个更贴近于生产环境的庞大系统，如果“光说不练”，即使你掌握了再多的知识，但不能和实际相结合，也只能是“纸上谈兵”。俗话说：“工欲善其事，必先利其器”，所以在正式学习之前，我们必须要有一个基本的实验环境，要能够在环境中熟悉 Kubernetes 的操作命令、验证测试 Kubernetes 的各种特性，有这样的“帮手”作为辅助，我们的学习才能够事半功倍。</p>
<h3 id="选择什么样的实验环境">选择什么样的实验环境</h3>
<p>但想要得到一个完整的 Kubernetes 环境不那么容易，因为它太复杂了，对软硬件的要求都比较高，安装部署过程中还有许多的小细节，这些都会成为学习过程中的“拦路虎”。那么，应该怎么搭建出符合我们要求的实验环境呢？你也许会说：现在的云厂商到处都是，去网上申请一个就好了。这也许是一个比较便捷的获取途径，不过我有一些不同的意见。首先，这些网上的“云主机”很少是免费的，都需要花钱，而且想要好配置还要花更多的钱，对于我们的学习来说性价比不高。其次，“云主机”都是在“云”上，免不了会受网络和厂商的限制，存在不稳定因素。再次，这些“云主机”都是厂商已经为我们配好了的，很多软硬件都是固定的，不能随意定制，特别是很难真正“从零搭建”。</p>
<p>考虑上面的这三点，我建议还是在本地搭建实验环境最好，不会受制于人，完全自主可控。不过，Kubernetes 通常都运行在集群环境下，由多台服务器组成，难道我们还要自己置办几台电脑来组网吗？这倒大可不必。因为现在的虚拟机软件已经非常成熟可靠了，能够在一台电脑里虚拟出多台主机，这些虚拟主机用起来和真实的物理主机几乎没有什么差异，只要你的电脑配置不是太差，组成一个三四台虚拟服务器的小集群是毫无问题的，而且虚拟机的创建删除都非常简单，成本极低。使用虚拟机软件还有一点额外的好处，由于很多云服务商内部也在大量使用虚拟服务器，Kubernetes 里的容器技术也与虚拟机有很多相似之处，通过使用虚拟机，我们还能顺便对比这些技术的异同点，加深对 Kubernetes 的理解。</p>
<p>所以综合来看，我建议你挑选一台配置不算太差的笔记本或者台式机，在里面使用虚拟机来搭建我们这门课程的实验环境。作为宿主机电脑的 CPU 和硬盘的要求不高，4 核、300G 就可以了，关键是内存要足够大，因为虚拟机和 Kubernetes 都很能“吃”内存，最少要有 8G，这样起码能够支持开两个虚拟机组成最小的集群。</p>
<h3 id="选择什么样的虚拟机软件">选择什么样的虚拟机软件</h3>
<p>确定了我们的实验环境大方向——虚拟机之后，我们就要选择虚拟机软件了。目前市面上的主流虚拟机软件屈指可数，所以选择起来并不算困难，我个人推荐的有两个：VirtualBox 和 VMWare Fusion。</p>
<p>我们先讲适用面广的 VirtualBox。VirtualBox 是 Oracle 推出的一款虚拟机软件，历史很悠久，一直坚持免费政策，使用条款上也没有什么限制，是一个难得的精品软件。VirtualBox 支持 Windows 和 macOS，但有一个小缺点，它只能运行在 Intel（x86_64）芯片上，不支持 Apple 新出的 M1（arm64/aarch64）芯片，这导致它无法在新款 Mac 上使用，不得不说是一大遗憾。所以，如果你手里是 Apple M1 Mac，就只能选择其他的虚拟机软件了。在 macOS 上，虚拟机最出名的应该是 Parallel Desktop 和 VMWare Fusion 这两个了，都需要付费。这里我比较推荐 VMWare Fusion。不过对于 VMWare Fusion 来说，它对 M1 的支持进展比较迟缓，所以在正式的付费版出来之前，公布了一个“技术预览版”，是完全免费的，而且功能、性能也比较好，虽然有使用时间的限制（大约 300 天），但对于我们的学习来说是足够了。这里我给出 VirtualBox（https://www.virtualbox.org/wiki/Downloads）和 VMWare Fusion（https://communities.vmware.com/t5/Fusion-for-Apple-Silicon-Tech/ct-p/3022）的网址，你可以课后去看一下，尽快下载。</p>
<h3 id="选择哪种-linux-发行版">选择哪种 Linux 发行版</h3>
<p>有了虚拟机软件之后，我们就要在上面安装操作系统，在这方面毫无疑问只能是 Linux，因为 Kubernetes 只能运行在 Linux 之上。不过麻烦的是，Linux 世界又分裂成很多不同的发行版，流行的有 CentOS/Fedora、 Ubuntu/Debian、SUSE 等等，没有一个占据绝对统治地位的系统。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/70/06/701a9e9a7757be4198f0e9d5a7175406.jpg?wh=662x628"
        data-srcset="https://static001.geekbang.org/resource/image/70/06/701a9e9a7757be4198f0e9d5a7175406.jpg?wh=662x628, https://static001.geekbang.org/resource/image/70/06/701a9e9a7757be4198f0e9d5a7175406.jpg?wh=662x628 1.5x, https://static001.geekbang.org/resource/image/70/06/701a9e9a7757be4198f0e9d5a7175406.jpg?wh=662x628 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/70/06/701a9e9a7757be4198f0e9d5a7175406.jpg?wh=662x628"
        title="img" /></p>
<p>那选哪个比较好呢？我们的主要目的是学习，所以易用性应该是首要关注点，另外系统还应该能够同时支持 x86_64 和 arm64。筛选下来我建议选择 Ubuntu 22.04 Jammy Jellyfish 桌面版（https://ubuntu.com/download/desktop），它有足够新的特性，非常适合运行 Kubernetes，而内置的浏览器、终端等工具也很方便我们的调试和测试。但对 Apple M1 用户来说，有一个不太好的消息，Ubuntu 22.04 在内核由 5.13 升级到 5.15 的时候引入了一个小 Bug，导致 VMWare Fusion 无法正常安装启动，这个问题直到 4 月份的正式版发布还没有解决。好在我当初为了测试，下载了一个较早的“daily build”版本，它可以在 VMWare Fusion 里正常安装，我把它上传到了云盘（https://www.aliyundrive.com/s/zzKcAQwQjR9），你可以下载后使用。需要注意一点，由于网站的限制，文件的后缀名被改成了 .mov ，你必须去掉这个后缀，还原成原始的 .iso 才能使用。</p>
<h3 id="如何配置虚拟机">如何配置虚拟机</h3>
<p>准备好虚拟机软件和 Ubuntu 光盘镜像之后，我们就可以来安装虚拟机了。不过在安装之前，我们必须要把虚拟机适当地配置一下。因为 Kubernetes 不是一般的应用软件，而是一个复杂的系统软件，对硬件资源的要求有一点高，好在并不太高，2 核 CPU、2G 内存是最低要求，如果条件允许，我建议把内存增大到 4G，硬盘 40G 以上，这样运行起来会更流畅一些。另外，一些对于服务器来说不必要的设备也可以禁用或者删除，比如声卡、摄像头、软驱等等，可以节约一点系统资源。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/3a/1d/3a6a52f38yy431abf4a0625e2532b01d.png?wh=1504x920"
        data-srcset="https://static001.geekbang.org/resource/image/3a/1d/3a6a52f38yy431abf4a0625e2532b01d.png?wh=1504x920, https://static001.geekbang.org/resource/image/3a/1d/3a6a52f38yy431abf4a0625e2532b01d.png?wh=1504x920 1.5x, https://static001.geekbang.org/resource/image/3a/1d/3a6a52f38yy431abf4a0625e2532b01d.png?wh=1504x920 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/3a/1d/3a6a52f38yy431abf4a0625e2532b01d.png?wh=1504x920"
        title="img" /></p>
<p>由于 Linux 服务器大多数要以终端登录的方式使用，多台服务器还要联网，所以在网络方面我们还需要特别设置。前面说虚拟机软件首选 VirtualBox，Apple M1 Mac 备选 VMWare Fusion 技术预览版，这里我也分别说下两个软件的不同设置。对于 VirtualBox，首先，你需要在“工具 - 网络”里创建一个“Host-only”的网络，IP 地址段随意，比如这里就使用了它自动分配的“192.168.56.1/24”：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/aa/f1/aacc45aayyc2e2b9dc870c8c233e53f1.png?wh=1764x1368"
        data-srcset="https://static001.geekbang.org/resource/image/aa/f1/aacc45aayyc2e2b9dc870c8c233e53f1.png?wh=1764x1368, https://static001.geekbang.org/resource/image/aa/f1/aacc45aayyc2e2b9dc870c8c233e53f1.png?wh=1764x1368 1.5x, https://static001.geekbang.org/resource/image/aa/f1/aacc45aayyc2e2b9dc870c8c233e53f1.png?wh=1764x1368 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/aa/f1/aacc45aayyc2e2b9dc870c8c233e53f1.png?wh=1764x1368"
        title="img" /></p>
<p>然后，在虚拟机的配置里，你需要启用两个网卡。“网卡 1”就设置成刚才创建的“Host-only”网络，它是我们在本地终端登录和联网时用的；而“网卡 2”是“网络地址转换（NAT）”，用来上外网：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/ba/d8/ba4c453893b38223aa10989b2c3240d8.png?wh=1560x906"
        data-srcset="https://static001.geekbang.org/resource/image/ba/d8/ba4c453893b38223aa10989b2c3240d8.png?wh=1560x906, https://static001.geekbang.org/resource/image/ba/d8/ba4c453893b38223aa10989b2c3240d8.png?wh=1560x906 1.5x, https://static001.geekbang.org/resource/image/ba/d8/ba4c453893b38223aa10989b2c3240d8.png?wh=1560x906 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/ba/d8/ba4c453893b38223aa10989b2c3240d8.png?wh=1560x906"
        title="img" /></p>
<p>对于 VMWare Fusion，你需要在“偏好设置 - 网络”里，添加一个自定义的网络，比如这里的“vmnet3”，网段是“192.168.10.0”，允许使用 NAT 连接外网，然后在虚拟机的网络设置里选用这个网络：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/82/48/829a9212b4b1ac7cb2f2f087ebe7e848.png?wh=1368x1638"
        data-srcset="https://static001.geekbang.org/resource/image/82/48/829a9212b4b1ac7cb2f2f087ebe7e848.png?wh=1368x1638, https://static001.geekbang.org/resource/image/82/48/829a9212b4b1ac7cb2f2f087ebe7e848.png?wh=1368x1638 1.5x, https://static001.geekbang.org/resource/image/82/48/829a9212b4b1ac7cb2f2f087ebe7e848.png?wh=1368x1638 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/82/48/829a9212b4b1ac7cb2f2f087ebe7e848.png?wh=1368x1638"
        title="img" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/1f/bf/1f6d264abdfd2ded54c12c57d89971bf.png?wh=1504x1072"
        data-srcset="https://static001.geekbang.org/resource/image/1f/bf/1f6d264abdfd2ded54c12c57d89971bf.png?wh=1504x1072, https://static001.geekbang.org/resource/image/1f/bf/1f6d264abdfd2ded54c12c57d89971bf.png?wh=1504x1072 1.5x, https://static001.geekbang.org/resource/image/1f/bf/1f6d264abdfd2ded54c12c57d89971bf.png?wh=1504x1072 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/1f/bf/1f6d264abdfd2ded54c12c57d89971bf.png?wh=1504x1072"
        title="img" /></p>
<h3 id="如何安装虚拟机">如何安装虚拟机</h3>
<p>把 CPU、内存、硬盘、网络都配置好之后，再加载上 Ubuntu 22.04 的光盘镜像，我们就可以开始安装 Linux 了。在安装的过程中，为了节约时间，建议选择“最小安装”，同时物理断网，避免下载升级包。注意，断网对于 Apple M1 来说特别重要，否则 Ubuntu 会自动更新到 5.15 内核，导致安装后无法正常启动。安装完 Linux 系统之后，我们还要再做一些环境的初始化操作。首先我们需要用 Ctrl + Alt + T 打开命令行窗口，然后用 apt 从 Ubuntu 的官方软件仓库安装 git、vim、curl 等常用工具：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">sudo apt update
sudo apt install -y git vim curl jq
</code></pre></td></tr></table>
</div>
</div><p>Ubuntu 桌面版默认是不支持远程登录的，所以为了让后续的实验更加便利，我们还需要安装“openssh-server”，再使用命令 ip addr ，查看虚拟机的 IP 地址，然后就可以在宿主机上使用 ssh 命令登录虚拟机：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">sudo apt install -y openssh-server
ip addr
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/59/50/59c0c45afe6538a9b6837d5277da6e50.png?wh=936x838"
        data-srcset="https://static001.geekbang.org/resource/image/59/50/59c0c45afe6538a9b6837d5277da6e50.png?wh=936x838, https://static001.geekbang.org/resource/image/59/50/59c0c45afe6538a9b6837d5277da6e50.png?wh=936x838 1.5x, https://static001.geekbang.org/resource/image/59/50/59c0c45afe6538a9b6837d5277da6e50.png?wh=936x838 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/59/50/59c0c45afe6538a9b6837d5277da6e50.png?wh=936x838"
        title="img" /></p>
<p>从这个截图里可以看到，这台 VirtualBox 虚拟机有 3 个网卡，其中名字是“enp0s3”的网卡就是我们之前配置的“192.168.56.1/24”网段，IP 地址是自动分配的“192.168.56.11”。如果你对自动分配的 IP 地址不是很满意，也可以在 Ubuntu 右上角的系统设置里修改网卡，把它从动态地址（DHCP）改成静态地址（Manual），具体的参数可以参考下面的截图，重启后新的 IP 地址就生效了。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/a3/88/a3d2749f6ea7f3327c7efd09116b5b88.png?wh=936x838"
        data-srcset="https://static001.geekbang.org/resource/image/a3/88/a3d2749f6ea7f3327c7efd09116b5b88.png?wh=936x838, https://static001.geekbang.org/resource/image/a3/88/a3d2749f6ea7f3327c7efd09116b5b88.png?wh=936x838 1.5x, https://static001.geekbang.org/resource/image/a3/88/a3d2749f6ea7f3327c7efd09116b5b88.png?wh=936x838 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/a3/88/a3d2749f6ea7f3327c7efd09116b5b88.png?wh=936x838"
        title="img" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/yy/61/yy8d883fe7b55a6f6fdf3cefd8990661.png?wh=1920x1569"
        data-srcset="https://static001.geekbang.org/resource/image/yy/61/yy8d883fe7b55a6f6fdf3cefd8990661.png?wh=1920x1569, https://static001.geekbang.org/resource/image/yy/61/yy8d883fe7b55a6f6fdf3cefd8990661.png?wh=1920x1569 1.5x, https://static001.geekbang.org/resource/image/yy/61/yy8d883fe7b55a6f6fdf3cefd8990661.png?wh=1920x1569 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/yy/61/yy8d883fe7b55a6f6fdf3cefd8990661.png?wh=1920x1569"
        title="img" /></p>
<p>这些工作完成之后，我建议你再给虚拟机拍个快照，做好备份工作，这样万一后面有什么意外发生环境被弄乱了，也可以轻松回滚到拍快照时的正确状态。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/b2/f8/b2291c4ed75a8cd6248202c461de4ff8.png?wh=1234x1316"
        data-srcset="https://static001.geekbang.org/resource/image/b2/f8/b2291c4ed75a8cd6248202c461de4ff8.png?wh=1234x1316, https://static001.geekbang.org/resource/image/b2/f8/b2291c4ed75a8cd6248202c461de4ff8.png?wh=1234x1316 1.5x, https://static001.geekbang.org/resource/image/b2/f8/b2291c4ed75a8cd6248202c461de4ff8.png?wh=1234x1316 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/b2/f8/b2291c4ed75a8cd6248202c461de4ff8.png?wh=1234x1316"
        title="img" /></p>
<p>现在，让我们启动一个命令行终端（我用的是 Mac 里的“iTerm2”），使用 ssh ，输入用户名、密码和 IP 地址，就能够登录创建好的虚拟机了：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/89/0c/89d4ccc118a6483f94cf9ebde548a30c.png?wh=1920x728"
        data-srcset="https://static001.geekbang.org/resource/image/89/0c/89d4ccc118a6483f94cf9ebde548a30c.png?wh=1920x728, https://static001.geekbang.org/resource/image/89/0c/89d4ccc118a6483f94cf9ebde548a30c.png?wh=1920x728 1.5x, https://static001.geekbang.org/resource/image/89/0c/89d4ccc118a6483f94cf9ebde548a30c.png?wh=1920x728 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/89/0c/89d4ccc118a6483f94cf9ebde548a30c.png?wh=1920x728"
        title="img" /></p>
<h3 id="有哪些常用的-linux-操作">有哪些常用的 Linux 操作</h3>
<p>到这里，我们的实验环境就算是搭建完毕了，虽然目前只有最基本的 Linux 系统，但在后面的“入门篇”“初级篇”“中级篇”里，我们会以它为基础逐步完善，实现完整的 Kubernetes 环境。特别提醒一下，因为 Kubernetes 基于 Linux，虽然也有图形化的 Dashboard，但更多的时候都是在命令行里工作，所以你需要对基本的 Linux 操作有所了解。学习 Linux 操作系统是另外一个很大的话题了，虽然它很重要，但并不是我们这门课的目标，我这里简单列一些比较常用的知识，你可以检测一下自己的掌握程度，如果有不了解的，希望你课后再查找相关资料补上这些点：</p>
<p>命令行界面称为“Shell”，支持交互操作，也支持脚本操作，也就是“Shell 编程”。root 用户有最高权限，但有安全隐患，所以通常我们都只使用普通用户身份，必要的时候使用 sudo 来临时使用 root 权限。查看系统当前进程列表的命令是 ps ，它是 Linux 里最常用的命令之一。查看文件可以使用 cat ，如果内容太多，可以用管道符 | ，后面跟 more 、less 。vim 是 Linux 里最流行的编辑器，但它的使用方式与一般的编辑器不同，学习成本略高。curl 能够以命令行的方式发送 HTTP 请求，多用来测试 HTTP 服务器（例如 Nginx）。</p>
<h3 id="小结">小结</h3>
<p>好了，我们的课前准备就要结束了，我再简单小结一下今天的要点内容：一个完善的实验环境能够很好地辅助我们的学习，建议在本地使用虚拟机从零开始搭建 Kubernetes 环境。虚拟机软件可以选择 VirtualBox（intel 芯片）和 VMWare Fusion（Apple M1 芯片），因为 Kubernetes 只能运行在 Linux 上，建议选择最新的 Ubuntu 22.04。虚拟机要事先配置好内存、网络等参数，安装系统时选最小安装，然后再安装一些常用的工具。虚拟机都支持快照，环境设置好后要及时备份，出现问题可以随时回滚恢复，避免重复安装系统浪费时间。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/31/ec/31aa9e27b25ef630f987ae17de070cec.jpg?wh=1920x1025"
        data-srcset="https://static001.geekbang.org/resource/image/31/ec/31aa9e27b25ef630f987ae17de070cec.jpg?wh=1920x1025, https://static001.geekbang.org/resource/image/31/ec/31aa9e27b25ef630f987ae17de070cec.jpg?wh=1920x1025 1.5x, https://static001.geekbang.org/resource/image/31/ec/31aa9e27b25ef630f987ae17de070cec.jpg?wh=1920x1025 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/31/ec/31aa9e27b25ef630f987ae17de070cec.jpg?wh=1920x1025"
        title="img" /></p>
<p>另外，我写专栏的惯例是在 GitHub 上开一个配套的学习项目，这门课程的仓库就叫“k8s_study”（https://github.com/chronolaw/k8s_study），里面有文档链接、安装脚本、测试命令、YAML 描述文件等等，你可以克隆下来在后续的课程中参照着学习。</p>
<h2 id="入门">入门</h2>
<h2 id="01初识容器">01｜初识容器</h2>
<p>俗话说：“万事开头难”，对于 Kubernetes 这个庞大而陌生的领域来说更是如此，如何迈出学习的第一步非常关键，所以，今天我们先从最简单、最基本的知识入手，聊聊最流行的容器技术 Docker，先搭建实验环境，再动手操作一下，进而破除它的神秘感。</p>
<h3 id="docker-的诞生">Docker 的诞生</h3>
<p>现在我们都已经对 Container、Kubernetes 这些技术名词耳熟能详了，但你知道这一切的开端——Docker，第一次在世界上的亮相是什么样子的吗？九年前，也就是 2013 年 3 月 15 日，在北美的圣克拉拉市召开了一场 Python 开发者社区的主题会议 PyCon，研究和探讨各种 Python 开发技术和应用，与我们常说的“云”“PaaS”“SaaS”根本毫不相关。在当天的会议日程快结束时，有一个“闪电演讲”（lighting talk）的小环节。其中有一位开发者，用了 5 分钟的时间，做了题为 “The future of Linux Containers” 的演讲，不过临近末尾因为超时而被主持人赶下了台，场面略显尴尬（你可以在这里回看这段具有历史意义的视频）。</p>
<p>相信你一定猜到了，这个只有短短 5 分钟的技术演示，就是我们目前所看到的、席卷整个业界的云原生大潮的开端。正是在这段演讲里，Solomon Hykes（dotCloud 公司，也就是 Docker 公司的创始人）首次向全世界展示了 Docker 技术。5 分钟的时间非常短，但演讲里却包含了几个现在已经普及，但当时却非常新奇的概念，比如容器、镜像、隔离运行进程等，信息量非常大。PyCon2013 大会之后，许多人都意识到了容器的价值和重要性，发现它能够解决困扰了云厂商多年的打包、部署、管理、运维等问题，Docker 也就迅速流行起来，成为了 GitHub 上的明星项目。然后在几个月的时间里，Docker 更是吸引了 Amazon、Google、Red Hat 等大公司的关注，这些公司利用自身的技术背景，纷纷在容器概念上大做文章，最终成就了我们今天所看到的至尊王者 Kubernetes 的出现。</p>
<h3 id="docker-的形态">Docker 的形态</h3>
<p>好了，下面我们就要来一个“情境再现”，在我们的 Linux 虚拟机上搭建一个容器运行环境，模拟一下当年 Solomon Hykes 初次展示 Docker 的场景。当然，如今的 Docker 经过了九年的发展，已经远不是当初的“吴下阿蒙”了，不过最核心的那些概念和操作还是保持了一贯性，没有太大的变化。首先，我们需要对 Docker 的形态有所了解。目前使用 Docker 基本上有两个选择：Docker Desktop 和 Docker Engine。</p>
<p>Docker Desktop 是专门针对个人使用而设计的，支持 Mac 和 Windows 快速安装，具有直观的图形界面，还集成了许多周边工具，方便易用。不过，我个人不是太推荐使用 Docker Desktop，原因有两个。第一个，它是商业产品，难免会带有 Docker 公司的“私人气息”，有一些自己的、非通用的东西，不利于我们后续的 Kubernetes 学习。第二个，它只是对个人学习免费，受条款限制不能商用，我们在日常工作中难免会“踩到雷区”。Docker Engine 则和 Docker Desktop 正好相反，完全免费，但只能在 Linux 上运行，只能使用命令行操作，缺乏辅助工具，需要我们自己动手 DIY 运行环境。不过要是较起真来，它才是 Docker 当初的真正形态，“血脉”最纯正，也是现在各个公司在生产环境中实际使用的 Docker 产品，毕竟机房里 99% 的服务器跑的都是 Linux。所以，在接下来的学习过程里，我推荐使用 Docker Engine，之后在本专栏内，如果没有什么特别的声明，Docker 这个词通常指的就是 Docker Engine。</p>
<h3 id="docker-的安装">Docker 的安装</h3>
<p>在课前准备里，我们已经在 Linux 虚拟机里安装了一些常用软件，用的是 Ubuntu 的包管理工具 apt，所以，我们仍然可以使用同样的方式来安装 Docker。先让我们尝试输入命令 docker ，会得到“命令未找到”的提示，还有如何安装的建议：</p>
<p>……</p>
<h3 id="docker-的使用">Docker 的使用</h3>
<p>现在，我们已经有了可用的 Docker 运行环境，就可以来重现 9 年前 Solomon Hykes 的那场简短的技术演示了。首先，我们使用命令 docker ps，它会列出当前系统里运行的容器，就像我们在 Linux 系统里使用 ps 命令列出运行的进程一样。注意，所有的 Docker 操作都是这种形式：以 docker 开始，然后是一个具体的子命令，之前的 docker version 和 docker info 也遵循了这样的规则。你还可以用 help 或者 &ndash;help 来获取帮助信息，查看命令清单和更详细的说明。</p>
<p>因为我们刚刚安装好 Docker 环境，这个时候还没有运行任何容器，所以列表显然是空的。</p>
<p>接下来，让我们尝试另一个非常重要的命令 docker pull ，从外部的镜像仓库（Registry）拉取一个 busybox 镜像（image），你可以把它类比成是 Ubuntu 里的“apt install”下载软件包：</p>
<p>docker pull 会有一些看起来比较奇怪的输出信息，现在我们暂时不用管，后续的课程会有详细解释。我们再执行命令 docker images ，它会列出当前 Docker 所存储的所有镜像：</p>
<p>可以看到，命令会显示有一个叫 busybox 的镜像，镜像的 ID 号是一串 16 进制数字，大小是 1.41MB。现在，我们就要从这个镜像启动容器了，命令是 docker run ，执行 echo 输出字符串，这也正是 Solomon Hykes 在大会上所展示的最精彩的那部分：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run busybox echo hello world
</code></pre></td></tr></table>
</div>
</div><p>然后我们再用 docker ps 命令，加上一个参数 -a ，就可以看到这个已经运行完毕的容器</p>
<h3 id="docker-的架构">Docker 的架构</h3>
<p>这里我再稍微讲一下 Docker Engine 的架构，让你有个初步的印象，也为之后的学习做一个铺垫。下面的这张图来自 Docker 官网（https://docs.docker.com/get-started/overview/），精准地描述了 Docker Engine 的内部角色和工作流程，对我们的学习研究非常有指导意义。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        data-srcset="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 1.5x, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        title="img" /></p>
<p>刚才我们敲的命令行 docker 实际上是一个客户端 client ，它会与 Docker Engine 里的后台服务 Docker daemon 通信，而镜像则存储在远端的仓库 Registry 里，客户端并不能直接访问镜像仓库。Docker client 可以通过 build、pull、run等命令向 Docker daemon 发送请求，而 Docker daemon 则是容器和镜像的“大管家”，负责从远端拉取镜像、在本地存储镜像，还有从镜像生成容器、管理容器等所有功能。所以，在 Docker Engine 里，真正干活的其实是默默运行在后台的 Docker daemon，而我们实际操作的命令行工具“docker”只是个“传声筒”的角色。Docker 官方还提供一个“hello-world”示例，可以为你展示 Docker client 到 Docker daemon 再到 Registry 的详细工作流程，你只需要执行这样一个命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run hello-world
</code></pre></td></tr></table>
</div>
</div><p>它会先检查本地镜像，如果没有就从远程仓库拉取，再运行容器，最后输出运行信息：</p>
<h3 id="小结-1">小结</h3>
<p>好了，今天我们初步了解了容器技术，再简单小结一下主要的内容：容器技术起源于 Docker，它目前有两个产品：Docker Desktop 和 Docker Engine，我们的课程里推荐使用免费的 Docker Engine，它可以在 Ubuntu 系统里直接用 apt 命令安装。Docker Engine 需要使用命令行操作，主命令是 docker，后面再接各种子命令。查看 Docker 的基本信息的命令是 docker version 和 docker info ，其他常用的命令有 docker ps、docker pull、docker images、docker run。Docker Engine 是典型的客户端 / 服务器（C/S）架构，命令行工具 Docker 直接面对用户，后面的 Docker daemon 和 Registry 协作完成各种功能。</p>
<h2 id="02被隔离的进程一起来看看容器的本质">02｜被隔离的进程：一起来看看容器的本质</h2>
<p>广义上来说，容器技术是动态的容器、静态的镜像和远端的仓库这三者的组合。不过，“容器”这个术语作为容器技术里的核心概念，不仅是大多数初次接触这个领域的人，即使是一些已经有使用经验的人，想要准确地把握它们的内涵、本质都是比较困难的。那么今天，我们就一起来看看究竟什么是容器（即狭义的、动态的容器）。</p>
<h3 id="容器到底是什么">容器到底是什么</h3>
<p>从字面上来看，容器就是 Container，一般把它形象地比喻成现实世界里的集装箱，它也正好和 Docker 的现实含义相对应，因为码头工人（那只可爱的小鲸鱼）就是不停地在搬运集装箱。</p>
<p>集装箱的作用是标准化封装各种货物，一旦打包完成之后，就可以从一个地方迁移到任意的其他地方。相比散装形式而言，集装箱隔离了箱内箱外两个世界，保持了货物的原始形态，避免了内外部相互干扰，极大地简化了商品的存储、运输、管理等工作。再回到我们的计算机世界，容器也发挥着同样的作用，不过它封装的货物是运行中的应用程序，也就是进程，同样它也会把进程与外界隔离开，让进程与外部系统互不影响。我们还是来实际操作一下吧，来看看在容器里运行的进程是个什么样子。首先，我们使用 docker pull 命令，拉取一个新的镜像——操作系统 Alpine：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull alpine
</code></pre></td></tr></table>
</div>
</div><p>然后我们使用 docker run 命令运行它的 Shell 程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -it alpine sh
</code></pre></td></tr></table>
</div>
</div><p>注意我们在这里多加了一个 -it 参数，这样我们就会暂时离开当前的 Ubuntu 操作系统，进入容器内部。现在，让我们执行 cat /etc/os-release ，还有 ps 这两个命令，最后再使用 exit 退出，看看容器里与容器外有什么不同：</p>
<p>就像这张截图里所显示的，在容器里查看系统信息，会发现已经不再是外面的 Ubuntu 系统了，而是变成了 Alpine Linux 3.15，使用 ps 命令也只会看到一个完全“干净”的运行环境，除了 Shell（即 sh）没有其他的进程存在。也就是说，在容器内部是一个全新的 Alpine 操作系统，在这里运行的应用程序完全看不到外面的 Ubuntu 系统，两个系统被互相“隔离”了，就像是一个“世外桃源”。我们还可以再拉取一个 Ubuntu 18.04 的镜像，用同样的方式进入容器内部，然后执行 apt update、apt install 等命令来看看：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull ubuntu:18.04
docker run -it ubuntu:18.04 sh

# 下面的命令都是在容器内执行
cat /etc/os-release
apt update
apt install -y wget redis
redis-server &amp;
</code></pre></td></tr></table>
</div>
</div><p>这里我就不截图了，具体的结果留给你课下去实际操作体会。可以看到的是，容器里是另一个完整的 Ubuntu 18.04 系统，我们可以在这个“世外桃源”做任意的事情，比如安装应用、运行 Redis 服务等。但无论我们在容器里做什么，都不会影响外面的 Ubuntu 系统（当然不是绝对的）。到这里，我们就可以得到一个初步的结论：<strong>容器，就是一个特殊的隔离环境，它能够让进程只看到这个环境里的有限信息，不能对外界环境施加影响</strong>。那么，很自然地，我们会产生另外一个问题：为什么需要创建这样的一个隔离环境，直接让进程在系统里运行不好吗？</p>
<h3 id="为什么要隔离">为什么要隔离</h3>
<p>相信因为这两年疫情，你对“隔离”这个词不会感觉到太陌生。为了防止疫情蔓延，我们需要建立方舱、定点医院，把患病人群控制在特定的区域内，更进一步还会实施封闭小区、关停商场等行动。虽然这些措施带来了一些不便，但都是为了整个社会更大范围的正常运转。同样的，在计算机世界里的隔离也是出于同样的考虑，也就是<strong>系统安全</strong>。对于 Linux 操作系统来说，一个不受任何限制的应用程序是十分危险的。这个进程能够看到系统里所有的文件、所有的进程、所有的网络流量，访问内存里的任何数据，那么恶意程序很容易就会把系统搞瘫痪，正常程序也可能会因为无意的 Bug 导致信息泄漏或者其他安全事故。虽然 Linux 提供了用户权限控制，能够限制进程只访问某些资源，但这个机制还是比较薄弱的，和真正的“隔离”需求相差得很远。而现在，<strong>使用容器技术，我们就可以让应用程序运行在一个有严密防护的“沙盒”（Sandbox）环境之内</strong>，就好像是把进程请进了“隔离酒店”，它可以在这个环境里自由活动，但绝不允许“越界”，从而保证了容器外系统的安全。</p>
<p>另外，在计算机里有各种各样的资源，CPU、内存、硬盘、网卡，虽然目前的高性能服务器都是几十核 CPU、上百 GB 的内存、数 TB 的硬盘、万兆网卡，但这些资源终究是有限的，而且考虑到成本，也不允许某个应用程序无限制地占用。容器技术的另一个本领就是为应用程序加上资源隔离，在系统里切分出一部分资源，让它只能使用指定的配额，比如只能使用一个 CPU，只能使用 1GB 内存等等，就好像在隔离酒店里保证一日三餐，但想要吃山珍海味那是不行的。这样就可以避免容器内进程的过度系统消耗，充分利用计算机硬件，让有限的资源能够提供稳定可靠的服务。所以，虽然进程被“关”在了容器里，损失了一些自由，但却保证了整个系统的安全。而且只要进程遵守隔离规定，不做什么出格的事情，也完全是可以正常运行的。</p>
<h3 id="与虚拟机的区别是什么">与虚拟机的区别是什么</h3>
<p>你也许会说，这么看来，容器不过就是常见的“沙盒”技术中的一种，和虚拟机差不了多少，那么它与虚拟机的区别在哪里呢？又有什么样的优势呢？在我看来，其实容器和虚拟机面对的都是相同的问题，使用的也都是虚拟化技术，只是所在的层次不同，我们可以参考 Docker 官网上的两张图，把这两者对比起来会更利于学习理解。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/b7/02/b734f7d91bda055236b3467bc16f6302.jpg?wh=1920x911"
        data-srcset="https://static001.geekbang.org/resource/image/b7/02/b734f7d91bda055236b3467bc16f6302.jpg?wh=1920x911, https://static001.geekbang.org/resource/image/b7/02/b734f7d91bda055236b3467bc16f6302.jpg?wh=1920x911 1.5x, https://static001.geekbang.org/resource/image/b7/02/b734f7d91bda055236b3467bc16f6302.jpg?wh=1920x911 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/b7/02/b734f7d91bda055236b3467bc16f6302.jpg?wh=1920x911"
        title="img" /></p>
<p>（Docker 官网的图示其实并不太准确，容器并不直接运行在 Docker 上，Docker 只是辅助建立隔离环境，让容器基于 Linux 操作系统运行）首先，容器和虚拟机的目的都是隔离资源，保证系统安全，然后是尽量提高资源的利用率。之前在使用 VirtualBox/VMware 创建虚拟机的时候，你也应该看到了，它们能够在宿主机系统里完整虚拟化出一套计算机硬件，在里面还能够安装任意的操作系统，这内外两个系统也同样是完全隔离，互不干扰。而在数据中心的服务器上，虚拟机软件（即图中的 Hypervisor）同样可以把一台物理服务器虚拟成多台逻辑服务器，这些逻辑服务器彼此独立，可以按需分隔物理服务器的资源，为不同的用户所使用。从实现的角度来看，虚拟机虚拟化出来的是硬件，需要在上面再安装一个操作系统后才能够运行应用程序，而硬件虚拟化和操作系统都比较“重”，会消耗大量的 CPU、内存、硬盘等系统资源，但这些消耗其实并没有带来什么价值，属于“重复劳动”和“无用功”，不过好处就是隔离程度非常高，每个虚拟机之间可以做到完全无干扰。</p>
<p>我们再来看容器（即图中的 Docker），它直接利用了下层的计算机硬件和操作系统，因为比虚拟机少了一层，所以自然就会节约 CPU 和内存，显得非常轻量级，能够更高效地利用硬件资源。不过，因为多个容器共用操作系统内核，应用程序的隔离程度就没有虚拟机那么高了。运行效率，可以说是容器相比于虚拟机最大的优势，在这个对比图中就可以看到，同样的系统资源，虚拟机只能跑 3 个应用，其他的资源都用来支持虚拟机运行了，而容器则能够把这部分资源释放出来，同时运行 6 个应用。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/26/6d/26cb446ac5ec53abde2744c431200c6d.jpg?wh=1920x869"
        data-srcset="https://static001.geekbang.org/resource/image/26/6d/26cb446ac5ec53abde2744c431200c6d.jpg?wh=1920x869, https://static001.geekbang.org/resource/image/26/6d/26cb446ac5ec53abde2744c431200c6d.jpg?wh=1920x869 1.5x, https://static001.geekbang.org/resource/image/26/6d/26cb446ac5ec53abde2744c431200c6d.jpg?wh=1920x869 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/26/6d/26cb446ac5ec53abde2744c431200c6d.jpg?wh=1920x869"
        title="img" /></p>
<p>当然，这个对比图只是一个形象的展示，不是严谨的数值比较，不过我们还可以用手里现有的 VirtualBox/VMware 虚拟机与 Docker 容器做个简单对比。一个普通的 Ubuntu 虚拟机安装完成之后，体积都是 GB 级别的，再安装一些应用很容易就会上到 10GB，启动的时间通常需要几分钟，我们的电脑上同时运行十来个虚拟机可能就是极限了。而一个 Ubuntu 镜像大小则只有几十 MB，启动起来更是非常快，基本上不超过一秒钟，同时跑上百个容器也毫无问题。不过，虚拟机和容器这两种技术也不是互相排斥的，它们完全可以结合起来使用，就像我们的课程里一样，用虚拟机实现与宿主机的强隔离，然后在虚拟机里使用 Docker 容器来快速运行应用程序。</p>
<h3 id="隔离是怎么实现的">隔离是怎么实现的</h3>
<p>我们知道虚拟机使用的是 Hypervisor（KVM、Xen 等），那么，容器是怎么实现和下层计算机硬件和操作系统交互的呢？为什么它会具有高效轻便的隔离特性呢？其实奥秘就在于 Linux 操作系统内核之中，为资源隔离提供了三种技术：namespace、cgroup、chroot，虽然这三种技术的初衷并不是为了实现容器，但它们三个结合在一起就会发生奇妙的“化学反应”。namespace 是 2002 年从 Linux 2.4.19 开始出现的，和编程语言里的 namespace 有点类似，它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离。cgroup 是 2008 年从 Linux 2.6.24 开始出现的，它的全称是 Linux Control Group，用来实现对进程的 CPU、内存等资源的优先级和配额限制，相当于给进程的小板房加了一个天花板。</p>
<p>chroot 的历史则要比前面的 namespace、cgroup 要古老得多，早在 1979 年的 UNIX V7 就已经出现了，它可以更改进程的根目录，也就是限制访问文件系统，相当于给进程的小板房铺上了地砖。你看，综合运用这三种技术，一个四四方方、具有完善的隔离特性的容器就此出现了，进程就可以搬进这个小房间，过它的“快乐生活”了。我觉得用鲁迅先生的一句诗来描述这个情景最为恰当：躲进小楼成一统，管他冬夏与春秋。</p>
<h3 id="小结-2">小结</h3>
<p>好了，今天我们一起学习了容器技术中最关键的概念：动态的容器，再简单小结一下课程的要点：容器就是操作系统里一个特殊的“沙盒”环境，里面运行的进程只能看到受限的信息，与外部系统实现了隔离。容器隔离的目的是为了系统安全，限制了进程能够访问的各种资源。相比虚拟机技术，容器更加轻巧、更加高效，消耗的系统资源非常少，在云计算时代极具优势。容器的基本实现技术是 Linux 系统里的 namespace、cgroup、chroot。</p>
<h2 id="03容器化的应用会了这些你就是docker高手">03｜容器化的应用：会了这些你就是Docker高手</h2>
<p>在上一次课里，我们了解了容器技术中最核心的概念：容器，知道它就是一个系统中被隔离的特殊环境，进程可以在其中不受干扰地运行。我们也可以把这段描述再简化一点：容器就是被隔离的进程。相比笨重的虚拟机，容器有许多优点，那我们应该如何创建并运行容器呢？是要用 Linux 内核里的 namespace、cgroup、chroot 三件套吗？当然不会，那样的方式实在是太原始了，所以今天，我们就以 Docker 为例，来看看什么是容器化的应用，怎么来操纵容器化的应用。</p>
<h3 id="什么是容器化的应用">什么是容器化的应用</h3>
<p>之前我们运行容器的时候，显然不是从零开始的，而是要先拉取一个“镜像”（image），再从这个“镜像”来启动容器，像第一节课这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull busybox      
docker run busybox echo hello world
</code></pre></td></tr></table>
</div>
</div><p>那么，这个“镜像”到底是什么东西呢？它又和“容器”有什么关系呢？其实我们在其他场合中也曾经见到过“镜像”这个词，比如最常见的光盘镜像，重装电脑时使用的硬盘镜像，还有虚拟机系统镜像。这些“镜像”都有一些相同点：只读，不允许修改，以标准格式存储了一系列的文件，然后在需要的时候再从中提取出数据运行起来。容器技术里的镜像也是同样的道理。因为容器是由操作系统动态创建的，那么必然就可以用一种办法把它的初始环境给固化下来，保存成一个静态的文件，相当于是把容器给“拍扁”了，这样就可以非常方便地存放、传输、版本化管理了。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/59/33/59a1cd035e21fe297072b20475d3c833.jpg?wh=1418x759"
        data-srcset="https://static001.geekbang.org/resource/image/59/33/59a1cd035e21fe297072b20475d3c833.jpg?wh=1418x759, https://static001.geekbang.org/resource/image/59/33/59a1cd035e21fe297072b20475d3c833.jpg?wh=1418x759 1.5x, https://static001.geekbang.org/resource/image/59/33/59a1cd035e21fe297072b20475d3c833.jpg?wh=1418x759 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/59/33/59a1cd035e21fe297072b20475d3c833.jpg?wh=1418x759"
        title="img" /></p>
<p>如果还拿之前的“小板房”来做比喻的话，那么镜像就可以说是一个“样板间”，把运行进程所需要的文件系统、依赖库、环境变量、启动参数等所有信息打包整合到了一起。之后镜像文件无论放在哪里，操作系统都能根据这个“样板间”快速重建容器，应用程序看到的就会是一致的运行环境了。从功能上来看，镜像和常见的 tar、rpm、deb 等安装包一样，都打包了应用程序，<strong>但最大的不同点在于它里面不仅有基本的可执行文件，还有应用运行时的整个系统环境。这就让镜像具有了非常好的跨平台便携性和兼容性</strong>，能够让开发者在一个系统上开发（例如 Ubuntu），然后打包成镜像，再去另一个系统上运行（例如 CentOS），完全不需要考虑环境依赖的问题，是一种更高级的应用打包方式。</p>
<p>理解了这一点，我们再回过头来看看第一节课里运行的 Docker 命令。docker pull busybox ，就是获取了一个打包了 busybox 应用的镜像，里面固化了 busybox 程序和它所需的完整运行环境。docker run busybox echo hello world ，就是提取镜像里的各种信息，运用 namespace、cgroup、chroot 技术创建出隔离环境，然后再运行 busybox 的 echo 命令，输出 hello world 的字符串。这两个步骤，由于是基于标准的 Linux 系统调用和只读的镜像文件，所以，无论是在哪种操作系统上，或者是使用哪种容器实现技术，都会得到完全一致的结果。</p>
<p>推而广之，任何应用都能够用这种形式打包再分发后运行，这也是无数开发者梦寐以求的“一次编写，到处运行（Build once, Run anywhere）”的至高境界。所以，所谓的“容器化的应用”，或者“应用的容器化”，就是指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。现在你就应该知道了，镜像就是静态的应用容器，容器就是动态的应用镜像，两者互相依存，互相转化，密不可分。之前的那张 Docker 官方架构图你还有印象吧，我们在第一节课曾经简单地介绍过。可以看到，在 Docker 里的核心处理对象就是镜像（image）和容器（container）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        data-srcset="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 1.5x, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        title="img" /></p>
<p>好，理解了什么是容器化的应用，接下来我们再来学习怎么操纵容器化的应用。因为镜像是容器运行的根本，先有镜像才有容器，所以先来看看关于镜像的一些常用命令。</p>
<h3 id="常用的镜像操作有哪些">常用的镜像操作有哪些</h3>
<p>在前面的课程里你应该已经了解了两个基本命令，docker pull 从远端仓库拉取镜像，docker images 列出当前本地已有的镜像。docker pull 的用法还是比较简单的，和普通的下载非常像，不过我们需要知道镜像的命名规则，这样才能准确地获取到我们想要的容器镜像。</p>
<p>镜像的完整名字由两个部分组成，名字和标签，中间用 : 连接起来。</p>
<p>名字表明了应用的身份，比如 busybox、Alpine、Nginx、Redis 等等。标签（tag）则可以理解成是为了区分不同版本的应用而做的额外标记，任何字符串都可以，比如 3.15 是纯数字的版本号、jammy 是项目代号、1.21-alpine 是版本号加操作系统名等等。其中有一个比较特殊的标签叫“latest”，它是默认的标签，如果只提供名字没有附带标签，那么就会使用这个默认的“latest”标签。那么现在，你就可以把名字和标签组合起来，使用 docker pull 来拉取一些镜像了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull alpine:3.15
docker pull ubuntu:jammy
docker pull nginx:1.21-alpine
docker pull nginx:alpine
docker pull redis
</code></pre></td></tr></table>
</div>
</div><p>有了这些镜像之后，我们再用 docker images 命令来看看它们的具体信息</p>
<p>在这个列表里，你可以看到，REPOSITORY 列就是镜像的名字，TAG 就是这个镜像的标签，那么第三列“IMAGE ID”又是什么意思呢？它可以说是镜像唯一的标识，就好像是身份证号一样。比如这里我们可以用“ubuntu:jammy”来表示 Ubuntu 22.04 镜像，同样也可以用它的 ID“d4c2c……”来表示。另外，你可能还会注意到，截图里的两个镜像“nginx:1.21-alpine”和“nginx:alpine”的 IMAGE ID 是一样的，都是“a63aa……”。这其实也很好理解，这就像是人的身份证号码是唯一的，但可以有大名、小名、昵称、绰号，同一个镜像也可以打上不同的标签，这样应用在不同的场合就更容易理解。IMAGE ID 还有一个好处，因为它是十六进制形式且唯一，Docker 特意为它提供了“短路”操作，在本地使用镜像的时候，我们不用像名字那样要完全写出来这一长串数字，通常只需要写出前三位就能够快速定位，在镜像数量比较少的时候用两位甚至一位数字也许就可以了。</p>
<p>来看另一个镜像操作命令 docker rmi ，它用来删除不再使用的镜像，可以节约磁盘空间，注意命令 rmi ，实际上是“remove image”的简写。下面我们就来试验一下，使用名字和 IMAGE ID 来删除镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker rmi redis    
docker rmi d4c
</code></pre></td></tr></table>
</div>
</div><p>这里的第一个 rmi 删除了 Redis 镜像，因为没有显式写出标签，默认使用的就是“latest”。第二个 rmi 没有给出名字，而是直接使用了 IMAGE ID 的前三位，也就是“d4c”，Docker 就会直接找到这个 ID 前缀的镜像然后删除。Docker 里与镜像相关的命令还有很多，不过以上的 docker pull、docker images、docker rmi 就是最常用的三个了，其他的命令我们后续课程会陆续介绍。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/27/19/27364161a8d3c1f960a91e07b5094419.jpg?wh=1920x963"
        data-srcset="https://static001.geekbang.org/resource/image/27/19/27364161a8d3c1f960a91e07b5094419.jpg?wh=1920x963, https://static001.geekbang.org/resource/image/27/19/27364161a8d3c1f960a91e07b5094419.jpg?wh=1920x963 1.5x, https://static001.geekbang.org/resource/image/27/19/27364161a8d3c1f960a91e07b5094419.jpg?wh=1920x963 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/27/19/27364161a8d3c1f960a91e07b5094419.jpg?wh=1920x963"
        title="img" /></p>
<h3 id="常用的容器操作">常用的容器操作</h3>
<p>有哪些现在我们已经在本地存放了镜像，就可以使用 docker run 命令把这些静态的应用运行起来，变成动态的容器了。基本的格式是“docker run 设置参数”，再跟上“镜像名或 ID”，后面可能还会有附加的“运行命令”。比如这个命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -h srv alpine hostname
</code></pre></td></tr></table>
</div>
</div><p>这里的 -h srv 就是容器的运行参数，alpine 是镜像名，它后面的 hostname 表示要在容器里运行的“hostname”这个程序，输出主机名。docker run 是最复杂的一个容器操作命令，有非常多的额外参数用来调整容器的运行状态，你可以加上 &ndash;help 来看它的帮助信息，今天我只说几个最常用的参数。-it 表示开启一个交互式操作的 Shell，这样可以直接进入容器内部，就好像是登录虚拟机一样。（它实际上是“-i”和“-t”两个参数的组合形式）-d 表示让容器在后台运行，这在我们启动 Nginx、Redis 等服务器程序的时候非常有用。&ndash;name 可以为容器起一个名字，方便我们查看，不过它不是必须的，如果不用这个参数，Docker 会分配一个随机的名字。</p>
<p>下面我们就来练习一下这三个参数，分别运行 Nginx、Redis 和 Ubuntu：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d nginx:alpine            # 后台运行Nginx
docker run -d --name red_srv redis    # 后台运行Redis
docker run -it --name ubuntu 2e6 sh   # 使用IMAGE ID，登录Ubuntu18.04
</code></pre></td></tr></table>
</div>
</div><p>因为第三个命令使用的是 -it 而不是 -d ，所以它会进入容器里的 Ubuntu 系统，我们需要另外开一个终端窗口，使用 docker ps 命令来查看容器的运行状态：</p>
<p>可以看到，每一个容器也会有一个“CONTAINER ID”，它的作用和镜像的“IMAGE ID”是一样的，唯一标识了容器。对于正在运行中的容器，我们可以使用 docker exec 命令在里面执行另一个程序，效果和 docker run 很类似，但因为容器已经存在，所以不会创建新的容器。它最常见的用法是使用 -it 参数打开一个 Shell，从而进入容器内部，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker exec -it red_srv sh
</code></pre></td></tr></table>
</div>
</div><p>这样我们就“登录”进了 Redis 容器，可以很方便地查看服务的运行状态或者日志。运行中的容器还可以使用 docker stop 命令来强制停止，这里我们仍然可以使用容器名字，不过或许用“CONTAINER ID”的前三位数字会更加方便。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker stop ed4 d60 45c
</code></pre></td></tr></table>
</div>
</div><p>容器被停止后使用 docker ps 命令就看不到了，不过容器并没有被彻底销毁，我们可以使用 docker ps -a 命令查看系统里所有的容器，当然也包括已经停止运行的容器：</p>
<p>这些停止运行的容器可以用 docker start 再次启动运行，如果你确定不再需要它们，可以使用 docker rm 命令来彻底删除。</p>
<p>注意，这个命令与 docker rmi 非常像，区别在于它没有后面的字母“i”，所以只会删除容器，不删除镜像。下面我们就来运行 docker rm 命令，使用“CONTAINER ID”的前两位数字来删除这些容器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker rm ed d6 45
</code></pre></td></tr></table>
</div>
</div><p>执行删除命令之后，再用 docker ps -a 查看列表就会发现这些容器已经彻底消失了。你可能会感觉这样的容器管理方式很麻烦，启动后要 ps 看 ID 再删除，如果稍微不注意，系统就会遗留非常多的“死”容器，占用系统资源，有没有什么办法能够让 Docker 自动删除不需要的容器呢？办法当然有，就是在执行 docker run 命令的时候加上一个 &ndash;rm 参数，这就会告诉 Docker 不保存容器，只要运行完毕就自动清除，省去了我们手工管理容器的麻烦。我们还是用刚才的 Nginx、Redis 和 Ubuntu 这三个容器来试验一下，加上 &ndash;rm 参数（省略了 name 参数）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm nginx:alpine 
docker run -d --rm redis
docker run -it --rm 2e6 sh 
</code></pre></td></tr></table>
</div>
</div><p>然后我们用 docker stop 停止容器，再用 docker ps -a ，就会发现不需要我们再手动执行 docker rm ，Docker 已经自动删除了这三个容器。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/85/c8cd008e91aaff2cd91e0392b0079085.jpg?wh=1920x1747"
        data-srcset="https://static001.geekbang.org/resource/image/c8/85/c8cd008e91aaff2cd91e0392b0079085.jpg?wh=1920x1747, https://static001.geekbang.org/resource/image/c8/85/c8cd008e91aaff2cd91e0392b0079085.jpg?wh=1920x1747 1.5x, https://static001.geekbang.org/resource/image/c8/85/c8cd008e91aaff2cd91e0392b0079085.jpg?wh=1920x1747 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/85/c8cd008e91aaff2cd91e0392b0079085.jpg?wh=1920x1747"
        title="img" /></p>
<h3 id="小结-3">小结</h3>
<p>好了，今天我们一起学习了容器化的应用，然后使用 Docker 实际操作了镜像和容器，运行了被容器化的 Alpine、Nginx、Redis 等应用。镜像是容器的静态形式，它打包了应用程序的所有运行依赖项，方便保存和传输。使用容器技术运行镜像，就形成了动态的容器，由于镜像只读不可修改，所以应用程序的运行环境总是一致的。而容器化的应用就是指以镜像的形式打包应用程序，然后在容器环境里从镜像启动容器。由于 Docker 的命令比较多，而且每个命令还有许多参数，一节课里很难把它们都详细说清楚，希望你课下参考 Docker 自带的帮助或者官网文档（https://docs.docker.com/reference/），再多加实操练习，相信你一定能够成为 Docker 高手。</p>
<p>我这里就对今天的镜像操作和容器操作做个小结：常用的镜像操作有 docker pull、docker images、docker rmi，分别是拉取镜像、查看镜像和删除镜像。用来启动容器的 docker run 是最常用的命令，它有很多参数用来调整容器的运行状态，对于后台服务来说应该使用 -d。docker exec 命令可以在容器内部执行任意程序，对于调试排错特别有用。其他常用的容器操作还有 docker ps、docker stop、docker rm，用来查看容器、停止容器和删除容器。</p>
<h2 id="04创建容器镜像如何编写正确高效的dockerfile">04｜创建容器镜像：如何编写正确、高效的Dockerfile</h2>
<p>上一次的课程里我们一起学习了容器化的应用，也就是被打包成镜像的应用程序，然后再用各种 Docker 命令来运行、管理它们。那么这又会带来一个疑问：这些镜像是怎么创建出来的？我们能不能够制作属于自己的镜像呢？所以今天，我就来讲解镜像的内部机制，还有高效、正确地编写 Dockerfile 制作容器镜像的方法。</p>
<h3 id="镜像的内部机制是什么">镜像的内部机制是什么</h3>
<p>现在你应该知道，镜像就是一个打包文件，里面包含了应用程序还有它运行所依赖的环境，例如文件系统、环境变量、配置参数等等。环境变量、配置参数这些东西还是比较简单的，随便用一个 manifest 清单就可以管理，真正麻烦的是文件系统。为了保证容器运行环境的一致性，镜像必须把应用程序所在操作系统的根目录，也就是 rootfs，都包含进来。虽然这些文件里不包含系统内核（因为容器共享了宿主机的内核），但如果每个镜像都重复做这样的打包操作，仍然会导致大量的冗余。可以想象，如果有一千个镜像，都基于 Ubuntu 系统打包，那么这些镜像里就会重复一千次 Ubuntu 根目录，对磁盘存储、网络传输都是很大的浪费。</p>
<p>很自然的，我们就会想到，应该把重复的部分抽取出来，只存放一份 Ubuntu 根目录文件，然后让这一千个镜像以某种方式共享这部分数据。这个思路，也正是容器镜像的一个重大创新点：分层，术语叫“Layer”。容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“Union FS 联合文件系统”的技术把它们合并在一起，就形成了容器最终看到的文件系统（图片来源）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c7/3f/c750a7795ff4787c6639dd42bf0a473f.png?wh=800x600"
        data-srcset="https://static001.geekbang.org/resource/image/c7/3f/c750a7795ff4787c6639dd42bf0a473f.png?wh=800x600, https://static001.geekbang.org/resource/image/c7/3f/c750a7795ff4787c6639dd42bf0a473f.png?wh=800x600 1.5x, https://static001.geekbang.org/resource/image/c7/3f/c750a7795ff4787c6639dd42bf0a473f.png?wh=800x600 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c7/3f/c750a7795ff4787c6639dd42bf0a473f.png?wh=800x600"
        title="img" /></p>
<p>我来拿大家都熟悉的千层糕做一个形象的比喻吧。千层糕也是由很多层叠加在一起的，从最上面可以看到每层里面镶嵌的葡萄干、核桃、杏仁、青丝等，每一层糕就相当于一个 Layer，干果就好比是 Layer 里的各个文件。但如果某两层的同一个位置都有干果，也就是有文件同名，那么我们就只能看到上层的文件，而下层的就被屏蔽了。你可以用命令 docker inspect 来查看镜像的分层信息，比如 nginx:alpine 镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker inspect nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>它的分层信息在“RootFS”部分：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/5y/b7/5yybd821a12ec1323f6ea8bb5a5c4ab7.png?wh=1920x592"
        data-srcset="https://static001.geekbang.org/resource/image/5y/b7/5yybd821a12ec1323f6ea8bb5a5c4ab7.png?wh=1920x592, https://static001.geekbang.org/resource/image/5y/b7/5yybd821a12ec1323f6ea8bb5a5c4ab7.png?wh=1920x592 1.5x, https://static001.geekbang.org/resource/image/5y/b7/5yybd821a12ec1323f6ea8bb5a5c4ab7.png?wh=1920x592 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/5y/b7/5yybd821a12ec1323f6ea8bb5a5c4ab7.png?wh=1920x592"
        title="img" /></p>
<p>通过这张截图就可以看到，nginx:alpine 镜像里一共有 6 个 Layer。相信你现在也就明白，之前在使用 docker pull、docker rmi 等命令操作镜像的时候，那些“奇怪”的输出信息是什么了，其实就是镜像里的各个 Layer。Docker 会检查是否有重复的层，如果本地已经存在就不会重复下载，如果层被其他镜像共享就不会删除，这样就可以节约磁盘和网络成本。</p>
<h3 id="dockerfile-是什么">Dockerfile 是什么</h3>
<p>知道了容器镜像的内部结构和基本原理，我们就可以来学习如何自己动手制作容器镜像了，也就是自己打包应用。在之前我们讲容器的时候，曾经说过容器就是“小板房”，镜像就是“样板间”。那么，要造出这个“样板间”，就必然要有一个“施工图纸”，由它来规定如何建造地基、铺设水电、开窗搭门等动作。这个“施工图纸”就是“Dockerfile”。比起容器、镜像来说，Dockerfile 非常普通，它就是一个纯文本，里面记录了一系列的构建指令，比如选择基础镜像、拷贝文件、运行脚本等等，每个指令都会生成一个 Layer，而 Docker 顺序执行这个文件里的所有步骤，最后就会创建出一个新的镜像出来。我们来看一个最简单的 Dockerfile 实例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># Dockerfile.busybox
FROM busybox                  # 选择基础镜像
CMD echo &#34;hello world&#34;        # 启动容器时默认运行的命令
</code></pre></td></tr></table>
</div>
</div><p>这个文件里只有两条指令。第一条指令是 FROM，所有的 Dockerfile 都要从它开始，表示选择构建使用的基础镜像，相当于“打地基”，这里我们使用的是 busybox。第二条指令是 CMD，它指定 docker run 启动容器时默认运行的命令，这里我们使用了 echo 命令，输出“hello world”字符串。现在有了 Dockerfile 这张“施工图纸”，我们就可以请出“施工队”了，用 docker build 命令来创建出镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker build -f Dockerfile.busybox .

Sending build context to Docker daemon   7.68kB
Step 1/2 : FROM busybox
 ---&gt; d38589532d97
Step 2/2 : CMD echo &#34;hello world&#34;
 ---&gt; Running in c5a762edd1c8
Removing intermediate container c5a762edd1c8
 ---&gt; b61882f42db7
Successfully built b61882f42db7
</code></pre></td></tr></table>
</div>
</div><p>你需要特别注意命令的格式，用 -f 参数指定 Dockerfile 文件名，后面必须跟一个文件路径，叫做“构建上下文”（build’s context），这里只是一个简单的点号，表示当前路径的意思。接下来，你就会看到 Docker 会逐行地读取并执行 Dockerfile 里的指令，依次创建镜像层，再生成完整的镜像。新的镜像暂时还没有名字（用 docker images 会看到是 &lt; none&gt;），但我们可以直接使用“IMAGE ID”来查看或者运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker inspect b61
docker run b61
</code></pre></td></tr></table>
</div>
</div><h3 id="怎样编写正确高效的-dockerfile">怎样编写正确、高效的 Dockerfile</h3>
<p>大概了解了 Dockerfile 之后，我再来讲讲编写 Dockerfile 的一些常用指令和最佳实践，帮你在今后的工作中把它写好、用好。首先因为构建镜像的第一条指令必须是 FROM，所以基础镜像的选择非常关键。如果关注的是镜像的安全和大小，那么一般会选择 Alpine；如果关注的是应用的运行稳定性，那么可能会选择 Ubuntu、Debian、CentOS。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">FROM alpine:3.15                # 选择Alpine镜像
FROM ubuntu:bionic              # 选择Ubuntu镜像
</code></pre></td></tr></table>
</div>
</div><p>我们在本机上开发测试时会产生一些源码、配置等文件，需要打包进镜像里，这时可以使用 COPY 命令，它的用法和 Linux 的 cp 差不多，不过拷贝的源文件必须是“构建上下文”路径里的，不能随意指定文件。也就是说，如果要从本机向镜像拷贝文件，就必须把这些文件放到一个专门的目录，然后在 docker build 里指定“构建上下文”到这个目录才行。这里有两个 COPY 命令示例，你可以看一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">COPY ./a.txt  /tmp/a.txt    # 把构建上下文里的a.txt拷贝到镜像的/tmp目录
COPY /etc/hosts  /tmp       # 错误！不能使用构建上下文之外的文件
</code></pre></td></tr></table>
</div>
</div><p>接下来要说的就是 Dockerfile 里最重要的一个指令 RUN ，它可以执行任意的 Shell 命令，比如更新系统、安装应用、下载文件、创建目录、编译程序等等，实现任意的镜像构建步骤，非常灵活。RUN 通常会是 Dockerfile 里最复杂的指令，会包含很多的 Shell 命令，但 Dockerfile 里一条指令只能是一行，所以有的 RUN 指令会在每行的末尾使用续行符 \，命令之间也会用 &amp;&amp; 来连接，这样保证在逻辑上是一行，就像下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">RUN apt-get update \
    &amp;&amp; apt-get install -y \
        build-essential \
        curl \
        make \
        unzip \
    &amp;&amp; cd /tmp \
    &amp;&amp; curl -fSL xxx.tar.gz -o xxx.tar.gz\
    &amp;&amp; tar xzf xxx.tar.gz \
    &amp;&amp; cd xxx \
    &amp;&amp; ./config \
    &amp;&amp; make \
    &amp;&amp; make clean
</code></pre></td></tr></table>
</div>
</div><p>有的时候在 Dockerfile 里写这种超长的 RUN 指令很不美观，而且一旦写错了，每次调试都要重新构建也很麻烦，所以你可以采用一种变通的技巧：把这些 Shell 命令集中到一个脚本文件里，用 COPY 命令拷贝进去再用 RUN 来执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">COPY setup.sh  /tmp/                # 拷贝脚本到/tmp目录

RUN cd /tmp &amp;&amp; chmod +x setup.sh \  # 添加执行权限
    &amp;&amp; ./setup.sh &amp;&amp; rm setup.sh    # 运行脚本然后再删除
</code></pre></td></tr></table>
</div>
</div><p>RUN 指令实际上就是 Shell 编程，如果你对它有所了解，就应该知道它有变量的概念，可以实现参数化运行，这在 Dockerfile 里也可以做到，需要使用两个指令 ARG 和 ENV。它们区别在于 ARG 创建的变量只在镜像构建过程中可见，容器运行时不可见，而 ENV 创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用。下面是一个简单的例子，使用 ARG 定义了基础镜像的名字（可以用在“FROM”指令里），使用 ENV 定义了两个环境变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">ARG IMAGE_BASE=&#34;node&#34;
ARG IMAGE_TAG=&#34;alpine&#34;

ENV PATH=$PATH:/tmp
ENV DEBUG=OFF

</code></pre></td></tr></table>
</div>
</div><p>还有一个重要的指令是 EXPOSE，它用来声明容器对外服务的端口号，对现在基于 Node.js、Tomcat、Nginx、Go 等开发的微服务系统来说非常有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">EXPOSE 443           # 默认是tcp协议
EXPOSE 53/udp        # 可以指定udp协议
</code></pre></td></tr></table>
</div>
</div><p>讲了这些 Dockerfile 指令之后，我还要特别强调一下，因为每个指令都会生成一个镜像层，所以 Dockerfile 里最好不要滥用指令，尽量精简合并，否则太多的层会导致镜像臃肿不堪。</p>
<h3 id="docker-build-是怎么工作的">docker build 是怎么工作的</h3>
<p>Dockerfile 必须要经过 docker build 才能生效，所以我们再来看看 docker build 的详细用法。刚才在构建镜像的时候，你是否对“构建上下文”这个词感到有些困惑呢？它到底是什么含义呢？我觉得用 Docker 的官方架构图来理解会比较清楚（注意图中与“docker build”关联的虚线）。因为命令行“docker”是一个简单的客户端，真正的镜像构建工作是由服务器端的“Docker daemon”来完成的，所以“docker”客户端就只能把“构建上下文”目录打包上传（显示信息 Sending build context to Docker daemon ），这样服务器才能够获取本地的这些文件。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        data-srcset="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 1.5x, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        title="img" /></p>
<p>明白了这一点，你就会知道，“构建上下文”其实与 Dockerfile 并没有直接的关系，它其实指定了要打包进镜像的一些依赖文件。而 COPY 命令也只能使用基于“构建上下文”的相对路径，因为“Docker daemon”看不到本地环境，只能看到打包上传的那些文件。但这个机制也会导致一些麻烦，如果目录里有的文件（例如 readme/.git/.svn 等）不需要拷贝进镜像，docker 也会一股脑地打包上传，效率很低。为了避免这种问题，你可以在“构建上下文”目录里再建立一个 .dockerignore 文件，语法与 .gitignore 类似，排除那些不需要的文件。下面是一个简单的示例，表示不打包上传后缀是“swp”“sh”的文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># docker ignore
*.swp
*.sh
</code></pre></td></tr></table>
</div>
</div><p>另外关于 Dockerfile，一般应该在命令行里使用 -f 来显式指定。但如果省略这个参数，docker build 就会在当前目录下找名字是 Dockerfile 的文件。所以，如果只有一个构建目标的话，文件直接叫“Dockerfile”是最省事的。现在我们使用 docker build 应该就没什么难点了，不过构建出来的镜像只有“IMAGE ID”没有名字，不是很方便。为此你可以加上一个 -t 参数，也就是指定镜像的标签（tag），这样 Docker 就会在构建完成后自动给镜像添加名字。当然，名字必须要符合上节课里的命名规范，用 : 分隔名字和标签，如果不提供标签默认就是“latest”。</p>
<h3 id="小结-4">小结</h3>
<p>了，今天我们一起学习了容器镜像的内部结构，重点理解容器镜像是由多个只读的 Layer 构成的，同一个 Layer 可以被不同的镜像共享，减少了存储和传输的成本。如何编写 Dockerfile 内容稍微多一点，我再简单做个小结：</p>
<p>创建镜像需要编写 Dockerfile，写清楚创建镜像的步骤，每个指令都会生成一个 Layer。Dockerfile 里，第一个指令必须是 FROM，用来选择基础镜像，常用的有 Alpine、Ubuntu 等。其他常用的指令有：COPY、RUN、EXPOSE，分别是拷贝文件，运行 Shell 命令，声明服务端口号。docker build 需要用 -f 来指定 Dockerfile，如果不指定就使用当前目录下名字是“Dockerfile”的文件。docker build 需要指定“构建上下文”，其中的文件会打包上传到 Docker daemon，所以尽量不要在“构建上下文”中存放多余的文件。创建镜像的时候应当尽量使用 -t 参数，为镜像起一个有意义的名字，方便管理。</p>
<p>今天讲了不少，但关于创建镜像还有很多高级技巧等待你去探索，比如使用缓存、多阶段构建等等，你可以再参考 Docker 官方文档（https://docs.docker.com/engine/reference/builder/），或者一些知名应用的镜像（如 Nginx、Redis、Node.js 等）进一步学习。</p>
<h2 id="05镜像仓库该怎样用好docker-hub这个宝藏">05｜镜像仓库：该怎样用好Docker Hub这个宝藏</h2>
<p>上一次课里我们学习了“Dockerfile”和“docker build”的用法，知道了如何创建自己的镜像。那么镜像文件应该如何管理呢，具体来说，应该如何存储、检索、分发、共享镜像呢？不解决这些问题，我们的容器化应用还是无法顺利地实施。今天，我就来谈一下这个话题，聊聊什么是镜像仓库，还有该怎么用好镜像仓库。</p>
<h3 id="什么是镜像仓库registry">什么是镜像仓库（Registry）</h3>
<p>之前我们已经用过 docker pull 命令拉取镜像，也说过有一个“镜像仓库”（Registry）的概念，那到底什么是镜像仓库呢？还是来看 Docker 的官方架构图（它真的非常重要）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        data-srcset="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 1.5x, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        title="img" /></p>
<p>图里右边的区域就是镜像仓库，术语叫 Registry，直译就是“注册中心”，意思是所有镜像的 Repository 都在这里登记保管，就像是一个巨大的档案馆。然后我们再来看左边的“docker pull”，虚线显示了它的工作流程，先到“Docker daemon”，再到 Registry，只有当 Registry 里存有镜像才能真正把它下载到本地。当然了，拉取镜像只是镜像仓库最基本的一个功能，它还会提供更多的功能，比如上传、查询、删除等等，是一个全面的镜像管理服务站点。你也可以把镜像仓库类比成手机上的应用商店，里面分门别类存放了许多容器化的应用，需要什么去找一下就行了。有了它，我们使用镜像才能够免除后顾之忧。</p>
<h3 id="什么是-docker-hub">什么是 Docker Hub</h3>
<p>不过，你有没有注意到，在使用 docker pull 获取镜像的时候，我们并没有明确地指定镜像仓库。在这种情况下，Docker 就会使用一个默认的镜像仓库，也就是大名鼎鼎的“Docker Hub”（https://hub.docker.com/）。Docker Hub 是 Docker 公司搭建的官方 Registry 服务，创立于 2014 年 6 月，和 Docker 1.0 同时发布。它号称是世界上最大的镜像仓库，和 GitHub 一样，几乎成为了容器世界的基础设施。Docker Hub 里面不仅有 Docker 自己打包的镜像，而且还对公众免费开放，任何人都可以上传自己的作品。经过这 8 年的发展，Docker Hub 已经不再是一个单纯的镜像仓库了，更应该说是一个丰富而繁荣的容器社区。你可以看看下面的这张截图，里面列出的都是下载量超过 10 亿次（1 Billion）的最受欢迎的应用程序，比如 Nginx、MongoDB、Node.js、Redis、OpenJDK 等等。显然，把这些容器化的应用引入到我们自己的系统里，就像是站在了巨人的肩膀上，一开始就会有一个高水平的起点。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/d4/e3/d47cc4d3f867069b055a47628acac2e3.png?wh=1920x890"
        data-srcset="https://static001.geekbang.org/resource/image/d4/e3/d47cc4d3f867069b055a47628acac2e3.png?wh=1920x890, https://static001.geekbang.org/resource/image/d4/e3/d47cc4d3f867069b055a47628acac2e3.png?wh=1920x890 1.5x, https://static001.geekbang.org/resource/image/d4/e3/d47cc4d3f867069b055a47628acac2e3.png?wh=1920x890 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/d4/e3/d47cc4d3f867069b055a47628acac2e3.png?wh=1920x890"
        title="img" /></p>
<p>但和 GitHub、App Store 一样，面向所有人公开的 Docker Hub 也有一个不可避免的缺点，就是“良莠不齐”。在 Docker Hub 搜索框里输入关键字，比如 Nginx、MySQL，它立即就会给出几百几千个搜索结果，有点“乱花迷人眼”的感觉，这么多镜像，应该如何挑选出最适合自己的呢？下面我就来说说自己在这方面的一些经验。</p>
<h3 id="如何在-docker-hub-上挑选镜像">如何在 Docker Hub 上挑选镜像</h3>
<p>首先，你应该知道，在 Docker Hub 上有官方镜像、认证镜像和非官方镜像的区别。官方镜像是指 Docker 公司官方提供的高质量镜像（https://github.com/docker-library/official-images），都经过了严格的漏洞扫描和安全检测，支持 x86_64、arm64 等多种硬件架构，还具有清晰易读的文档，一般来说是我们构建镜像的首选，也是我们编写 Dockerfile 的最佳范例。官方镜像目前有大约 100 多个，基本上囊括了现在的各种流行技术，下面就是官方的 Nginx 镜像网页截图：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/10/f3/109fc664da4f5124c4758b0e8f9c95f3.png?wh=1376x754"
        data-srcset="https://static001.geekbang.org/resource/image/10/f3/109fc664da4f5124c4758b0e8f9c95f3.png?wh=1376x754, https://static001.geekbang.org/resource/image/10/f3/109fc664da4f5124c4758b0e8f9c95f3.png?wh=1376x754 1.5x, https://static001.geekbang.org/resource/image/10/f3/109fc664da4f5124c4758b0e8f9c95f3.png?wh=1376x754 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/10/f3/109fc664da4f5124c4758b0e8f9c95f3.png?wh=1376x754"
        title="img" /></p>
<p>你会看到，官方镜像会有一个特殊的“Official image”的标记，这就表示这个镜像经过了 Docker 公司的认证，有专门的团队负责审核、发布和更新，质量上绝对可以放心。第二类是认证镜像，标记是“Verified publisher”，也就是认证发行商，比如 Bitnami、Rancher、Ubuntu 等。它们都是颇具规模的大公司，具有不逊于 Docker 公司的实力，所以就在 Docker Hub 上开了个认证账号，发布自己打包的镜像，有点类似我们微博上的“大 V”。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/57/f2/576d07439fc85d2bc461953f31a084f2.png?wh=1058x542"
        data-srcset="https://static001.geekbang.org/resource/image/57/f2/576d07439fc85d2bc461953f31a084f2.png?wh=1058x542, https://static001.geekbang.org/resource/image/57/f2/576d07439fc85d2bc461953f31a084f2.png?wh=1058x542 1.5x, https://static001.geekbang.org/resource/image/57/f2/576d07439fc85d2bc461953f31a084f2.png?wh=1058x542 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/57/f2/576d07439fc85d2bc461953f31a084f2.png?wh=1058x542"
        title="img" /></p>
<p>这些镜像有公司背书，当然也很值得信赖，不过它们难免会带上一些各自公司的“烙印”，比如 Bitnami 的镜像就统一以“minideb”为基础，灵活性上比 Docker 官方镜像略差，有的时候也许会不符合我们的需求。除了官方镜像和认证镜像，剩下的就都属于非官方镜像了，不过这里面也可以分出两类。第一类是“半官方”镜像。因为成为“Verified publisher”是要给 Docker 公司交钱的，而很多公司不想花这笔“冤枉钱”，所以只在 Docker Hub 上开了公司账号，但并不加入认证。这里我以 OpenResty 为例，看一下它的 Docker Hub 页面，可以看到显示的是 OpenResty 官方发布，但并没有经过 Docker 正式认证，所以难免就会存在一些风险，有被“冒名顶替”的可能，需要我们在使用的时候留心鉴别一下。不过一般来说，这种“半官方”镜像也是比较可靠的。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/6d/3c/6d94d351137fb72cab36d73e8eea1f3c.png?wh=1496x566"
        data-srcset="https://static001.geekbang.org/resource/image/6d/3c/6d94d351137fb72cab36d73e8eea1f3c.png?wh=1496x566, https://static001.geekbang.org/resource/image/6d/3c/6d94d351137fb72cab36d73e8eea1f3c.png?wh=1496x566 1.5x, https://static001.geekbang.org/resource/image/6d/3c/6d94d351137fb72cab36d73e8eea1f3c.png?wh=1496x566 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/6d/3c/6d94d351137fb72cab36d73e8eea1f3c.png?wh=1496x566"
        title="img" /></p>
<p>第二类就是纯粹的“民间”镜像了，通常是个人上传到 Docker Hub 的，因为条件所限，测试不完全甚至没有测试，质量上难以得到保证，下载的时候需要小心谨慎。除了查看镜像是否为官方认证，我们还应该再结合其他的条件来判断镜像质量是否足够好。做法和 GitHub 差不多，就是看它的下载量、星数、还有更新历史，简单来说就是“好评”数量。一般来说下载量是最重要的参考依据，好的镜像下载量通常都在百万级别（超过 1M），而有的镜像虽然也是官方认证，但缺乏维护，更新不及时，用的人很少，星数、下载数都寥寥无几，那么还是应该选择下载量最多的镜像，通俗来说就是“随大流”。下面的这张截图就是 OpenResty 在 Docker Hub 上的搜索结果。可以看到，有两个认证发行商的镜像（Bitnami、IBM），但下载量都很少，还有一个“民间”镜像下载量虽然超过了 1M，但更新时间是 3 年前，所以毫无疑问，我们应该选择排在第三位，但下载量超过 10M、有 360 多个星的“半官方”镜像。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/5c/93/5c0b39da3bba66955e2byydcbe0d8593.png?wh=1878x1530"
        data-srcset="https://static001.geekbang.org/resource/image/5c/93/5c0b39da3bba66955e2byydcbe0d8593.png?wh=1878x1530, https://static001.geekbang.org/resource/image/5c/93/5c0b39da3bba66955e2byydcbe0d8593.png?wh=1878x1530 1.5x, https://static001.geekbang.org/resource/image/5c/93/5c0b39da3bba66955e2byydcbe0d8593.png?wh=1878x1530 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/5c/93/5c0b39da3bba66955e2byydcbe0d8593.png?wh=1878x1530"
        title="img" /></p>
<p>看了这么多 Docker Hub 上的镜像，你一定注意到了，应用都是一样的名字，比如都是 Nginx、Redis、OpenResty，该怎么区分不同作者打包出的镜像呢？如果你熟悉 GitHub，就会发现 Docker Hub 也使用了同样的规则，就是“用户名 / 应用名”的形式，比如 bitnami/nginx、ubuntu/nginx、rancher/nginx 等等。所以，我们在使用 docker pull 下载这些非官方镜像的时候，就必须把用户名也带上，否则默认就会使用官方镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull bitnami/nginx
docker pull ubuntu/nginx
</code></pre></td></tr></table>
</div>
</div><h3 id="docker-hub-上镜像命名的规则是什么">Docker Hub 上镜像命名的规则是什么</h3>
<p>确定了要使用的镜像还不够，因为镜像还会有许多不同的版本，也就是“标签”（tag）。直接使用默认的“latest”虽然简单方便，但在生产环境里是一种非常不负责任的做法，会导致版本不可控。所以我们还需要理解 Docker Hub 上标签命名的含义，才能够挑选出最适合我们自己的镜像版本。下面我就拿官方的 Redis 镜像作为例子，解释一下这些标签都是什么意思。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/1d/d5/1dd392b8f286507b83cd31400d5dccd5.png?wh=1796x846"
        data-srcset="https://static001.geekbang.org/resource/image/1d/d5/1dd392b8f286507b83cd31400d5dccd5.png?wh=1796x846, https://static001.geekbang.org/resource/image/1d/d5/1dd392b8f286507b83cd31400d5dccd5.png?wh=1796x846 1.5x, https://static001.geekbang.org/resource/image/1d/d5/1dd392b8f286507b83cd31400d5dccd5.png?wh=1796x846 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/1d/d5/1dd392b8f286507b83cd31400d5dccd5.png?wh=1796x846"
        title="img" /></p>
<p>通常来说，镜像标签的格式是应用的版本号加上操作系统。版本号你应该比较了解吧，基本上都是主版本号 + 次版本号 + 补丁号的形式，有的还会在正式发布前出 rc 版（候选版本，release candidate）。而操作系统的情况略微复杂一些，因为各个 Linux 发行版的命名方式“花样”太多了。Alpine、CentOS 的命名比较简单明了，就是数字的版本号，像这里的 alpine3.15 ，而 Ubuntu、Debian 则采用了代号的形式。比如 Ubuntu 18.04 是 bionic，Ubuntu 20.04 是 focal，Debian 9 是 stretch，Debian 10 是 buster，Debian 11 是 bullseye。另外，有的标签还会加上 slim、fat，来进一步表示这个镜像的内容是经过精简的，还是包含了较多的辅助工具。通常 slim 镜像会比较小，运行效率高，而 fat 镜像会比较大，适合用来开发调试。</p>
<p>下面我就列出几个标签的例子来说明一下。nginx:1.21.6-alpine，表示版本号是 1.21.6，基础镜像是最新的 Alpine。redis:7.0-rc-bullseye，表示版本号是 7.0 候选版，基础镜像是 Debian 11。node:17-buster-slim，表示版本号是 17，基础镜像是精简的 Debian 10。</p>
<h3 id="该怎么上传自己的镜像">该怎么上传自己的镜像</h3>
<p>现在，我想你应该对如何在 Docker Hub 上选择镜像有了比较全面的了解，那么接下来的问题就是，我们自己用 Dockerfile 创建的镜像该如何上传到 Docker Hub 上呢？这件事其实一点也不难，只需要 4 个步骤就能完成。第一步，你需要在 Docker Hub 上注册一个用户，这个就不必再多说了。第二步，你需要在本机上使用 docker login 命令，用刚才注册的用户名和密码认证身份登录，像这里就用了我的用户名“chronolaw”：</p>
<p>第三步很关键，需要使用 docker tag 命令，给镜像改成带用户名的完整名字，表示镜像是属于这个用户的。或者简单一点，直接用 docker build -t 在创建镜像的时候就起好名字。这里我就用上次课里的镜像“ngx-app”作为例子，给它改名成 chronolaw/ngx-app:1.0：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker tag ngx-app chronolaw/ngx-app:1.0
</code></pre></td></tr></table>
</div>
</div><p>第四步，用 docker push 把这个镜像推上去，我们的镜像发布工作就大功告成了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker push chronolaw/ngx-app:1.0
</code></pre></td></tr></table>
</div>
</div><p>你还可以登录 Docker Hub 网站验证一下镜像发布的效果，可以看到它会自动为我们生成一个页面模板，里面还可以进一步丰富完善，比如添加描述信息、使用说明等等：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/76/d1/76f1f566c029d2a3743d79d80cdeddd1.png?wh=1920x715"
        data-srcset="https://static001.geekbang.org/resource/image/76/d1/76f1f566c029d2a3743d79d80cdeddd1.png?wh=1920x715, https://static001.geekbang.org/resource/image/76/d1/76f1f566c029d2a3743d79d80cdeddd1.png?wh=1920x715 1.5x, https://static001.geekbang.org/resource/image/76/d1/76f1f566c029d2a3743d79d80cdeddd1.png?wh=1920x715 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/76/d1/76f1f566c029d2a3743d79d80cdeddd1.png?wh=1920x715"
        title="img" /></p>
<p>现在你就可以把这个镜像的名字（用户名 / 应用名: 标签）告诉你的同事，让他去用 docker pull 下载部署了。</p>
<h3 id="离线环境该怎么办">离线环境该怎么办</h3>
<p>使用 Docker Hub 来管理镜像的确是非常方便，不过有一种场景下它却是无法发挥作用，那就是企业内网的离线环境，连不上外网，自然也就不能使用 docker push、docker pull  来推送拉取镜像了。那这种情况有没有解决办法呢？方法当然有，而且有很多。最佳的方法就是在内网环境里仿造 Docker Hub，创建一个自己的私有 Registry 服务，由它来管理我们的镜像，就像我们自己搭建 GitLab 做版本管理一样。自建 Registry 已经有很多成熟的解决方案，比如 Docker Registry，还有 CNCF Harbor，不过使用它们还需要一些目前没有讲到的知识，步骤也有点繁琐，所以我会在后续的课程里再介绍。下面我讲讲存储、分发镜像的一种“笨”办法，虽然比较“原始”，但简单易行，可以作为临时的应急手段。Docker 提供了 save 和 load 这两个镜像归档命令，可以把镜像导出成压缩包，或者从压缩包导入 Docker，而压缩包是非常容易保管和传输的，可以联机拷贝，FTP 共享，甚至存在 U 盘上随身携带。</p>
<p>需要注意的是，这两个命令默认使用标准流作为输入输出（为了方便 Linux 管道操作），所以一般会用 -o、-i 参数来使用文件的形式，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker save ngx-app:latest -o ngx.tar
docker load -i ngx.tar
</code></pre></td></tr></table>
</div>
</div><h3 id="小结-5">小结</h3>
<p>好了，今天我们一起学习了镜像仓库，了解了 Docker Hub 的使用方法，整理一下要点方便你加深理解：镜像仓库（Registry）是一个提供综合镜像服务的网站，最基本的功能是上传和下载。Docker Hub 是目前最大的镜像仓库，拥有许多高质量的镜像。上面的镜像非常多，选择的标准有官方认证、下载量、星数等，需要综合评估。镜像也有很多版本，应该根据版本号和操作系统仔细确认合适的标签。在 Docker Hub 注册之后就可以上传自己的镜像，用 docker tag 打上标签再用 docker push 推送。离线环境可以自己搭建私有镜像仓库，或者使用 docker save 把镜像存成压缩包，再用 docker load 从压缩包恢复成镜像。</p>
<h2 id="06打破次元壁容器该如何与外界互联互通">06｜打破次元壁：容器该如何与外界互联互通</h2>
<p>在前面的几节课里，我们已经学习了容器、镜像、镜像仓库的概念和用法，也知道了应该如何创建镜像，再以容器的形式启动应用。不过，用容器来运行“busybox”“hello world”这样比较简单的应用还好，如果是 Nginx、Redis、MySQL 这样的后台服务应用，因为它们运行在容器的“沙盒”里，完全与外界隔离，无法对外提供服务，也就失去了价值。这个时候，容器的隔离环境反而成为了一种负面特性。所以，容器的这个“小板房”不应该是一个完全密闭的铁屋子，而是应该给它开几扇门窗，让应用在“足不出户”的情况下，也能够与外界交换数据、互通有无，这样“有限的隔离”才是我们真正所需要的运行环境。那么今天，我就以 Docker 为例，来讲讲有哪些手段能够在容器与外部系统之间沟通交流。</p>
<h3 id="如何拷贝容器内的数据">如何拷贝容器内的数据</h3>
<p>我们首先来看看 Docker 提供的 cp 命令，它可以在宿主机和容器之间拷贝文件，是最基本的一种数据交换功能。试验这个命令需要先用 docker run 启动一个容器，就用 Redis 吧：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm redis
</code></pre></td></tr></table>
</div>
</div><p>注意这里使用了 -d、&ndash;rm 两个参数，表示运行在后台，容器结束后自动删除，然后使用 docker ps 命令可以看到 Redis 容器正在运行，容器 ID 是“062”。docker cp 的用法很简单，很类似 Linux 的“cp”“scp”，指定源路径（src path）和目标路径（dest path）就可以了。如果源路径是宿主机那么就是把文件拷贝进容器，如果源路径是容器那么就是把文件拷贝出容器，注意需要用容器名或者容器 ID 来指明是哪个容器的路径。假设当前目录下有一个“a.txt”的文件，现在我们要把它拷贝进 Redis 容器的“/tmp”目录，如果使用容器 ID，命令就会是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker cp a.txt 062:/tmp
</code></pre></td></tr></table>
</div>
</div><p>接下来我们可以使用 docker exec 命令，进入容器看看文件是否已经正确拷贝了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker exec -it 062 sh
</code></pre></td></tr></table>
</div>
</div><p>可以看到，在“/tmp”目录下，确实已经有了一个“a.txt”。现在让我们再来试验一下从容器拷贝出文件，只需要把 docker cp 后面的两个路径调换一下位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker cp 062:/tmp/a.txt ./b.txt
</code></pre></td></tr></table>
</div>
</div><p>这样，在宿主机的当前目录里，就会多出一个新的“b.txt”，也就是从容器里拿到的文件。</p>
<h3 id="如何共享主机上的文件">如何共享主机上的文件</h3>
<p>docker cp 的用法模仿了操作系统的拷贝命令，偶尔一两次的文件共享还可以应付，如果容器运行时经常有文件来往互通，这样反复地拷来拷去就显得很麻烦，也很容易出错。你也许会联想到虚拟机有一种“共享目录”的功能。它可以在宿主机上开一个目录，然后把这个目录“挂载”进虚拟机，这样就实现了两者共享同一个目录，一边对目录里文件的操作另一边立刻就能看到，没有了数据拷贝，效率自然也会高很多。沿用这个思路，容器也提供了这样的共享宿主机目录的功能，效果也和虚拟机几乎一样，用起来很方便，只需要在 docker run 命令启动容器的时候使用 -v 参数就行，具体的格式是“宿主机路径: 容器内路径”。</p>
<p>我还是以 Redis 为例，启动容器，使用 -v 参数把本机的“/tmp”目录挂载到容器里的“/tmp”目录，也就是说让容器共享宿主机的“/tmp”目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm -v /tmp:/tmp redis
</code></pre></td></tr></table>
</div>
</div><p>然后我们再用 docker exec 进入容器，查看一下容器内的“/tmp”目录，应该就可以看到文件与宿主机是完全一致的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker exec -it b5a sh    # b5a是容器ID
</code></pre></td></tr></table>
</div>
</div><p>你也可以在容器里的“/tmp”目录下随便做一些操作，比如删除文件、建立新目录等等，再回头观察一下宿主机，会发现修改会即时同步，这就表明容器和宿主机确实已经共享了这个目录。-v 参数挂载宿主机目录的这个功能，对于我们日常开发测试工作来说非常有用，我们可以在不变动本机环境的前提下，使用镜像安装任意的应用，然后直接以容器来运行我们本地的源码、脚本，非常方便。这里我举一个简单的例子。比如我本机上只有 Python 2.7，但我想用 Python 3 开发，如果同时安装 Python 2 和 Python 3 很容易就会把系统搞乱，所以我就可以这么做：</p>
<p>先使用 docker pull 拉取一个 Python 3 的镜像，因为它打包了完整的运行环境，运行时有隔离，所以不会对现有系统的 Python 2.7 产生任何影响。在本地的某个目录编写 Python 代码，然后用 -v 参数让容器共享这个目录。现在就可以在容器里以 Python 3 来安装各种包，再运行脚本做开发了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">docker</span><span class="w"> </span><span class="n">pull</span><span class="w"> </span><span class="n">python</span><span class="p">:</span><span class="n">alpine</span><span class="w">
</span><span class="w"></span><span class="n">docker</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">-</span><span class="n">it</span><span class="w"> </span><span class="o">--</span><span class="n">rm</span><span class="w"> </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="o">`</span><span class="n">pwd</span><span class="o">`</span><span class="p">:</span><span class="o">/</span><span class="n">tmp</span><span class="w"> </span><span class="n">python</span><span class="p">:</span><span class="n">alpine</span><span class="w"> </span><span class="n">sh</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>显然，这种方式比把文件打包到镜像或者 docker cp 会更加灵活，非常适合有频繁修改的开发测试工作。</p>
<h3 id="如何实现网络互通">如何实现网络互通</h3>
<p>现在我们使用 docker cp 和 docker run -v 可以解决容器与外界的文件互通问题，但对于 Nginx、Redis 这些服务器来说，网络互通才是更要紧的问题。网络互通的关键在于“打通”容器内外的网络，而处理网络通信无疑是计算机系统里最棘手的工作之一，有许许多多的名词、协议、工具，在这里我也没有办法一下子就把它都完全说清楚，所以只能从“宏观”层面讲个大概，帮助你快速理解。</p>
<p>Docker 提供了三种网络模式，分别是 null、host 和 bridge。null 是最简单的模式，也就是没有网络，但允许其他的网络插件来自定义网络连接，这里就不多做介绍了。host 的意思是直接使用宿主机网络，相当于去掉了容器的网络隔离（其他隔离依然保留），所有的容器会共享宿主机的 IP 地址和网卡。这种模式没有中间层，自然通信效率高，但缺少了隔离，运行太多的容器也容易导致端口冲突。host 模式需要在 docker run 时使用 &ndash;net=host 参数，下面我就用这个参数启动 Nginx：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm --net=host nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>为了验证效果，我们可以在本机和容器里分别执行 ip addr 命令，查看网卡信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">ip addr                    # 本机查看网卡
docker exec xxx ip addr    # 容器查看网卡
</code></pre></td></tr></table>
</div>
</div><p>可以看到这两个 ip addr 命令的输出信息是完全一样的，比如都是一个网卡 ens160，IP 地址是“192.168.10.208”，这就证明 Nginx 容器确实与本机共享了网络栈。第三种 bridge，也就是桥接模式，它有点类似现实世界里的交换机、路由器，只不过是由软件虚拟出来的，容器和宿主机再通过虚拟网卡接入这个网桥（图中的 docker0），那么它们之间也就可以正常的收发网络数据包了。不过和 host 模式相比，bridge 模式多了虚拟网桥和网卡，通信效率会低一些。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/6e/60/6e0d05cf19720f44ca68f88238627460.jpg?wh=1920x1407"
        data-srcset="https://static001.geekbang.org/resource/image/6e/60/6e0d05cf19720f44ca68f88238627460.jpg?wh=1920x1407, https://static001.geekbang.org/resource/image/6e/60/6e0d05cf19720f44ca68f88238627460.jpg?wh=1920x1407 1.5x, https://static001.geekbang.org/resource/image/6e/60/6e0d05cf19720f44ca68f88238627460.jpg?wh=1920x1407 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/6e/60/6e0d05cf19720f44ca68f88238627460.jpg?wh=1920x1407"
        title="img" /></p>
<p>和 host 模式一样，我们也可以用 &ndash;net=bridge 来启用桥接模式，但其实并没有这个必要，因为 Docker 默认的网络模式就是 bridge，所以一般不需要显式指定。下面我们启动两个容器 Nginx 和 Redis，就像刚才说的，没有特殊指定就会使用 bridge 模式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm nginx:alpine    # 默认使用桥接模式
docker run -d --rm redis           # 默认使用桥接模式
</code></pre></td></tr></table>
</div>
</div><p>然后我们还是在本机和容器里执行 ip addr 命令（Redis 容器里没有 ip 命令，所以只能在 Nginx 容器里执行）</p>
<p>对比一下刚才 host 模式的输出，就可以发现容器里的网卡设置与宿主机完全不同，eth0 是一个虚拟网卡，IP 地址是 B 类私有地址“172.17.0.2”。我们还可以用 docker inspect 直接查看容器的 ip 地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker inspect xxx |grep IPAddress
</code></pre></td></tr></table>
</div>
</div><p>这显示出两个容器的 IP 地址分别是“172.17.0.2”和“172.17.0.3”，而宿主机的 IP 地址则是“172.17.0.1”，所以它们都在“172.17.0.0/16”这个 Docker 的默认网段，彼此之间就能够使用 IP 地址来实现网络通信了。</p>
<h3 id="如何分配服务端口号">如何分配服务端口号</h3>
<p>使用 host 模式或者 bridge 模式，我们的容器就有了 IP 地址，建立了与外部世界的网络连接，接下来要解决的就是网络服务的端口号问题。你一定知道，服务器应用都必须要有端口号才能对外提供服务，比如 HTTP 协议用 80、HTTPS 用 443、Redis 是 6379、MySQL 是 3306。第 4 讲我们在学习编写 Dockerfile 的时候也看到过，可以用 EXPOSE 指令声明容器对外的端口号。一台主机上的端口号数量是有限的，而且多个服务之间还不能够冲突，但我们打包镜像应用的时候通常都使用的是默认端口，容器实际运行起来就很容易因为端口号被占用而无法启动。</p>
<p>解决这个问题的方法就是加入一个“中间层”，由容器环境例如 Docker 来统一管理分配端口号，在本机端口和容器端口之间做一个“映射”操作，容器内部还是用自己的端口号，但外界看到的却是另外一个端口号，这样就很好地避免了冲突。端口号映射需要使用 bridge 模式，并且在 docker run 启动容器时使用 -p 参数，形式和共享目录的 -v 参数很类似，用 : 分隔本机端口和容器端口。比如，如果要启动两个 Nginx 容器，分别跑在 80 和 8080 端口上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d -p 80:80 --rm nginx:alpine
docker run -d -p 8080:80 --rm nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>这样就把本机的 80 和 8080 端口分别“映射”到了两个容器里的 80 端口，不会发生冲突，我们可以用 curl 再验证一下：</p>
<p>使用 docker ps 命令能够在“PORTS”栏里更直观地看到端口的映射情况：</p>
<h3 id="小结-6">小结</h3>
<p>好了，今天我们一起学习了容器与外部系统之间沟通交流的几种方法。你会发现，这些方法几乎消除了容器化的应用和本地应用因为隔离特性而产生的差异，而因为镜像独特的打包机制，容器技术显然能够比 apt/yum 更方便地安装各种应用，绝不会“污染”已有的系统。今天的课里我列举了 Python、Nginx 等例子，你还可以举一反三，借鉴它们把本地配置文件加载到容器里适当的位置，再映射端口号，把 Redis、MySQL、Node.js 都运行起来，让容器成为我们工作中的得力助手。照例简单小结一下这次的要点：</p>
<p>docker cp 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换。docker run -v 命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率。host 网络模式让容器与主机共享网络栈，效率高但容易导致端口冲突。bridge 网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通。docker run -p 命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突问题。</p>
<h2 id="07实战演练玩转docker">07｜实战演练：玩转Docker</h2>
<p>要提醒你的是，Docker 相关的内容很多很广，在入门篇中，我只从中挑选出了一些最基本最有用的介绍给你。而且在我看来，我们不需要完全了解 Docker 的所有功能，我也不建议你对 Docker 的内部架构细节和具体的命令行参数做过多的了解，太浪费精力，只要会用够用，需要的时候能够查找官方手册就行。毕竟我们这门课程的目标是 Kubernetes，而 Docker 只不过是众多容器运行时（Container Runtime）中最出名的一款而已。当然，如果你当前的工作是与 Docker 深度绑定，那就另当别论了。好下面我先把容器技术做一个简要的总结，然后演示两个实战项目：使用 Docker 部署 Registry 和 WordPress。</p>
<h3 id="容器技术要点回顾">容器技术要点回顾</h3>
<p>容器技术是后端应用领域的一项重大创新，它彻底变革了应用的开发、交付与部署方式，是“云原生”的根本（01 讲）。容器基于 Linux 底层的 namespace、cgroup、chroot 等功能，虽然它们很早就出现了，但直到 Docker“横空出世”，把它们整合在一起，容器才真正走近了大众的视野，逐渐为广大开发者所熟知（02 讲）。容器技术中有三个核心概念：容器（Container）、镜像（Image），以及镜像仓库（Registry）（03 讲）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        data-srcset="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 1.5x, https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/c8/fe/c8116066bdbf295a7c9fc25b87755dfe.jpg?wh=1920x1048"
        title="img" /></p>
<p>从本质上来说，容器属于虚拟化技术的一种，和虚拟机（Virtual Machine）很类似，都能够分拆系统资源，隔离应用进程，但容器更加轻量级，运行效率更高，比虚拟机更适合云计算的需求。镜像是容器的静态形式，它把应用程序连同依赖的操作系统、配置文件、环境变量等等都打包到了一起，因而能够在任何系统上运行，免除了很多部署运维和平台迁移的麻烦。镜像内部由多个层（Layer）组成，每一层都是一组文件，多个层会使用 Union FS 技术合并成一个文件系统供容器使用。这种细粒度结构的好处是相同的层可以共享、复用，节约磁盘存储和网络传输的成本，也让构建镜像的工作变得更加容易（04 讲）。为了方便管理镜像，就出现了镜像仓库，它集中存放各种容器化的应用，用户可以任意上传下载，是分发镜像的最佳方式（05 讲）。目前最知名的公开镜像仓库是 Docker Hub，其他的还有 quay.io、gcr.io，我们可以在这些网站上找到许多高质量镜像，集成到我们自己的应用系统中。容器技术有很多具体的实现，Docker 是最初也是最流行的容器技术，它的主要形态是运行在 Linux 上的“Docker Engine”。我们日常使用的 docker 命令其实只是一个前端工具，它必须与后台服务“Docker daemon”通信才能实现各种功能。操作容器的常用命令有 docker ps、docker run、docker exec、docker stop 等；操作镜像的常用命令有 docker images、docker rmi、docker build、docker tag 等；操作镜像仓库的常用命令有 docker pull、docker push 等。好简单地回顾了容器技术，下面我们就来综合运用在“入门篇”所学到的各个知识点，开始实战演练，玩转 Docker。</p>
<h3 id="搭建私有镜像仓库">搭建私有镜像仓库</h3>
<p>在第 5 节课讲 Docker Hub 的时候曾经说过，在离线环境里，我们可以自己搭建私有仓库。但因为镜像仓库是网络服务的形式，当时还没有学到容器网络相关的知识，所以只有到了现在，我们具备了比较完整的 Docker 知识体系，才能够搭建私有仓库。私有镜像仓库有很多现成的解决方案，今天我只选择最简单的 Docker Registry，而功能更完善的 CNCF Harbor 留到后续学习 Kubernetes 时再介绍。你可以在 Docker Hub 网站上搜索“registry”，找到它的官方页面（https://registry.hub.docker.com/_/registry/）：</p>
<p>Docker Registry 的网页上有很详细的说明，包括下载命令、用法等，我们可以完全照着它来操作。首先，你需要使用 docker pull 命令拉取镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull registry
</code></pre></td></tr></table>
</div>
</div><p>然后，我们需要做一个端口映射，对外暴露端口，这样 Docker Registry 才能提供服务。它的容器内端口是 5000，简单起见，我们在外面也使用同样的 5000 端口，所以运行命令就是 docker run -d -p 5000:5000 registry ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d -p 5000:5000 registry

</code></pre></td></tr></table>
</div>
</div><p>启动 Docker Registry 之后，你可以使用 docker ps 查看它的运行状态，可以看到它确实把本机的 5000 端口映射到了容器内的 5000 端口。</p>
<p>接下来，我们就要使用 docker tag 命令给镜像打标签再上传了。因为上传的目标不是默认的 Docker Hub，而是本地的私有仓库，所以镜像的名字前面还必须再加上仓库的地址（域名或者 IP 地址都行），形式上和 HTTP 的 URL 非常像。比如在这里，我就把“nginx:alpine”改成了“127.0.0.1:5000/nginx:alpine”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker tag nginx:alpine 127.0.0.1:5000/nginx:alpine

</code></pre></td></tr></table>
</div>
</div><p>现在，这个镜像有了一个附加仓库地址的完整名字，就可以用 docker push 推上去了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker push 127.0.0.1:5000/nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>为了验证是否已经成功推送，我们可以把刚才打标签的镜像删掉，再重新下载：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker rmi  127.0.0.1:5000/nginx:alpine
docker pull 127.0.0.1:5000/nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>这里 docker pull 确实完成了镜像下载任务，不过因为原来的层原本就已经存在，所以不会有实际的下载动作，只会创建一个新的镜像标签。Docker Registry 虽然没有图形界面，但提供了 RESTful API，也可以发送 HTTP 请求来查看仓库里的镜像，具体的端点信息可以参考官方文档（https://docs.docker.com/registry/spec/api/），下面的这两条 curl 命令就分别获取了镜像列表和 Nginx 镜像的标签列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">curl 127.1:5000/v2/_catalog
curl 127.1:5000/v2/nginx/tags/list
</code></pre></td></tr></table>
</div>
</div><p>可以看到，因为应用被封装到了镜像里，所以我们只用简单的一两条命令就完成了私有仓库的搭建工作，完全不需要复杂的软件安装、环境设置、调试测试等繁琐的操作，这在容器技术出现之前简直是不可想象的。</p>
<h3 id="搭建-wordpress-网站">搭建 WordPress 网站</h3>
<p>Docker Registry 应用比较简单，只用单个容器就运行了一个完整的服务，下面我们再来搭建一个有点复杂的 WordPress 网站。网站需要用到三个容器：WordPress、MariaDB、Nginx，它们都是非常流行的开源项目，在 Docker Hub 网站上有官方镜像，网页上的说明也很详细，所以具体的搜索过程我就略过了，直接使用 docker pull 拉取它们的镜像：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker pull wordpress:5
docker pull mariadb:10
docker pull nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>我画了一个简单的网络架构图，你可以直观感受一下它们之间的关系：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/59/ca/59dfbe961bcd233b83e1c1ec064e2eca.png?wh=1920x643"
        data-srcset="https://static001.geekbang.org/resource/image/59/ca/59dfbe961bcd233b83e1c1ec064e2eca.png?wh=1920x643, https://static001.geekbang.org/resource/image/59/ca/59dfbe961bcd233b83e1c1ec064e2eca.png?wh=1920x643 1.5x, https://static001.geekbang.org/resource/image/59/ca/59dfbe961bcd233b83e1c1ec064e2eca.png?wh=1920x643 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/59/ca/59dfbe961bcd233b83e1c1ec064e2eca.png?wh=1920x643"
        title="img" /></p>
<p>这个系统可以说是比较典型的网站了。MariaDB 作为后面的关系型数据库，端口号是 3306；WordPress 是中间的应用服务器，使用 MariaDB 来存储数据，它的端口是 80；Nginx 是前面的反向代理，它对外暴露 80 端口，然后把请求转发给 WordPress。我们先来运行 MariaDB。根据说明文档，需要配置“MARIADB_DATABASE”等几个环境变量，用 &ndash;env 参数来指定启动时的数据库、用户名和密码，这里我指定数据库是“db”，用户名是“wp”，密码是“123”，管理员密码（root password）也是“123”。下面就是启动 MariaDB 的 docker run 命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm \
    --env MARIADB_DATABASE=db \
    --env MARIADB_USER=wp \
    --env MARIADB_PASSWORD=123 \
    --env MARIADB_ROOT_PASSWORD=123 \
    mariadb:10
</code></pre></td></tr></table>
</div>
</div><p>启动之后，我们还可以使用 docker exec 命令，执行数据库的客户端工具“mysql”，验证数据库是否正常运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker exec -it 9ac mysql -u wp -p
</code></pre></td></tr></table>
</div>
</div><p>输入刚才设定的用户名“wp”和密码“123”之后，我们就连接上了 MariaDB，可以使用 show databases; 和 show tables; 等命令来查看数据库里的内容。当然，现在肯定是空的。</p>
<p>因为 Docker 的 bridge 网络模式的默认网段是“172.17.0.0/16”，宿主机固定是“172.17.0.1”，而且 IP 地址是顺序分配的，所以如果之前没有其他容器在运行的话，MariaDB 容器的 IP 地址应该就是“172.17.0.2”，这可以通过 docker inspect 命令来验证：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker inspect 9ac |grep IPAddress

</code></pre></td></tr></table>
</div>
</div><p>现在数据库服务已经正常，该运行应用服务器 WordPress 了，它也要用 &ndash;env 参数来指定一些环境变量才能连接到 MariaDB，注意“WORDPRESS_DB_HOST”必须是 MariaDB 的 IP 地址，否则会无法连接数据库：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">docker run -d --rm \
    --env WORDPRESS_DB_HOST=172.17.0.2 \
    --env WORDPRESS_DB_USER=wp \
    --env WORDPRESS_DB_PASSWORD=123 \
    --env WORDPRESS_DB_NAME=db \
    wordpress:5
</code></pre></td></tr></table>
</div>
</div><p>WordPress 容器在启动的时候并没有使用 -p 参数映射端口号，所以外界是不能直接访问的，我们需要在前面配一个 Nginx 反向代理，把请求转发给 WordPress 的 80 端口。配置 Nginx 反向代理必须要知道 WordPress 的 IP 地址，同样可以用 docker inspect 命令查看，如果没有什么意外的话它应该是“172.17.0.3”，所以我们就能够写出如下的配置文件（Nginx 的用法可参考其他资料，这里就不展开讲了）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">server {
  listen 80;
  default_type text/html;

  location / {
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_pass http://172.17.0.3;
  }
}
</code></pre></td></tr></table>
</div>
</div><p>有了这个配置文件，最关键的一步就来了，我们需要用 -p 参数把本机的端口映射到 Nginx 容器内部的 80 端口，再用 -v 参数把配置文件挂载到 Nginx 的“conf.d”目录下。这样，Nginx 就会使用刚才编写好的配置文件，在 80 端口上监听 HTTP 请求，再转发到 WordPress 应用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="n">docker</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">-</span><span class="n">d</span><span class="w"> </span><span class="o">--</span><span class="n">rm</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">    </span><span class="o">-</span><span class="n">p</span><span class="w"> </span><span class="mi">80</span><span class="p">:</span><span class="mi">80</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">    </span><span class="o">-</span><span class="n">v</span><span class="w"> </span><span class="o">`</span><span class="n">pwd</span><span class="o">`/</span><span class="n">wp</span><span class="p">.</span><span class="n">conf</span><span class="p">:</span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">nginx</span><span class="o">/</span><span class="n">conf</span><span class="p">.</span><span class="n">d</span><span class="o">/</span><span class="k">default</span><span class="p">.</span><span class="n">conf</span><span class="w"> </span><span class="err">\</span><span class="w">
</span><span class="w">    </span><span class="n">nginx</span><span class="p">:</span><span class="n">alpine</span><span class="w">
</span></code></pre></td></tr></table>
</div>
</div><p>三个容器都启动之后，我们再用 docker ps 来看看它们的状态：
可以看到，WordPress 和 MariaDB 虽然使用了 80 和 3306 端口，但被容器隔离，外界不可见，只有 Nginx 有端口映射，能够从外界的 80 端口收发数据，网络状态和我们的架构图是一致的。现在整个系统就已经在容器环境里运行好了，我们来打开浏览器，输入本机的“127.0.0.1”或者是虚拟机的 IP 地址（我这里是“http://192.168.10.208”），就可以看到 WordPress 的界面：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/a6/31/a63084a8dd95d0034ba72dcb60613531.png?wh=1224x1156"
        data-srcset="https://static001.geekbang.org/resource/image/a6/31/a63084a8dd95d0034ba72dcb60613531.png?wh=1224x1156, https://static001.geekbang.org/resource/image/a6/31/a63084a8dd95d0034ba72dcb60613531.png?wh=1224x1156 1.5x, https://static001.geekbang.org/resource/image/a6/31/a63084a8dd95d0034ba72dcb60613531.png?wh=1224x1156 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/a6/31/a63084a8dd95d0034ba72dcb60613531.png?wh=1224x1156"
        title="img" /></p>
<p>在创建基本的用户、初始化网站之后，我们可以再登录 MariaDB，看看是否已经有了一些数据：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/a2/1e/a22dcabe805471e304a74c715e7fb51e.png?wh=1920x1749"
        data-srcset="https://static001.geekbang.org/resource/image/a2/1e/a22dcabe805471e304a74c715e7fb51e.png?wh=1920x1749, https://static001.geekbang.org/resource/image/a2/1e/a22dcabe805471e304a74c715e7fb51e.png?wh=1920x1749 1.5x, https://static001.geekbang.org/resource/image/a2/1e/a22dcabe805471e304a74c715e7fb51e.png?wh=1920x1749 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/a2/1e/a22dcabe805471e304a74c715e7fb51e.png?wh=1920x1749"
        title="img" /></p>
<p>可以看到，WordPress 已经在数据库里新建了很多的表，这就证明我们的容器化的 WordPress 网站搭建成功。</p>
<h3 id="小结-7">小结</h3>
<p>好了，今天我们简单地回顾了一下容器技术，这里有一份思维导图，是对前面所有容器知识要点的总结，你可以对照着用来复习。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/79/16/79f8c75e018e0a82eff432786110ef16.jpg?wh=1920x2142"
        data-srcset="https://static001.geekbang.org/resource/image/79/16/79f8c75e018e0a82eff432786110ef16.jpg?wh=1920x2142, https://static001.geekbang.org/resource/image/79/16/79f8c75e018e0a82eff432786110ef16.jpg?wh=1920x2142 1.5x, https://static001.geekbang.org/resource/image/79/16/79f8c75e018e0a82eff432786110ef16.jpg?wh=1920x2142 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/79/16/79f8c75e018e0a82eff432786110ef16.jpg?wh=1920x2142"
        title="img" /></p>
<p>我们还使用 Docker 实际搭建了两个服务：Registry 镜像仓库和 WordPress 网站。通过这两个项目的实战演练，你应该能够感受到容器化对后端开发带来的巨大改变，它简化了应用的打包、分发和部署，简单的几条命令就可以完成之前需要编写大量脚本才能完成的任务，对于开发、运维来绝对是一个“福音”。不过，在感受容器便利的同时，你有没有注意到它还是存在一些遗憾呢？比如说：</p>
<p>我们还是要手动运行一些命令来启动应用，然后再人工确认运行状态。运行多个容器组成的应用比较麻烦，需要人工干预（如检查 IP 地址）才能维护网络通信。现有的网络模式功能只适合单机，多台服务器上运行应用、负载均衡该怎么做？如果要增加应用数量该怎么办？这时容器技术完全帮不上忙。</p>
<p>其实，如果我们仔细整理这些运行容器的 docker run 命令，写成脚本，再加上一些 Shell、Python 编程来实现自动化，也许就能够得到一个勉强可用的解决方案。这个方案已经超越了容器技术本身，是在更高的层次上规划容器的运行次序、网络连接、数据持久化等应用要素，也就是现在我们常说的“容器编排”（Container Orchestration）的雏形，也正是后面要学习的 Kubernetes 的主要出发点。</p>
<h2 id="初级">初级</h2>
<h2 id="09走近云原生如何在本机搭建小巧完备的kubernetes环境">09｜走近云原生：如何在本机搭建小巧完备的Kubernetes环境</h2>
<p>在前面的“入门篇”里，我们学习了以 Docker 为代表的容器技术，做好了充分的准备，那么今天我们就来看看什么是容器编排、什么是 Kubernetes，还有应该怎么在自己的电脑上搭建出一个小巧完善的 Kubernetes 环境，一起走近云原生。</p>
<h3 id="什么是容器编排">什么是容器编排</h3>
<p>容器技术的核心概念是容器、镜像、仓库，使用这三大基本要素我们就可以轻松地完成应用的打包、分发工作，实现“一次开发，到处运行”的梦想。不过，当我们熟练地掌握了容器技术，信心满满地要在服务器集群里大规模实施的时候，却会发现容器技术的创新只是解决了运维部署工作中一个很小的问题。现实生产环境的复杂程度实在是太高了，除了最基本的安装，还会有各式各样的需求，比如服务发现、负载均衡、状态监控、健康检查、扩容缩容、应用迁移、高可用等等。</p>
<p>虽然容器技术开启了云原生时代，但它也只走出了一小步，再继续前进就无能为力了，因为这已经不再是隔离一两个进程的普通问题，而是要隔离数不清的进程，还有它们之间互相通信、互相协作的超级问题，困难程度可以说是指数级别的上升。这些容器之上的管理、调度工作，就是这些年最流行的词汇：“容器编排”（Container Orchestration）。</p>
<p>容器编排这个词听起来好像挺高大上，但如果你理解了之后就会发现其实也并不神秘。像我们在上次课里使用 Docker 部署 WordPress 网站的时候，把 Nginx、WordPress、MariaDB 这三个容器理清次序、配好 IP 地址去运行，就是最初级的一种“容器编排”，只不过这是纯手工操作，比较原始、粗糙。面对单机上的几个容器，“人肉”编排调度还可以应付，但如果规模上到几百台服务器、成千上万的容器，处理它们之间的复杂联系就必须要依靠计算机了，而目前计算机用来调度管理的“事实标准”，就是我们专栏的主角：Kubernetes。</p>
<h3 id="什么是-kubernetes">什么是 Kubernetes</h3>
<p>现在大家谈到容器都会说是 Docker，但其实早在 Docker 之前，Google 在公司内部就使用了类似的技术（cgroup 就是 Google 开发再提交给 Linux 内核的），只不过不叫容器。作为世界上最大的搜索引擎，Google 拥有数量庞大的服务器集群，为了提高资源利用率和部署运维效率，它专门开发了一个集群应用管理系统，代号 Borg，在底层支持整个公司的运转。</p>
<p>2014 年，Google 内部系统要“升级换代”，从原来的 Borg 切换到 Omega，于是按照惯例，Google 会发表公开论文。因为之前在发表 MapReduce、BigTable、GFS 时吃过亏（被 Yahoo 开发的 Hadoop 占领了市场），所以 Google 决定借着 Docker 的“东风”，在发论文的同时，把 C++ 开发的 Borg 系统用 Go 语言重写并开源，于是 Kubernetes 就这样诞生了。</p>
<p>由于 Kubernetes 背后有 Borg 系统十多年生产环境经验的支持，技术底蕴深厚，理论水平也非常高，一经推出就引起了轰动。然后在 2015 年，Google 又联合 Linux 基金会成立了 CNCF（Cloud Native Computing Foundation，云原生基金会），并把 Kubernetes 捐献出来作为种子项目。有了 Google 和 Linux 这两大家族的保驾护航，再加上宽容开放的社区，作为 CNCF 的“头把交椅”，Kubernetes 旗下很快就汇集了众多行业精英，仅用了两年的时间就打败了同期的竞争对手 Apache Mesos 和 Docker Swarm，成为了这个领域的唯一霸主。</p>
<p>那么，Kubernetes 到底能够为我们做什么呢？简单来说，Kubernetes 就是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器，它凝聚了 Google 等大公司和开源社区的集体智慧，从而让中小型公司也可以具备轻松运维海量计算节点——也就是“云计算”的能力。</p>
<h4 id="什么是-minikube">什么是 minikube</h4>
<p>Kubernetes 一般都运行在大规模的计算集群上，管理很严格，这就对我们个人来说造成了一定的障碍，没有实际操作环境怎么能够学好用好呢？好在 Kubernetes 充分考虑到了这方面的需求，提供了一些快速搭建 Kubernetes 环境的工具，在官网（https://kubernetes.io/zh/docs/tasks/tools/）上推荐的有两个：kind 和 minikube，它们都可以在本机上运行完整的 Kubernetes 环境。</p>
<p>我说一下对这两个工具的个人看法，供你参考。kind 基于 Docker，意思是“Kubernetes in Docker”。它功能少，用法简单，也因此运行速度快，容易上手。不过它缺少很多 Kubernetes 的标准功能，例如仪表盘、网络插件，也很难定制化，所以我认为它比较适合有经验的 Kubernetes 用户做快速开发测试，不太适合学习研究。不选 kind 还有一个原因，它的名字与 Kubernetes YAML 配置里的字段 kind 重名，会对初学者造成误解，干扰学习。再来看 minikube，从名字就能够看出来，它是一个“迷你”版本的 Kubernetes，自从 2016 年发布以来一直在积极地开发维护，紧跟 Kubernetes 的版本更新，同时也兼容较旧的版本（最多只到之前的 6 个小版本）。minikube 最大特点就是“小而美”，可执行文件仅有不到 100MB，运行镜像也不过 1GB，但就在这么小的空间里却集成了 Kubernetes 的绝大多数功能特性，不仅有核心的容器编排功能，还有丰富的插件，例如 Dashboard、GPU、Ingress、Istio、Kong、Registry 等等，综合来看非常完善。所以，我建议你在这个专栏里选择 minikube 来学习 Kubernetes。</p>
<h3 id="如何搭建-minikube-环境">如何搭建 minikube 环境</h3>
<p>minikube 支持 Mac、Windows、Linux 这三种主流平台，你可以在它的官网（https://minikube.sigs.k8s.io）找到详细的安装说明，当然在我们这里就只用虚拟机里的 Linux 了。minikube 的最新版本是 1.25.2，支持的 Kubernetes 版本是 1.23.3，所以我们就选定它作为我们初级篇的学习工具。</p>
<p>minikube 不包含在系统自带的 apt/yum 软件仓库里，我们只能自己去网上找安装包。不过因为它是用 Go 语言开发的，整体就是一个二进制文件，没有多余的依赖，所以安装过程也非常简单，只需要用 curl 或者 wget 下载就行。minikube 的官网提供了各种系统的安装命令，通常就是下载、拷贝这两步，不过你需要注意一下本机电脑的硬件架构，Intel 芯片要选择带“amd64”后缀，Apple M1 芯片要选择“arm64”后缀，选错了就会因为 CPU 指令集不同而无法运行：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/d5/84/d526aa920fba9bee9856177495a1c884.png?wh=1920x1004"
        data-srcset="https://static001.geekbang.org/resource/image/d5/84/d526aa920fba9bee9856177495a1c884.png?wh=1920x1004, https://static001.geekbang.org/resource/image/d5/84/d526aa920fba9bee9856177495a1c884.png?wh=1920x1004 1.5x, https://static001.geekbang.org/resource/image/d5/84/d526aa920fba9bee9856177495a1c884.png?wh=1920x1004 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/d5/84/d526aa920fba9bee9856177495a1c884.png?wh=1920x1004"
        title="img" /></p>
<p>我也把官网上 Linux 系统安装的命令抄在了这里，你可以直接拷贝后安装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># Intel x86_64
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64

# Apple arm64
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64

sudo install minikube /usr/local/bin/
</code></pre></td></tr></table>
</div>
</div><p>安装完成之后，你可以执行命令 minikube version，看看它的版本号，验证是否安装成功：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube version
</code></pre></td></tr></table>
</div>
</div><p>不过 minikube 只能够搭建 Kubernetes 环境，要操作 Kubernetes，还需要另一个专门的客户端工具“kubectl”。kubectl 的作用有点类似之前我们学习容器技术时候的工具“docker”，它也是一个命令行工具，作用也比较类似，同样是与 Kubernetes 后台服务通信，把我们的命令转发给 Kubernetes，实现容器和集群的管理功能。kubectl 是一个与 Kubernetes、minikube 彼此独立的项目，所以不包含在 minikube 里，但 minikube 提供了安装它的简化方式，你只需执行下面的这条命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube kubectl
</code></pre></td></tr></table>
</div>
</div><p>它就会把与当前 Kubernetes 版本匹配的 kubectl 下载下来，存放在内部目录（例如 .minikube/cache/linux/arm64/v1.23.3），然后我们就可以使用它来对 Kubernetes“发号施令”了。所以，在 minikube 环境里，我们会用到两个客户端：minikube 管理 Kubernetes 集群环境，kubectl 操作实际的 Kubernetes 功能，和 Docker 比起来有点复杂。我画了一个简单的 minikube 环境示意图，方便你理解它们的关系。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/22/e3/22c4d6ef48a0cf009946ebbbc31b91e3.jpg?wh=1920x1406"
        data-srcset="https://static001.geekbang.org/resource/image/22/e3/22c4d6ef48a0cf009946ebbbc31b91e3.jpg?wh=1920x1406, https://static001.geekbang.org/resource/image/22/e3/22c4d6ef48a0cf009946ebbbc31b91e3.jpg?wh=1920x1406 1.5x, https://static001.geekbang.org/resource/image/22/e3/22c4d6ef48a0cf009946ebbbc31b91e3.jpg?wh=1920x1406 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/22/e3/22c4d6ef48a0cf009946ebbbc31b91e3.jpg?wh=1920x1406"
        title="img" /></p>
<h3 id="实际验证-minikube-环境">实际验证 minikube 环境</h3>
<p>前面的工作都做完之后，我们就可以在本机上运行 minikube，创建 Kubernetes 实验环境了。使用命令 minikube start 会从 Docker Hub 上拉取镜像，以当前最新版本的 Kubernetes 启动集群。不过为了保证实验环境的一致性，我们可以在后面再加上一个参数 &ndash;kubernetes-version，明确指定要使用 Kubernetes 版本。这里我使用“1.23.3”，启动命令就是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube start --kubernetes-version=v1.23.3
</code></pre></td></tr></table>
</div>
</div><p>（它的启动过程使用了比较活泼的表情符号，可能是想表现得平易近人吧，如果不喜欢也可以调整设置关闭它。）现在 Kubernetes 集群就已经在我们本地运行了，你可以使用 minikube status、minikube node list这两个命令来查看集群的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube status
minikube node list
</code></pre></td></tr></table>
</div>
</div><p>从截图里可以看到，Kubernetes 集群里现在只有一个节点，名字就叫“minikube”，类型是“Control Plane”，里面有 host、kubelet、apiserver 三个服务，IP 地址是 192.168.49.2。你还可以用命令 minikube ssh 登录到这个节点上，虽然它是虚拟的，但用起来和实机也没什么区别</p>
<p>有了集群，接下来我们就可以使用 kubectl 来操作一下，初步体会 Kubernetes 这个容器编排系统，最简单的命令当然就是查看版本：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl version
</code></pre></td></tr></table>
</div>
</div><p>不过这条命令还不能直接用，因为使用 minikube 自带的 kubectl 有一点形式上的限制，要在前面加上 minikube 的前缀，后面再有个 &ndash;，像这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube kubectl -- version 
</code></pre></td></tr></table>
</div>
</div><p>为了避免这个不大不小的麻烦，我建议你使用 Linux 的“alias”功能，为它创建一个别名，写到当前用户目录下的 .bashrc 里，也就是这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">alias kubectl=&#34;minikube kubectl --&#34;
</code></pre></td></tr></table>
</div>
</div><p>另外，kubectl 还提供了命令自动补全的功能，你还应该再加上“kubectl completion”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">source &lt;(kubectl completion bash)
</code></pre></td></tr></table>
</div>
</div><p>现在，我们就可以愉快地使用 kubectl 了</p>
<p>下面我们在 Kubernetes 里运行一个 Nginx 应用，命令与 Docker 一样，也是 run，不过形式上有点区别，需要用 &ndash;image 指定镜像，然后 Kubernetes 会自动拉取并运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl run ngx --image=nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>这里涉及 Kubernetes 里的一个非常重要的概念：Pod，你可以暂时把它理解成是“穿了马甲”的容器，查看 Pod 列表需要使用命令 kubectl get pod，它的效果类似 docker ps</p>
<p>命令执行之后可以看到，在 Kubernetes 集群里就有了一个名字叫 ngx 的 Pod 正在运行，表示我们的这个单节点 minikube 环境已经搭建成功。</p>
<h3 id="小结-8">小结</h3>
<p>好了，今天我们先了解了容器编排概念和 Kubernetes 的历史，然后在 Linux 虚拟机上安装了 minikube 和 kubectl，运行了一个简单但完整的 Kubernetes 集群，实现了与云原生的“第一次亲密接触”。那什么是云原生呢？这在 CNCF 上有明确的定义，不过我觉得太学术化了，我也不想机械重复，就讲讲我自己的通俗理解吧。所谓的“云”，现在就指的是 Kubernetes，那么“云原生”的意思就是应用的开发、部署、运维等一系列工作都要向 Kubernetes 看齐，使用容器、微服务、声明式 API 等技术，保证应用的整个生命周期都能够在 Kubernetes 环境里顺利实施，不需要附加额外的条件。换句话说，“云原生”就是 Kubernetes 里的“原住民”，而不是从其他环境迁过来的“移民”。最后照例小结一下今天的内容：</p>
<p>容器技术只解决了应用的打包、安装问题，面对复杂的生产环境就束手无策了，解决之道就是容器编排，它能够组织管理各个应用容器之间的关系，让它们顺利地协同运行。Kubernetes 源自 Google 内部的 Borg 系统，也是当前容器编排领域的事实标准。minikube 可以在本机搭建 Kubernetes 环境，功能很完善，适合学习研究。操作 Kubernetes 需要使用命令行工具 kubectl，只有通过它才能与 Kubernetes 集群交互。kubectl 的用法与 docker 类似，也可以拉取镜像运行，但操作的不是简单的容器，而是 Pod。</p>
<p>另外还要说一下 Kubernetes 的官网（https://kubernetes.io/zh/），里面有非常详细的文档，包括概念解释、入门教程、参考手册等等，最难得的是它有全中文版本，我们阅读起来完全不会有语言障碍，希望你有时间多上去看看，及时获取官方第一手知识。</p>
<h2 id="10自动化的运维管理探究kubernetes工作机制的奥秘">10｜自动化的运维管理：探究Kubernetes工作机制的奥秘</h2>
<p>在上一次课里，我们看到容器技术只实现了应用的打包分发，到运维真正落地实施的时候仍然会遇到很多困难，所以就需要用容器编排技术来解决这些问题，而 Kubernetes 是这个领域的唯一霸主，已经成为了“事实标准”。那么，Kubernetes 凭什么能担当这样的领军重任呢？难道仅仅因为它是由 Google 主导开发的吗？今天我就带你一起来看看 Kubernetes 的内部架构和工作机制，了解它能够傲视群雄的秘密所在。</p>
<h3 id="云计算时代的操作系统">云计算时代的操作系统</h3>
<p>前面我曾经说过，Kubernetes 是一个生产级别的容器编排平台和集群管理系统，能够创建、调度容器，监控、管理服务器。容器是什么？容器是软件，是应用，是进程。服务器是什么？服务器是硬件，是 CPU、内存、硬盘、网卡。那么，既可以管理软件，也可以管理硬件，这样的东西应该是什么？你也许会脱口而出：这就是一个操作系统（Operating System）！没错，从某种角度来看，Kubernetes 可以说是一个集群级别的操作系统，主要功能就是资源管理和作业调度。但 Kubernetes 不是运行在单机上管理单台计算资源和进程，而是运行在多台服务器上管理几百几千台的计算资源，以及在这些资源上运行的上万上百万的进程，规模要大得多。</p>
<p>所以，你可以把 Kubernetes 与 Linux 对比起来学习，而这个新的操作系统里自然会有一系列新名词、新术语，你也需要使用新的思维方式来考虑问题，必要的时候还得和过去的习惯“说再见”。Kubernetes 这个操作系统与 Linux 还有一点区别你值得注意。Linux 的用户通常是两类人：Dev 和 Ops，而在 Kubernetes 里则只有一类人：DevOps。在以前的应用实施流程中，开发人员和运维人员分工明确，开发完成后需要编写详细的说明文档，然后交给运维去部署管理，两者之间不能随便“越线”。而在 Kubernetes 这里，开发和运维的界限变得不那么清晰了。由于云原生的兴起，开发人员从一开始就必须考虑后续的部署运维工作，而运维人员也需要在早期介入开发，才能做好应用的运维监控工作。这就会导致很多 Kubernetes 的新用户会面临身份的转变，一开始可能会有点困难。不过不用担心，这也非常正常，任何的学习过程都有个适应期，只要过了最初的概念理解阶段就好了。</p>
<h3 id="kubernetes-的基本架构">Kubernetes 的基本架构</h3>
<p>操作系统的一个重要功能就是抽象，从繁琐的底层事务中抽象出一些简洁的概念，然后基于这些概念去管理系统资源。Kubernetes 也是这样，它的管理目标是大规模的集群和应用，必须要能够把系统抽象到足够高的层次，分解出一些松耦合的对象，才能简化系统模型，减轻用户的心智负担。所以，Kubernetes 扮演的角色就如同一个“大师级别”的系统管理员，具有丰富的集群运维经验，独创了自己的一套工作方式，不需要太多的外部干预，就能够自主实现原先许多复杂的管理工作。下面我们就来看看这位资深管理员的“内功心法”。Kubernetes 官网上有一张架构图，但我觉得不是太清晰、重点不突出，所以另外找了一份（图片来源）。虽然这张图有点“老”，但对于我们初学 Kubernetes 还是比较合适的。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704"
        data-srcset="https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704, https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704 1.5x, https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704"
        title="img" /></p>
<p>Kubernetes 采用了现今流行的“控制面 / 数据面”（Control Plane / Data Plane）架构，集群里的计算机被称为“节点”（Node），可以是实机也可以是虚机，少量的节点用作控制面来执行集群的管理维护工作，其他的大部分节点都被划归数据面，用来跑业务应用。控制面的节点在 Kubernetes 里叫做 Master Node，一般简称为 Master，它是整个集群里最重要的部分，可以说是 Kubernetes 的大脑和心脏。数据面的节点叫做 Worker Node，一般就简称为 Worker 或者 Node，相当于 Kubernetes 的手和脚，在 Master 的指挥下干活。Node 的数量非常多，构成了一个资源池，Kubernetes 就在这个池里分配资源，调度应用。因为资源被“池化”了，所以管理也就变得比较简单，可以在集群中任意添加或者删除节点。在这张架构图里，我们还可以看到有一个 kubectl，它就是 Kubernetes 的客户端工具，用来操作 Kubernetes，但它位于集群之外，理论上不属于集群。你可以使用命令 kubectl get node 来查看 Kubernetes 的节点状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl get node
</code></pre></td></tr></table>
</div>
</div><p>可以看到当前的 minikube 集群里只有一个 Master，那 Node 怎么不见了？这是因为 Master 和 Node 的划分不是绝对的。当集群的规模较小，工作负载较少的时候，Master 也可以承担 Node 的工作，就像我们搭建的 minikube 环境，它就只有一个节点，这个节点既是 Master 又是 Node。</p>
<h3 id="节点内部的结构">节点内部的结构</h3>
<p>Kubernetes 的节点内部也具有复杂的结构，是由很多的模块构成的，这些模块又可以分成组件（Component）和插件（Addon）两类。组件实现了 Kubernetes 的核心功能特性，没有这些组件 Kubernetes 就无法启动，而插件则是 Kubernetes 的一些附加功能，属于“锦上添花”，不安装也不会影响 Kubernetes 的正常运行。接下来我先来讲讲 Master 和 Node 里的组件，然后再捎带提一下插件，理解了它们的工作流程，你就会明白为什么 Kubernetes 有如此强大的自动化运维能力。</p>
<h3 id="master-里的组件有哪些">Master 里的组件有哪些</h3>
<p>Master 里有 4 个组件，分别是 apiserver、etcd、scheduler、controller-manager。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/33/c6/330e03a66f636657c0d8695397c508c6.jpg?wh=1278x704"
        data-srcset="https://static001.geekbang.org/resource/image/33/c6/330e03a66f636657c0d8695397c508c6.jpg?wh=1278x704, https://static001.geekbang.org/resource/image/33/c6/330e03a66f636657c0d8695397c508c6.jpg?wh=1278x704 1.5x, https://static001.geekbang.org/resource/image/33/c6/330e03a66f636657c0d8695397c508c6.jpg?wh=1278x704 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/33/c6/330e03a66f636657c0d8695397c508c6.jpg?wh=1278x704"
        title="img" /></p>
<p>apiserver 是 Master 节点——同时也是整个 Kubernetes 系统的唯一入口，它对外公开了一系列的 RESTful API，并且加上了验证、授权等功能，所有其他组件都只能和它直接通信，可以说是 Kubernetes 里的联络员。etcd 是一个高可用的分布式 Key-Value 数据库，用来持久化存储系统里的各种资源对象和状态，相当于 Kubernetes 里的配置管理员。注意它只与 apiserver 有直接联系，也就是说任何其他组件想要读写 etcd 里的数据都必须经过 apiserver。scheduler 负责容器的编排工作，检查节点的资源状态，把 Pod 调度到最适合的节点上运行，相当于部署人员。因为节点状态和 Pod 信息都存储在 etcd 里，所以 scheduler 必须通过 apiserver 才能获得。controller-manager 负责维护容器和节点等资源的状态，实现故障检测、服务迁移、应用伸缩等功能，相当于监控运维人员。同样地，它也必须通过 apiserver 获得存储在 etcd 里的信息，才能够实现对资源的各种操作。这 4 个组件也都被容器化了，运行在集群的 Pod 里，我们可以用 kubectl 来查看它们的状态，使用命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl get pod -n kube-system
</code></pre></td></tr></table>
</div>
</div><p>注意命令行里要用 -n kube-system 参数，表示检查“kube-system”名字空间里的 Pod，至于名字空间是什么，我们后面会讲到。</p>
<h3 id="node-里的组件有哪些">Node 里的组件有哪些</h3>
<p>Master 里的 apiserver、scheduler 等组件需要获取节点的各种信息才能够作出管理决策，那这些信息该怎么来呢？这就需要 Node 里的 3 个组件了，分别是 kubelet、kube-proxy、container-runtime。kubelet 是 Node 的代理，负责管理 Node 相关的绝大部分操作，Node 上只有它能够与 apiserver 通信，实现状态报告、命令下发、启停容器等功能，相当于是 Node 上的一个“小管家”。kube-proxy 的作用有点特别，它是 Node 的网络代理，只负责管理容器的网络通信，简单来说就是为 Pod 转发 TCP/UDP 数据包，相当于是专职的“小邮差”。第三个组件 container-runtime 我们就比较熟悉了，它是容器和镜像的实际使用者，在 kubelet 的指挥下创建容器，管理 Pod 的生命周期，是真正干活的“苦力”。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/87/35/87bab507ce8381325e85570f3bc1d935.jpg?wh=1278x704"
        data-srcset="https://static001.geekbang.org/resource/image/87/35/87bab507ce8381325e85570f3bc1d935.jpg?wh=1278x704, https://static001.geekbang.org/resource/image/87/35/87bab507ce8381325e85570f3bc1d935.jpg?wh=1278x704 1.5x, https://static001.geekbang.org/resource/image/87/35/87bab507ce8381325e85570f3bc1d935.jpg?wh=1278x704 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/87/35/87bab507ce8381325e85570f3bc1d935.jpg?wh=1278x704"
        title="img" /></p>
<p>我们一定要注意，因为 Kubernetes 的定位是容器编排平台，所以它没有限定 container-runtime 必须是 Docker，完全可以替换成任何符合标准的其他容器运行时，例如 containerd、CRI-O 等等，只不过在这里我们使用的是 Docker。这 3 个组件中只有 kube-proxy 被容器化了，而 kubelet 因为必须要管理整个节点，容器化会限制它的能力，所以它必须在 container-runtime 之外运行。使用 minikube ssh 命令登录到节点后，可以用 docker ps 看到 kube-proxy：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube ssh
docker ps |grep kube-proxy
</code></pre></td></tr></table>
</div>
</div><p>而 kubelet 用 docker ps 是找不到的，需要用操作系统的 ps 命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">ps -ef|grep kubelet
</code></pre></td></tr></table>
</div>
</div><p>现在，我们再把 Node 里的组件和 Master 里的组件放在一起来看，就能够明白 Kubernetes 的大致工作流程了：每个 Node 上的 kubelet 会定期向 apiserver 上报节点状态，apiserver 再存到 etcd 里。每个 Node 上的 kube-proxy 实现了 TCP/UDP 反向代理，让容器对外提供稳定的服务。scheduler 通过 apiserver 得到当前的节点状态，调度 Pod，然后 apiserver 下发命令给某个 Node 的 kubelet，kubelet 调用 container-runtime 启动容器。controller-manager 也通过 apiserver 得到实时的节点状态，监控可能的异常情况，再使用相应的手段去调节恢复。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704"
        data-srcset="https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704, https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704 1.5x, https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/34/b7/344e0c6dc2141b12f99e61252110f6b7.png?wh=1278x704"
        title="img" /></p>
<p>其实，这和我们在 Kubernetes 出现之前的操作流程也差不了多少，但 Kubernetes 的高明之处就在于把这些都抽象化规范化了。于是，这些组件就好像是无数个不知疲倦的运维工程师，把原先繁琐低效的人力工作搬进了高效的计算机里，就能够随时发现集群里的变化和异常，再互相协作，维护集群的健康状态。</p>
<h3 id="插件addons有哪些">插件（Addons）有哪些</h3>
<p>只要服务器节点上运行了 apiserver、scheduler、kubelet、kube-proxy、container-runtime 等组件，就可以说是一个功能齐全的 Kubernetes 集群了。不过就像 Linux 一样，操作系统提供的基础功能虽然“可用”，但想达到“好用”的程度，还是要再安装一些附加功能，这在 Kubernetes 里就是插件（Addon）。由于 Kubernetes 本身的设计非常灵活，所以就有大量的插件用来扩展、增强它对应用和集群的管理能力。minikube 也支持很多的插件，使用命令 minikube addons list 就可以查看插件列表：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube addons list
</code></pre></td></tr></table>
</div>
</div><p>插件中我个人认为比较重要的有两个：DNS 和 Dashboard。DNS 你应该比较熟悉吧，它在 Kubernetes 集群里实现了域名解析服务，能够让我们以域名而不是 IP 地址的方式来互相通信，是服务发现和负载均衡的基础。由于它对微服务、服务网格等架构至关重要，所以基本上是 Kubernetes 的必备插件。Dashboard 就是仪表盘，为 Kubernetes 提供了一个图形化的操作界面，非常直观友好，虽然大多数 Kubernetes 工作都是使用命令行 kubectl，但有的时候在 Dashboard 上查看信息也是挺方便的。你只要在 minikube 环境里执行一条简单的命令，就可以自动用浏览器打开 Dashboard 页面，而且还支持中文：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">minikube dashboard
</code></pre></td></tr></table>
</div>
</div><h3 id="小结-9">小结</h3>
<p>好了，今天我们一起来研究了 Kubernetes 的内部架构和工作机制，可以看到它的功能非常完善，实现了大部分常见的运维管理工作，而且是全自动化的，能够节约大量的人力成本。由于 Kubernetes 的抽象程度比较高，有很多陌生的新术语，不太好理解，所以我画了一张思维导图，你可以对照着再加深理解。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/65/e1/65d38ac50b4f2f1fd4b6700d5b8e7be1.jpg?wh=1920x1096"
        data-srcset="https://static001.geekbang.org/resource/image/65/e1/65d38ac50b4f2f1fd4b6700d5b8e7be1.jpg?wh=1920x1096, https://static001.geekbang.org/resource/image/65/e1/65d38ac50b4f2f1fd4b6700d5b8e7be1.jpg?wh=1920x1096 1.5x, https://static001.geekbang.org/resource/image/65/e1/65d38ac50b4f2f1fd4b6700d5b8e7be1.jpg?wh=1920x1096 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/65/e1/65d38ac50b4f2f1fd4b6700d5b8e7be1.jpg?wh=1920x1096"
        title="img" /></p>
<p>最后小结一下今天的要点：Kubernetes 能够在集群级别管理应用和服务器，可以认为是一种集群操作系统。它使用“控制面 / 数据面”的基本架构，Master 节点实现管理控制功能，Worker 节点运行具体业务。Kubernetes 由很多模块组成，可分为核心的组件和选配的插件两类。Master 里有 4 个组件，分别是 apiserver、etcd、scheduler、controller-manager。Node 里有 3 个组件，分别是 kubelet、kube-proxy、container-runtime。通常必备的插件有 DNS 和 Dashboard。</p>
<h2 id="加餐kubernetes弃用docker是怎么回事">加餐｜Kubernetes“弃用Docker”是怎么回事？</h2>
<p>在“入门篇”学习容器技术的过程中，我看到有不少同学留言问 Kubernetes“弃用 Docker”的事情，担心现在学 Docker 是否还有价值，是否现在就应该切换到 containerd 或者是其他 runtime。这些疑虑的确是有些道理。两年前，Kubernetes 放出消息要“弃用 Docker”的时候，确确实实在 Kubernetes 社区里掀起了一场“轩然大波”，影响甚至波及到社区之外，也导致 Kubernetes 不得不写了好几篇博客来反复解释这么做的原因。两年过去了，虽然最新的 Kubernetes 1.24 已经达成了“弃用”的目标，但很多人对这件事似乎还是没有非常清晰的认识。所以今天，我们就来聊聊这个话题，我也讲讲我的一些看法。</p>
<h3 id="什么是-cri">什么是 CRI</h3>
<p>要了解 Kubernetes 为什么要“弃用 Docker”，还得追根溯源，回头去看 Kubernetes 的发展历史。2014 年，Docker 正如日中天，在容器领域没有任何对手，而这时 Kubernetes 才刚刚诞生，虽然背后有 Google 和 Borg 的支持，但还是比较弱小的。所以，Kubernetes 很自然就选择了在 Docker 上运行，毕竟“背靠大树好乘凉”，同时也能趁机“养精蓄锐”逐步发展壮大自己。时间一转眼到了 2016 年，CNCF 已经成立一年了，而 Kubernetes 也已经发布了 1.0 版，可以正式用于生产环境，这些都标志着 Kubernetes 已经成长起来了，不再需要“看脸色吃饭”。于是它就宣布加入了 CNCF，成为了第一个 CNCF 托管项目，想要借助基金会的力量联合其他厂商，一起来“扳倒”Docker。那它是怎么做的呢？</p>
<p>在 2016 年底的 1.5 版里，Kubernetes 引入了一个新的接口标准：CRI ，Container Runtime Interface。CRI 采用了 ProtoBuffer 和 gPRC，规定 kubelet 该如何调用容器运行时去管理容器和镜像，但这是一套全新的接口，和之前的 Docker 调用完全不兼容。Kubernetes 意思很明显，就是不想再绑定在 Docker 上了，允许在底层接入其他容器技术（比如 rkt、kata 等），随时可以把 Docker“踢开”。但是这个时候 Docker 已经非常成熟，而且市场的惯性也非常强大，各大云厂商不可能一下子就把 Docker 全部替换掉。所以 Kubernetes 也只能同时提供一个“折中”方案，在 kubelet 和 Docker 中间加入一个“适配器”，把 Docker 的接口转换成符合 CRI 标准的接口（图片来源）：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/11/ef/11e3de04b296248711455f22ce5578ef.png?wh=572x136"
        data-srcset="https://static001.geekbang.org/resource/image/11/ef/11e3de04b296248711455f22ce5578ef.png?wh=572x136, https://static001.geekbang.org/resource/image/11/ef/11e3de04b296248711455f22ce5578ef.png?wh=572x136 1.5x, https://static001.geekbang.org/resource/image/11/ef/11e3de04b296248711455f22ce5578ef.png?wh=572x136 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/11/ef/11e3de04b296248711455f22ce5578ef.png?wh=572x136"
        title="img" /></p>
<p>因为这个“适配器”夹在 kubelet 和 Docker 之间，所以就被形象地称为是“shim”，也就是“垫片”的意思。有了 CRI 和 shim，虽然 Kubernetes 还使用 Docker 作为底层运行时，但也具备了和 Docker 解耦的条件，从此就拉开了“弃用 Docker”这场大戏的帷幕。</p>
<h3 id="什么是-containerd">什么是 containerd</h3>
<p>面对 Kubernetes“咄咄逼人”的架势，Docker 是看在眼里痛在心里，虽然有苦心经营了多年的社区和用户群，但公司的体量太小，实在是没有足够的实力与大公司相抗衡。不过 Docker 也没有“坐以待毙”，而是采取了“断臂求生”的策略，推动自身的重构，把原本单体架构的 Docker Engine 拆分成了多个模块，其中的 Docker daemon 部分就捐献给了 CNCF，形成了 containerd。containerd 作为 CNCF 的托管项目，自然是要符合 CRI 标准的。但 Docker 出于自己诸多原因的考虑，它只是在 Docker Engine 里调用了 containerd，外部的接口仍然保持不变，也就是说还不与 CRI 兼容。</p>
<p>由于 Docker 的“固执己见”，这时 Kubernetes 里就出现了两种调用链：第一种是用 CRI 接口调用 dockershim，然后 dockershim 调用 Docker，Docker 再走 containerd 去操作容器。第二种是用 CRI 接口直接调用 containerd 去操作容器。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/a8/9b/a8abfe5a55d0fa8b383867cc6062089b.png?wh=1920x627"
        data-srcset="https://static001.geekbang.org/resource/image/a8/9b/a8abfe5a55d0fa8b383867cc6062089b.png?wh=1920x627, https://static001.geekbang.org/resource/image/a8/9b/a8abfe5a55d0fa8b383867cc6062089b.png?wh=1920x627 1.5x, https://static001.geekbang.org/resource/image/a8/9b/a8abfe5a55d0fa8b383867cc6062089b.png?wh=1920x627 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/a8/9b/a8abfe5a55d0fa8b383867cc6062089b.png?wh=1920x627"
        title="img" /></p>
<p>显然，由于都是用 containerd 来管理容器，所以这两种调用链的最终效果是完全一样的，但是第二种方式省去了 dockershim 和 Docker Engine 两个环节，更加简洁明了，损耗更少，性能也会提升一些。在 2018 年 Kubernetes 1.10 发布的时候，containerd 也更新到了 1.1 版，正式与 Kubernetes 集成，同时还发表了一篇博客文章（https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/），展示了一些性能测试数据：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/6f/e9/6fd065d916e5815e044c10738746ace9.jpg?wh=1784x591"
        data-srcset="https://static001.geekbang.org/resource/image/6f/e9/6fd065d916e5815e044c10738746ace9.jpg?wh=1784x591, https://static001.geekbang.org/resource/image/6f/e9/6fd065d916e5815e044c10738746ace9.jpg?wh=1784x591 1.5x, https://static001.geekbang.org/resource/image/6f/e9/6fd065d916e5815e044c10738746ace9.jpg?wh=1784x591 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/6f/e9/6fd065d916e5815e044c10738746ace9.jpg?wh=1784x591"
        title="img" /></p>
<p>从这些数据可以看到，containerd1.1 相比当时的 Docker 18.03，Pod 的启动延迟降低了大约 20%，CPU 使用率降低了 68%，内存使用率降低了 12%，这是一个相当大的性能改善，对于云厂商非常有诱惑力。</p>
<h3 id="正式弃用-docker">正式“弃用 Docker”</h3>
<p>有了 CRI 和 containerd 这两件强大的武器，胜利的天平已经明显向 Kubernetes 倾斜了。又是两年之后，到了 2020 年，Kubernetes 1.20 终于正式向 Docker“宣战”：kubelet 将弃用 Docker 支持，并会在未来的版本中彻底删除。但由于 Docker 几乎成为了容器技术的代名词，而且 Kubernetes 也已经使用 Docker 很多年，这个声明在不断传播的过程中很快就“变味”了，“kubelet 将弃用 Docker 支持”被简化成了更吸引眼球的“Kubernetes 将弃用 Docker”。</p>
<p>这自然就在 IT 界引起了恐慌，“不明真相的广大群众”纷纷表示震惊：用了这么久的 Docker 突然就不能用了，Kubernetes 为什么要如此对待 Docker？之前在 Docker 上的投入会不会就全归零了？现有的大量镜像该怎么办？其实，如果你理解了前面讲的 CRI 和 containerd 这两个项目，就会知道 Kubernetes 的这个举动也没有什么值得大惊小怪的，一切都是“水到渠成”的：<strong>它实际上只是“弃用了 dockershim”这个小组件，也就是说把 dockershim 移出了 kubelet，并不是“弃用了 Docker”这个软件产品</strong>。所以，“弃用 Docker”对 Kubernetes 和 Docker 来说都不会有什么太大的影响，因为他们两个都早已经把下层都改成了开源的 containerd，原来的 Docker 镜像和容器仍然会正常运行，唯一的变化就是 Kubernetes 绕过了 Docker，直接调用 Docker 内部的 containerd 而已。这个关系你可以参考下面的这张图来理解：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/97/e8/970a234bd610b55340505dac74b026e8.png?wh=740x680"
        data-srcset="https://static001.geekbang.org/resource/image/97/e8/970a234bd610b55340505dac74b026e8.png?wh=740x680, https://static001.geekbang.org/resource/image/97/e8/970a234bd610b55340505dac74b026e8.png?wh=740x680 1.5x, https://static001.geekbang.org/resource/image/97/e8/970a234bd610b55340505dac74b026e8.png?wh=740x680 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/97/e8/970a234bd610b55340505dac74b026e8.png?wh=740x680"
        title="img" /></p>
<p>当然，影响也不是完全没有。如果 Kubernetes 直接使用 containerd 来操纵容器，那么它就是一个与 Docker 独立的工作环境，彼此都不能访问对方管理的容器和镜像。换句话说，使用命令 docker ps 就看不到在 Kubernetes 里运行的容器了。这对有的人来说可能需要稍微习惯一下，改用新的工具 crictl，不过用来查看容器、镜像的子命令还是一样的，比如 ps、images 等等，适应起来难度不大（但如果我们一直用 kubectl 来管理 Kubernetes 的话，这就是没有任何影响了）。“宣战”之后，Kubernetes 原本打算用一年的时间完成“弃用 Docker”的工作，但它也确实低估了 Docker 的根基，到了 1.23 版还是没能移除 dockershim，不得已又往后推迟了半年，终于在今年 5 月份发布的 1.24 版把 dockershim 的代码从 kubelet 里删掉了。自此，Kubernetes 彻底和 Docker“分道扬镳”，今后就是“大路朝天，各走一边”。</p>
<h3 id="docker-的未来">Docker 的未来</h3>
<p>那么，Docker 的未来会是怎么样的呢？难道云原生时代就没有它的立足之地了吗？这个问题的答案很显然是否定的。作为容器技术的初创者，Docker 的历史地位无人能够质疑，虽然现在 Kubernetes 不再默认绑定 Docker，但 Docker 还是能够以其他的形式与 Kubernetes 共存的。首先，因为容器镜像格式已经被标准化了（OCI 规范，Open Container Initiative），Docker 镜像仍然可以在 Kubernetes 里正常使用，原来的开发测试、CI/CD 流程都不需要改动，我们仍然可以拉取 Docker Hub 上的镜像，或者编写 Dockerfile 来打包应用。其次，Docker 是一个完整的软件产品线，不止是 containerd，它还包括了镜像构建、分发、测试等许多服务，甚至在 Docker Desktop 里还内置了 Kubernetes。单就容器开发的便利性来讲，Docker 还是暂时难以被替代的，广大云原生开发者可以在这个熟悉的环境里继续工作，利用 Docker 来开发运行在 Kubernetes 里的应用。</p>
<p>再次，虽然 Kubernetes 已经不再包含 dockershim，但 Docker 公司却把这部分代码接管了过来，另建了一个叫 cri-dockerd（https://github.com/mirantis/cri-dockerd）的项目，作用也是一样的，把 Docker Engine 适配成 CRI 接口，这样 kubelet 就又可以通过它来操作 Docker 了，就仿佛是一切从未发生过。综合来看，Docker 虽然在容器编排战争里落败，被 Kubernetes 排挤到了角落，但它仍然具有强韧的生命力，多年来积累的众多忠实用户和数量庞大的应用镜像是它的最大资本和后盾，足以支持它在另一条不与 Kubernetes 正面交锋的道路上走下去。而对于我们这些初学者来说，Docker 方便易用，具有完善的工具链和友好的交互界面，市面上很难找到能够与它媲美的软件了，应该说是入门学习容器技术和云原生的“不二之选”。至于 Kubernetes 底层用的什么，我们又何必太过于执着和关心呢？</p>
<h2 id="11yamlkubernetes世界里的通用语">11｜YAML：Kubernetes世界里的通用语</h2>
<p>在上次课里，我们一起研究了 Kubernetes 的内部架构和组成，知道它分为控制面和数据面。控制面管理集群，数据面跑业务应用，节点内部又有 apiserver、etcd、scheduler、kubelet、kube-proxy 等组件，它们互相协作来维护整个集群的稳定运行。这套独特的 Master/Node 架构是 Kubernetes 得以安身立命的根本，但仅依靠这套“内功心法”是不是就能够随意仗剑走天涯了呢？显然不行。就像许多武侠、玄幻作品里的人物一样，Kubernetes 也需要一份“招式秘籍”才能把自己的“内功”完全发挥出来，只有内外兼修才能够达到笑傲江湖的境界。而这份“招式秘籍”，就是 Kubernetes 世界里的标准工作语言 YAML，所以今天，我就来讲讲为什么要有 YAML、它是个什么样子、该怎么使用。</p>
<h3 id="声明式与命令式是怎么回事">声明式与命令式是怎么回事</h3>
<p>Kubernetes 使用的 YAML 语言有一个非常关键的特性，叫“声明式”（Declarative），对应的有另外一个词：“命令式”（Imperative）。所以在详细了解 YAML 之前，我们得先来看看“声明式”与“命令式”这两种工作方式，它们在计算机世界里的关系有点像小说里的“剑宗”与“气宗”。我们在入门篇里学习的 Docker 命令和 Dockerfile 就属于“命令式”，大多数编程语言也属于命令式，它的特点是交互性强，注重顺序和过程，你必须“告诉”计算机每步该做什么，所有的步骤都列清楚，这样程序才能够一步步走下去，最后完成任务，显得计算机有点“笨”。“声明式”，在 Kubernetes 出现之前比较少见，它与“命令式”完全相反，不关心具体的过程，更注重结果。我们不需要“教”计算机该怎么做，只要告诉它一个目标状态，它自己就会想办法去完成任务，相比起来自动化、智能化程度更高。这两个概念比较抽象，不太好理解，也是 Kubernetes 初学者经常遇到的障碍之一。Kubernetes 官网上特意以空调为例，解说“声明式”的原理，但我感觉还是没有说得太清楚，所以这里我就再以“打车”来形象地解释一下“命令式”和“声明式”的区别。</p>
<p>假设你要打车去高铁站，但司机不熟悉路况，你就只好不厌其烦地告诉他该走哪条路、在哪个路口转向、在哪里进出主路、停哪个站口。虽然最后到达了目的地，但这一路上也费了很多口舌，发出了无数的“命令”。很显然，这段路程就属于“命令式”。现在我们来换一种方式，同样是去高铁站，但司机经验丰富，他知道哪里有拥堵、哪条路的红绿灯多、哪段路有临时管控、哪里可以抄小道，此时你再多嘴无疑会干扰他的正常驾驶，所以，你只要给他一个“声明”：我要去高铁站，接下来就可以舒舒服服地躺在后座上休息，顺利到达目的地了。在这个“打车”的例子里，Kubernetes 就是这样的一位熟练的司机，Master/Node 架构让它对整个集群的状态了如指掌，内部的众多组件和插件也能够自动监控管理应用。这个时候我们再用“命令式”跟它打交道就不太合适了，因为它知道的信息比我们更多更全面，不需要我们这个外行去指导它这个内行，所以我们最好是做一个“甩手掌柜”，用“声明式”把任务的目标告诉它，比如使用哪个镜像、什么时候运行，让它自己去处理执行过程中的细节。那么，该用什么方式去给 Kubernetes 发出一个“声明”呢？容器技术里的 Shell 脚本和 Dockerfile 可以很好地描述“命令式”，但对于“声明式”就不太合适了，这个时候，我们需要使用专门的 YAML 语言。</p>
<h3 id="什么是-yaml">什么是 YAML</h3>
<p>YAML 语言创建于 2001 年，比 XML 晚了三年。XML 你应该知道吧，它是一种类似 HTML 的标签式语言，有很多繁文缛节。而 YAML 虽然在名字上模仿了 XML，但实质上与 XML 完全不同，更适合人类阅读，计算机解析起来也很容易。YAML 的官网（https://yaml.org/）有对语言规范的完整介绍，所以我就不在这里列举语言的细节了，只讲一些与 Kubernetes 相关的要点，帮助你快速掌握。你需要知道，YAML 是 JSON 的超集，支持整数、浮点数、布尔、字符串、数组和对象等数据类型。也就是说，任何合法的 JSON 文档也都是 YAML 文档，如果你了解 JSON，那么学习 YAML 会容易很多。但和 JSON 比起来，YAML 的语法更简单，形式也更清晰紧凑，比如：</p>
<p>使用空白与缩进表示层次（有点类似 Python），可以不使用花括号和方括号。可以使用 # 书写注释，比起 JSON 是很大的改进。对象（字典）的格式与 JSON 基本相同，但 Key 不需要使用双引号。数组（列表）是使用 - 开头的清单形式（有点类似 MarkDown）。表示对象的 : 和表示数组的 - 后面都必须要有空格。可以使用 &mdash; 在一个文件里分隔多个 YAML 对象。</p>
<p>下面我们来看几个 YAML 的简单示例。首先是数组，它使用 - 列出了三种操作系统：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># YAML数组(列表)
OS:
  - linux
  - macOS
  - Windows
</code></pre></td></tr></table>
</div>
</div><p>这段 YAML 对应的 JSON 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">{
  &#34;OS&#34;: [&#34;linux&#34;, &#34;macOS&#34;, &#34;Windows&#34;]
}
</code></pre></td></tr></table>
</div>
</div><p>对比可以看到 YAML 形式上很简单，没有闭合花括号、方括号的麻烦，每个元素后面也不需要逗号。再来看一个 YAML 对象，声明了 1 个 Master 节点，3 个 Worker 节点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># YAML对象(字典)
Kubernetes:
  master: 1
  worker: 3
</code></pre></td></tr></table>
</div>
</div><p>它等价的 JSON 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">{
  &#34;Kubernetes&#34;: {
    &#34;master&#34;: 1,
    &#34;worker&#34;: 3
  }
}
</code></pre></td></tr></table>
</div>
</div><p>注意到了吗 YAML 里的 Key 都不需要使用双引号，看起来更舒服。把 YAML 的数组、对象组合起来，我们就可以描述出任意的 Kubernetes 资源对象，第三个例子略微复杂点，你可以自己尝试着解释一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"># 复杂的例子，组合数组和对象
Kubernetes:
  master:
    - apiserver: running
    - etcd: running
  node:
    - kubelet: running
    - kube-proxy: down
    - container-runtime: [docker, containerd, cri-o]

</code></pre></td></tr></table>
</div>
</div><p>关于 YAML 语言的其他知识点我就不再一一细说了，都整理在了这张图里，你可以参考YAML 官网，在今后的课程中慢慢体会。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/d4/04/d4f3d4cc27a8a4a70d4898b41efebf04.jpg?wh=1920x2030"
        data-srcset="https://static001.geekbang.org/resource/image/d4/04/d4f3d4cc27a8a4a70d4898b41efebf04.jpg?wh=1920x2030, https://static001.geekbang.org/resource/image/d4/04/d4f3d4cc27a8a4a70d4898b41efebf04.jpg?wh=1920x2030 1.5x, https://static001.geekbang.org/resource/image/d4/04/d4f3d4cc27a8a4a70d4898b41efebf04.jpg?wh=1920x2030 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/d4/04/d4f3d4cc27a8a4a70d4898b41efebf04.jpg?wh=1920x2030"
        title="img" /></p>
<h3 id="什么是-api-对象">什么是 API 对象</h3>
<p>学到这里还不够，因为 YAML 语言只相当于“语法”，要与 Kubernetes 对话，我们还必须有足够的“词汇”来表示“语义”。那么应该声明 Kubernetes 里的哪些东西，才能够让 Kubernetes 明白我们的意思呢？作为一个集群操作系统，Kubernetes 归纳总结了 Google 多年的经验，在理论层面抽象出了很多个概念，用来描述系统的管理运维工作，这些概念就叫做“API 对象”。说到这个名字，你也许会联想到上次课里讲到的 Kubernetes 组件 apiserver。没错，它正是来源于此。因为 apiserver 是 Kubernetes 系统的唯一入口，外部用户和内部组件都必须和它通信，而它采用了 HTTP 协议的 URL 资源理念，API 风格也用 RESTful 的 GET/POST/DELETE 等等，所以，这些概念很自然地就被称为是“API 对象”了。那都有哪些 API 对象呢？你可以使用 kubectl api-resources 来查看当前 Kubernetes 版本支持的所有对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
kubectl api-resources
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/b2/91/b259e8bfbd0d15b796228d92ede42a91.png?wh=1920x701"
        data-srcset="https://static001.geekbang.org/resource/image/b2/91/b259e8bfbd0d15b796228d92ede42a91.png?wh=1920x701, https://static001.geekbang.org/resource/image/b2/91/b259e8bfbd0d15b796228d92ede42a91.png?wh=1920x701 1.5x, https://static001.geekbang.org/resource/image/b2/91/b259e8bfbd0d15b796228d92ede42a91.png?wh=1920x701 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/b2/91/b259e8bfbd0d15b796228d92ede42a91.png?wh=1920x701"
        title="img" /></p>
<p>在输出的“NAME”一栏，就是对象的名字，比如 ConfigMap、Pod、Service 等等，第二栏“SHORTNAMES”则是这种资源的简写，在我们使用 kubectl 命令的时候很有用，可以少敲几次键盘，比如 Pod 可以简写成 po，Service 可以简写成 svc。在使用 kubectl 命令的时候，你还可以加上一个参数 &ndash;v=9，它会显示出详细的命令执行过程，清楚地看到发出的 HTTP 请求，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
kubectl get pod --v=9
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/3f/31/3fe4823f6ba10600e63c197487e84931.png?wh=1920x571"
        data-srcset="https://static001.geekbang.org/resource/image/3f/31/3fe4823f6ba10600e63c197487e84931.png?wh=1920x571, https://static001.geekbang.org/resource/image/3f/31/3fe4823f6ba10600e63c197487e84931.png?wh=1920x571 1.5x, https://static001.geekbang.org/resource/image/3f/31/3fe4823f6ba10600e63c197487e84931.png?wh=1920x571 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/3f/31/3fe4823f6ba10600e63c197487e84931.png?wh=1920x571"
        title="img" /></p>
<p>从截图里可以看到，kubectl 客户端等价于调用了 curl，向 8443 端口发送了 HTTP GET 请求，URL 是 /api/v1/namespaces/default/pods。目前的 Kubernetes 1.23 版本有 50 多种 API 对象，全面地描述了集群的节点、应用、配置、服务、账号等等信息，apiserver 会把它们都存储在数据库 etcd 里，然后 kubelet、scheduler、controller-manager 等组件通过 apiserver 来操作它们，就在 API 对象这个抽象层次实现了对整个集群的管理。</p>
<h3 id="如何描述-api-对象">如何描述 API 对象</h3>
<p>现在我们就来看看如何以 YAML 语言，使用“声明式”在 Kubernetes 里描述并创建 API 对象。之前我们运行 Nginx 的命令你还记得吗？使用的是 kubectl run，和 Docker 一样是“命令式”的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl run ngx --image=nginx:alpine
</code></pre></td></tr></table>
</div>
</div><p>我们来把它改写成“声明式”的 YAML，说清楚我们想要的 Nginx 应用是个什么样子，也就是“目标状态”，让 Kubernetes 自己去决定如何拉取镜像运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
apiVersion: v1
kind: Pod
metadata:
  name: ngx-pod
  labels:
    env: demo
    owner: chrono

spec:
  containers:
  - image: nginx:alpine
    name: ngx
    ports:
    - containerPort: 80

</code></pre></td></tr></table>
</div>
</div><p>有了刚才 YAML 语言知识“打底”，相信你基本上能够把它看明白，知道它是一个 Pod，要使用 nginx:alpine 镜像创建一个容器，开放端口 80，而其他的部分，就是 Kubernetes 对 API 对象强制的格式要求了。因为 API 对象采用标准的 HTTP 协议，为了方便理解，我们可以借鉴一下 HTTP 的报文格式，把 API 对象的描述分成“header”和“body”两部分。“header”包含的是 API 对象的基本信息，有三个字段：apiVersion、kind、metadata。</p>
<p>apiVersion 表示操作这种资源的 API 版本号，由于 Kubernetes 的迭代速度很快，不同的版本创建的对象会有差异，为了区分这些版本就需要使用 apiVersion 这个字段，比如 v1、v1alpha1、v1beta1 等等。kind 表示资源对象的类型，这个应该很好理解，比如 Pod、Node、Job、Service 等等。metadata 这个字段顾名思义，表示的是资源的一些“元信息”，也就是用来标记对象，方便 Kubernetes 管理的一些信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apiVersion: v1
kind: Pod
metadata:
  name: ngx-pod
  labels:
    env: demo
    owner: chrono
</code></pre></td></tr></table>
</div>
</div><p>比如在这个 YAML 示例里就有两个“元信息”，一个是 name，给 Pod 起了个名字叫 ngx-pod，另一个是 labels，给 Pod“贴”上了一些便于查找的标签，分别是 env 和 owner。apiVersion、kind、metadata 都被 kubectl 用于生成 HTTP 请求发给 apiserver，你可以用 &ndash;v=9 参数在请求的 URL 里看到它们，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">https://192.168.49.2:8443/api/v1/namespaces/default/pods/ngx-pod
</code></pre></td></tr></table>
</div>
</div><p>和 HTTP 协议一样，“header”里的 apiVersion、kind、metadata 这三个字段是任何对象都必须有的，而“body”部分则会与对象特定相关，每种对象会有不同的规格定义，在 YAML 里就表现为 spec 字段（即 specification），表示我们对对象的“期望状态”（desired status）。还是来看这个 Pod，它的 spec 里就是一个 containers 数组，里面的每个元素又是一个对象，指定了名字、镜像、端口等信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">spec:
  containers:
  - image: nginx:alpine
    name: ngx
    ports:
    - containerPort: 80
</code></pre></td></tr></table>
</div>
</div><p>现在把这些字段综合起来，我们就能够看出，这份 YAML 文档完整地描述了一个类型是 Pod 的 API 对象，要求使用 v1 版本的 API 接口去管理，其他更具体的名称、标签、状态等细节都记录在了 metadata 和 spec 字段等里。使用 kubectl apply、kubectl delete，再加上参数 -f，你就可以使用这个 YAML 文件，创建或者删除对象了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl apply -f ngx-pod.yml
kubectl delete -f ngx-pod.yml
</code></pre></td></tr></table>
</div>
</div><p>Kubernetes 收到这份“声明式”的数据，再根据 HTTP 请求里的 POST/DELETE 等方法，就会自动操作这个资源对象，至于对象在哪个节点上、怎么创建、怎么删除完全不用我们操心。</p>
<h3 id="如何编写-yaml">如何编写 YAML</h3>
<p>讲到这里，相信你对如何使用 YAML 与 Kubernetes 沟通应该大概了解了，不过疑问也会随之而来：这么多 API 对象，我们怎么知道该用什么 apiVersion、什么 kind？metadata、spec 里又该写哪些字段呢？还有，YAML 看起来简单，写起来却比较麻烦，缩进对齐很容易搞错，有没有什么简单的方法呢？这些问题最权威的答案无疑是 Kubernetes 的官方参考文档（https://kubernetes.io/docs/reference/kubernetes-api/），API 对象的所有字段都可以在里面找到。不过官方文档内容太多太细，查阅起来有些费劲，所以下面我就介绍几个简单实用的小技巧。</p>
<p>第一个技巧其实前面已经说过了，就是 kubectl api-resources 命令，它会显示出资源对象相应的 API 版本和类型，比如 Pod 的版本是“v1”，Ingress 的版本是“networking.k8s.io/v1”，照着它写绝对不会错。第二个技巧，是命令 kubectl explain，它相当于是 Kubernetes 自带的 API 文档，会给出对象字段的详细说明，这样我们就不必去网上查找了。比如想要看 Pod 里的字段该怎么写，就可以这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl explain pod
kubectl explain pod.metadata
kubectl explain pod.spec
kubectl explain pod.spec.containers
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/53/85/53cf783195be896e7632c1fc6bd24185.png?wh=1920x1068"
        data-srcset="https://static001.geekbang.org/resource/image/53/85/53cf783195be896e7632c1fc6bd24185.png?wh=1920x1068, https://static001.geekbang.org/resource/image/53/85/53cf783195be896e7632c1fc6bd24185.png?wh=1920x1068 1.5x, https://static001.geekbang.org/resource/image/53/85/53cf783195be896e7632c1fc6bd24185.png?wh=1920x1068 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/53/85/53cf783195be896e7632c1fc6bd24185.png?wh=1920x1068"
        title="img" /></p>
<p>使用前两个技巧编写 YAML 就基本上没有难度了。不过我们还可以让 kubectl 为我们“代劳”，生成一份“文档样板”，免去我们打字和对齐格式的工作。这第三个技巧就是 kubectl 的两个特殊参数 &ndash;dry-run=client 和 -o yaml，前者是空运行，后者是生成 YAML 格式，结合起来使用就会让 kubectl 不会有实际的创建动作，而只生成 YAML 文件。例如，想要生成一个 Pod 的 YAML 样板示例，可以在 kubectl run 后面加上这两个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl run ngx --image=nginx:alpine --dry-run=client -o yaml
</code></pre></td></tr></table>
</div>
</div><p>就会生成一个绝对正确的 YAML 文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: ngx
  name: ngx
spec:
  containers:
  - image: nginx:alpine
    name: ngx
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
</code></pre></td></tr></table>
</div>
</div><p>接下来你要做的，就是查阅对象的说明文档，添加或者删除字段来定制这个 YAML 了。这个小技巧还可以再进化一下，把这段参数定义成 Shell 变量（名字任意，比如$do/$go，这里用的是$out），用起来会更省事，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">export out=&#34;--dry-run=client -o yaml&#34;
kubectl run ngx --image=nginx:alpine $out
</code></pre></td></tr></table>
</div>
</div><p>今后除了一些特殊情况，我们都不会再使用 kubectl run 这样的命令去直接创建 Pod，而是会编写 YAML，用“声明式”来描述对象，再用 kubectl apply 去发布 YAML 来创建对象。</p>
<h3 id="小结-10">小结</h3>
<p>好了，今天就到这里，我们一起学习了“声明式”和“命令式”的区别、YAML 语言的语法、如何用 YAML 来描述 API 对象，还有一些编写 YAML 文件的技巧。Kubernetes 采用 YAML 作为工作语言是它有别与其他系统的一大特色，声明式的语言能够更准确更清晰地描述系统状态，避免引入繁琐的操作步骤扰乱系统，与 Kubernetes 高度自动化的内部结构相得益彰，而且纯文本形式的 YAML 也很容易版本化，适合 CI/CD。再小结一下今天的内容要点：YAML 是 JSON 的超集，支持数组和对象，能够描述复杂的状态，可读性也很好。Kubernetes 把集群里的一切资源都定义为 API 对象，通过 RESTful 接口来管理。描述 API 对象需要使用 YAML 语言，必须的字段是 apiVersion、kind、metadata。命令 kubectl api-resources 可以查看对象的 apiVersion 和 kind，命令 kubectl explain 可以查看对象字段的说明文档。命令 kubectl apply、kubectl delete 发送 HTTP 请求，管理 API 对象。使用参数 &ndash;dry-run=client -o yaml 可以生成对象的 YAML 模板，简化编写工作。</p>
<h2 id="12pod如何理解这个kubernetes里最核心的概念">12｜Pod：如何理解这个Kubernetes里最核心的概念？</h2>
<p>前两天我们学习了 Kubernetes 世界里的工作语言 YAML，还编写了一个简短的 YAML 文件，描述了一个 API 对象：Pod，它在 spec 字段里包含了容器的定义。那么为什么 Kubernetes 不直接使用已经非常成熟稳定的容器？为什么要再单独抽象出一个 Pod 对象？为什么几乎所有人都说 Pod 是 Kubernetes 里最核心最基本的概念呢？今天我就来逐一解答这些问题，希望你学完今天的这次课，心里面能够有明确的答案。</p>
<h3 id="为什么要有-pod">为什么要有 Pod</h3>
<p>Pod 这个词原意是“豌豆荚”，后来又延伸出“舱室”“太空舱”等含义，你可以看一下这张图片，形象地来说 Pod 就是包含了很多组件、成员的一种结构。</p>
<p>容器技术我想你现在已经比较熟悉了，它让进程在一个“沙盒”环境里运行，具有良好的隔离性，对应用是一个非常好的封装。不过，当容器技术进入到现实的生产环境中时，这种隔离性就带来了一些麻烦。因为很少有应用是完全独立运行的，经常需要几个进程互相协作才能完成任务，比如在“入门篇”里我们搭建 WordPress 网站的时候，就需要 Nginx、WordPress、MariaDB 三个容器一起工作。WordPress 例子里的这三个应用之间的关系还是比较松散的，它们可以分别调度，运行在不同的机器上也能够以 IP 地址通信。但还有一些特殊情况，多个应用结合得非常紧密以至于无法把它们拆开。比如，有的应用运行前需要其他应用帮它初始化一些配置，还有就是日志代理，它必须读取另一个应用存储在本地磁盘的文件再转发出去。这些应用如果被强制分离成两个容器，切断联系，就无法正常工作了。那么把这些应用都放在一个容器里运行可不可以呢？当然可以，但这并不是一种好的做法。因为容器的理念是对应用的独立封装，它里面就应该是一个进程、一个应用，如果里面有多个应用，不仅违背了容器的初衷，也会让容器更难以管理。为了解决这样多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个“收纳舱”，让多个容器既保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态。所以，Pod 的概念也就呼之欲出了，容器正是“豆荚”里那些小小的“豌豆”，你可以在 Pod 的 YAML 里看到，“spec.containers”字段其实是一个数组，里面允许定义多个容器。如果再拿之前讲过的“小板房”来比喻的话，Pod 就是由客厅、卧室、厨房等预制房间拼装成的一个齐全的生活环境，不仅同样具备易于拆装易于搬迁的优点，而且要比单独的“一居室”功能强大得多，能够让进程“住”得更舒服。</p>
<h3 id="为什么-pod-是-kubernetes-的核心对象">为什么 Pod 是 Kubernetes 的核心对象</h3>
<p>因为 Pod 是对容器的“打包”，里面的容器是一个整体，总是能够一起调度、一起运行，绝不会出现分离的情况，而且 Pod 属于 Kubernetes，可以在不触碰下层容器的情况下任意定制修改。所以有了 Pod 这个抽象概念，Kubernetes 在集群级别上管理应用就会“得心应手”了。Kubernetes 让 Pod 去编排处理容器，然后把 Pod 作为应用调度部署的最小单位，Pod 也因此成为了 Kubernetes 世界里的“原子”（当然这个“原子”内部是有结构的，不是铁板一块），基于 Pod 就可以构建出更多更复杂的业务形态了。下面的这张图你也许在其他资料里见过，它从 Pod 开始，扩展出了 Kubernetes 里的一些重要 API 对象，比如配置信息 ConfigMap、离线作业 Job、多实例部署 Deployment 等等，它们都分别对应到现实中的各种实际运维需求。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/9e/75/9ebab7d513a211a926dd69f7535ac175.png?wh=1478x812"
        data-srcset="https://static001.geekbang.org/resource/image/9e/75/9ebab7d513a211a926dd69f7535ac175.png?wh=1478x812, https://static001.geekbang.org/resource/image/9e/75/9ebab7d513a211a926dd69f7535ac175.png?wh=1478x812 1.5x, https://static001.geekbang.org/resource/image/9e/75/9ebab7d513a211a926dd69f7535ac175.png?wh=1478x812 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/9e/75/9ebab7d513a211a926dd69f7535ac175.png?wh=1478x812"
        title="img" /></p>
<p>不过这张图虽然很经典，参考价值很高，但毕竟有些年头了，随着 Kubernetes 的发展，它已经不能够全面地描述 Kubernetes 的资源对象了。受这张图的启发，我自己重新画了一份以 Pod 为中心的 Kubernetes 资源对象关系图，添加了一些新增的 Kubernetes 概念，今后我们就依据这张图来探索 Kubernetes 的各项功能。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/b5/cf/b5a7003788cb6f2b1c5c4f6873a8b5cf.jpg?wh=1920x1298"
        data-srcset="https://static001.geekbang.org/resource/image/b5/cf/b5a7003788cb6f2b1c5c4f6873a8b5cf.jpg?wh=1920x1298, https://static001.geekbang.org/resource/image/b5/cf/b5a7003788cb6f2b1c5c4f6873a8b5cf.jpg?wh=1920x1298 1.5x, https://static001.geekbang.org/resource/image/b5/cf/b5a7003788cb6f2b1c5c4f6873a8b5cf.jpg?wh=1920x1298 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/b5/cf/b5a7003788cb6f2b1c5c4f6873a8b5cf.jpg?wh=1920x1298"
        title="img" /></p>
<p>从这两张图中你也应该能够看出来，所有的 Kubernetes 资源都直接或者间接地依附在 Pod 之上，所有的 Kubernetes 功能都必须通过 Pod 来实现，所以 Pod 理所当然地成为了 Kubernetes 的核心对象。</p>
<h3 id="如何使用-yaml-描述-pod">如何使用 YAML 描述 Pod</h3>
<p>既然 Pod 这么重要，那么我们就很有必要来详细了解一下 Pod，理解了 Pod 概念，我们的 Kubernetes 学习之旅就成功了一半。还记得吧，我们始终可以用命令 kubectl explain 来查看任意字段的详细说明，所以接下来我就只简要说说写 YAML 时 Pod 里的一些常用字段。因为 Pod 也是 API 对象，所以它也必然具有 apiVersion、kind、metadata、spec 这四个基本组成部分。“apiVersion”和“kind”这两个字段很简单，对于 Pod 来说分别是固定的值 v1 和 Pod，而一般来说，“metadata”里应该有 name 和 labels 这两个字段。我们在使用 Docker 创建容器的时候，可以不给容器起名字，但在 Kubernetes 里，Pod 必须要有一个名字，这也是 Kubernetes 里所有资源对象的一个约定。在课程里，我通常会为 Pod 名字统一加上 pod 后缀，这样可以和其他类型的资源区分开。</p>
<p>name 只是一个基本的标识，信息有限，所以 labels 字段就派上了用处。它可以添加任意数量的 Key-Value，给 Pod“贴”上归类的标签，结合 name 就更方便识别和管理了。比如说，我们可以根据运行环境，使用标签 env=dev/test/prod，或者根据所在的数据中心，使用标签 region: north/south，还可以根据应用在系统中的层次，使用 tier=front/middle/back ……如此种种，只需要发挥你的想象力。下面这段 YAML 代码就描述了一个简单的 Pod，名字是“busy-pod”，再附加上一些标签：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apiVersion: v1
kind: Pod
metadata:
  name: busy-pod
  labels:
    owner: chrono
    env: demo
    region: north
    tier: back
</code></pre></td></tr></table>
</div>
</div><p>“metadata”一般写上 name 和 labels 就足够了，而“spec”字段由于需要管理、维护 Pod 这个 Kubernetes 的基本调度单元，里面有非常多的关键信息，今天我介绍最重要的“containers”，其他的 hostname、restartPolicy 等字段你可以课后自己查阅文档学习。“containers”是一个数组，里面的每一个元素又是一个 container 对象，也就是容器。和 Pod 一样，container 对象也必须要有一个 name 表示名字，然后当然还要有一个 image 字段来说明它使用的镜像，这两个字段是必须要有的，否则 Kubernetes 会报告数据验证错误。container 对象的其他字段基本上都可以和“入门篇”学过的 Docker、容器技术对应，理解起来难度不大，我就随便列举几个：</p>
<p>ports：列出容器对外暴露的端口，和 Docker 的 -p 参数有点像。imagePullPolicy：指定镜像的拉取策略，可以是 Always/Never/IfNotPresent，一般默认是 IfNotPresent，也就是说只有本地不存在才会远程拉取镜像，可以减少网络消耗。env：定义 Pod 的环境变量，和 Dockerfile 里的 ENV 指令有点类似，但它是运行时指定的，更加灵活可配置。command：定义容器启动时要执行的命令，相当于 Dockerfile 里的 ENTRYPOINT 指令。args：它是 command 运行时的参数，相当于 Dockerfile 里的 CMD 指令，这两个命令和 Docker 的含义不同，要特别注意。</p>
<p>现在我们就来编写“busy-pod”的 spec 部分，添加 env、command、args 等字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">spec:
  containers:
  - image: busybox:latest
    name: busy
    imagePullPolicy: IfNotPresent
    env:
      - name: os
        value: &#34;ubuntu&#34;
      - name: debug
        value: &#34;on&#34;
    command:
      - /bin/echo
    args:
      - &#34;$(os), $(debug)&#34;
</code></pre></td></tr></table>
</div>
</div><p>这里我为 Pod 指定使用镜像 busybox:latest，拉取策略是 IfNotPresent ，然后定义了 os 和 debug 两个环境变量，启动命令是 /bin/echo，参数里输出刚才定义的环境变量。把这份 YAML 文件和 Docker 命令对比一下，你就可以看出，YAML 在 spec.containers 字段里用“声明式”把容器的运行状态描述得非常清晰准确，要比 docker run 那长长的命令行要整洁的多，对人、对机器都非常友好。</p>
<h3 id="如何使用-kubectl-操作-pod">如何使用 kubectl 操作 Pod</h3>
<p>有了描述 Pod 的 YAML 文件，现在我就介绍一下用来操作 Pod 的 kubectl 命令。kubectl apply、kubectl delete 这两个命令在上次课里已经说过了，它们可以使用 -f 参数指定 YAML 文件创建或者删除 Pod，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl apply -f busy-pod.yml
kubectl delete -f busy-pod.yaml
</code></pre></td></tr></table>
</div>
</div><p>不过，因为我们在 YAML 里定义了“name”字段，所以也可以在删除的时候直接指定名字来删除：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl delete pod busy-pod
</code></pre></td></tr></table>
</div>
</div><p>和 Docker 不一样，Kubernetes 的 Pod 不会在前台运行，只能在后台（相当于默认使用了参数 -d），所以输出信息不能直接看到。我们可以用命令 kubectl logs，它会把 Pod 的标准输出流信息展示给我们看，在这里就会显示出预设的两个环境变量的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl logs busy-pod
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/76/f2/76452a603cddaf3cce6706697369d1f2.png?wh=948x124"
        data-srcset="https://static001.geekbang.org/resource/image/76/f2/76452a603cddaf3cce6706697369d1f2.png?wh=948x124, https://static001.geekbang.org/resource/image/76/f2/76452a603cddaf3cce6706697369d1f2.png?wh=948x124 1.5x, https://static001.geekbang.org/resource/image/76/f2/76452a603cddaf3cce6706697369d1f2.png?wh=948x124 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/76/f2/76452a603cddaf3cce6706697369d1f2.png?wh=948x124"
        title="img" /></p>
<p>使用命令 kubectl get pod 可以查看 Pod 列表和运行状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
kubectl get pod
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/54/9c/544d4d4521yy1e2cyy3b79615cbcc69c.png?wh=1464x184"
        data-srcset="https://static001.geekbang.org/resource/image/54/9c/544d4d4521yy1e2cyy3b79615cbcc69c.png?wh=1464x184, https://static001.geekbang.org/resource/image/54/9c/544d4d4521yy1e2cyy3b79615cbcc69c.png?wh=1464x184 1.5x, https://static001.geekbang.org/resource/image/54/9c/544d4d4521yy1e2cyy3b79615cbcc69c.png?wh=1464x184 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/54/9c/544d4d4521yy1e2cyy3b79615cbcc69c.png?wh=1464x184"
        title="img" /></p>
<p>你会发现这个 Pod 运行有点不正常，状态是“CrashLoopBackOff”，那么我们可以使用命令 kubectl describe 来检查它的详细状态，它在调试排错时很有用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
kubectl describe pod busy-pod
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/78/68/786bb31f3d6d69edd16ddfb540d9ef68.png?wh=1920x294"
        data-srcset="https://static001.geekbang.org/resource/image/78/68/786bb31f3d6d69edd16ddfb540d9ef68.png?wh=1920x294, https://static001.geekbang.org/resource/image/78/68/786bb31f3d6d69edd16ddfb540d9ef68.png?wh=1920x294 1.5x, https://static001.geekbang.org/resource/image/78/68/786bb31f3d6d69edd16ddfb540d9ef68.png?wh=1920x294 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/78/68/786bb31f3d6d69edd16ddfb540d9ef68.png?wh=1920x294"
        title="img" /></p>
<p>通常需要关注的是末尾的“Events”部分，它显示的是 Pod 运行过程中的一些关键节点事件。对于这个 busy-pod，因为它只执行了一条 echo 命令就退出了，而 Kubernetes 默认会重启 Pod，所以就会进入一个反复停止 - 启动的循环错误状态。因为 Kubernetes 里运行的应用大部分都是不会主动退出的服务，所以我们可以把这个 busy-pod 删掉，用上次课里创建的 ngx-pod.yml，启动一个 Nginx 服务，这才是大多数 Pod 的工作方式。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
kubectl apply -f ngx-pod.yml
</code></pre></td></tr></table>
</div>
</div><p>启动之后，我们再用 kubectl get pod 来查看状态，就会发现它已经是“Running”状态了：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/6c/b1/6c1ce29c29602f111ba39dea6aab95b1.png?wh=1920x415"
        data-srcset="https://static001.geekbang.org/resource/image/6c/b1/6c1ce29c29602f111ba39dea6aab95b1.png?wh=1920x415, https://static001.geekbang.org/resource/image/6c/b1/6c1ce29c29602f111ba39dea6aab95b1.png?wh=1920x415 1.5x, https://static001.geekbang.org/resource/image/6c/b1/6c1ce29c29602f111ba39dea6aab95b1.png?wh=1920x415 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/6c/b1/6c1ce29c29602f111ba39dea6aab95b1.png?wh=1920x415"
        title="img" /></p>
<p>另外，kubectl 也提供与 docker 类似的 cp 和 exec 命令，kubectl cp 可以把本地文件拷贝进 Pod，kubectl exec 是进入 Pod 内部执行 Shell 命令，用法也差不多。比如我有一个“a.txt”文件，那么就可以使用 kubectl cp 拷贝进 Pod 的“/tmp”目录里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
echo &#39;aaa&#39; &gt; a.txt
kubectl cp a.txt ngx-pod:/tmp
</code></pre></td></tr></table>
</div>
</div><p>不过 kubectl exec 的命令格式与 Docker 有一点小差异，需要在 Pod 后面加上 &ndash;，把 kubectl 的命令与 Shell 命令分隔开，你在用的时候需要小心一些：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
kubectl exec -it ngx-pod -- sh
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/34/6b/343756ee45533a056fdca97f9fe2dd6b.png?wh=1920x402"
        data-srcset="https://static001.geekbang.org/resource/image/34/6b/343756ee45533a056fdca97f9fe2dd6b.png?wh=1920x402, https://static001.geekbang.org/resource/image/34/6b/343756ee45533a056fdca97f9fe2dd6b.png?wh=1920x402 1.5x, https://static001.geekbang.org/resource/image/34/6b/343756ee45533a056fdca97f9fe2dd6b.png?wh=1920x402 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/34/6b/343756ee45533a056fdca97f9fe2dd6b.png?wh=1920x402"
        title="img" /></p>
<h3 id="小结-11">小结</h3>
<p>好了，今天我们一起学习了 Kubernetes 里最核心最基本的概念 Pod，知道了应该如何使用 YAML 来定制 Pod，还有如何使用 kubectl 命令来创建、删除、查看、调试 Pod。Pod 屏蔽了容器的一些底层细节，同时又具有足够的控制管理能力，比起容器的“细粒度”、虚拟机的“粗粒度”，Pod 可以说是“中粒度”，灵活又轻便，非常适合在云计算领域作为应用调度的基本单元，因而成为了 Kubernetes 世界里构建一切业务的“原子”。今天的知识要点我简单列在了下面：</p>
<p>现实中经常会有多个进程密切协作才能完成任务的应用，而仅使用容器很难描述这种关系，所以就出现了 Pod，它“打包”一个或多个容器，保证里面的进程能够被整体调度。Pod 是 Kubernetes 管理应用的最小单位，其他的所有概念都是从 Pod 衍生出来的。Pod 也应该使用 YAML“声明式”描述，关键字段是“spec.containers”，列出名字、镜像、端口等要素，定义内部的容器运行状态。操作 Pod 的命令很多与 Docker 类似，如 kubectl run、kubectl cp、kubectl exec 等，但有的命令有些小差异，使用的时候需要注意。</p>
<p>虽然 Pod 是 Kubernetes 的核心概念，非常重要，但事实上在 Kubernetes 里通常并不会直接创建 Pod，因为它只是对容器做了简单的包装，比较脆弱，离复杂的业务需求还有些距离，需要 Job、CronJob、Deployment 等其他对象增添更多的功能才能投入生产使用。</p>
<h2 id="13jobcronjob为什么不直接用pod来处理业务">13｜Job/CronJob：为什么不直接用Pod来处理业务？</h2>
<p>在上次的课里我们学习了 Kubernetes 的核心对象 Pod，用来编排一个或多个容器，让这些容器共享网络、存储等资源，总是共同调度，从而紧密协同工作。因为 Pod 比容器更能够表示实际的应用，所以 Kubernetes 不会在容器层面来编排业务，而是把 Pod 作为在集群里调度运维的最小单位。前面我们也看到了一张 Kubernetes 的资源对象关系图，以 Pod 为中心，延伸出了很多表示各种业务的其他资源对象。那么你会不会有这样的疑问：Pod 的功能已经足够完善了，为什么还要定义这些额外的对象呢？为什么不直接在 Pod 里添加功能，来处理业务需求呢？这个问题体现了 Google 对大规模计算集群管理的深度思考，今天我就说说 Kubernetes 基于 Pod 的设计理念，先从最简单的两种对象——Job 和 CronJob 讲起。</p>
<h3 id="为什么不直接使用-pod">为什么不直接使用 Pod</h3>
<p>现在你应该知道，Kubernetes 使用的是 RESTful API，把集群中的各种业务都抽象为 HTTP 资源对象，那么在这个层次之上，我们就可以使用面向对象的方式来考虑问题。如果你有一些编程方面的经验，就会知道面向对象编程（OOP），它把一切都视为高内聚的对象，强调对象之间互相通信来完成任务。虽然面向对象的设计思想多用于软件开发，但它放到 Kubernetes 里却意外地合适。因为 Kubernetes 使用 YAML 来描述资源，把业务简化成了一个个的对象，内部有属性，外部有联系，也需要互相协作，只不过我们不需要编程，完全由 Kubernetes 自动处理（其实 Kubernetes 的 Go 语言内部实现就大量应用了面向对象）。面向对象的设计有许多基本原则，其中有两条我认为比较恰当地描述了 Kubernetes 对象设计思路，一个是“单一职责”，另一个是“组合优于继承”。</p>
<p>“单一职责”的意思是对象应该只专注于做好一件事情，不要贪大求全，保持足够小的粒度才更方便复用和管理。“组合优于继承”的意思是应该尽量让对象在运行时产生联系，保持松耦合，而不要用硬编码的方式固定对象的关系。应用这两条原则，我们再来看 Kubernetes 的资源对象就会很清晰了。因为 Pod 已经是一个相对完善的对象，专门负责管理容器，那么我们就不应该再“画蛇添足”地盲目为它扩充功能，而是要保持它的独立性，容器之外的功能就需要定义其他的对象，把 Pod 作为它的一个成员“组合”进去。这样每种 Kubernetes 对象就可以只关注自己的业务领域，只做自己最擅长的事情，其他的工作交给其他对象来处理，既不“缺位”也不“越位”，既有分工又有协作，从而以最小成本实现最大收益。</p>
<h3 id="为什么要有-jobcronjob">为什么要有 Job/CronJob</h3>
<p>现在我们来看看 Kubernetes 里的两种新对象：Job 和 CronJob，它们就组合了 Pod，实现了对离线业务的处理。上次课讲 Pod 的时候我们运行了两个 Pod：Nginx 和 busybox，它们分别代表了 Kubernetes 里的两大类业务。一类是像 Nginx 这样长时间运行的“在线业务”，另一类是像 busybox 这样短时间运行的“离线业务”。“在线业务”类型的应用有很多，比如 Nginx、Node.js、MySQL、Redis 等等，一旦运行起来基本上不会停，也就是永远在线。而“离线业务”类型的应用也并不少见，它们一般不直接服务于外部用户，只对内部用户有意义，比如日志分析、数据建模、视频转码等等，虽然计算量很大，但只会运行一段时间。“离线业务”的特点是必定会退出，不会无期限地运行下去，所以它的调度策略也就与“在线业务”存在很大的不同，需要考虑运行超时、状态检查、失败重试、获取计算结果等管理事项。而这些业务特性与容器管理没有必然的联系，如果由 Pod 来实现就会承担不必要的义务，违反了“单一职责”，所以我们应该把这部分功能分离到另外一个对象上实现，让这个对象去控制 Pod 的运行，完成附加的工作。</p>
<p>“离线业务”也可以分为两种。一种是“临时任务”，跑完就完事了，下次有需求了说一声再重新安排；另一种是“定时任务”，可以按时按点周期运行，不需要过多干预。对应到 Kubernetes 里，“临时任务”就是 API 对象 Job，“定时任务”就是 API 对象 CronJob，使用这两个对象你就能够在 Kubernetes 里调度管理任意的离线业务了。由于 Job 和 CronJob 都属于离线业务，所以它们也比较相似。我们先学习通常只会运行一次的 Job 对象以及如何操作。</p>
<h3 id="如何使用-yaml-描述-job">如何使用 YAML 描述 Job</h3>
<p>Job 的 YAML“文件头”部分还是那几个必备字段，我就不再重复解释了，简单说一下：apiVersion 不是 v1，而是 batch/v1。kind 是 Job，这个和对象的名字是一致的。metadata 里仍然要有 name 标记名字，也可以用 labels 添加任意的标签。</p>
<p>如果记不住这些也不要紧，你还可以使用命令 kubectl explain job 来看它的字段说明。不过想要生成 YAML 样板文件的话不能使用 kubectl run，因为 kubectl run 只能创建 Pod，要创建 Pod 以外的其他 API 对象，需要使用命令 kubectl create，再加上对象的类型名。比如用 busybox 创建一个“echo-job”，命令就是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">export out=&#34;--dry-run=client -o yaml&#34;              # 定义Shell变量
kubectl create job echo-job --image=busybox $out
</code></pre></td></tr></table>
</div>
</div><p>会生成一个基本的 YAML 文件，保存之后做点修改，就有了一个 Job 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apiVersion: batch/v1
kind: Job
metadata:
  name: echo-job

spec:
  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - image: busybox
        name: echo-job
        imagePullPolicy: IfNotPresent
        command: [&#34;/bin/echo&#34;]
        args: [&#34;hello&#34;, &#34;world&#34;]
</code></pre></td></tr></table>
</div>
</div><p>你会注意到 Job 的描述与 Pod 很像，但又有些不一样，主要的区别就在“spec”字段里，多了一个 template 字段，然后又是一个“spec”，显得有点怪。如果你理解了刚才说的面向对象设计思想，就会明白这种做法的道理。它其实就是在 Job 对象里应用了组合模式，template 字段定义了一个“应用模板”，里面嵌入了一个 Pod，这样 Job 就可以从这个模板来创建出 Pod。而这个 Pod 因为受 Job 的管理控制，不直接和 apiserver 打交道，也就没必要重复 apiVersion 等“头字段”，只需要定义好关键的 spec，描述清楚容器相关的信息就可以了，可以说是一个“无头”的 Pod 对象。为了辅助你理解，我把 Job 对象重新组织了一下，用不同的颜色来区分字段，这样你就能够很容易看出来，其实这个“echo-job”里并没有太多额外的功能，只是把 Pod 做了个简单的包装：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/9b/28/9b780905a824d2103d4ayyc79267ae28.jpg?wh=1920x2141"
        data-srcset="https://static001.geekbang.org/resource/image/9b/28/9b780905a824d2103d4ayyc79267ae28.jpg?wh=1920x2141, https://static001.geekbang.org/resource/image/9b/28/9b780905a824d2103d4ayyc79267ae28.jpg?wh=1920x2141 1.5x, https://static001.geekbang.org/resource/image/9b/28/9b780905a824d2103d4ayyc79267ae28.jpg?wh=1920x2141 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/9b/28/9b780905a824d2103d4ayyc79267ae28.jpg?wh=1920x2141"
        title="img" /></p>
<p>总的来说，这里的 Pod 工作非常简单，在 containers 里写好名字和镜像，command 执行 /bin/echo，输出“hello world”。不过，因为 Job 业务的特殊性，所以我们还要在 spec 里多加一个字段 restartPolicy，确定 Pod 运行失败时的策略，OnFailure 是失败原地重启容器，而 Never 则是不重启容器，让 Job 去重新调度生成一个新的 Pod。</p>
<h3 id="如何在-kubernetes-里操作-job">如何在 Kubernetes 里操作 Job</h3>
<p>现在让我们来创建 Job 对象，运行这个简单的离线作业，用的命令还是 kubectl apply：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl apply -f job.yml
</code></pre></td></tr></table>
</div>
</div><p>创建之后 Kubernetes 就会从 YAML 的模板定义中提取 Pod，在 Job 的控制下运行 Pod，你可以用 kubectl get job、kubectl get pod 来分别查看 Job 和 Pod 的状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl get job
kubectl get pod
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/33/55/33ac80cb9f5dd91d1affc133e56efc55.png?wh=1382x368"
        data-srcset="https://static001.geekbang.org/resource/image/33/55/33ac80cb9f5dd91d1affc133e56efc55.png?wh=1382x368, https://static001.geekbang.org/resource/image/33/55/33ac80cb9f5dd91d1affc133e56efc55.png?wh=1382x368 1.5x, https://static001.geekbang.org/resource/image/33/55/33ac80cb9f5dd91d1affc133e56efc55.png?wh=1382x368 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/33/55/33ac80cb9f5dd91d1affc133e56efc55.png?wh=1382x368"
        title="img" /></p>
<p>可以看到，因为 Pod 被 Job 管理，它就不会反复重启报错了，而是会显示为 Completed 表示任务完成，而 Job 里也会列出运行成功的作业数量，这里只有一个作业，所以就是 1/1。你还可以看到，Pod 被自动关联了一个名字，用的是 Job 的名字（echo-job）再加上一个随机字符串（pb5gh），这当然也是 Job 管理的“功劳”，免去了我们手工定义的麻烦，这样我们就可以使用命令 kubectl logs 来获取 Pod 的运行结果：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/81/b5/81224cedf0acf209b746a1162d09b3b5.png?wh=1114x118"
        data-srcset="https://static001.geekbang.org/resource/image/81/b5/81224cedf0acf209b746a1162d09b3b5.png?wh=1114x118, https://static001.geekbang.org/resource/image/81/b5/81224cedf0acf209b746a1162d09b3b5.png?wh=1114x118 1.5x, https://static001.geekbang.org/resource/image/81/b5/81224cedf0acf209b746a1162d09b3b5.png?wh=1114x118 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/81/b5/81224cedf0acf209b746a1162d09b3b5.png?wh=1114x118"
        title="img" /></p>
<p>到这里，你可能会觉得，经过了 Job、Pod 对容器的两次封装，虽然从概念上很清晰，但好像并没有带来什么实际的好处，和直接跑容器也差不了多少。其实 Kubernetes 的这套 YAML 描述对象的框架提供了非常多的灵活性，可以在 Job 级别、Pod 级别添加任意的字段来定制业务，这种优势是简单的容器技术无法相比的。这里我列出几个控制离线作业的重要字段，其他更详细的信息可以参考 Job 文档：</p>
<p>activeDeadlineSeconds，设置 Pod 运行的超时时间。backoffLimit，设置 Pod 的失败重试次数。completions，Job 完成需要运行多少个 Pod，默认是 1 个。parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源。</p>
<p>要注意这 4 个字段并不在 template 字段下，而是在 spec 字段下，所以它们是属于 Job 级别的，用来控制模板里的 Pod 对象。下面我再创建一个 Job 对象，名字叫“sleep-job”，它随机睡眠一段时间再退出，模拟运行时间较长的作业（比如 MapReduce）。Job 的参数设置成 15 秒超时，最多重试 2 次，总共需要运行完 4 个 Pod，但同一时刻最多并发 2 个 Pod：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
apiVersion: batch/v1
kind: Job
metadata:
  name: sleep-job

spec:
  activeDeadlineSeconds: 15
  backoffLimit: 2
  completions: 4
  parallelism: 2

  template:
    spec:
      restartPolicy: OnFailure
      containers:
      - image: busybox
        name: echo-job
        imagePullPolicy: IfNotPresent
        command:
          - sh
          - -c
          - sleep $(($RANDOM % 10 + 1)) &amp;&amp; echo done
</code></pre></td></tr></table>
</div>
</div><p>使用 kubectl apply 创建 Job 之后，我们可以用 kubectl get pod -w 来实时观察 Pod 的状态，看到 Pod 不断被排队、创建、运行的过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl apply -f sleep-job.yml
kubectl get pod -w
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/7d/b7/7d413a0c38065de2063a99e7df2b7eb7.png?wh=1591x1328"
        data-srcset="https://static001.geekbang.org/resource/image/7d/b7/7d413a0c38065de2063a99e7df2b7eb7.png?wh=1591x1328, https://static001.geekbang.org/resource/image/7d/b7/7d413a0c38065de2063a99e7df2b7eb7.png?wh=1591x1328 1.5x, https://static001.geekbang.org/resource/image/7d/b7/7d413a0c38065de2063a99e7df2b7eb7.png?wh=1591x1328 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/7d/b7/7d413a0c38065de2063a99e7df2b7eb7.png?wh=1591x1328"
        title="img" /></p>
<p>等到 4 个 Pod 都运行完毕，我们再用 kubectl get 来看看 Job 和 Pod 的状态：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/58/46/58b99356c811bd377acfa4cb921d2446.png?wh=1426x542"
        data-srcset="https://static001.geekbang.org/resource/image/58/46/58b99356c811bd377acfa4cb921d2446.png?wh=1426x542, https://static001.geekbang.org/resource/image/58/46/58b99356c811bd377acfa4cb921d2446.png?wh=1426x542 1.5x, https://static001.geekbang.org/resource/image/58/46/58b99356c811bd377acfa4cb921d2446.png?wh=1426x542 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/58/46/58b99356c811bd377acfa4cb921d2446.png?wh=1426x542"
        title="img" /></p>
<p>就会看到 Job 的完成数量如同我们预期的是 4，而 4 个 Pod 也都是完成状态。显然，“声明式”的 Job 对象让离线业务的描述变得非常直观，简单的几个字段就可以很好地控制作业的并行度和完成数量，不需要我们去人工监控干预，Kubernetes 把这些都自动化实现了。</p>
<h3 id="如何使用-yaml-描述-cronjob">如何使用 YAML 描述 CronJob</h3>
<p>学习了“临时任务”的 Job 对象之后，再学习“定时任务”的 CronJob 对象也就比较容易了，我就直接使用命令 kubectl create 来创建 CronJob 的样板。要注意两点。第一，因为 CronJob 的名字有点长，所以 Kubernetes 提供了简写 cj，这个简写也可以使用命令 kubectl api-resources 看到；第二，CronJob 需要定时运行，所以我们在命令行里还需要指定参数 &ndash;schedule。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">
export out=&#34;--dry-run=client -o yaml&#34;              # 定义Shell变量
kubectl create cj echo-cj --image=busybox --schedule=&#34;&#34; $out
</code></pre></td></tr></table>
</div>
</div><p>然后我们编辑这个 YAML 样板，生成 CronJob 对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">apiVersion: batch/v1
kind: CronJob
metadata:
  name: echo-cj

spec:
  schedule: &#39;*/1 * * * *&#39;
  jobTemplate:
    spec:
      template:
        spec:
          restartPolicy: OnFailure
          containers:
          - image: busybox
            name: echo-cj
            imagePullPolicy: IfNotPresent
            command: [&#34;/bin/echo&#34;]
            args: [&#34;hello&#34;, &#34;world&#34;]

</code></pre></td></tr></table>
</div>
</div><p>我们还是重点关注它的 spec 字段，你会发现它居然连续有三个 spec 嵌套层次：第一个 spec 是 CronJob 自己的对象规格声明第二个 spec 从属于“jobTemplate”，它定义了一个 Job 对象。第三个 spec 从属于“template”，它定义了 Job 里运行的 Pod。</p>
<p>所以，CronJob 其实是又组合了 Job 而生成的新对象，我还是画了一张图，方便你理解它的“套娃”结构：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/yy/3c/yy352c661ae37dd116dd12c61932b43c.jpg?wh=1920x2206"
        data-srcset="https://static001.geekbang.org/resource/image/yy/3c/yy352c661ae37dd116dd12c61932b43c.jpg?wh=1920x2206, https://static001.geekbang.org/resource/image/yy/3c/yy352c661ae37dd116dd12c61932b43c.jpg?wh=1920x2206 1.5x, https://static001.geekbang.org/resource/image/yy/3c/yy352c661ae37dd116dd12c61932b43c.jpg?wh=1920x2206 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/yy/3c/yy352c661ae37dd116dd12c61932b43c.jpg?wh=1920x2206"
        title="img" /></p>
<p>除了定义 Job 对象的“jobTemplate”字段之外，CronJob 还有一个新字段就是“schedule”，用来定义任务周期运行的规则。它使用的是标准的 Cron 语法，指定分钟、小时、天、月、周，和 Linux 上的 crontab 是一样的。像在这里我就指定每分钟运行一次，格式具体的含义你可以课后参考 Kubernetes 官网文档。除了名字不同，CronJob 和 Job 的用法几乎是一样的，使用 kubectl apply 创建 CronJob，使用 kubectl get cj、kubectl get pod 来查看状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">kubectl apply -f cronjob.yml
kubectl get cj
kubectl get pod
</code></pre></td></tr></table>
</div>
</div><p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://static001.geekbang.org/resource/image/b0/2c/b00fdd8541372fb7a4de00de5ac6342c.png?wh=1644x484"
        data-srcset="https://static001.geekbang.org/resource/image/b0/2c/b00fdd8541372fb7a4de00de5ac6342c.png?wh=1644x484, https://static001.geekbang.org/resource/image/b0/2c/b00fdd8541372fb7a4de00de5ac6342c.png?wh=1644x484 1.5x, https://static001.geekbang.org/resource/image/b0/2c/b00fdd8541372fb7a4de00de5ac6342c.png?wh=1644x484 2x"
        data-sizes="auto"
        alt="https://static001.geekbang.org/resource/image/b0/2c/b00fdd8541372fb7a4de00de5ac6342c.png?wh=1644x484"
        title="img" /></p>
<h3 id="小结-12">小结</h3>
<p>好了，今天我们以面向对象思想分析了一下 Kubernetes 里的资源对象设计，它强调“职责单一”和“对象组合”，简单来说就是“对象套对象”。通过这种嵌套方式，Kubernetes 里的这些 API 对象就形成了一个“控制链”：CronJob 使用定时规则控制 Job，Job 使用并发数量控制 Pod，Pod 再定义参数控制容器，容器再隔离控制进程，进程最终实现业务功能，层层递进的形式有点像设计模式里的 Decorator（装饰模式），链条里的每个环节都各司其职，在 Kubernetes 的统一指挥下完成任务。小结一下今天的内容：</p>
<p>Pod 是 Kubernetes 的最小调度单元，但为了保持它的独立性，不应该向它添加多余的功能。Kubernetes 为离线业务提供了 Job 和 CronJob 两种 API 对象，分别处理“临时任务”和“定时任务”。Job 的关键字段是 spec.template，里面定义了用来运行业务的 Pod 模板，其他的重要字段有 completions、parallelism 等CronJob 的关键字段是 spec.jobTemplate 和 spec.schedule，分别定义了 Job 模板和定时运行的规则。</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2022-07-14 00:00:00</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://qizhengzou.github.io/k8s_base/" data-title="K8s_base" data-hashtags="k8s"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://qizhengzou.github.io/k8s_base/" data-hashtag="k8s"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Reddit" data-sharer="reddit" data-url="https://qizhengzou.github.io/k8s_base/"><i class="fab fa-reddit fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://qizhengzou.github.io/k8s_base/" data-title="K8s_base"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://qizhengzou.github.io/k8s_base/" data-title="K8s_base"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://qizhengzou.github.io/k8s_base/" data-title="K8s_base"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/baidu.svg"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/k8s/">k8s</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/middleware/" class="prev" rel="prev" title="Middleware"><i class="fas fa-angle-left fa-fw"></i>Middleware</a>
            <a href="/k8s_advanced/" class="next" rel="next" title="K8s_advanced">K8s_advanced<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="disqus_thread" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://disqus.com/?ref_noscript">Disqus</a>.
            </noscript></div></article></div>
            </main></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://jefos-blog.disqus.com/embed.js" defer></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"J0OW8CCKJZ","algoliaIndex":"JF","algoliaSearchKey":"3b4a19e831c95174aca4c03fcdf95f5c","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
