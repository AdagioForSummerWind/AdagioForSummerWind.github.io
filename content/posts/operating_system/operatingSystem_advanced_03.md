---
title: "OperatingSystem_advanced_03"
date: 2021-12-02T20:14:02+08:00
lastmod: 2021-12-02
tags: [operating system]
categories: [Advanced learning]
slug: Kernel structure and design
draft: true
---

# 内核结构与设计 内核架构
## 内核结构与设计
- 先搞清楚内核之中有些什么东西
- 然后探讨一下怎么组织它们、用什么架构来组织、并对比成熟的架构
- 最后设计出我们想要的内核架构。
### 内核里有什么？
- 硬件资源：
    1. 总线，负责连接各种其它设备，是其它设备工作的基础。
    2. CPU，即中央处理器，负责执行程序和处理数据运算。
    3. 内存，负责储存运行时的代码和数据。
    4. 硬盘，负责长久储存用户文件数据。
    5. 网卡，负责计算机与计算机之间的通信。
    6. 显卡，负责显示工作。
    7. 各种 I/O 设备，如显示器，打印机，键盘，鼠标等。
- 软件资源，则可表示为计算机中的各种形式的数据。如各种文件、软件程序等。

内核作为管理者，需要管理的东西很多：
1. 管理 CPU，由于 CPU 是执行程序的，而内核把运行时的程序抽象成进程，所以又称为进程管理。
2. 管理内存，由于程序和数据都要占用内存，内存是非常宝贵的资源，所以内核要非常小心地分配、释放内存。
3. 管理硬盘，而硬盘主要存放用户数据，而内核把用户数据抽象成文件，即管理文件，文件需要合理地组织，方便用户查找和读写，所以形成了文件系统。
4. 管理显卡，负责显示信息，而现在操作系统都是支持 GUI（图形用户接口）的，管理显卡自然而然地就成了内核中的图形系统。
5. 管理网卡，网卡主要完成网络通信，网络通信需要各种通信协议，最后在内核中就形成了网络协议栈，又称网络组件。
6. 管理各种 I/O 设备，我们经常把键盘、鼠标、打印机、显示器等统称为 I/O（输入输出）设备，在内核中抽象成 I/O 管理器。
7. 管理一些安全组件。

各种计算机硬件的性能不同，硬件型号不同，硬件种类不同，硬件厂商不同，内核要想管理和控制这些硬件就要编写对应的代码，通常这样的代码我们称之为**驱动程序**。硬件厂商就可以根据自己不同的硬件编写不同的驱动，加入到内核之中

如何组织这些组件？一些经典内核结构：宏内核结构、微内核结构
#### 宏内核结构
最简单适用，也是最早的一种内核结构。

宏内核就是把以上诸如管理进程的代码、管理内存的代码、管理各种 I/O 设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码，把这些所有的代码经过编译，最后链接在一起，形成一个大的可执行程序。

这个大程序里有实现支持这些功能的所有代码，向用户应用软件提供一些接口（API）。而这个大程序会在处理器的特权模式下运行，这个模式通常被称为宏内核模式。

宏内核提供**内存分配功能**的服务过程：
1. 应用程序调用内存分配的 API（应用程序接口）函数。
2. 处理器切换到特权模式，开始运行内核代码。
3. 内核里的内存管理代码按照特定的算法，分配一块内存。
4. 把分配的内存块的首地址，返回给内存分配的 API 函数。
5. 内存分配的 API 函数返回，处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。

这个过程和一个实际的操作系统中的运行过程，可能有差异，但大同小异。当然，系统 API 和应用程序之间可能还有库函数，也可能只是分配了一个虚拟地址空间，但是我们关注的只是这个过程。

宏内核结构**缺点**：没有模块化，没有扩展性、没有移植性，高度耦合在一起，一旦其中一个组件有漏洞，内核中所有的组件可能都会出问题。开发一个新的功能也得重新编译、链接、安装内核。

**唯一的优点**是性能很好，因为在内核中，这些组件可以互相调用，性能极高。
#### 微内核结构
微内核结构提倡内核功能尽可能少：仅仅只有进程调度、处理中断、内存空间映射、进程间通信等功能。

这样的内核是不能完成什么实际功能的，开发者们把实际的进程管理、内存管理、设备管理、文件管理等服务功能，做成一个个**服务进程**。和用户应用进程一样，只是它们很特殊，宏内核提供的功能，在微内核架构里由这些服务进程专门负责完成。

微内核定义了一种良好的进程间通信的机制——**消息**。应用程序要请求相关服务，就向微内核发送一条与此服务对应的消息，微内核再把这条消息转发给相关的服务进程，接着服务进程会完成相关的服务。

服务进程的**编程模型**就是循环处理来自其它进程的消息，完成相关的服务功能。

微内核提供**内存分配**功能的服务过程，具体如下：
1. 应用程序发送内存分配的消息，这个发送消息的函数是微内核提供的，相当于系统 API，微内核的 API（应用程序接口）相当少，极端情况下仅需要两个，一个接收消息的 API 和一个发送消息的 API。
2. 处理器切换到特权模式，开始运行内核代码。
3. 微内核代码让当前进程停止运行，并根据消息包中的数据，确定消息发送给谁，分配内存的消息当然是发送给内存管理服务进程。
4. 内存管理服务进程收到消息，分配一块内存。
5. 内存管理服务进程，也会通过消息的形式返回分配内存块的地址给内核，然后继续等待下一条消息。
6. 微内核把包含内存块地址的消息返回给发送内存分配消息的应用程序。
7. 处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。

**开销变大**：同样是分配内存，在微内核下拐了几个弯，一来一去的消息带来了非常大的开销，当然各个服务进程的切换开销也不小。这样系统性能就大打折扣。

**优点很多**：
- 首先，系统结构相当清晰利于协作开发。
- 其次，系统有良好的移植性，微内核代码量非常少，就算重写整个内核也不是难事。
- 最后，微内核有相当好的伸缩性、扩展性，因为那些系统功能只是一个进程，可以随时拿掉一个服务进程以减少系统功能，或者增加几个服务进程以增强系统功能。

**eg**:MACH、MINIX、L4 系统，这些系统都是微内核，但是它们不是商业级的系统，商业级的系统不采用微内核主要还是因为性能差。
### 分离硬件的相关性





[参考](https://time.geekbang.org/column/intro/100078401?tab=catalog)

