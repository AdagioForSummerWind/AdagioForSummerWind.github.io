---
title: "Vim"
date: 2022-07-15T16:59:08+08:00
lastmod: 2022-07-15
tags: [linux]
categories: [Advanced learning]
slug: linux vim
draft: true
---
goalng插件配置
https://www.jianshu.com/p/8426cef1f4f5


## Vim从入门到精通
<div align='center'>
  <h1>Vim 从入门到精通</h1>
  <div>
    <a href='https://github.com/mhinz/vim-galore'>English</a> |
    <a href='http://postd.cc/?s=vim-galore'>Japanese</a> |
    <a href='https://github.com/lsrdg/vim-galore'>Portuguese</a> |
    <a href='http://givi.olnd.ru/vim-galore/vim-galore-ru.html'>Russian</a>
    <div>
      <br />
      <sub>Licensed under <a href='https://creativecommons.org/licenses/by-sa/4.0'>CC BY-SA 4.0<a/>.</sub>
    </div>
  </div>
  <br /><br />
</div>

[![Gitter](https://badges.gitter.im/SpaceVim/SpaceVim.svg)](https://gitter.im/SpaceVim/cn)
[![telegram](https://img.shields.io/badge/chat-telegram-blue.svg)](https://t.me/joinchat/1TvSIDrsaq0zMjZl)
[![QQ](https://img.shields.io/badge/QQ群-970953433-blue.svg)](https://jq.qq.com/?_wv=1027&k=XYqDdQTM)

<!-- vim-markdown-toc GFM -->

- [Vim从入门到精通](#vim从入门到精通)
- [简介](#简介)
- [什么是 Vim？](#什么是-vim)
- [Vim 哲学](#vim-哲学)
- [入门](#入门)
- [精简的 vimrc](#精简的-vimrc)
  - [Windows 系统](#windows-系统)
  - [Linux 或者 Mac OS](#linux-或者-mac-os)
- [我正在使用什么样的 Vim](#我正在使用什么样的-vim)
- [备忘录](#备忘录)
- [基础](#基础)
- [缓冲区，窗口，标签](#缓冲区窗口标签)
- [已激活、已载入、已列出、已命名的缓冲区](#已激活已载入已列出已命名的缓冲区)
- [参数列表](#参数列表)
- [按键映射](#按键映射)
- [映射前置键](#映射前置键)
- [寄存器](#寄存器)
- [范围](#范围)
- [标注](#标注)
- [补全](#补全)
- [动作，操作符，文本对象](#动作操作符文本对象)
- [自动命令](#自动命令)
- [变更历史，跳转历史](#变更历史跳转历史)
- [内容变更历史记录](#内容变更历史记录)
- [全局位置信息表，局部位置信息表](#全局位置信息表局部位置信息表)
- [宏](#宏)
- [颜色主题](#颜色主题)
- [折叠](#折叠)
- [会话](#会话)
- [局部化](#局部化)
- [用法](#用法)
- [获取离线帮助](#获取离线帮助)
- [获取离线帮助（补充）](#获取离线帮助补充)
- [获取在线帮助](#获取在线帮助)
- [执行自动命令](#执行自动命令)
  - [用户自定义事件](#用户自定义事件)
  - [事件嵌套](#事件嵌套)
- [剪切板](#剪切板)
  - [剪贴板的使用（Windows, OSX）](#剪贴板的使用windows-osx)
  - [剪贴板的使用（Linux, BSD, ...）](#剪贴板的使用linux-bsd-)
- [打开文件时恢复光标位置](#打开文件时恢复光标位置)
- [临时文件](#临时文件)
  - [备份文件](#备份文件)
  - [交换文件](#交换文件)
  - [撤销文件](#撤销文件)
  - [viminfo 文件](#viminfo-文件)
  - [临时文件管理设置示例](#临时文件管理设置示例)
- [编辑远程文件](#编辑远程文件)
- [插件管理](#插件管理)
- [多行编辑](#多行编辑)
- [使用外部程序和过滤器](#使用外部程序和过滤器)
- [Cscope](#cscope)
  - [1. 构建数据库](#1-构建数据库)
  - [2. 添加数据库](#2-添加数据库)
  - [3. 查询数据库](#3-查询数据库)
- [MatchIt](#matchit)
  - [在 Vim 8 中安装](#在-vim-8-中安装)
  - [在 Vim 7 或者更早的版本中安装](#在-vim-7-或者更早的版本中安装)
  - [简短的介绍](#简短的介绍)
- [技巧](#技巧)
- [跳至选择的区域另一端](#跳至选择的区域另一端)
- [聪明地使用 n 和 N](#聪明地使用-n-和-n)
- [聪明地使用命令行历史](#聪明地使用命令行历史)
- [智能 Ctrl-l](#智能-ctrl-l)
- [禁用错误报警声音和图标](#禁用错误报警声音和图标)
- [快速移动当前行](#快速移动当前行)
- [快速添加空行](#快速添加空行)
  - [运行时检测](#运行时检测)
  - [查看启动时间](#查看启动时间)
- [NUL 符用新行表示](#nul-符用新行表示)
- [快速编辑自定义宏](#快速编辑自定义宏)
- [快速跳转到源(头)文件](#快速跳转到源头文件)
- [在 GUI 中快速改变字体大小](#在-gui-中快速改变字体大小)
- [根据模式改变光标类型](#根据模式改变光标类型)
- [防止水平滑动的时候失去选择](#防止水平滑动的时候失去选择)
- [选择当前行至结尾，排除换行符](#选择当前行至结尾排除换行符)
- [重新载入保存文件](#重新载入保存文件)
- [更加智能的当前行高亮](#更加智能的当前行高亮)
- [更快的关键字补全](#更快的关键字补全)
- [改变颜色主题的默认外观](#改变颜色主题的默认外观)
- [命令](#命令)
  - [:global 和 :vglobal - 在所有匹配行执行命令](#global-和-vglobal---在所有匹配行执行命令)
  - [:normal 和 :execute - 脚本梦之队](#normal-和-execute---脚本梦之队)
  - [重定向消息](#重定向消息)
- [调试](#调试)
- [常规建议](#常规建议)
- [调整日志等级](#调整日志等级)
- [查看启动日志](#查看启动日志)
- [查看运行时日志](#查看运行时日志)
- [Vim 脚本调试](#vim-脚本调试)
- [语法文件调试](#语法文件调试)
- [杂项](#杂项)
- [附加资源](#附加资源)
- [Vim 配置集合](#vim-配置集合)
- [常见问题](#常见问题)
  - [编辑小文件时很慢](#编辑小文件时很慢)
  - [编辑大文件的时候很慢](#编辑大文件的时候很慢)
  - [持续粘贴（为什么我每次都要设置 'paste' 模式）](#持续粘贴为什么我每次都要设置-paste-模式)
  - [在终端中按 ESC 后有延时](#在终端中按-esc-后有延时)
  - [无法重复函数中执行的搜索](#无法重复函数中执行的搜索)
- [进阶阅读](#进阶阅读)
- [加入我们](#加入我们)
- [参考资料](#参考资料)
- [开篇词｜我们为什么要学 Vim？](#开篇词我们为什么要学-vim)
  - [Vim 的“前世今生”](#vim-的前世今生)
  - [Vim 的优势](#vim-的优势)
  - [课程主要内容](#课程主要内容)
  - [课程学习要求](#课程学习要求)
- [导读｜池建强：Vim 就是四个字“唯快不破”](#导读池建强vim-就是四个字唯快不破)
  - [缘起](#缘起)
  - [场景](#场景)
  - [历史](#历史)
  - [理念](#理念)
- [基础](#基础-1)
- [01｜各平台下的 Vim 安装方法：上路前准备好你的宝马](#01各平台下的-vim-安装方法上路前准备好你的宝马)
  - [Linux 下的安装](#linux-下的安装)
    - [Red Hat 和 CentOS 系列](#red-hat-和-centos-系列)
    - [Debian 和 Ubuntu 系列](#debian-和-ubuntu-系列)
    - [手工编译](#手工编译)
  - [macOS 下的安装](#macos-下的安装)
    - [使用 Homebrew 安装 MacVim](#使用-homebrew-安装-macvim)
    - [使用安装包安装 MacVim](#使用安装包安装-macvim)
  - [Windows 下的安装](#windows-下的安装)
  - [Cygwin/MSYS2](#cygwinmsys2)
  - [远程使用 Vim](#远程使用-vim)
  - [学习 Vim](#学习-vim)
  - [中文帮助文件](#中文帮助文件)
  - [Vim 教程](#vim-教程)
  - [键盘重配置](#键盘重配置)
  - [内容小结](#内容小结)
- [02｜基本概念和基础命令：应对简单的编辑任务](#02基本概念和基础命令应对简单的编辑任务)
  - [Vim 教程的内容概要](#vim-教程的内容概要)
  - [Vim 的模式](#vim-的模式)
  - [Vim 的键描述体例](#vim-的键描述体例)
  - [Vim 的选项和配置](#vim-的选项和配置)
  - [备份和撤销文件](#备份和撤销文件)
  - [鼠标支持](#鼠标支持)
  - [中文支持](#中文支持)
  - [图形界面的字体配置](#图形界面的字体配置)
  - [内容小结](#内容小结-1)
- [03｜更多常用命令：应对稍复杂的编辑任务](#03更多常用命令应对稍复杂的编辑任务)
  - [光标移动](#光标移动)
  - [文本修改](#文本修改)
  - [文本对象选择](#文本对象选择)
  - [更快地移动](#更快地移动)
  - [重复，重复，再重复](#重复重复再重复)
  - [内容小结](#内容小结-2)
- [04｜初步定制：让你的 Vim 更顺手](#04初步定制让你的-vim-更顺手)
  - [Vim 的目录结构](#vim-的目录结构)
    - [安装目录下的运行支持文件](#安装目录下的运行支持文件)
    - [用户的 Vim 配置目录](#用户的-vim-配置目录)
  - [Vim 8 新功能](#vim-8-新功能)
  - [Vim 软件包](#vim-软件包)
  - [安装 minpac](#安装-minpac)
  - [通过 minpac 安装扩展包](#通过-minpac-安装扩展包)
  - [最近使用的文件](#最近使用的文件)
  - [内容小结](#内容小结-3)
- [05｜多文件打开与缓冲区：复制粘贴的正确姿势](#05多文件打开与缓冲区复制粘贴的正确姿势)
  - [单文件的打开方式](#单文件的打开方式)
    - [图形界面](#图形界面)
    - [终端 Vim](#终端-vim)
    - [Vim 老版本的特殊处理](#vim-老版本的特殊处理)
    - [“已经存在交换文件！”](#已经存在交换文件)
    - [多文件的打开方式](#多文件的打开方式)
    - [缓冲区的管理和切换](#缓冲区的管理和切换)
  - [内容小结](#内容小结-4)
- [06｜窗口和标签页：修改、对比多个文件的正确姿势](#06窗口和标签页修改对比多个文件的正确姿势)
  - [多窗口编辑](#多窗口编辑)
    - [双窗口比较](#双窗口比较)
  - [多标签页编辑](#多标签页编辑)
  - [NERDTree 插件](#nerdtree-插件)
    - [安装](#安装)
    - [使用](#使用)
    - [类似插件](#类似插件)
  - [内容小结](#内容小结-5)
- [07｜正则表达式：实现文件内容的搜索和替换](#07正则表达式实现文件内容的搜索和替换)
  - [正则表达式搜索](#正则表达式搜索)
  - [搜索实例](#搜索实例)
  - [最长匹配和最短匹配](#最长匹配和最短匹配)
  - [搜索加亮和取消](#搜索加亮和取消)
  - [正则表达式替换](#正则表达式替换)
  - [替换实例](#替换实例)
  - [内容小结](#内容小结-6)
- [08｜基本编程支持：规避、解决编程时的常见问题](#08基本编程支持规避解决编程时的常见问题)
  - [文件类型和关联设定](#文件类型和关联设定)
  - [文件类型判断](#文件类型判断)
  - [文件类型](#文件类型)
  - [Tags 支持](#tags-支持)
  - [生成 tags 文件的工具](#生成-tags-文件的工具)
  - [生成 tags 文件的命令](#生成-tags-文件的命令)
  - [使用 tags 文件](#使用-tags-文件)
  - [Tagbar 插件](#tagbar-插件)
  - [Quickfix 窗口](#quickfix-窗口)
  - [:make 命令的其他细节](#make-命令的其他细节)
  - [:grep 命令](#grep-命令)
  - [异步支持](#异步支持)
  - [查看文档](#查看文档)
  - [内容小结](#内容小结-7)
- [09｜七大常用技巧：让编辑效率再上一个台阶](#09七大常用技巧让编辑效率再上一个台阶)
  - [自动完成](#自动完成)
  - [文本目标跳转](#文本目标跳转)
  - [Vim 寄存器 / 剪贴板](#vim-寄存器--剪贴板)
  - [常用的寄存器使用场景](#常用的寄存器使用场景)
  - [宏的录制和播放](#宏的录制和播放)
  - [文本对象增强](#文本对象增强)
  - [撤销树](#撤销树)
  - [对当前缓冲区的更名和移动](#对当前缓冲区的更名和移动)
  - [模糊文件查找](#模糊文件查找)
  - [内容小结](#内容小结-8)
- [10｜代码重构实验：在实战中提高编辑熟练度](#10代码重构实验在实战中提高编辑熟练度)
  - [开始前的准备工作](#开始前的准备工作)
  - [类模板 smart_ptr 更名](#类模板-smart_ptr-更名)
    - [修改类定义](#修改类定义)
    - [修改使用 smart_ptr 的地方](#修改使用-smart_ptr-的地方)
  - [编译执行（可选）](#编译执行可选)
  - [添加跟踪语句](#添加跟踪语句)
  - [调整测试用例](#调整测试用例)
  - [内容小结](#内容小结-9)

<!-- vim-markdown-toc -->

## 简介

## 什么是 Vim？

[Vim](https://github.com/vim/vim) 是一个历史悠久的文本编辑器，可以追溯到
[qed](<https://en.wikipedia.org/wiki/QED_(text_editor)>)。
[Bram Moolenaar](https://en.wikipedia.org/wiki/Bram_Moolenaar) 于
1991 年发布初始版本。

Linux、Mac 用户，可以使用包管理器安装 Vim，对于 Windows 用户，可以从
[我的网盘](https://www.jianguoyun.com/p/DVBqom8QtY2QCBj7xL0EIAA) 下载。
该版本可轻易添加 `python` 、`python3` 、`lua` 等支持，只需要安装 python、lua
即可。

项目在 [Github](https://github.com/vim/vim) 上开发，项目讨论请订阅
[`vim_dev`](https://groups.google.com/forum/#!forum/vim_dev) 邮件列表。

通过阅读 [Why, oh WHY, do those #?@! nutheads use vi?](http://www.viemu.com/a-why-vi-vim.html)
来对 Vim 进行大致的了解。

## Vim 哲学

Vim 采用模式编辑的理念，即它提供了多种模式，按键在不同的模式下作用不同。
你可以在**普通模式** 下浏览文件，在**插入模式**下插入文本，
在**可视模式**下选择行，在**命令模式**下执行命令等等。起初这听起来可能很复杂，
但是这有一个很大的优点：不需要通过同时按住多个键来完成操作，
大多数时候你只需要依次按下这些按键即可。越常用的操作，所需要的按键数量越少。

和模式编辑紧密相连的概念是 **操作符** 和 **动作**。**操作符** 指的是开始某个行为，
例如：修改、删除或者选择文本，之后你要用一个 **动作** 来指定需要操作的文本区域。
比如，要改变括号内的文本，需要执行 `ci(` （读做 `change inner parentheses`）；
删除整个段落的内容，需要执行 `dap` （读做：`delete around paragraph`）。

如果你能看见 Vim 老司机操作，你会发现他们使用 Vim 脚本语言就如同钢琴师弹钢琴一样。复杂的操作只需要几个按键就能完成。他们甚至不用刻意去想，因为这已经成为[肌肉记忆](https://en.wikipedia.org/wiki/Muscle_memory)了。这减少[认识负荷](https://en.wikipedia.org/wiki/Cognitive_load)并帮助人们专注于实际任务。

## 入门

Vim 自带一个交互式的教程，内含你需要了解的最基础的信息，你可以通过终端运行以下命令打开教程：

    $ vimtutor

不要因为这个看上去很无聊而跳过，按照此教程多练习。你以前用的 IDE 或者其他编辑器很少是有“模式”概念的，因此一开始你会很难适应模式切换。但是你 Vim 使用的越多，[肌肉记忆](https://en.wikipedia.org/wiki/Muscle_memory) 将越容易形成。

Vim 基于一个 [vi](https://en.wikipedia.org/wiki/Vi) 克隆，叫做 [Stevie](<https://en.wikipedia.org/wiki/Stevie_(text_editor)>)，支持两种运行模式："compatible" 和 "nocompatible"。在兼容模式下运行 Vim 意味着使用 vi 的默认设置，而不是 Vim 的默认设置。除非你新建一个用户的 `vimrc` 或者使用 `vim -N` 命令启动 Vim，否则就是在兼容模式下运行 Vim！请大家不要在兼容模式下运行 Vim。

下一步

1. 创建你自己的 [vimrc](#精简的-vimrc)。
2. 在第一周准备[备忘录](#备忘录)。
3. 通读[基础](#基础-1)章节了解 Vim 还有哪些功能。
4. 按需学习！Vim 是学不完的。如果你遇到了问题，先上网寻找解决方案，你的问题可能已经被解决了。Vim 拥有大量的参考文档，知道如何利用这些参考文档很有必要：[获取离线帮助](#获取离线帮助)。
5. 浏览[附加资源](#附加资源)。

最后一个建议：使用[插件](#插件管理)之前，请先掌握 Vim 的基本操作。很多插件都只是对 Vim 自带功能的封装。

返回主目录 [:arrow_heading_up:](#简介)

## 精简的 vimrc

Vim 启动是会按照一定的优先顺序来搜索配置文件，这个顺序，可以通过 `:version` 命令查看。下面分 Windows 系统，
和 \*niux 系统分别来说明 Vim 是如何载入配置文件的。

### Windows 系统

```
   system vimrc file: "$VIM\vimrc"
     user vimrc file: "$HOME\_vimrc"
 2nd user vimrc file: "$HOME\vimfiles\vimrc"
 3rd user vimrc file: "$VIM\_vimrc"
      user exrc file: "$HOME\_exrc"
  2nd user exrc file: "$VIM\_exrc"
  system gvimrc file: "$VIM\gvimrc"
    user gvimrc file: "$HOME\_gvimrc"
2nd user gvimrc file: "$HOME\vimfiles\gvimrc"
3rd user gvimrc file: "$VIM\_gvimrc"
       defaults file: "$VIMRUNTIME\defaults.vim"
    system menu file: "$VIMRUNTIME\menu.vim"
```

我们只看上面这一段，Vim 会优先读取 user vimrc file: `$HOME\_vimrc`, 当这一文件不存在是，
Vim 再去寻找 2nd user vimrc file: `$HOME\vimfiles\vimrc`; 倘若这个文件还是不存在，那么 Vim
会去继续寻找 3rd user vimrc file: `$VIM\_vimrc`。 了解以上顺序后，就不会再因为 Vim
总是不读取配置文件而感到烦恼了。

### Linux 或者 Mac OS

同 Windows 系统类似，也可以使用 `:version` 命令查看 vim 载入配置的优先顺序。

```
     系统 vimrc 文件: "/etc/vimrc"
     用户 vimrc 文件: "$HOME/.vimrc"
 第二用户 vimrc 文件: "~/.vim/vimrc"
      用户 exrc 文件: "$HOME/.exrc"
       defaults file: "$VIMRUNTIME/defaults.vim"
         $VIM 预设值: "/etc"
  $VIMRUNTIME 预设值: "/usr/share/vim/vim81"
```

你可以在网上找到许多精简的 vimrc 配置文件，我的版本可能并不是最简单的版本，但是我的版本提供了一套我认为良好的，非常适合入门的设置。

最终你需要阅读完那些设置，然后自行决定需要使用哪些。:-)

精简的 vimrc 地址：[minimal-vimrc](contents/minimal-vimrc.vim)

如果你有兴趣，这里是我（原作者）的 [vimrc](https://github.com/mhinz/dotfiles/blob/master/.vim/vimrc)。

**建议**：大多数插件作者都维护不止一个插件并且将他们的 vimrc 放在 Github 上展示（通常放在叫做 "vim-config" 或者 "dotfiles" 的仓库中），所以当你发现你喜欢的插件时，去插件维护者的 Github 主页看看有没有这样的仓库。

返回主目录 [:arrow_heading_up:](#简介)

## 我正在使用什么样的 Vim

使用 `:version` 命令将向你展示当前正在运行的 Vim 的所有相关信息，包括它是如何编译的。

第一行告诉你这个二进制文件的编译时间和版本号，比如：7.4。接下来的一行呈现 `Included patches: 1-1051`，这是补丁版本包。因此你 Vim 确切的版本号是 7.4.1051。

另一行显示着一些像 `Tiny version without GUI` 或者 `Huge version with GUI` 的信息。很显然这些信息告诉你当前的 Vim 是否支持 GUI，例如：从终端中运行 `gvim` 或者从终端模拟器中的 Vim 内运行 `:gui` 命令。另一个重要的信息是 `Tiny` 和 `Huge`。Vim 的特性集区分被叫做 `tiny`，`small`，`normal`，`big` and `huge`，所有的都实现不同的功能子集。

`:version` 主要的输出内容是特性列表。`+clipboard` 意味这剪贴板功能被编译支持了，`-clipboard` 意味着剪贴板特性没有被编译支持。

一些功能特性需要编译支持才能正常工作。例如：为了让 `:prof` 工作，你需要使用 `huge` 模式编译的 Vim，因为那种模式启用了 `+profile` 特性。

如果你的输出情况并不是那样，并且你是从包管理器安装 Vim 的，确保你安装了 `vim-x`，`vim-x11`，`vim-gtk`，`vim-gnome` 这些包或者相似的，因为这些包通常都是 `huge` 模式编译的。

你也可以运行下面这段代码来测试 Vim 版本以及功能支持：

```vim
" Do something if running at least Vim 7.4.42 with +profile enabled.
if (v:version > 704 || v:version == 704 && has('patch42')) && has('profile')
  " do stuff
endif
```

相关帮助：

    :h :version
    :h feature-list
    :h +feature-list
    :h has-patch

返回主目录 [:arrow_heading_up:](#简介)

## 备忘录

为了避免版权问题，我只贴出链接：

- <http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png>
- <https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png>
- <http://www.nathael.org/Data/vi-vim-cheat-sheet.svg>
- <http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png>
- <http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png>

或者在 Vim 中快速打开备忘录：[vim-cheat40](https://github.com/lifepillar/vim-cheat40)。

返回主目录 [:arrow_heading_up:](#简介)

## 基础

## 缓冲区，窗口，标签

Vim 是一个文本编辑器。每次文本都是作为**缓冲区**的一部分显示的。每一份文件都是在他们自己独有的缓冲区打开的，插件显示的内容也在它们自己的缓冲区中。

缓冲区有很多属性，比如这个缓冲区的内容是否可以修改，或者这个缓冲区是否和文件相关联，是否需要同步保存到磁盘上。

**窗口** 是缓冲区上一层的视窗。如果你想同时查看几个文件或者查看同一文件的不同位置，那样你会需要窗口。

请别把他们叫做 _分屏_ 。你可以把一个窗口分割成两个，但是这并没有让这两个窗口完全 _分离_ 。

窗口可以水平或者竖直分割并且现有窗口的高度和宽度都是可以被调节设置的，因此，如果你需要多种窗口布局，请考虑使用标签。

**标签页** （标签）是窗口的集合。因此当你想使用多种窗口布局时候请使用标签。

简单的说，如果你启动 Vim 的时候没有附带任何参数，你会得到一个包含着一个呈现一个缓冲区的窗口的标签。

顺带提一下，缓冲区列表是全局可见的，你可以在任何标签中访问任何一个缓冲区。

返回主目录 [:arrow_heading_up:](#基础)

## 已激活、已载入、已列出、已命名的缓冲区

用类似 `vim file1` 的命令启动 Vim 。这个文件的内容将会被加载到缓冲区中，你现在有一个**已载入的缓冲区**。如果你在 Vim 中保存这个文件，缓冲区内容将会被同步到磁盘上（写回文件中）。

由于这个缓冲区也在一个窗口上显示，所以他也是一个**已激活的缓冲区**。如果你现在通过 `:e file2` 命令加载另一个文件，`file1` 将会变成一个**隐藏的缓冲区**，并且 `file2` 变成已激活缓冲区。

使用 `:ls` 我们能够列出所有可以列出的缓冲区。插件缓冲区和帮助缓冲区通常被标记为不可以列出的缓冲区，因为那并不是你经常需要在编辑器中编辑的常规文件。通过 `:ls!` 命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区。

**未命名的缓冲区**是一种没有关联特定文件的缓冲区，这种缓冲区经常被插件使用。比如 `:enew` 将会创建一个无名临时缓冲区。添加一些文本然后使用 `:w /tmp/foo` 将他写入到磁盘，这样这个缓冲区就会变成一个**已命名的缓冲区**。

返回主目录 [:arrow_heading_up:](#基础)

## 参数列表

[全局缓冲区列表](#缓冲区窗口标签)是 Vim 的特性。在这之前的 vi 中，仅仅只有参数列表，参数列表在 Vim 中依旧可以使用。

每一个通过 shell 命令传递给 Vim 的文件名都被记录在一个参数列表中。可以有多个参数列表：默认情况下所有参数都被放在全局参数列表下，但是你可以使用 `:arglocal` 命令去创建一个新的本地窗口的参数列表。

使用 `:args` 命令可以列出当前参数。使用 `:next`，`:previous`，`:first`，`:last` 命令可以在切换在参数列表中的文件。通过使用 `:argadd`，`:argdelete` 或者 `:args` 等命令加上一个文件列表可以改变参数列表。

偏爱缓冲区列表还是参数列表完全是个人选择，我的印象中大多数人都是使用缓冲区列表的。

然而参数列表在有些情况下被大量使用：批处理
使用 `:argdo`！ 一个简单的重构例子：

```vim
:args **/*.[ch]
:argdo %s/foo/bar/ge | update
```

这条命令将替换掉当前目录下以及当前目录的子目录中所有的 C 源文件和头文件中的“foo”，并用“bar”代替。

相关帮助：`:h argument-list`

返回主目录 [:arrow_heading_up:](#基础)

## 按键映射

使用 `:map` 命令家族你可以定义属于你自己的快捷键。该家族的每一个命令都限定在特定的模式下。从技术上来说 Vim 自带高达 12 中模式，其中 6 种可以被映射。另外一些命令作用于多种模式：

|   递归   |   非递归     | 模式                             |
| -------- | ------------ | -------------------------------- |
| `:map`   | `:noremap`   | normal, visual, operator-pending |
| `:nmap`  | `:nnoremap`  | normal                           |
| `:xmap`  | `:xnoremap`  | visual                           |
| `:cmap`  | `:cnoremap`  | command-line                     |
| `:omap`  | `:onoremap`  | operator-pending                 |
| `:imap`  | `:inoremap`  | insert                           |

例如：这个自定义的快捷键只在普通模式下工作。

```vim
:nmap <space> :echo "foo"<cr>
```

使用 `:nunmap <space>` 可以取消这个映射。

对于更少数，不常见的模式（或者他们的组合），查看 `:h map-modes`。

到现在为止还好，对新手而言有一个问题会困扰他们：`:nmap` 是**递归执行**的！结果是，右边执行可能的映射。

你自定义了一个简单的映射去输出“Foo”：

```vim
:nmap b :echo "Foo"<cr>
```

但是如果你想要映射 `b` （回退一个单词）的默认功能到一个键上呢？

```vim
:nmap a b
```

如果你敲击<kbd>a</kbd>，我们期望着光标回退到上一个单词，但是实际情况是“Foo”被输出到命令行里！因为在右边，`b` 已经被映射到别的行为上了，换句话说就是 `:echo "Foo"<cr>`。

解决此问题的正确方法是使用一种 _非递归_ 的映射代替：

```vim
:nnoremap a b
```

经验法则：除递归映射是必须的，否则总是使用非递归映射。

通过不给一个右值来检查你的映射。比如`:nmap` 显示所以普通模式下的映射，`:nmap <leader>` 显示所有以 `<leader>` 键开头的普通模式下的映射。

如果你想禁止用标准映射，把他们映射到特殊字符 `<nop>` 上，例如：`:noremap <left> <nop>`。

相关帮助：

```vim
:h key-notation
:h mapping
:h 05.3
```

返回主目录 [:arrow_heading_up:](#基础)

## 映射前置键

映射前置键（Leader 键）本身就是一个按键映射，默认为 <kbd>\\</kbd>。我们可以通过在 `map` 中调用 `<leader>` 来为把它添加到其他按键映射中。

```vim
nnoremap <leader>h :helpgrep<space>
```

这样，我们只需要先按 <kbd>\\</kbd> 然后按 <kbd>h</kbd> 就可以激活这个映射 `:helpgrep<space>`。如果你想通过先按 <kbd>空格</kbd> 键来触发，只需要这样做：

```vim
let g:mapleader = ' '
nnoremap <leader>h :helpgrep<space>
```

此处建议使用 `g:mapleader`，因为在 Vim 脚本中，函数外的变量缺省的作用域是全局变量，但是在函数内缺省作用域是局部变量，而设置快捷键前缀需要修改全局变量 `g:mapleader` 的值。

另外，还有一个叫 `<localleader>` 的，可以把它理解为局部环境中的 `<leader>`，默认值依然为 <kbd>\\</kbd>。当我们需要只对某一个条件下（比如，特定文件类型的插件）的缓冲区设置特别的 `<leader>` 键，那么我们就可以通过修改当前环境下的 `<localleader>` 来实现。

**注意**：如果你打算设置 Leader 键，请确保在设置按键映射之前，先设置好 Leader 键。如果你先设置了含有 Leader 键的映射，然后又修改了 Leader 键，那么之前映射内的 Leader 键是不会因此而改变的。你可以通过执行 `:nmap <leader>` 来查看普通模式中已绑定给 Leader 键的所有映射。

请参阅 `:h mapleader` 与 `:h maploacalleader` 来获取更多帮助。

返回主目录 [:arrow_heading_up:](#基础)

## 寄存器

寄存器就是存储文本的地方。我们常用的「复制」操作就是把文本存储到寄存器，「 粘贴」 操作就是把文本从寄存器中读出来。顺便，在 Vim 中复制的快捷键是 <kbd>y</kbd>，粘贴的快捷键是 <kbd>p</kbd>。

Vim 为我们提供了如下的寄存器：

| 类型                | 标识               | 读写者 | 是否为只读 | 包含的字符来源                                                                                                                                                                                                                                       |
| ------------------- | ------------------ | ------ | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Unnamed             | `"`                | vim    | 否         | 最近一次的复制或删除操作 (`d`, `c`, `s`, `x`, `y`)                                                                                                                                                                                                   |
| Numbered            | `0`至`9`           | vim    | 否         | 寄存器 `0`: 最近一次复制。寄存器 `1`: 最近一次删除。寄存器 `2`: 倒数第二次删除，以此类推。对于寄存器 `1` 至 `9`，他们其实是只读的最多包含 9 个元素的队列。这里的队列即为数据类型 [queue](<https://en.wikipedia.org/wiki/Queue_(abstract_data_type)>) |
| Small delete        | `-`                | vim    | 否         | 最近一次行内删除                                                                                                                                                                                                                                     |
| Named               | `a`至`z`, `A`至`Z` | 用户   | 否         | 如果你通过复制操作存储文本至寄存器 `a`，那么 `a` 中的文本就会被完全覆盖。如果你存储至 `A`，那么会将文本添加给寄存器 `a`，不会覆盖之前已有的文本                                                                                                      |
| Read-only           | `:`与`.`和`%`      | vim    | 是         | `:`: 最近一次使用的命令，`.`: 最近一次添加的文本，`%`: 当前的文件名                                                                                                                                                                                  |
| Alternate buffer    | `#`                | vim    | 否         | 大部分情况下，这个寄存器是当前窗口中，上一次访问的缓冲区。请参阅 `:h alternate-file` 来获取更多帮助                                                                                                                                                  |
| Expression          | `=`                | 用户   | 否         | 复制 VimL 代码时，这个寄存器用于存储代码片段的执行结果。比如，在插入模式下复制 `<c-r>=5+5<cr>`，那么这个寄存器就会存入 10                                                                                                                            |
| Selection           | `+`和`*`           | vim    | 否         | `*` 和 `+` 是 [剪贴板](#剪贴板) 寄存器                                                                                                                                                                                                               |
| Drop                | `~`                | vim    | 是         | 最后一次拖拽添加至 Vim 的文本（需要 "+dnd" 支持，暂时只支持 GTK GUI。请参阅 `:help dnd` 及 `:help quote~`）                                                                                                                                          |
| Black hole          | `_`                | vim    | 否         | 一般称为黑洞寄存器。对于当前操作，如果你不希望在其他寄存器中保留文本，那就在命令前加上 `_`。比如，`"_dd` 命令不会将文本放到寄存器 `"`、`1`、`+` 或 `*` 中                                                                                            |
| Last search pattern | `/`                | vim    | 否         | 最近一次通过 `/`、`?` 或 `:global` 等命令调用的匹配条件                                                                                                                                                                                              |

只要不是只读的寄存器，用户都有权限修改它的内容，比如：

```vim
:let @/ = 'register'
```

这样，我们按 <kbd>n</kbd> 的时候就会跳转到单词"register" 出现的地方。

有些时候，你的操作可能已经修改了寄存器，而你没有察觉到。请参阅 `:h registers` 获取更多帮助。

上面提到过，复制的命令是 <kbd>y</kbd>，粘贴的命令是 <kbd>p</kbd> 或者 <kbd>P</kbd>。但请注意，Vim 会区分「字符选取」与「行选取」。请参阅 `:h linewise` 获取更多帮助。

**行选取**：
命令 `yy` 或 `Y` 都是复制当前行。这时移动光标至其他位置，按下 `p` 就可以在光标下方粘贴复制的行，按下 `P` 就可以在光标上方粘贴至复制的行。

**字符选取**：
命令 `0yw` 可以复制第一个单词。这时移动光标至其他位置，按下 `p` 就可以在当前行、光标后的位置粘贴单词，按下 `P` 就可以在当前行、光标前的位置粘贴单词。

**将文本存到指定的寄存器中**：
命令 `"aY` 可以将当前行复制，并存储到寄存器 `a` 中。这时移动光标至其他位置，通过命令 `"AY` 就可以把这一行的内容扩展到寄存器 `a` 中，而之前存储的内容也不会丢失。

为了便于理解和记忆，建议大家现在就试一试上面提到的这些操作。操作过程中，你可以随时通过 `:reg` 来查看寄存器的变化。

**有趣的是**：
在 Vim 中，`y` 是复制命令，源于单词 "yanking"。而在 Emacs 中，"yanking" 代表的是粘贴（或者说，重新插入刚才删掉的内容），而并不是复制。

返回主目录 [:arrow_heading_up:](#基础)

## 范围

范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。

- 很多命令都可以加一个数字，用于指明操作范围
- 范围可以是一个行号，用于指定某一行
- 范围也可以是一对通过 `,` 或 `;` 分割的行号
- 大部分命令，默认只作用于当前行
- 只有 `:write` 和 `:global` 是默认作用于所有行的

范围的使用是十分直观的。以下为一些例子（其中，`:d` 为 `:delete` 的缩写）：

| 命令                | 操作的行                                                          |
| ------------------- | ----------------------------------------------------------------- |
| `:d`                | 当前行                                                            |
| `:.d`               | 当前行                                                            |
| `:1d`               | 第一行                                                            |
| `:$d`               | 最后一行                                                          |
| `:1,$d`             | 所有行                                                            |
| `:%d`               | 所有行（这是 `1,$` 的语法糖）                                     |
| `:.,5d`             | 当前行至第 5 行                                                   |
| `:,5d`              | 同样是当前行至第 5 行                                             |
| `:,+3d`             | 当前行及接下来的 3 行                                             |
| `:1,+3d`            | 第一行至当前行再加 3 行                                           |
| `:,-3d`             | 当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围） |
| `:3,'xdelete`       | 第三行至[标注](#标注) 为 x 的那一行                               |
| `:/^foo/,$delete`   | 当前行以下，以字符 "foo" 开头的那一行至结尾                       |
| `:/^foo/+1,$delete` | 当前行以下，以字符 "foo" 开头的那一行的下一行至结尾               |

需要注意的是，`;` 也可以用于表示范围。区别在于，`a,b` 的 `b` 是以当前行作为参考的。而 `a;b` 的 `b` 是以 `a` 行作为参考的。举个例子，现在你的光标在第 5 行。这时 `:1,+1d` 会删除第 1 行至第 6 行，而 `:1;+1d` 会删除第 1 行和第 2 行。

如果你想设置多个寻找条件，只需要在条件前加上 `/`，比如：

```vim
:/foo//bar//quux/d
```

这就会删除当前行之后的某一行。定位方式是，先在当前行之后寻找第一个包含 "foo" 字符的那一行，然后在找到的这一行之后寻找第一个包含 "bar" 字符的那一行，然后再在找到的这一行之后寻找第一个包含 "quux" 的那一行。删除的就是最后找到的这一行。

有时，Vim 会在命令前自动添加范围。举个例子，如果你先通过 `V` 命令进入行选取模式，选中一些行后按下 `:` 进入命令模式，这时候你会发现 Vim 自动添加了 `'<,'>` 范围。这表示，接下来的命令会使用之前选取的行号作为范围。但如果后续命令不支持范围，Vim 就会报错。为了避免这样的情况发生，有些人会设置这样的按键映射：`:vnoremap foo :<c-u>command`，组合键 <kbd>Ctrl + u</kbd> 可以清除当前命令行中的内容。

另一个例子是在普通模式中按下 `!!`，命令行中会出现 `:.!`。如果这时你如果输入一个外部命令，那么当前行的内容就会被这个外部命令的输出替换。你也可以通过命令 `:?^$?+1,/^$/-1!ls` 把当前段落的内容替换成外部命令 `ls` 的输出，原理是向前和向后各搜索一个空白行，删除这两个空白行之间的内容，并将外部命令 `ls` 的输出放到这两个空白行之间。

请参阅以下两个命令来获取更多帮助：

```vim
:h cmdline-ranges
:h 10.3
```

返回主目录 [:arrow_heading_up:](#基础)

## 标注

你可以使用标注功能来标记一个位置，也就是记录文件某行的某个位置。

| 标注    | 设置者  | 使用                                                                                                                                  |
| ------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| `a`-`z` | 用户    | 仅对当前的一个文件生效，也就意味着只可以在当前文件中跳转                                                                              |
| `A`-`Z` | 用户    | 全局标注，可以作用于不同文件。大写标注也称为「文件标注」。跳转时有可能会切换到另一个缓冲区                                            |
| `0`-`9` | viminfo | `0` 代表 viminfo 最后一次被写入的位置。实际使用中，就代表 Vim 进程最后一次结束的位置。`1` 代表 Vim 进程倒数第二次结束的位置，以此类推 |

如果想跳转到指定的标注，你可以先按下 `'` / `g'` 或者 `` ` `` / `` g` `` 然后按下标注名。

如果你想定义当前文件中的标注，可以先按下 `m` 再按下标注名。比如，按下 `mm` 就可以把当前位置标注为 `m`。在这之后，如果你的光标切换到了文件的其他位置，只需要通过 `'m` 或者 `` `m ``即可回到刚才标注的行。区别在于，`'m`会跳转回被标记行的第一个非空字符，而`` `m ``会跳转回被标记行的被标记列。根据 viminfo 的设置，你可以在退出 Vim 的时候保留小写字符标注。请参阅`:h viminfo-'` 来获取更多帮助。

如果你想定义全局的标注，可以先按下 `m` 再按下大写英文字符。比如，按下 `mM` 就可以把当前文件的当前位置标注为 `M`。在这之后，就算你切换到其他的缓冲区，依然可以通过 `'M` 或 `` `M `` 跳转回来。

关于跳转，还有以下的方式：

| 按键             | 跳转至                                         |
| ---------------- | ---------------------------------------------- |
| `'[` 与 `` `[ `` | 上一次修改或复制的第一行或第一个字符           |
| `']` 与 `` `] `` | 上一次修改或复制的最后一行或最后一个字符       |
| `'<` 与 `` `< `` | 上一次在可视模式下选取的第一行或第一个字符     |
| `'>` 与 `` `> `` | 上一次在可视模式下选取的最后一行或最后一个字符 |
| `''` 与 `` `' `` | 上一次跳转之前的光标位置                       |
| `'"` 与 `` `" `` | 上一次关闭当前缓冲区时的光标位置               |
| `'^` 与 `` `^ `` | 上一次插入字符后的光标位置                     |
| `'.` 与 `` `. `` | 上一次修改文本后的光标位置                     |
| `'(` 与 `` `( `` | 当前句子的开头                                 |
| `')` 与 `` `) `` | 当前句子的结尾                                 |
| `'{` 与 `` `{ `` | 当前段落的开头                                 |
| `'}` 与 `` `} `` | 当前段落的结尾                                 |

标注也可以搭配 [范围](#范围) 一起使用。前面提到过，如果你在可视模式下选取一些文本，然后按下 `:`，这时候你会发现命令行已经被填充了 `:'<,'>`。对照上面的表格，现在你应该明白了，这段代表的就是可视模式下选取的范围。

请使用 `:marks` 命令来显示所有的标注，参阅 `:h mark-motions` 来获取关于标注的更多帮助。

返回主目录 [:arrow_heading_up:](#基础)

## 补全

Vim 在插入模式中为我们提供了多种补全方案。如果有多个补全结果，Vim 会弹出一个菜单供你选择。

常见的补全有标签、项目中引入的模块或库中的方法名、文件名、字典及当前缓冲区的字段。

针对不同的补全方案，Vim 为我们提供了不同的按键映射。这些映射都是在**插入模式中**通过 <kbd>Ctrl</kbd> + <kbd>x</kbd> 来触发：

| 映射         | 类型                                            | 帮助文档   |
| ------------ | ----------------------------------------------- | ---------- |
| `<c-x><c-l>` | 整行                                            | `:h i^x^l` |
| `<c-x><c-n>` | 当前缓冲区中的关键字                            | `:h i^x^n` |
| `<c-x><c-k>` | 字典（请参阅 `:h 'dictionary'`）中的关键字      | `:h i^x^k` |
| `<c-x><c-t>` | 同义词字典（请参阅 `:h 'thesaurus'`）中的关键字 | `:h i^x^t` |
| `<c-x><c-i>` | 当前文件以及包含的文件中的关键字                | `:h i^x^i` |
| `<c-x><c-]>` | 标签                                            | `:h i^x^]` |
| `<c-x><c-f>` | 文件名                                          | `:h i^x^f` |
| `<c-x><c-d>` | 定义或宏定义                                    | `:h i^x^d` |
| `<c-x><c-v>` | Vim 命令                                        | `:h i^x^v` |
| `<c-x><c-u>` | 用户自定义补全（通过 `'completefunc'` 定义）    | `:h i^x^u` |
| `<c-x><c-o>` | Omni Completion（通过 `'omnifunc'` 定义）       | `:h i^x^o` |
| `<c-x>s`     | 拼写建议                                        | `:h i^Xs`  |

尽管用户自定义补全与 Omni Completion 是不同的，但他们做的事情基本一致。共同点在于，他们都是一个监听当前光标位置的函数，返回值为一系列的补全建议。用户自定义补全是由用户定义的，基于用户的个人用途，因此你可以根据自己的喜好和需求随意定制。而 Omni Completion 是针对文件类型的补全，比如在 C 语言中补全一个结构体（struct）的成员（members），或者补全一个类的方法，因而它通常都是由文件类型插件设置和调用的。

如果你设置了 `'complete'` 选项，那么你就可以在一次操作中采用多种补全方案。这个选项默认包含了多种可能性，因此请按照自己的需求来配置。你可以通过 `<c-n>` 来调用下一个补全建议，或通过 `<c-p>` 来调用上一个补全建议。当然，这两个映射同样可以直接调用补全函数。请参阅 `:h i^n` 与 `:h 'complete'` 来获得更多帮助。

如果你想配置弹出菜单的行为，请一定要看一看 `:h 'completeopt'` 这篇帮助文档。默认的配置已经不错了，但我个人（原作者）更倾向于把 "noselect" 加上。

请参阅以下文档获取更多帮助：

```vim
:h ins-completion
:h popupmenu-keys
:h new-omni-completion
```

返回主目录 [:arrow_heading_up:](#基础)

## 动作，操作符，文本对象

**动作**也就是指移动光标的操作，你肯定很熟悉 `h`、`j`、`k` 和 `l`，以及 `w` 和 `b`。但其实，`/` 也是一个动作。他们都可以搭配数字使用，比如 `2?the<cr>` 可以将光标移动到倒数第二个 "the" 出现的位置。

以下会列出一些常用的动作。你也可以通过 `:h navigation` 来获取更多的帮助。

**操作符**是对某个区域文本执行的操作。比如，`d`、`~`、`gU` 和 `>` 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。在普通模式中，顺序是先按操作符，再按动作指令，比如 `>j`。在可视模式中，选中区域后直接按操作符就可以，比如 `Vjd`。

与动作一样，操作符也可以搭配数字使用，比如 `2gUw` 可以将当前单词以及下一个单词转成大写。由于动作和操作符都可以搭配数字使用，因此 `2gU2w` 与执行两次 `gU2w` 效果是相同的。

请参阅 `:h operator` 来查看所有的操作符。你也可以通过 `:set tildeop` 命令把 `~` 也变成一个操作符

值得注意的是，动作是单向的，而**文本对象**是双向的。文本对象不仅作用于符号（比如括号、中括号和大括号等）标记的范围内，也作用于整个单词、整个句子等其他情况。

文本对象不能用于普通模式中移动光标的操作，因为光标还没有智能到可以向两个方向同时跳转。但这个功能可以在可视模式中实现，因为在对象的一端选中的情况下，光标只需要跳转到另一端就可以了。

文本对象操作一般用 `i` 或 `a` 加上对象标识符操作，其中 `i` 表示在对象内（英文 inner）操作，`a` 表示对整个对象（英文 around）操作，这时开头和结尾的空格都会被考虑进来。举个例子，`diw` 可以删除当前单词，`ci(` 可以改变括号中的内容。

文本对象同样可以与数字搭配使用。比如，像 `((( )))` 这样的文本，假如光标位于最内层的括号上或最内层的括号内，那么 `d2a(` 将会删除从最内层开始的两对括号，以及他们之间的所有内容。其实，`d2a(` 这个操作等同于 `2da(`。在 Vim 的命令中，如果有两处都可以接收数字作为参数，那么最终结果就等同于两个数字相乘。在这里，`d` 与 `a(` 都是可以接收参数的，一个参数是 1，另一个是 2，我们可以把它们相乘然后放到最前面。

请参阅 `:h text-objects` 来获取更多关于文本对象的帮助。

返回主目录 [:arrow_heading_up:](#基础)

## 自动命令

在特定的情况下，Vim 会传出事件。如果你想针对这些事件执行回调方法，那么就需要用到自动命令这个功能。

如果没有了自动命令，那你基本上是用不了 Vim 的。自动命令一直都在执行，只是很多时候你没有注意到。不信的话，可以执行命令 `:au` ，不要被结果吓到，这些是当前有效的所有自动命令。

请使用 `:h {event}` 来查看 Vim 中所有事件的列表，你也可以参考 `:h autocmd-events-abc` 来获取关于事件的更多帮助。

一个很常用的例子，就是针对文件类型执行某些设置：

```vim
autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:#
```

但是缓冲区是如何知道当前的文件中包含 Ruby 代码呢？这其实是另一个自动命令检测的到的，然后把文件类型设置成为 Ruby，这样就触发了上面的 `FileType` 事件。

在配置 vimrc 的时候，一般第一行加进去的就是 `filetype on`。这就意味着，Vim 启动时会读取 `filetype.vim` 文件，然后根据文件类型来触发相应的自动命令。

如果你勇于尝试，可以查看下 `:e $VIMRUNTIME/filetype.vim`，然后在输出中搜索 "Ruby"。这样，你就会发现其实 Vim 只是通过文件扩展名 `.rb` 判断某个文件是不是 Ruby 的。

**注意**：对于相同事件，如果有多个自动命令，那么自动命令会按照定义时的顺序执行。通过 `:au` 就可以查看它们的执行顺序。

```vim
au BufNewFile,BufRead *.rb,*.rbw setf ruby
```

`BufNewFile` 与 `BufRead` 事件是被写在 Vim 源文件中的。因此，每当你通过 `:e` 或者类似的命令打开文件，这两个事件都会触发。然后，就是读取 `filetype.vim` 文件来判断打开的文件类型。

简单来说，事件和自动命令在 Vim 中的应用十分广泛。而且，Vim 为我们留出了一些易用的接口，方便用户配置适合自己的事件驱动回调。

请参阅 `:h autocommand` 来获取更多帮助

返回主目录 [:arrow_heading_up:](#基础)

## 变更历史，跳转历史

在 Vim 中，用户最近 100 次的文字改动都会被保存在**变更历史**中。如果在同一行有多个小改动，那么 Vim 会把它们合并成一个。尽管内容改动会合并，但作用的位置还是会只记录下最后一次改动的位置。

在你移动光标或跳转的时候，每一次的移动或跳转前的位置会被记录到**跳转历史**中。类似地，跳转历史也可以最多保存 100 条记录。对于每个窗口，跳转记录是独立的。但当你分离窗口时（比如使用 `:split` 命令），跳转历史会被复制过去。

Vim 中的跳转命令，包括 `'`、`` ` ``、`G`、`/`、`?`、`n`、`N`、`%`、`(`、`)`、`[[`、`]]`、`{`、`}`、`:s`、`:tag`、`L`、`M`、`H` 以及开始编辑一个新文件的命令。

| 列表     | 显示所有条目 | 跳转到上一个位置 | 跳转到下一个位置 |
| -------- | ------------ | ---------------- | ---------------- |
| 跳转历史 | `:jumps`     | `[count]<c-o>`   | `[count]<c-i>`   |
| 变更历史 | `:changes`   | `[count]g;`      | `[count]g,`      |

如果你执行第二列的命令显示所有条目，这时 Vim 会用 `>` 标记来为你指示当前位置。通常这个标记位于 1 的下方，也就代表最后一次的位置。

如果你希望关闭 Vim 之后还保留这些条目，请参阅 `:h viminfo-'` 来获取更多帮助。

**注意**：上面提到过，最后一次跳转前的位置也会记录在[标注](#标注)中，也可以通过连按 <kbd>\`\`</kbd> 或 <kbd>''</kbd> 跳转到那个位置

请参阅以下两个命令来获取更多帮助：

```vim
:h changelist
:h jumplist
```

返回主目录 [:arrow_heading_up:](#基础)

## 内容变更历史记录

Vim 会记录文本改变之前的状态。因此，你可以使用「撤销」操作 <kbd>u</kbd> 来取消更改，也可以通过「重做」操作 <kbd>Ctrl + r</kbd> 来恢复更改。

值得注意的是，Vim 采用 [tree](<https://en.wikipedia.org/wiki/Tree_(data_structure)>) 数据结构来存储内容变更的历史记录，而不是采用 [queue](<https://en.wikipedia.org/wiki/Queue_(abstract_data_type)>)。你的每次改动都会成为存储为树的节点。而且，除了第一次改动（根节点），之后的每次改动都可以找到一个对应的父节点。每一个节点都会记录改动的内容和时间。其中，「分支」代表从任一节点到根节点的路径。当你进行了撤销操作，然后又输入了新的内容，这时候就相当于创建了分支。这个原理和 git 中的 branch（分支）十分类似。

考虑以下这一系列按键操作：

```vim
ifoo<esc>
obar<esc>
obaz<esc>
u
oquux<exc>
```

那么现在，Vim 中会显示三行文本，分别是 "foo"、"bar" 和 "quux"。这时候，存储的树形结构如下：

         foo(1)
           /
        bar(2)
       /      \
    baz(3)   quux(4)

这个树形结构共包含四次改动，括号中的数字就代表时间顺序。

现在，我们有两种方式遍历这个树结构。一种叫「按分支遍历」，一种叫「按时间遍历」。

撤销 <kbd>u</kbd> 与重做 <kbd>Ctrl + r</kbd> 操作是按分支遍历。对于上面的例子，现在我们有三行字符。这时候按 <kbd>u</kbd> 会回退到 "bar" 节点，如果再按一次 <kbd>u</kbd> 则会回退到 "foo" 节点。这时，如果我们按下 <kbd>Ctrl + r</kbd> 就会前进至 "bar" 节点，再按一次就回前进至 "quux" 节点。在这种方式下，我们无法访问到兄弟节点（即 "baz" 节点）。

与之对应的是按时间遍历，对应的按键是 `g-` 和 `g+`。对于上面的例子，按下 `g-` 会首先回退到 "baz" 节点。再次按下 `g-` 会回退到 "bar" 节点。

| 命令/按键                          | 执行效果                                                                                                                                                          |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `[count]u` 或 `:undo [count]`      | 回退到 `[count]` 次改动之前                                                                                                                                       |
| `[count]<c-r>` 或 `:redo [count]`  | 重做 `[count]` 次改动                                                                                                                                             |
| `U`                                | 回退至最新的改动                                                                                                                                                  |
| `[count]g-` 或 `:earlier [count]?` | 根据时间回退到 `[count]` 次改动之前。"?" 为 "s"、"m"、"h"、"d" 或 "f"之一。例如，`:earlier 2d` 会回退到两天之前。`:earlier 1f` 则会回退到最近一次文件保存时的内容 |
| `[count]g+` 或 `:later [count]?`   | 类似 `g-`，但方向相反                                                                                                                                             |

内容变更记录会储存在内存中，当 Vim 退出时就会清空。如果需要持久化存储内容变更记录，请参阅[备份文件，交换文件，撤销文件以及 viminfo 文件的处理](#备份文件交换文件撤销文件以及viminfo文件的处理)章节的内容。

如果你觉得这一部分的内容难以理解，请参阅 [undotree](https://github.com/mbbill/undotree)，这是一个可视化管理内容变更历史记录的插件。类似的还有 [vim-mundo](https://github.com/simnalamburt/vim-mundo)。

请参阅以下链接获取更多帮助：

```vim
:h undo.txt
:h usr_32
```

返回主目录 [:arrow_heading_up:](#基础)

## 全局位置信息表，局部位置信息表

在某一个动作返回一系列「位置」的时候，我们可以利用「全局位置信息表」和「局部位置信息表」来存储这些位置信息，方便以后跳转回对应的位置。每一个存储的位置包括文件名、行号和列号。

比如，编译代码是出现错误，这时候我们就可以把错误的位置直接显示在全局位置信息表，或者通过外部抓取工具使位置显示在局部位置信息表中。

尽管我们也可以把这些信息显示到一个空格缓冲区中，但用这两个信息表显示的好处在于接口调用很方便，而且也便于浏览输出。

Vim 中，全局位置信息表只能有一个，但每一个窗口都可以有自己的局部位置信息表。这两个信息表的外观看上去很类似，但在操作上会稍有不同。

以下为两者的操作比较：

| 动作         | 全局位置信息表 | 局部位置信息表 |
| ------------ | -------------- | -------------- |
| 打开窗口     | `:copen`       | `:lopen`       |
| 关闭窗口     | `:cclose`      | `:lclose`      |
| 下一个条目   | `:cnext`       | `:lnext`       |
| 上一个条目   | `:cprevious`   | `:lprevious`   |
| 第一个条目   | `:cfirst`      | `:lfirst`      |
| 最后一个条目 | `:clast`       | `:llast`       |

请参阅 `:h :cc` 以及底下的内容，来获取更多命令的帮助。

**应用实例**：
如果我们想用 `grep` 递归地在当前文件夹中寻找某个关键词，然后把输出结果放到全局位置信息表中，只需要这样：

```vim
:let &grepprg = 'grep -Rn $* .'
:grep! foo
<grep output - hit enter>
:copen
```

执行了上面的代码，你就能看到所有包含字符串 "foo" 的文件名以及匹配到的相关字段都会显示在全局位置信息表中。

返回主目录 [:arrow_heading_up:](#基础)

## 宏

你可以在 Vim 中录制一系列按键，并把他们存储到[寄存器](#寄存器)中。对于一些需要临时使用多次的一系列操作，把它们作为宏保存起来会显著地提升效率。对于一些复杂的操作，建议使用 Vim 脚本来实现。

- 首先，按下 <kbd>q</kbd>，然后按下你想要保存的寄存器，任何小写字母都可以。比如我们来把它保存到 `q` 这个寄存器中。按下 `qq`，你会发现命令行里已经显示了 "recording @q"。
- 如果你已经录制完成，那么只需要再按一次 <kbd>q</kbd> 就可以结束录制。
- 如果你想调用刚才录制的宏，只需要 `[count]@q`
- 如果你想调用上一次使用的宏，只需要 `[count]@@`

**实例 1**：

一个插入字符串 "abc" 后换行的宏，重复调用十次：

```vim
qq
iabc<cr><esc>
q
10@q
```

（对于上面这个功能，你同样可以通过如下的按键： <kbd>o</kbd><kbd>a</kbd><kbd>b</kbd><kbd>c</kbd> 然后 <kbd>ESC</kbd> 然后 <kbd>1</kbd><kbd>0</kbd><kbd>.</kbd> 来实现）。

**实例 2**：

一个在每行前都加上行号的宏。从第一行开始，行号为 1，后面依次递增。我们可以通过 <kbd>Ctrl</kbd> + <kbd>a</kbd> 来实现递增的行号，在定义宏的时候，它会显示成 `^A`。

```vim
qq
0yf jP0^A
q
1000 @q
```

这里能实现功能，是因为我们假定了文件最多只有 1000 行。但更好的方式是使用「递归」宏，它会一直执行，知道不能执行为止：

```vim
qq
0yf jP0^A@q
q
@q
```

（对于上面这个插入行号的功能，如果你不愿意使用宏，同样可以通过这段按键操作来实现：`:%s/^/\=line('.') . '. '`）。

这里向大家展示了如何不用宏来达到相应的效果，但要注意，这些不用宏的实现方式只适用于这些简单的示例。对于一些比较复杂的自动化操作，你确实应该考虑使用宏。

请参阅以下文档获取更多帮助：

```vim
:h recording
:h 'lazyredraw'
```

返回主目录 [:arrow_heading_up:](#基础)

## 颜色主题

颜色主题可以把你的 Vim 变得更漂亮。Vim 是由多个组件构成的，我们可以给每一个组件都设置不同的文字颜色、背景颜色以及文字加粗等等。比如，我们可以通过这个命令来设置背景颜色：

```vim
:highlight Normal ctermbg=1 guibg=red
```

执行后你会发现，现在背景颜色变成红色了。请参阅 `:h :highlight` 来获取更多帮助。

其实，颜色主题就是一系列的 `:highlight` 命令的集合。

事实上，大部分颜色主题都包含两套配置。一套适用于例如 xterm 和 iTerm 这样的终端环境（使用前缀 `cterm`），另一套适用于例如 gvim 和 MacVim 的图形界面环境（使用前缀 `gui`）。对于上面的例子，`ctermbg` 就是针对终端环境的，而 `guibg` 就是针对图形界面环境的。

如果你下载了一个颜色主题，并且在终端环境中打开了 Vim，然后发现显示的颜色与主题截图中差别很大，那很可能是配置文件只设置了图形界面环境的颜色。反之同理，如果你使用的是图形界面环境，发现显示颜色有问题，那就很可能是配置文件只设置了终端环境的颜色。

第二种情况（图形界面环境的显示问题）其实不难解决。如果你使用的是 Neovim 或者 Vim 7.4.1830 的后续版本，可以通过打开[真彩色](https://zh.wikipedia.org/wiki/真彩色)设置来解决显示问题。这就可以让终端环境的 Vim 使用 GUI 的颜色定义，但首先，你要确认一下你的终端环境和环境内的组件（比如 tmux）是否都支持真彩色。可以看一下[这篇文档](https://gist.github.com/XVilka/8346728)，描述的十分详细。

请参阅以下文档或链接来获取更多帮助：

- `:h 'termguicolors'`
- [主题列表](#主题列表)
- [自定义主题中的颜色](#自定义主题中的颜色)

返回主目录 [:arrow_heading_up:](#基础)

## 折叠

每一部分文字（或者代码）都会有特定的结构。对于存在结构的文字和代码，也就意味着它们可以按照一定的逻辑分割成不同区域。Vim 中的折叠功能，就是按照特定的逻辑把文字和代码折叠成一行，并显示一些简短的描述。折叠功能涉及到很多操作，而且折叠功能可以嵌套使用。

在 Vim 中，有以下 6 中折叠类型：

| 折叠方式 | 概述                                       |
| -------- | ------------------------------------------ |
| diff     | 在「比较窗口」中折叠未改变的文本           |
| expr     | 使用 `'foldexpr'` 来创建新的折叠逻辑       |
| indent   | 基于缩进折叠                               |
| manual   | 使用 `zf`、`zF` 或 `:fold` 来自定义折叠    |
| marker   | 根据特定的文本标记折叠（通常用于代码注释） |
| syntax   | 根据语法折叠，比如折叠 `if` 代码块         |

**注意**：折叠功能可能会显著地影响性能。如果你在使用折叠功能的时候出现了打字卡顿之类的问题，请考虑使用 [FastFold 插件](https://github.com/Konfekt/FastFold)。这个插件可以让 Vim 按需更新折叠内容，而不是一直调用。

请参阅以下文档获取更多帮助：

```vim
:h usr_28
:h folds
```

## 会话

如果你保存了当前的「视图」（请参阅 `:h :mkview`），那么当前窗口、配置和按键映射都会被保存下来（请参阅 `:h :loadview`）。

「会话」就是存储所有窗口的相关设置，以及全局设置。简单来说，就是给当前的 Vim 运行实例拍个照，然后把相关信息存储到会话文件中。存储之后的改动就不会在会话文件中显示，你只需要在改动后更新一下会话文件就可以了。

你可以把当前工作的「项目」存储起来，然后可以在不同的「项目」之间切换。

现在就来试试吧。打开几个窗口和标签，然后执行 `:mksession Foo.vim`。如果你没有指定文件名，那就会默认保存为 `Session.vim`。这个文件会保存在当前的目录下，你可以通过 `:pwd` 来显示当前路径。重启 Vim 之后，你只需要执行 `:source Foo.vim`，就可以恢复刚才的会话了。所有的缓冲区、窗口布局、按键映射以及工作路径都会恢复到保存时的状态。

其实 Vim 的会话文件就只是 Vim 命令的集合。你可以通过命令 `:vs Foo.vim` 来看看会话文件中究竟有什么。

你可以决定 Vim 会话中究竟要保存哪些配置，只需要设置一下 `'sessionoptions'` 就可以了。

为了方便开发，Vim 把最后一次调用或写入的会话赋值给了一个内部变量 `v:this_session`。

请参阅以下文档来获取更多帮助：

```vim
:h Session
:h 'sessionoptions'
:h v:this_session
```

## 局部化

以上提到的很多概念，都有一个局部化（非全局）的版本：

| 全局        | 局部                  | 作用域       | 帮助文档              |
| ----------- | --------------------- | ------------ | --------------------- |
| `:set`      | `:setlocal`           | 缓冲区或窗口 | `:h local-options`    |
| `:map`      | `:map <buffer>`       | 缓冲区       | `:h :map-local`       |
| `:autocmd`  | `:autocmd * <buffer>` | 缓冲区       | `:h autocmd-buflocal` |
| `:cd`       | `:lcd`                | 窗口         | `:h :lcd`             |
| `:<leader>` | `:<localleader>`      | 缓冲区       | `:h maploacalleader`  |

变量也有不同的作用域，详细内容请参考 [Vim scripting 的文档](http://vimdoc.sourceforge.net/htmldoc/usr_41.html)。

## 用法

## 获取离线帮助

Vim 自带了一套很完善的帮助文档，它们是一个个有固定排版格式的文本文件，通过标签可以访问这些文件的特定位置。

在开始之前先读一下这个章节：`:help :help`。执行这个命令以后会在新窗口打开 `$VIMRUNTIME/doc/helphelp.txt` 文件并跳转到这个文件中 `:help` 标签的位置。

一些关于帮助主题的简单规则：

- 用单引号把文本包起来表示选项，如：`:h 'textwidth'`
- 以小括号结尾表示 VimL 函数，如：`:h reverse()`
- 以英文冒号开头表示命令，如：`:h :echo`

使用快捷键 `<c-d>` （这是 <kbd>ctrl</kbd>+<kbd>d</kbd>）来列出所有包含你当前输入的内容的帮助主题。如：`:h tab<c-d>` 会列出所有包含 `tab` 主题，从 `softtabstop` 到 `setting-guitablabel` （译者注：根据安装的插件不同列出的选项也会不同）。

你想查看所有的 VimL 方法吗？很简单，只要输入：`:h ()<c-d>` 就可以了。你想查看所有与窗口相关的函数吗？输入 `:h win*()<c-d>`。

相信你很快就能掌握这些技巧，但是在刚开始的时候，你可能对于该通过什么进行查找一点线索都没有。这时你可以想象一些与要查找的内容相关的关键字，再让 `:helpgrep` 来帮忙。

```vim
:helpgrep backwards
```

上面的命令会在所有的帮助文件中搜索“backwards”，然后跳转到第一个匹配的位置。所有的匹配位置都会被添加到全局位置信息表，用 `:cp / :cn` 可以在匹配位置之间进行切换。或者用 `:copen` 命令来打开全局位置信息表，将光标定位到你想要的位置，再按 回车就可以跳转到该匹配项。详细说明请参考 `:h quickfix`。

## 获取离线帮助（补充）

这个列表最初发表在 [vim_dev](https://groups.google.com/forum/#!forum/vim_dev)，由 @chrisbra 编辑的，他是 Vim 开发人员中最活跃的一个。

经过一些微小的改动后，重新发布到了这里。

---

如果你知道你想要找什么，使用帮助系统的搜索会更简单一些，因为搜索出的主题都带有固定的格式。

而且帮助系统中的主题包含了你当前使用的 Vim 版本的所特有特性，而网上那些已经过时或者是早期发布的话题是不会包含这些的。

因此学习使用帮助系统以及它所用的语言是很有必要的。这里是一些例子（不一定全，我有可能忘了一些什么）。

（译者注：下面列表中提及的都是如何指定搜索主题以便快速准确的找到你想要的帮助）

1. 选项要用单引号引起来。用 `:h 'list'` 来查看列表选项帮助。只有你明确的知道你要找这么一个选项的时候才可以这么做，不然的话你可以用 `:h options.txt` 来打开所有选项的帮助页面，再用正则表达式进行搜索，如：`/width`。某些选项有它们自己的命名空间，如：`:h cpo-a`，`:h cpo-A`， `:h cpo-b` 等等。

2. 普通模式的命令不能用冒号作为前缀。使用 `:h gt` 来转到“gt”命令的帮助页面。

3. 正则表达式以“/”开头，所以 `:h /\+` 会带你到正则表达式中量词“+”的帮助页面。

4. 组合键经常以一个字母开头表示它们可以在哪些模式中使用。如：`:h i_CTRL-X` 会带你到插入模式下的 CTRL-X 命令的用法帮助页面，这是一个自动完成类的组合键。需要注意的是某些键是有固定写法的，如 Control 键写成 CTRL。还有，查找普通模式下的组合键帮助时，可以省略开头的字母“n”，如：`:h CTRL-A`。而 `:h c_CTRL-A`（译者注：原文为 `:h c_CRTL-R`，感觉改为 A 更符合上下文语境）会解释 CTRL-A 在命令模式下输入命令时的作用；`:h v_CTRL-A` 说的是在可见模式下把光标所在处的数字加 1；`:h g_CTRL-A` 则说的是 g 命令（你需要先按 "g" 的命令）。这里的 "g" 代表一个普通的命令，这个命令总是与其它的按键组合使用才生效，与 "z" 开始的命令相似。

5. 寄存器是以 "quote" 开头的。如：`:h quote:` （译者注：原文为`:h quote`，感觉作者想以":"来举例）来查看关于":"寄存器的说明。

6. 关于 Vim 脚本（VimL）的帮助都在 `:h eval.txt` 里。而某些方面的语言可以使用 `:h expr-X` 获取帮助，其中的 'X' 是一个特定的字符，如：`:h expr-!` 会跳转到描述 VimL 中'!'（非）的章节。另外一个重要提示，可以使用 `:h function-list` 来查看所有函数的简要描述，列表中包括函数名和一句话描述。

7. 关于映射都可以在 `:h map.txt` 中找到。通过 `:h mapmode-i` 来查找 `:imap` 命令的相关信息；通过 `:h map-topic` 来查找专门针对映射的帮助（译者注：topic 为一个占位符，正如上面的字符 'X' 一样，在实际使用中需要替换成相应的单词）（如：`:h :map-local` 查询本地 buffer 的映射，`:h map-bar` 查询如何在映射中处理'|')。

8. 命令定义用 "command-" 开头，如用 `:h command-bar` 来查看自定义命令中'!'的作用。

9. 窗口管理类的命令是以 "CTRL-W" 开头的，所以你可以用 `:h CTRL-W_*` 来查找相应的帮助（译者注：'\*'同样为占位符）（如：`:h CTRL-W_p` 查看切换到之前访问的窗口命令的解释）。如果你想找窗口处理的命令，还可以通过访问 `:h windows.txt` 并逐行向下浏览，所有窗口管理的命令都在这里了。

10. 执行类的命令以":"开头，即：`:h :s` 讲的是 ":s" 命令。

11. 在输入某个话题时按 CTRL-D，让 Vim 列出所有的近似项辅助你输入。

12. 用 `:helpgrep` 在所有的帮助页面（通常还包括了已安装的插件的帮助页面）中进行搜索。参考 `:h :helpgrep` 来了解如何使用。当你搜索了一个话题之后，所有的匹配结果都被保存到了全局位置信息表（或局部位置信息表）当中，可以通过 `:copen` 或 `:lopen` 打开。在打开的窗口中可能通过 `/` 对搜索结果进行进一步的过滤。

13. `:h helphelp` 里介绍了如何使用帮助系统。

14. 用户手册。它采用了一种对初学者更加友好的方式来展示帮助话题。用 `:h usr_toc.txt` 打开目录（你可能已经猜到这个命令的用处了）。浏览用户手册能帮助你找出某些你想了解的话题，如你可以在第 24 章看到关于“复合字符”以及“输入特殊字符”的讲解（用 `:h usr_24.txt` 可以快速打开相关章节）。

15. 高亮分组的帮助以 `hl-` 开头。如：`:h hl-WarningMsg` 说的是警告信息分组的高亮。

16. 语法高亮以`:syc-` 开头，如：`:h :syn-conceal` 讲的是 `:syn` 命令的对于隐藏字符是如何显示的。

17. 快速修复命令以 `:c` 开头，而位置列表命令以 `:l` 开头。

18. `:h BufWinLeave` 讲的是 BufWinLeave 自动命令。还有，`:h autocommand-events` （译者注：原文是 `:h autocommands-events`，但是没有该帮助）讲的是所有可用的事件。

19. 启动参数都以“-”开头，如：`:h -f` 会告诉你 Vim 中 “-f” 参数的作用。

20. 额外的特性都以“+”开头，如：`:h +conceal` 讲的是关于隐藏字符的支持。

21. 错误代码可以在帮助系统中直接查到。`:h E297` 会带你到关于这一错误的详细解释。但是有时并没有转到错误描述，而是列出了经常导出这一错误的 Vim 命令，如 `:h E128` （译者注：原文为`:h hE128`，但是并没有该帮助）会直接跳转到 `:function` 命令。

22. 关于包含的语法文件的文档的帮助话题格式是 `:h ft-*-syntax`。如：`:h ft-c-syntax` 说的就是 C 语言语法文件以及它所提供的选项。有的语法文件还会带有自动完成（`:h ft-php-omni`）或文件类型插件（`:h ft-tex-plugin`）相关的章节可以查看。

另外在每个帮助页的顶端通常会包含一个用户文档链接（更多的从从用户的角度出发来主角命令的功能和用法，不涉及那么多细节）。如：`:h pattern.txt` 里包含了 `:h 03.9` 和 `:h usr_27` 两个章节的链接。

## 获取在线帮助

如果你遇到了无法解决的问题，或者需要指引的话，可以参考 [Vim 使用](https://groups.google.com/forum/#!forum/vim_use)邮件列表。 [IRC](https://de.wikipedia.org/wiki/Internet_Relay_Chat) 也是一个很不错的资源。 [Freenode](https://freenode.net/) 上的 `#vim` 频道很庞大，并且里面有许多乐于助人的人。

如果你想给 Vim 提交 Bug 的话，可以使用 [vim_dev](https://groups.google.com/forum/#!forum/vim_dev) 邮件列表。

## 执行自动命令

你可以触发任何事件，如：`:doautocmd BufRead`。

### 用户自定义事件

对于插件而言，创建你自己的自定义事件有时非常有用。

```vim
function! Chibby()
    " A lot of stuff is happening here.
    " And at last..
    doautocmd User ChibbyExit
endfunction
```

现在你插件的用户可以在 Chibby 执行完成之后做任何他想做的事情：

```vim
autocmd User ChibbyExit call ChibbyCleanup()
```

顺便提一句，如果在使用 `:autocmd` 或 `:doautocmd` 时没有捕捉异常，那么会输出 "No matching autocommands" 信息。这也是为什么许多插件用 `silent doautocmd ...` 的原因。但是这也会有不足，那就是你不能再在 :autocmd 中使用 `echo "foo"` 了，取而代之的是你要使用 `unsilent echo "foo"` 来输出。

这就是为什么要在触发事件之前先判断事件是否存在的原因，

```vim
if exists('#User#ChibbyExit')
  doautocmd User ChibbyExit
endif
```

帮助文档：`:h User`

### 事件嵌套

默认情况下，自动命令不能嵌套！如果某个自动命令执行了一个命令，这个命令再依次触发其它的事件，这是不可能的。

例如你想在每次启动 Vim 的时候自动打开你的 vimrc 文件：

```vim
autocmd VimEnter * edit $MYVIMRC
```

当你启动 Vim 的时候，它会帮你打开你的 vimrc 文件，但是你很快会注意到这个文件没有任何的高亮，尽管平时它是正常可以高亮的。

问题在于你的非嵌套自动命令 `:edit` 不会触发“BufRead”事件，所以并不会把文件类型设置成“vim”，进而 `$VIMRUNTIME/syntax/vim.vim` 永远不会被引入。详细信息请参考：`:au BufRead *.vim`。要想完成上面所说的需求，使用下面这个命令：

```vim
autocmd VimEnter * nested edit $MYVIMRC
```

帮助文档：`:h autocmd-nested`

## 剪切板

如果你想在没有 GUI 支持的 Unix 系统中使用 Vim 的 `'clipboard'` 选项，则需要 `+clipboard` 以及可选的 `+xterm_clipboard` 两个[特性](#what-kind-of-vim-am-i-running)支持。

帮助文档：

```vim
:h 'clipboard'
:h gui-clipboard
:h gui-selections
```

另外请参考：[持续粘贴（为什么我每次都要设置 'paste' 模式](#持续粘贴为什么我每次都要设置-paste-模式)

### 剪贴板的使用（Windows, OSX）

Windows 自带了[剪贴板](<https://msdn.microsoft.com/en-us/library/windows/desktop/ms649012(v=vs.85).aspx>)，OSX 则带了一个[粘贴板](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/PasteboardGuide106/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008100-SW1)

在这两个系统中都可以用大家习惯用的 `ctrl+c / cmd+c` 复制选择的文本，然后在另外一个应用中用 `ctrl+v / cmd+v` 进行粘贴。

需要注意的是复制的文本已经被发送到了剪贴板，所以你在粘贴复制的内容之前关闭这个应用是没有任何问题的。

每次复制的时候，都会向剪贴板寄存器 `*` 中写入数据。 而在 Vim 中分别使用 `"*y` 和 `"*p` 来进行复制（yank) 和 粘贴（paste)。

如果你不想每次操作都要指定 `*` 寄存器，可以在你的 vimrc 中添加如下配置：

```vim
set clipboard=unnamed
```

通常情况下复制/删除/放入操作会往 `"` 寄存器中写入数据，而加上了上面的配置之后 `*` 寄存器也会被写入同样数据，因此简单的使用 `y` 和 `p` 就可以复制粘贴了。

我再说一遍：使用上面的选项意味着每一次的复制/粘贴，即使在同一个 Vim 窗口里，都会修改剪贴板的内容。你自己决定上面的选项是否适合。

如果你觉得输入 `y` 还是太麻烦的话，可以使用下面的设置把在可视模式下选择的内容发送到剪贴板：

```vim
set clipboard=unnamed,autoselect
set guioptions+=a
```

帮助文档：

```vim
:h clipboard-unnamed
:h autoselect
:h 'go_a'
```

### 剪贴板的使用（Linux, BSD, ...）

如果你的系统使用了 [X 图形界面](http://www.x.org/wiki)，事情会变得有一点不同。X 图形界面实现了 [X 窗口系统协议](http://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html), 这个协议在 1987 年发布的主版本 11，因此 X 也通常被称为 X11。

在 X10 版本中，[剪贴缓冲区](http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Cut_Buffers)被用来实现像 _clipboard_ 一样由 X 来复制文本，并且可以被所有的程序访问。现在这个机制在 X 中还存在，但是已经过时了，很多程序都不再使用这一机制。

近年来数据在程序之间是通过[选择](http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#Peer_to_Peer_Communication_by_Means_of_Selections)进行传递的。一共有三种选择，经常用到的有两种：PRIMARY 和 CLIPBOARD。

选择的工作工模大致是这样的：

    Program A：<ctrl+c>
    Program A：声称对 CLIPBOARD 的所有权
    Program B：<ctrl+v>
    Program B：发现CLIPBOARD的所有权被Program A持有
    Program B：从Program A请求数据
    Program A：响应这个请求并发送数据给Program B
    Program B：从Program A接收数据并插入到窗口中

| 选择      | 何时使用              | 如何粘贴               | 如何在 Vim 中访问 |
| --------- | --------------------- | ---------------------- | ----------------- |
| PRIMARY   | 选择文本              | 鼠标中键, shift+insert | `*` 寄存器        |
| CLIPBOARD | 选择文本并按 `ctrl+c` | `ctrl+v`               | `+`寄存器         |

**注意**：X 服务器并不会保存选择（不仅仅是 CLIPBOARD 选择）！因此在关闭了相应的程序后，你用 `ctrl+c` 复制的内容将丢失。

使用 `"*p` 来贴粘 PRIMARY 选择中的内容，或者使用 `"+y1G` 来将整个文件的内容复制到 CLIPBOARD 选择。

如果你需要经常访问这两个寄存器，可以考虑使用如下配置：

```vim
set clipboard^=unnamed          " * 寄存器
" 或者
set clipboard^=unnamedplus      " + 寄存器
```

（`^=` 用来将设置的值加到默认值之前，详见：`:h :set^=`）

这会使得所有复制/删除/放入操作使用 `*` 或 `+` 寄存器代替默认的未命令寄存器 `"`。之后你就可以直接使用 `y` 或 `p` 访问你的 X 选择了。

帮助文档：

```vim
:h clipboard-unnamed
:h clipboard-unnamedplus
```

## 打开文件时恢复光标位置

如果没有这个设置，每次打开文件时光标都将定位在第一行。而加入了这个设置以后，你就可以恢复到上次关闭文件时光标所在的位置了。

将下面的配置添加到你的 vimrc 文件：

```vim
autocmd BufReadPost *
    \ if line("'\"") > 1 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif
```

这是通过判断之前的光标位置是否存在（文件可能被其它程序修改而导致所记录的位置已经不存在了），如果存在的话就执行 `` g`" `` （转到你离开时的光标位置但是不更改跳转列表）。

这需要使用 viminfo 文件：`:h viminfo-`。

## 临时文件

根据选项的不同， Vim 最多会创建 4 种工作文件。

### 备份文件

你可以让 Vim 在将修改写入到文件之前先备份原文件。默认情况下， Vim 会保存一个备份文件但是当修改成功写入后会立即删除它（`:set writebackup`）。如果你想一直保留这个备份文件的话，可以使用 `:set backup`。而如果你想禁用备份功能的话，可以使用 `:set nobackup nowritebackup`。

咱们来看一下上次我在 vimrc 中改了什么：

```sh
$ diff ~/.vim/vimrc ~/.vim/files/backup/vimrc-vimbackup
390d389
< command! -bar -nargs=* -complete=help H helpgrep <args>
```

帮助文档：`:h backup`

### 交换文件

假设你有一个非常棒的科幻小说的构思。在按照故事情节已经写了好几个小时几十万字的时候..忽然停电了！而那时你才想起来你上次保存 `~/来自外太空的邪恶入侵者.txt` 是在.. 好吧，你从来没有保存过。

但是并非没有希望了！在编辑某个文件的时候， Vim 会创建一个交换文件，里面保存的是对当前文件所有未保存的修改。自己试一下，打开任意的文件，并使用 `:swapname` 获得当前的交换文件的保存路径。你也可以将 `:set noswapfile` 加入到 vimrc 中来禁用交换文件。

默认情况下，交换文件会自动保存在被编辑文件所在的目录下，文件名以 `.file.swp` 后缀结尾，每当你修改了超过 200 个字符或是在之前 4 秒内没有任何动作时更新它的内容，在你不再编辑这个文件的时候会被删除。你可以自己修改这些数字，详见：`:h 'updatecount'` 和 `:h 'updatetime'`。

而在断电时，交换文件并不会被删除。当你再次打开 `vim ~/来自外太空的邪恶入侵者.txt` 时， Vim 会提示你恢复这个文件。

帮助文档：`:h swap-file` 和 `:h usr_11`

### 撤销文件

[内容变更历史记录](#%E5%86%85%E5%AE%B9%E5%8F%98%E6%9B%B4%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95)是保存在内存中的，并且会在 Vim 退出时清空。如果你想让它持久化到磁盘中，可以设置 `:set undofile`。这会把文件 `~/foo.c` 的撤销文件保存在 `~/foo.c.un~`。

帮助文档：`:h 'undofile'` 和 `:h undo-persistence`

### viminfo 文件

备份文件、交换文件和撤销文件都是与文本状态相关的，而 viminfo 文件是用来保存在 Vim 退出时可能会丢失的其它的信息的。包括历史记录（命令历史、搜索历史、输入历史）、寄存器内容、标注、缓冲区列表、全局变量等等。

默认情况下，viminfo 被保存在 `~/.viminfo`。

帮助文档：`:h viminfo` 和 `:h 'viminfo'`

### 临时文件管理设置示例

如果你跟我一样，也喜欢把这些文件放到一个位置（如：`~/.vim/files`）的话，可以使用下面的配置：

```vim
" 如果文件夹不存在，则新建文件夹
if !isdirectory($HOME.'/.vim/files') && exists('*mkdir')
  call mkdir($HOME.'/.vim/files')
endif

" 备份文件
set backup
set backupdir   =$HOME/.vim/files/backup/
set backupext   =-vimbackup
set backupskip  =
" 交换文件
set directory   =$HOME/.vim/files/swap//
set updatecount =100
" 撤销文件
set undofile
set undodir     =$HOME/.vim/files/undo/
" viminfo 文件
set viminfo     ='100,n$HOME/.vim/files/info/viminfo
```

注意：如果你在一个多用户系统中编辑某个文件时， Vim 提示你交换文件已经存在的话，可能是因为有其他的用户此时正在编辑这个文件。而如果将交换文件放到自己的 home 目录的话，这个功能就失效了。因此服务器非常不建议将这些文件修改到 HOME 目录，避免多人同时编辑一个文件，却没有任何警告。

## 编辑远程文件

Vim 自带的 netrw 插件支持对远程文件的编辑。实际上它将远程的文件通过 scp 复制到本地的临时文件中，再用那个文件打开一个缓冲区，然后在保存时把文件再复制回远程位置。

下面的命令在你本地的 VIM 配置与 SSH 远程服务器上管理员想让你使用的配置有冲突时尤其有用：

```vim
:e scp://bram@awesome.site.com/.vimrc
```

如果你已经设置了 `~/.ssh/config`，SSH 会自动读取这里的配置：

    Host awesome
        HostName awesome.site.com
        Port 1234
        User bram

如果你的 `~/.ssh/config` 中有以上的内容，那么下面的命令就可以正常执行了：

```vim
:e scp://awesome/.vimrc
```

可以用同样的方法编辑 `~/.netrc`, 详见：`:h netrc-netrc`。

确保你已经看过了 `:h netrw-ssh-hack` 和 `:h g:netrw_ssh_cmd`。

另外一种编辑远程文件的方法是使用 [sshfs](https://wiki.archlinux.org/index.php/Sshfs)，它会用 [FUSE](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) 来挂载远程的文件系统到你本地的系统当中。

## 插件管理

[Pathogen](https://github.com/tpope/vim-pathogen)是第一个比较流行的插件管理工具。实际上它只是修改了 _runtimepath_ （`:h 'rtp'`） 来引入所有放到该目录下的文件。你需要自己克隆插件的代码仓库到那个目录。

真正的插件管理工具会在 Vim 中提供帮助你安装或更新插件的命令。以下是一些常用的插件管理工具：

- [dein](https://github.com/Shougo/dein.vim)
- [plug](https://github.com/junegunn/vim-plug)
- [vim-addon-manager](https://github.com/MarcWeber/vim-addon-manager)
- [vundle](https://github.com/VundleVim/Vundle.vim)

## 多行编辑

这是一种可以同时输入多行连续文本的技术。参考这个[示例](https://raw.githubusercontent.com/mhinz/vim-galore/master/contents/images/content-block_insert.gif)。

用 `<c-v>` 切换到可视块模式。然后向下选中几行，按 `I` 或 `A` （译者注：大写字母，即 shift+i 或 shift+a）然后开始输入你想要输入的文本。

在刚开始的时候可能会有些迷惑，因为文本只出现在了当前编辑的行，只有在当前的插入动作结束后，之前选中的其它行才会出现插入的文本。

举一个简单的例子：`<c-v>3jItext<esc>`。

如果你要编辑的行长度不同，但是你想在他们后面追加相同的内容的话，可以试一下这个：`<c-v>3j$Atext<esc>`。

有时你可能需要把光标放到当前行末尾之后，默认情况下你是不可能做到的，但是可能通过设置 `virtualedit` 选项达到目的：

```vim
set virtualedit=all
```

设置之后 `$10l` 或 `90|` 都会生效，即使超过了行尾的长度。

详见 `:h blockwise-examples`。在开始的时候可能会觉得有些复杂，但是它很快就会成为你的第二天性的。

如果你想探索更有趣的事情，可以看看[多光标](https://github.com/terryma/vim-multiple-cursors)

## 使用外部程序和过滤器

免责声明：Vim 是单线程的，因此在 Vim 中以前端进程执行其它的程序时会阻止其它的一切。当然你可以使用 Vim 程序接口，如 Lua，并且使用它的多线程支持，但是在那期间， Vim 的处理还是被阻止了。Neovim 添加了任务 API 解决了此问题。

（据说 Bram 正在考虑在 Vim 中也添加任务控制。如果你使用了较新版本的的 Vim ，可以看一下 `:helpgrep startjob`。）

使用 `:!` 启动一个新任务。如果你想列出当前工作目录下的所有文件，可以使用 `:!ls`。 用 `|` 来将结果通过管道重定向，如：`:!ls -l | sort | tail -n5`。

没有使用范围时（译者注：范围就是 `:` 和 `!` 之间的内容，`.` 表示当前行，`+4` 表示向下偏移 4 行，`$` 表示最末行等，多行时用 `,` 将它们分开，如 `.,$` 表示从当前行到末行），`:!` 会显示在一个可滚动的窗口中（译者注：在 GVim 和在终端里运行的结果稍有不同）。相反的，如果指定了范围，这些行会被[过滤](<https://en.wikipedia.org/wiki/Filter_(software)>)。这意味着它们会通过管道被重定向到过滤程序的 [stdin](https://en.wikipedia.org/wiki/Standard_streams#Standard_input_.28stdin.29)，在处理后再通过过滤程序的 [stdout](https://en.wikipedia.org/wiki/Standard_streams#Standard_output_.28stdout.29) 输出，用输出结果替换范围内的文本。例如：为接下来的 5 行文本添加行号，可以使用：

```vim
:.,+4!nl -ba -w1 -s' '
```

由于手动添加范围很麻烦， Vim 提供了一些辅助方法以方便的添加范围。如果需要经常带着范围的话，你可以在可见模式中先选择，然后再按 `:` （译者注：选中后再按 `!` 更方便）。还可以使用 `!` 来取用一个 motion 的范围，如 `!ipsort` （译者注：原文为 `!ip!sort` ，但经过实验发现该命令执行报错，可能是因为 Vim 版本的原因造成的，新版本使用 `ip` 选择当前段落后自动在命令后添加了 `!` ，按照作者的写法来看，可能之前的版本没有自动添加 `!` ）可以将当前段落的所有行按字母表顺序进行排序。

一个使用过滤器比较好的案例是[Go 语言](https://golang.org/)。它的缩进语法非常个性，甚至还专门提供了一个名为 `gofmt` 的过滤器来对 Go 语言的源文件进行正确的缩进。Go 语言的插件通常会提供一个名为 `:Fmt` 的函数，这个函数就是执行了 `:%!gofmt` 来对整个文件进行缩进。

人们常用 `:r !prog` 将 prog 程序的插入放到当前行的下面，这对于脚本来说是很不错的选择，但是在使用的过程中我发现 `!!ls` 更加方便，它会用输出结果替换当前行的内容。（译者注：前面命令中的 `prog` 只是个占位符，在实际使用中需要替换成其它的程序，如 `:r !ls`，这就与后面的 `!!ls` 相对应了，两者唯一的不同是第一个命令不会覆盖当前行内容，但是第二个命令会）

帮助文档：

```vim
:h filter
:h :read!
```

## Cscope

[Cscope](http://cscope.sourceforge.net/) 的功能比 [ctags](http://ctags.sourceforge.net/) 要完善，但是只支持 C（通过设置 cscope.files 后同样支持 C++以及 Java）。

鉴于 Tag 文件只是知道某个符号是在哪里定义的，cscope 的数据库里的数据信息就多的多了：

- 符号是在哪里定义的？
- 符号是在哪里被使用的？
- 这个全局符号定义了什么？
- 这个变量是在哪里被赋值的？
- 这个函数在源文件的哪个位置？
- 哪些函数调用了这个函数？
- 这个函数调用了哪些函数？
- "out of space"消息是从哪来的？
- 在目录结构中当前的源文件在哪个位置？
- 哪些文件引用了这个头文件？

### 1. 构建数据库

在你项目的根目录执行下面的命令：

```sh
$ cscope -bqR
```

这条命令会在当前目录下创建三个文件：`cscope{,.in,.po}.out` 。把它们想象成你的数据库。

不幸的时 `cscope` 默认只分析 `*.[c|h|y|l]` 文件。如果你想在 Java 项目中使用 cscope ，需要这样做：

```sh
$ find . -name "*.java" > cscope.files
$ cscope -bq
```

### 2. 添加数据库

打开你新创建的数据库连接：

```vim
:cs add cscope.out
```

检查连接已经创建成功：

```vim
:cs show
```

（当然你可以添加多个连接。）

### 3. 查询数据库

```vim
:cs find <kind> <query>
```

如：`:cs find d foo` 会列出 `foo(...)` 调用的所有函数。

| Kind | 说明                                   |
| ---- | -------------------------------------- |
| s    | **s**ymbol：查找使用该符号的引用       |
| g    | **g**lobal：查找该全局符号的定义       |
| c    | **c**alls：查找调用当前方法的位置      |
| t    | **t**ext：查找出现该文本的位置         |
| e    | **e**grep：使用 egrep 搜索当前单词     |
| f    | **f**ile：打开文件名                   |
| i    | **i**ncludes：查询引入了当前文件的文件 |
| d    | **d**epends：查找当前方法调用的方法    |

推荐一些比较方便的映射，如：

```vim
nnoremap <buffer> <leader>cs :cscope find s  <c-r>=expand('<cword>')<cr><cr>
nnoremap <buffer> <leader>cg :cscope find g  <c-r>=expand('<cword>')<cr><cr>
nnoremap <buffer> <leader>cc :cscope find c  <c-r>=expand('<cword>')<cr><cr>
nnoremap <buffer> <leader>ct :cscope find t  <c-r>=expand('<cword>')<cr><cr>
nnoremap <buffer> <leader>ce :cscope find e  <c-r>=expand('<cword>')<cr><cr>
nnoremap <buffer> <leader>cf :cscope find f  <c-r>=expand('<cfile>')<cr><cr>
nnoremap <buffer> <leader>ci :cscope find i ^<c-r>=expand('<cfile>')<cr>$<cr>
nnoremap <buffer> <leader>cd :cscope find d  <c-r>=expand('<cword>')<cr><cr>
```

所以 `:tag` （或 `<c-]>`）跳转到标签定义的文件，而 `:cstag` 可以达到同样的目的，同时还会打开 cscope 的数据库连接。`'cscopetag'` 选项使得 `:tag` 命令自动的像 `:cstag` 一样工作。这在你已经使用了基于标签的映射时会非常方便。

帮助文档：`:h cscope`

## MatchIt

由于 Vim 是用 C 语言编写的，因此许多功能都假设使用类似 C 语言的语法。默认情况下，如果你的光标在 `{` 或 `#endif` , 就可以使用 `%` 跳转到与之匹配的 `}` 或 `#ifdef`。

Vim 自带了一个名为 matchit.vim 的插件，但是默认没有启用。启用后可以用 `%` 在 HTML 相匹配的标签或 VimL 的 if/else/endif 块之间进行跳转，它还带来了一些新的命令。

### 在 Vim 8 中安装

```vim
" vimrc
packadd! matchit
```

### 在 Vim 7 或者更早的版本中安装

```vim
"vimrc
runtime macros/matchit.vim
```

由于 matchit 的文档很全面，我建议安装以后执行一次下面的命令：

```vim
:!mkdir -p ~/.vim/doc
:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/doc
:helptags ~/.vim/doc
```

### 简短的介绍

至此这个插件已经可以使用了。 参考 `:h matchit-intro` 来获得支持的命令以及 `:h matchit-languages` 来获得支持的语言。

你可以很方便的定义自己的匹配对，如：

```vim
autocmd FileType python let b:match_words = '\<if\>:\<elif\>:\<else\>'
```

之后你就可以在任何的 Python 文件中使用 `%` （向前）或 `g%` （向后）在这三个片断之间跳转了。

帮助文档：

```vim
:h matchit-install
:h matchit
:h b:match_words
```

## 技巧

## 跳至选择的区域另一端

在使用 `v` 或者 `V` 选择某段文字后，可以用 `o` 或者 `O` 按键跳至选择区域的开头或者结尾。

```
:h v_o
:h v_O
```

## 聪明地使用 n 和 N

<kbd>n</kbd> 与 <kbd>N</kbd> 的实际跳转方向取决于使用 `/` 还是 `?` 来执行搜索，其中 `/` 是向后搜索，`?` 是向前搜索。一开始我（原作者）觉得这里很难理解。

如果你希望 <kbd>n</kbd> 始终为向后搜索，<kbd>N</kbd> 始终为向前搜索，那么只需要这样设置：

```vim
nnoremap <expr> n  'Nn'[v:searchforward]
nnoremap <expr> N  'nN'[v:searchforward]
```

## 聪明地使用命令行历史

我（原作者）习惯用 <kbd>Ctrl</kbd> + <kbd>p</kbd> 和 <kbd>Ctrl</kbd> + <kbd>n</kbd> 来跳转到上一个/下一个条目。其实这个操作也可以用在命令行中，快速调出之前执行过的命令。

不仅如此，你会发现 <kbd>上</kbd> 和 <kbd>下</kbd> 其实更智能。如果命令行中已经存在了一些文字，我们可以通过按方向键来匹配已经存在的内容。比如，命令行中现在是 `:echo`，这时候我们按 <kbd>上</kbd>，就会帮我们补全成 `:echo "Vim rocks!"`（前提是，之前输入过这段命令）。

当然，Vim 用户都不愿意去按方向键，事实上我们也不需要去按，只需要设置这样的映射：

```vim
cnoremap <c-n> <down>
cnoremap <c-p> <up>
```

这个功能，我（原作者）每天都要用很多次。

## 智能 Ctrl-l

<kbd>Ctrl</kbd> + <kbd>l</kbd> 的默认功能是清空并「重新绘制」当前的屏幕，就和 `:redraw!` 的功能一样。下面的这个映射就是执行重新绘制，并且取消通过 `/` 和 `?` 匹配字符的高亮，而且还可以修复代码高亮问题（有时候，由于多个代码高亮的脚本重叠，或者规则过于复杂，Vim 的代码高亮显示会出现问题）。不仅如此，还可以刷新「比较模式」（请参阅 `:help diff-mode`）的代码高亮：

```vim
nnoremap <leader>l :nohlsearch<cr>:diffupdate<cr>:syntax sync fromstart<cr><c-l>
```

## 禁用错误报警声音和图标

```vim
set noerrorbells
set novisualbell
set t_vb=
```

请参阅 [Vim Wiki: Disable beeping](http://vim.wikia.com/wiki/Disable_beeping)。

## 快速移动当前行

有时，我（原作者）想要快速把当前行上移或下移一行，只需要这样设置映射：

```vim
nnoremap [e  :<c-u>execute 'move -1-'. v:count1<cr>
nnoremap ]e  :<c-u>execute 'move +'. v:count1<cr>
```

这个映射，同样可以搭配数字使用，比如连续按下 <kbd>2</kbd> <kbd>]</kbd> <kbd>e</kbd> 就可以把当前行向下移动两行。

## 快速添加空行

```vim
nnoremap [<space>  :<c-u>put! =repeat(nr2char(10), v:count1)<cr>'[
nnoremap ]<space>  :<c-u>put =repeat(nr2char(10), v:count1)<cr>
```

设置之后，连续按下 <kbd>5</kbd> <kbd>\[</kbd> <kbd>空格</kbd> 在当前行上方插入 5 个空行。

### 运行时检测

需要的特性：+profile

Vim 提供了一个内置的运行时检查功能，能够找出运行慢的代码。

`:profile` 命令后面跟着子命令来确定要查看什么。

如果你想查看所有的：

```Vim
:profile start /tmp/profile.log
:profile file *
:profile func *
<do something in Vim>
<quit Vim>
```

Vim 不断地在内存中检查信息，只在退出的时候输出出来。（Neovim 已经解决了这个问题用 `:profile dump` 命令）

看一下 `/tmp/profile.log` 文件，检查时运行的所有代码都会被显示出来，包括每一行代码运行的频率和时间。

大多数代码都是用户不熟悉的插件代码，如果你是在解决一个确切的问题，
直接跳到这个日志文件的末尾，那里有 `FUNCTIONS SORTED ON TOTAL TIME` 和 `FUNCTIONS SORTED ON SELF TIME` 两个部分，如果某个 function 运行时间过长一眼就可以看到。

### 查看启动时间

感觉 Vim 启动的慢？到了研究几个数字的时候了：

```vim
vim --startuptime /tmp/startup.log +q && vim /tmp/startup.log
```

第一栏是最重要的因为它显示了**绝对运行时间**，如果在前后两行之间时间差有很大的跳跃，那么是第二个文件太大或者含有需要检查的错误的 VimL 代码。

## NUL 符用新行表示

文件中的 NUL 符 （`\0`），在内存中被以新行（`\n`）保存，在缓存空间中显示为 `^@`。

更多信息请参看 `man 7 ascii` 和 `:h NL-used-for-Nul` 。

## 快速编辑自定义宏

这个功能真的很实用！下面的映射，就是在一个新的命令行窗口中读取某一个寄存器（默认为 `*`）。当你设置完成后，只需要按下 <kbd>回车</kbd> 即可让它生效。

在录制宏的时候，我经常用这个来更改拼写错误。

```vim
nnoremap <leader>m  :<c-u><c-r><c-r>='let @'. v:register .' = '. string(getreg(v:register))<cr><c-f><left>
```

只需要连续按下 <kbd>leader</kbd> <kbd>m</kbd> 或者 <kbd>"</kbd> <kbd>leader</kbd> <kbd>m</kbd> 就可以调用了。

请注意，这里之所以要写成 `<c-r><c-r>` 是为了确保 `<c-r>` 执行了。请参阅 `:h c_^R^R`

## 快速跳转到源(头)文件

这个技巧可以用在多种文件类型中。当你从源文件或者头文件中切换到其他文件的时候，这个技巧可以设置「文件标记」（请参阅 `:h marks`），然后你就可以通过连续按下 <kbd>'</kbd> <kbd>C</kbd> 或者 <kbd>'</kbd> <kbd>H</kbd> 快速跳转回去（请参阅 `:h 'A`）。

```vim
autocmd BufLeave *.{c,cpp} mark C
autocmd BufLeave *.h       mark H
```

**注意**：由于这个标记是设置在 viminfo 文件中，因此请先确认 `:set viminfo?` 中包含了 `:h viminfo-'`。

## 在 GUI 中快速改变字体大小

印象中，我（原作者）记得一下代码是来自 tpope's 的配置文件：

```vim
command! Bigger  :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)+1', '')
command! Smaller :let &guifont = substitute(&guifont, '\d\+$', '\=submatch(0)-1', '')
```

## 根据模式改变光标类型

我（原作者）习惯在普通模式下用块状光标，在插入模式下用条状光标（形状类似英文 "I" 的样子），然后在替换模式中使用下划线形状的光标。

```vim
if empty($TMUX)
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
  let &t_SR = "\<Esc>]50;CursorShape=2\x7"
else
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
  let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
endif
```

原理很简单，就是让 Vim 在进入和离开插入模式的时候，输出一些序列，请参考 [escape sequence](https://en.wikipedia.org/wiki/Escape_sequence)。Vim 与终端之间的中间层，比如 [tmux](https://tmux.github.io) 会处理并执行上面的代码。

但上面这个还是有一个缺点的。终端环境的内部原理不尽相同，对于序列的处理方式也稍有不同。因此，上面的代码可能无法在你的环境中运行。甚至，你的运行环境也有可能不支持其他光标形状，请参阅你的 Vim 运行环境的文档。

好消息是，上面这个代码，可以在 iTerm2 中完美运行。

## 防止水平滑动的时候失去选择

如果你选中了一行或多行，那么你可以用 <kbd>&lt;</kbd> 或 <kbd>></kbd> 来调整他们的缩进。但在调整之后就不会保持选中状态了。

你可以连续按下 <kbd>g</kbd> <kbd>v</kbd> 来重新选中他们，请参考 `:h gv`。因此，你可以这样来配置映射：

```vim
xnoremap <  <gv
xnoremap >  >gv
```

设置好之后，在可视模式中使用 `>>>>>` 就不会再出现上面提到的问题了。

## 选择当前行至结尾，排除换行符

在 Vim 里，我们可以同过 `v$` 选择当前行至结尾，但此时会把最后一个换行符也选中，通常需要按额外的 `h` 来取消最后选中最后一个换行符号。
Vim 提供了一个 `g_` 快捷键，可以移动光标至最后一个非空字符。因此，为达到次效果，可以使用 `vg_`。当然，如果觉得按三个键比较麻烦，
可以添加一个映射：

```vim
nnoremap L g_
```

这样就可以通过 `vL` 达到一样的效果了。

## 重新载入保存文件

通过[自动命令](#自动命令)，你可以在保存文件的同时触发一些其他功能。比如，如果这个文件是一个配置文件，那么就重新载入；或者你还可以对这个文件进行代码风格检查。

```vim
autocmd BufWritePost $MYVIMRC source $MYVIMRC
autocmd BufWritePost ~/.Xdefaults call system('xrdb ~/.Xdefaults')
```

## 更加智能的当前行高亮

我（原作者）很喜欢「当前行高亮」（请参阅 `:h cursorline`）这个功能，但我只想让这个效果出现在当前窗口，而且在插入模式中关闭这个效果：

```vim
autocmd InsertLeave,WinEnter * set cursorline
autocmd InsertEnter,WinLeave * set nocursorline
```

## 更快的关键字补全

关键字补全（`<c-n>` 或 `<c-p>`）功能的工作方式是，无论 `'complete'` 设置中有什么，它都会尝试着去补全。这样，一些我们用不到的标签也会出现在补全列表中。而且，它会扫描很多文件，有时候运行起来非常慢。如果你不需要这些，那么完全可以像这样把它们禁用掉：

```vim
set complete-=i   " disable scanning included files
set complete-=t   " disable searching tags
```

## 改变颜色主题的默认外观

如果你想让状态栏在颜色主题更改后依然保持灰色，那么只需要这样设置：

```vim
autocmd ColorScheme * highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE
```

同理，如果你想让某一个颜色主题（比如 "lucius"）的状态栏为灰色（请使用 `:echo color_name` 来查看当前可用的所有颜色主题）：

```vim
autocmd ColorScheme lucius highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE
```

## 命令

下面的命令都比较有用，最好了解一下。用 `:h :<command name>` 来了解更多关于它们的信息，如：`:h :global`。

### :global 和 :vglobal - 在所有匹配行执行命令

在所有符合条件的行上执行某个命令。如： `:global /regexp/ print` 会在所有包含 "regexp" 的行上执行 `print` 命令（译者注：regexp 有正则表达式的意思，该命令同样支持正则表达式，在所有符合正则表达式的行上执行指定的命令）。

趣闻：你们可能都知道老牌的 grep 命令，一个由 Ken Thompson 编写的过滤程序。它是干什么用的呢？它会输出所有匹配指定正则表达式的行！现在猜一下 `:global /regexp/ print` 的简写形式是什么？没错！就是 `:g/re/p` 。 Ken Thompsom 在编写 grep 程序的时候是受了 vi `:global` 的启发。（译者注： <https://robots.thoughtbot.com/how-grep-got-its-name）>

既然它的名字是 `:global`，理应仅作用在所有行上，但是它也是可以带范围限制的。假设你想使用 `:delete` 命令删除从当前行到下一个空行（由正则表达式 `^$` 匹配）范围内所有包含 "foo" 的行：

```vim
:,/^$/g/foo/d
```

如果要在所有 _不_ 匹配的行上执行命令的话，可以使用 `:global!` 或是它的别名 `:vglobal` （ V 代表的是 inVerse ）。

### :normal 和 :execute - 脚本梦之队

这两个命令经常在 Vim 的脚本里使用。

借助于 `:normal` 可以在命令行里进行普通模式的映射。如：`:normal! 4j` 会令光标下移 4 行（由于加了"!"，所以不会使用自定义的映射 "j"）。

需要注意的是 `:normal` 同样可以使用范围数（译者注：参考 `:h range` 和 `:h :normal-range` 了解更多），故 `:%norm! Iabc` 会在所有行前加上 "abc"。

借助于 `:execute` 可以将命令和表达式混合在一起使用。假设你正在编辑一个 C 语言的文件，想切换到它的头文件：

```vim
:execute 'edit' fnamemodify(expand('%'), ':r') . '.h'
```

（译者注：头文件为与与源文件同名但是扩展名为 `.h` 的文件。上面的命令中 expand 获得当前文件的名称，fnamemodify 获取不带扩展名的文件名，再连上 '.h' 就是头文件的文件名了，最后在使用 edit 命令打开这个头文件。）

这两个命令经常一起使用。假设你想让光标下移 n 行：

```vim
:let n = 4
:execute 'normal!' n . 'j'
```

### 重定向消息

许多命令都会输出消息，`:redir` 用来重定向这些消息。它可以将消息输出到文件、[寄存器](#寄存器)或是某个变量中。

```vim
" 将消息重定向到变量 `neatvar` 中
:redir => neatvar
" 打印所有寄存器的内容
:reg
" 结束重定向
:redir END
" 输出变量
:echo neatvar
" 恶搞一下，我们把它输出到当前缓冲区
:put =neatvar
```

再 Vim 8 中，可以更简单的方式即位：

    :put =execute('reg')

（译者注：原文最后一条命令是 `:put =nicevar` 但是实际会报变量未定义的错误）
（实测 neovim/vim8 下没问题）

帮助文档：`:h :redir`

## 调试

## 常规建议

如果你遇到了奇怪的行为，尝试用这个命令重现它：

    vim -u NONE -N

这样会在不引用 vimrc（默认设置）的情况下重启 vim，并且在 **nocompatible** 模式下（使用 vim 默认设置而不是 vi 的）。（搜索 `:h --noplugin` 命令了解更多启动加载方式）

如果仍旧能够出现该错误，那么这极有可能是 vim 本身的 bug，请给 [vim_dev]("https://groups.google.com/forum/#!forum/vim_dev") 发送邮件反馈错误，多数情况下问题不会立刻解决，你还需要进一步研究

许多插件经常会提供新的（默认的/自动的）操作。如果在保存的时候发生了，那么请用 `:verb au BufWritePost` 命令检查潜在的问题

如果你在使用一个插件管理工具，将插件行注释调，再进行调试。

问题还没有解决？如果不是插件的问题，那么肯定是你的自定义的设置的问题，可能是你的 options 或 autocmd 等等。

到了一行行代码检查的时候了，不断地排除缩小检查范围知道你找出错误，根据二分法的原理你不会花费太多时间的。

在实践过程中，可能就是这样，把 `:finish` 放在你的 **vimrc** 文件中间，Vim 会跳过它之后的设置。如果问题还在，那么问题就出在`:finish`之前的设置中，再把`:finish`放到前一部分设置的中间位置。否则问题就出现在它后面的半部分设置，那么就把`:finish`放到后半部分的中间位置。不断的重复即可找到。

## 调整日志等级

Vim 现在正在使用的另一个比较有用的方法是增加 debug 信息输出详细等级。现在 Vim 支持 9 个等级，可以用`:h 'verbose'`命令查看。

```vim
:e /tmp/foo
:set verbose=2
:w
:set verbose=0
```

这可以显示出所有引用的文件、没有变化的文件或者各种各样的作用于保存的插件。

如果你只是想用简单的命令来提高等级，也是用 `:verbose` ，放在其他命令之前，通过计数来指明等级，默认是 1.

```vim
:verb set verbose
"  verbose=1
:10verb set verbose
"  verbose=10
```

通常用等级 1 来显示上次从哪里设置的选项

```vim
:verb set ai?
"      Last set from ~/.vim/vimrc
```

一般等级越高输出信息月详细。但是不要害怕，亦可以把输出导入到文件中：

```vim
:set verbosefile=/tmp/foo | 15verbose echo "foo" | vsplit /tmp/foo
```

你可以一开始的时候就打开 verbosity，用 `-V` 选项，它默认设置调试等级为 10。 例如：`vim -V5`

## 查看启动日志

## 查看运行时日志

## Vim 脚本调试

如果你以前使用过命令行调试器的话，对于`:debug`命令你很快就会感到熟悉。

只需要在任何其他命令之前加上`:debug`就会让你进入调试模式。也就是，被调试的 Vim 脚本会在第一行停止运行，同时该行会被显示出来。

想了解可用的 6 个调试命令，可以查阅`:h >cont`和阅读下面内容。需要指出的是，类似 gdb 和其他相似调试器，调试命令可以使用它们的简短形式：`c`、 `q`、`n`、`s`、 `i`和 `f`。

除了上面的之外，你还可以自由地使用任何 Vim 的命令。比如，`:echo myvar`，该命令会在当前的脚本代码位置和上下文上被执行。

只需要简单使用`:debug 1`，你就获得了[REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)调试特性。

当然，调试模式下是可以定义断点的，不然的话每一行都去单步调试就会十分痛苦。（断点之所以被叫做断点，是因为运行到它们的时候，运行就会停止下来。因此，你可以利用断点跳过自己不感兴趣的代码区域）。请查阅`:h :breakadd`、 `:h :breakdel`和 `:h :breaklist`获取更多细节。

假设你需要知道你每次在保存一个文件的时候有哪些代码在运行：

```vim
:au BufWritePost
" signify  BufWritePost
"     *         call sy#start()
:breakadd func *start
:w
" Breakpoint in "sy#start" line 1
" Entering Debug mode.  Type "cont" to continue.
" function sy#start
" line 1: if g:signify_locked
>s
" function sy#start
" line 3: endif
>
" function sy#start
" line 5: let sy_path = resolve(expand('%:p'))
>q
:breakdel *
```

正如你所见，使用`<cr>`命令会重复之前的调试命令，也就是在该例子中的`s`命令。

`:debug`命令可以和[verbose](#verbosity)选项一起使用。

## 语法文件调试

语法文件由于包含错误的或者复制的正则表达式，常常会使得 Vim 的运行较慢。如果 Vim 在编译的时候包含了`+profile` [feature](#what-kind-of-vim-am-i-running)特性，就可以给用户提供一个超级好用的`:syntime`命令。

```vim
:syntime on
" 多次敲击<c-l>来重绘窗口，这样的话就会使得相应的语法规则被重新应用一次
:syntime off
:syntime report
```

输出结果包含了很多的度量维度。比如，你可以通过结果知道哪些正则表达式耗时太久需要被优化；哪些正则表达式一直在别使用但重来没有一次成功匹配。

请查阅`:h :syntime`。

## 杂项

## 附加资源

| 资源名称                                                                                                                                                                     | 简介                                  |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- |
| [七个高效的文本编辑习惯](http://www.moolenaar.net/habits.html)                                                                                                               | 作者：Bram Moolenaar（即 Vim 的作者） |
| [七个高效的文本编辑习惯 2.0（PDF 版）](http://www.moolenaar.net/habits_2007.pdf)                                                                                             | 同上                                  |
| [IBM DeveloperWorks: 使用脚本编写 Vim 编辑器](http://www.ibm.com/developerworks/views/linux/libraryview.jsp?sort_order=asc&sort_by=Title&search_by=scripting+the+vim+editor) | Vim 脚本编写五辑                      |
| [《漫漫 Vim 路》](http://learnvimscriptthehardway.stevelosh.com)                                                                                                             | 使用魔抓定制 Vim 插件                 |
| [《 Vim 实践 (第 2 版)》](http://www.amazon.com/Practical-Vim-Edit-Speed-Thought/dp/1680501275/)                                                                             | 轻取 Vim 最佳书籍                     |
| [Vimcasts.org](http://vimcasts.org/episodes/archive)                                                                                                                         | Vim 录屏演示                          |
| [为什么是个脚本都用 vi？](http://www.viemu.com/a-why-vi-vim.html)                                                                                                            | 常见误区释疑                          |
| [你不爱 vi，所以你不懂 Vim ](http://stackoverflow.com/a/1220118)                                                                                                             | 简明,扼要,准确的干货                  |

## Vim 配置集合

目前，网上有很多流行 Vim 配置集合，对于 Vim 配置集合，个人认为有利有弊。
对于维护的比较好的配置，比如 [SpaceVim](http://spacevim.org/cn/) 还是值得尝试的，可以节省很多自行配置的时间。
当然，网上还有很多其他很流行的配置，比如：

- [k-vim](https://github.com/wklken/k-vim)
- [amix's vimrc](https://github.com/amix/vimrc)
- [janus](https://github.com/carlhuda/janus)

## 常见问题

### 编辑小文件时很慢

有两个因素对性能影响非常大：

1. 过于复杂的 **正则表达式** 。尤其是 Ruby 的语法文件，以前会造成性能下降。（见[调试语法文件](#debugging-syntax-files)）

2. **屏幕重绘** 。有一些功能会强制重绘所有行。

| 典型肇事者               | 原因                                                               | 解决方案                                                                                                       |
| ------------------------ | ------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------- |
| `:set cursorline`        | 会导致所有行重绘                                                   | `:set nocursorline`                                                                                            |
| `:set cursorcolumn`      | 会导致所有行重绘                                                   | `:set nocursorcolumn`                                                                                          |
| `:set relativenumber`    | 会导致所有行重绘                                                   | `:set norelativenumber`                                                                                        |
| `:set foldmethod=syntax` | 如果语法文件已经很慢了，这只会变得更慢                             | `:set foldmethod=manual`，`:set foldmethod=marker` 或者使用[快速折叠](https://github.com/Konfekt/FastFold)插件 |
| `:set synmaxcol=3000`    | 由于内部表示法，Vim 处理比较长的行时会有问题。让它高亮到 3000 列…… | `:set synmaxcol=200`                                                                                           |
| matchparen.vim           | Vim 默认加载的插件，用正则表达式查找配对的括号                     | 禁用插件：`:h matchparen`                                                                                      |

**注意**：只有在你真正遇到性能问题的时候才需要做上面的调整。在大多数情况下使用上面提到的选项是完全没有问题的。

### 编辑大文件的时候很慢

Vim 处理大文件最大的问题就是它会一次性读取整个文件。这么做是由于缓冲区的内部机理导致的（在 [vim_dev](https://groups.google.com/forum/#!topic/vim_dev/oY3i8rqYGD4/discussion) 中讨论）。

如果只是想查看的话，`tail hugefile | vim -` 是一个不错的选择。

如果你能接受没有语法高亮，并且禁用所有插件和设置的话，使用：

```sh
$ vim -u NONE -N
```

这将会使得跳转变快很多，尤其是省去了基于很耗费资源的正则表达式的语法高亮。你还可以告诉 Vim 不要使用交换文件和 viminfo 文件，以避免由于写这些文件而造成的延时：

```sh
$ vim -n -u NONE -i NONE -N
```

简而言之，尽量避免使用 Vim 写过大的文件。

### 持续粘贴（为什么我每次都要设置 'paste' 模式）

持续粘贴模式让终端模拟器可以区分输入内容与粘贴内容。

你有没有遇到过往 Vim 里粘贴代码之后被搞的一团糟？

这在你使用 `cmd+v`、`shirt-insert`、`middle-click` 等进行粘贴的时候才会发生。
因为那样的话你只是向终端模拟器扔了一大堆的文本。
Vim 并不知道你刚刚是粘贴的文本，它以为你在飞速的输入。
于是它想缩进这些行但是失败了。

这明显不是个问题，如果你用 Vim 的寄存器粘贴，如：`"+p` ，这时 Vim 就知道了你在粘贴，就不会导致格式错乱了。

使用 `:set paste` 就可以解决这个问题正常进行粘贴。见 `:h 'paste'` 和 `:h 'pastetoggle'` 获取更多信息。

如果你受够了每次都要设置 `'paste'` 的话，看看这个能帮你自动设置的插件：[bracketed-paste](https://github.com/ConradIrwin/vim-bracketed-paste)。

[点此](http://cirw.in/blog/bracketed-paste)查看该作者对于这个插件的更多描述。

Neovim 尝试把这些变得更顺畅，如果终端支持的话，它会自动开启持续粘贴模式，无须再手动进行切换。

### 在终端中按 ESC 后有延时

如果你经常使用命令行，那么肯定要接触 _终端模拟器_ ，如 xterm、gnome-terminal、iTerm2 等等（与实际的[终端](https://en.wikipedia.org/wiki/Computer_terminal)不同）。

终端模拟器与他们的祖辈一样，使用 [转义序列](https://zh.wikipedia.org/wiki/%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97) （也叫 _控制序列_ ）来控制光标移动、改变文本颜色等。转义序列就是以转义字符开头的 ASCII 字符串（用[脱字符表示法](https://zh.wikipedia.org/wiki/%E8%84%B1%E5%AD%97%E7%AC%A6%E8%A1%A8%E7%A4%BA%E6%B3%95)表示成 `^[` ）。当遇到这样的字符串后，终端模拟器会从[终端信息](https://en.wikipedia.org/wiki/Terminfo)数据库中查找对应的动作。

为了使用问题更加清晰，我会先来解释一下什么是映射超时。在映射存在歧义的时候就会产生映射超时：

```vim
:nnoremap ,a :echo 'foo'<cr>
:nnoremap ,ab :echo 'bar'<cr>
```

上面的例子中两个映射都能正常工作，但是当输入 `,a` 之后，Vim 会延时 1 秒，因为它要确认用户是否还要输入那个 `b`。

转义序列会产生同样的问题：

- `<esc>` 作为返回普通模式或取消某个动作的按键而被大量使用
- 光标键使用转义序列进行的编码
- Vim 期望 <kbd>Alt</kbd> （也叫作 _Mate Key_ ）会发送一个正确的 8-bit 编码的高位，但是许多终端模拟器并不支持这个（也可能默认没有启用），而只是发送一个转义序列作为代替。

你可以这样测试上面所提到的事情： `vim -u NONE -N` 然后输入 `i<c-v><left>` ，你会看到一个以 `^[` 开头的字符串，表明这是一个转义序列，`^[` 就是转义字符。

简而言之，Vim 在区分录入的 `<esc>` 和转义序列的时候需要一定的时间。

默认情况下，Vim 用 `:set timeout timeoutlen=1000`，就是说它会用 1 秒的时间来区分有歧义的映射 _以及_ 按键编码。这对于映射来说是一个比较合理的值，但是你可以自行定义按键延时的长短，这是解决该问题最根本的办法：

```vim
set timeout           " for mappings
set timeoutlen=1000   " default value
set ttimeout          " for key codes
set ttimeoutlen=10    " unnoticeable small value
```

在 `:h ttimeout` 里你可以找到一个关于这些选项之间关系的小表格。

而如果你在 tmux 中使用 Vim 的话，别忘了把下面的配置加入到你的 `~/.tmux.conf`文件中：

    set -sg escape-time 0

### 无法重复函数中执行的搜索

- 在命令中的搜索（`/`、`:substitute` 等）内容会改变“上次使用的搜索内容”。（它保存在`/`寄存器中，用 `:echo @/` 可以输出它里面的内容）
- 简单的文本变化可以通过 `.` 重做。（它保存在 `.` 寄存器，用 `:echo @.` 可以输出它的内容）

而在你在函数中进行这些操作的时候，一切就会变得不同。因此你不能用 N/n 查找某个函数刚刚查找的内容，也不能重做函数中对文本的修改。

帮助文档：`:h function-search-undo`。

## 进阶阅读

- [Vim 插件开发指南](https://github.com/wsdjeg/vim-plugin-dev-guide)
- [常用插件列表](PLUGINS.md)

## 加入我们

可以协助我们核对翻译，或者从[章节列表](CONTRIBUTING.md)中认领章节进行翻译。

## 参考资料

- [Nifty Little Nvim Techniques to Make My Life Easier -- Series 1](https://jdhao.github.io/2019/03/28/nifty_nvim_techniques_s1/)


## 开篇词｜我们为什么要学 Vim？

我特别喜欢 Larry Wall（拉里 · 沃尔）所说的程序员的三大美德：懒惰，急切，傲慢（laziness, impatience, hubris)。正是这些美德，驱动我们不断地追求效率和极致，而 Vim 就恰恰是这样一个效率利器。我想通过接下来的课程，和你一起享受 Vim 带来的技术乐趣。


### Vim 的“前世今生”
说到 Vim，就不能不谈一下 vi；要说 vi，那跟 Unix 就有着千丝万缕的联系。万物起源总有那么点故事，我们这个课程的主题也不例外。这个故事可以讲上很长时间，不过，今天不是故事会时间，我只会花几分钟给你快速梳理一下这段历史，带你了解 Vim 的“前世”，也就能更好地理解它的“今生”。

故事的开头是在 1975 年秋天，Unix 诞生之后的第六年。Ken Thompson（肯 · 汤普逊）来到了加利福尼亚大学伯克利分校，开始了为期一年的访问教授生活。当然，他也带上了最新版本的 Unix 的补丁。根据传说，由于贝尔实验室律师们的阻挠，他不能直接把补丁给其他人，而只能把装有补丁的磁带“丢”在某个地方，然后由别人“正好”捡到……Unix 就以这种“地下”的传播方式流传开了。同年，年轻的 Bill Joy（比尔 · 乔伊）也进入了加利福尼亚大学伯克利分校，学习电子工程和计算机科学。他立刻就迷上了 Unix。在后面几年的硕士生涯里，他修正了 Unix 里的 Pascal 系统，使得 Pascal 成了学生编程的缺省选择。他在 1978 年负责发布了第一个伯克利发行版（BSD，即 Berkeley Software Distribution），其中包含了他写的 ex，一个编辑器 ed 的改进版本。随即，在 1979 年他发布了第二版的伯克利 Unix（2BSD），包含了他写的 vi 和 csh。他独立实现了 BSD 中的 TCP/IP 栈。

离开伯克利后，他成了 Sun 的联合创始人和首席科学家，在 Solaris 操作系统、NFS 网络文件系统、SPARC 处理器、Java 语言的开发等多个领域中作出了自己的贡献……在 Bill Joy 的无数传奇故事里，有一个是，他只花了一个周末就写出了 vi。这当然……不是真的。vi 是演进的结果，前面还有 ed、em、en、ex（哈，对于两字母的 Unix 命令，我看得也是有点晕了🤔）等等一系列。只不过，那些都是基于命令的行编辑器，而不是全屏编辑器（部分原因是那时的很多系统仍然使用着电传打字机，而不是 CRT 终端）。vi 可以充分使用整个终端屏幕的资源，易用性的提升是毋庸置疑的。

不管怎么说，vi 只是一个 Bill 无意插柳柳成荫的结果，是他职业生涯中的一个副产品而已。在 1982 年初，Bill Joy 加入 Sun 公司之后，vi 就不怎么有人维护了。此外，由于没有得到 AT&T 授权的公司和个人也不能使用 vi 的源码（律师又一次发挥了威力），因此，大量的 vi 克隆版本纷纷出现。

目前大部分 Linux 发行版和 macOS 中的 vi 命令唤起的都是 Vim，一个由 Bram Moolenaar（布莱姆 · 穆勒纳尔）持续开发维护了三十多年的 vi 克隆（想想，三十年在计算机的发展中，那是经历了多少代技术的演进！）。在这些年里，其他的 vi 克隆诞生又死去，最后只剩下了 Vim（好吧，“只”是夸张手法）。起初，Vim 的意思是 Vi IMitation，但很快就成了 Vi IMproved。而这，就是我们这个课程的主题。


### Vim 的优势
vi 有着一个非常老古董的设计，就是它是一个有“模式”的编辑器。其他大部分编辑器都相当于 vi 的插入模式，输入什么字符就会在屏幕上出现什么字符。但 vi 的行为不是如此。事实上，这种不那么直观的设计，即使在 vi 初次出现的 20 世纪 70 年代，也被认为是违反人机交互的原则的。所有的后续 vi 实现，包括 Vim，都继承了 vi 的模式设计。令人惊讶的恐怕是，尽管有这些问题，Vim 在程序员群体中的流行程度并没有受到影响。根据 Stack Overflow 的开发者调查：2015 年程序员中最流行的编辑器是 Notepad++，Vim 的使用比例是 15.2%；2019 年最流行的开发环境变成了 Visual Studio Code，而 Vim 的使用比例还保持在了 25.4%。这就是这门课程从头到尾都会试图回答的问题：Vim 到底好在哪里？

拿我自己来说，我刚开始使用 Vim 时，不是出于选择，而是在 Linux 上开发的需要。不过，用着用着我就喜欢上 Vim 了——不仅在 Linux 下用，也在 Windows 下用（从十几年前开始，我就一直自己编译和维护着一个 Windows 下的最新 Vim 可执行文件）。自打切换到了 Mac 上之后，当然就更不用说，MacVim 是日常打开次数最多的工具。这里面最最主要的原因，**就是使用 Vim 编辑文件非常高效。**

在很大程度上，vi 的“高效”是一种历史性的设计要求，当年程序员需要在网速 300 波特（大致认为是今天网速的百万分之一吧）的环境里编辑文本文件。那个时代，人们还不可能拥有自己的计算机，大学、政府、公司里的计算机全都通过终端来进行分时共用。因此，vi 在命令上不得不非常“经济”。好玩的是，这种经济性，在今天仍然非常有用，它是 vi 及其克隆软件的高效之源。

我已经强调了几遍了，编辑的高效性，就是 Vim 最大的一个特点。除此之外，Vim 的优势还有很多，我来给你分享一下我认为最重要的三点。

第一，与 vi 最初只运行在 Unix 平台上不同，Vim 是一个完全跨平台的编辑器。

它支持的第一个操作系统是 AmigaOS，然后被逐步移植到了大部分其他操作系统上，既有我们常见的 Unix/Linux、Windows、macOS，也有不常见或者过时的操作系统，如 OS/2、BeOS、OpenVMS，甚至在 iOS 和 Android 上也能找到 Vim 的移植版本。这可以算是 Vim 的一个重要优点了。这个课程里，我会介绍 Vim 在主流操作系统上的使用，包括 Linux、macOS 和 Windows。

第二，Vim 也是一个高度可定制、可扩展的编辑器。


这对热爱折腾的程序员来说，绝对是一种乐趣，同时也是进一步提升效率的源泉。定制 Vim ，大部分情况下，你不需要什么特殊工具，使用 Vim 本身就可以。Vim 有自己的脚本语言，就叫 Vim 脚本（Vim script），语法相当简单，任何一个程序员应该都可以轻松地学会。配置文件和功能扩展都使用 Vim 脚本，使用统一的语法。同时，需要更强大的扩展能力还可以使用 Python、Perl、Ruby、Tcl 等其他通用的脚本语言，或者直接调用外部命令。你可以很容易打造一个你自己专属的开发环境，也很容易把这个环境从一台机器转移到另外一台机器上。

第三，作为一个发展了几十年的老牌开源软件，Vim 也有着良好的生态环境。

网上可以找到大量的现成脚本和插件，能帮助你打造一个顺手的开发环境。总的来说，像语法检查、自动补全等程序员常用功能，全都可以在 Vim 里实现。你不需要离开 Vim，就可以完成从写代码、编译到运行的大部分工作。下面的这张图里，就展示了 Vim 的很多扩展一起工作的结果：

![img](https://static001.geekbang.org/resource/image/d7/yc/d71beed8a4e1e2b970c63f7317655yyc.png?wh=1352*1309)

你可以看到，左边栏展示了 Vim 相对当前 Git 版本的修改状态（一处增，一处改），波浪线标出了代码中目前有错误的部分，底部显示了错误的原因，下面有个小窗口显示了光标所在处相对 Git 版本的变化，状态栏里更是密密麻麻地显示了编辑器模式、Git 分支、文件名、修改状态等信息。这里面用到了好几个扩展，包括颜色主题也是一个扩展。


虽然 Vim 最初是个针对字符界面的应用程序，但它也能支持主流的图形界面，包括 Windows 的图形界面，Linux 下的 GTK，以及 macOS 下的 Cocoa 和 Carbon，等等。作为一个并非“原教旨主义”的 Vim 用户，我个人是绝对赞成图形界面的使用的。因而我会推荐，只要有条件，就使用有图形界面的 Vim 版本。


不过，这个课程的绝大部分内容是对图形界面和文本界面都有效的（在两者有区别的地方，我则会明确指出）。换句话说，在你只能使用基于字符界面进行远程连接时，Vim 的功能仍然大部分有效，只是界面的美观程度会受一定的影响而已。也由于这个原因，Vim 在后端开发人员中特别受欢迎。

Vim 的模式是 Vim 的高效所在，但同时也是 Vim 学习上的一个难点。略有点搞笑的是，Stack Overflow 上有一个目前票数达到 3840 的问题是“[如何退出 Vim 编辑器](https://stackoverflow.com/questions/11828270/how-do-i-exit-vim)”，按问题票数排名可以进入前 100，这可能就是 Vim 的模式造成的困惑了。

反过来，这个反常规的设计使得 Vim 可以使用很逻辑的多个按键来处理文本，比如，在正常模式使用 daw 三个按键代表 delete a word 来删除光标下的一个完整单词，也可以输入 : 进入命令模式使用“make”这样的完整命令来进行项目的构建。

整体来说，Vim 会给你一个高效、跨平台、高定制性、易于扩展的开发环境。全面掌握 Vim 需要花费一定的时间进行学习。但这个时间不会白费，因为 Vim 可以在任何地方使用，它会成为你编程道路上一件称手的兵刃，让你成为更加高效的开发者。


### 课程主要内容
比起很多“开箱即用”的编辑器，Vim 是有一定的学习曲线的。虽然学 Vim 比学编程容易多了，但对于非英语母语的人来说，Vim 又会难上一点点。我会尽量多讲原理，而不是枯燥地讲解命令。不得不讲命令的时候，我会使用图片和动画，让你能对相关内容有一个直观的理解。对于很多 Vim 的命令，我们是需要形成“肌肉记忆”的；我们不需要死记硬背，但需要多看、多练，熟能生巧，在学习过程中自然而然就掌握了使用 Vim 的技巧。

作为一个有历史的编辑器，Vim 一直保持着非常良好的向后兼容性。学 Vim 学到的东西不会过时，在你的程序员生涯中一直可以用下去。我个人的 Vim 配置文件始于约 20 年前，慢慢地添砖加瓦，一直用到了今天。同时，Vim 也一直在发展，虽然不快，却也从来没有停下来（从发布 8.0 版本算起，平均每天 3.7 个补丁吧）。在这个课程中，我会基于目前最新的 Vim 8.2 来讲解 Vim 的功能。你将会学到：


Vim 的安装Vim 的模式和命令Vim 的配置Vim 的使用技巧Vim 里的重要插件


及最最重要的如何把 Vim 集成到你的工作流里，让它成为一件称手的工具，来进行高效的编辑


### 课程学习要求
我对这门课程的定位是零基础课，哪怕你以前没有用过 Vim ，也完全可以上手。这个课程不是 Vim 的百科全书，不会把 Vim 的所有命令选项，不管有用没用，全部都教给你。这是一个“新”教程，里面讲述的版本、很多技巧和插件是最近几年才有的，甚至是我在写专栏的时候才发现的。这也是一个面向实践者的教程，会让一个需要或想要使用 Vim 的开发者，从入门到精通，学会高效地使用 Vim 完成程序或其他文本文件的编辑。


虽然课程定位是零基础，但这并不意味着我对你没有任何要求。我仍然要求你在学习课程前：熟悉你使用的平台上的包管理器（yum、apt、brew 等；仅类 Unix 环境），知道如何完成程序的安装和卸载；安装了 Git，并对 Git 操作有基本的概念（不要求熟练掌握，因为我会给出大部分情况下需要的命令）；有一颗勇于探索的心，愿意花点力气把手里的“武器”打造得更为好用、称心。

使用 Vim 有不同的场景。在我设想的环境里，你是一个程序员，但我不对语言作出要求。课程的大部分内容完全是语言无关的，无论你使用什么编程语言开发，都应该可以获得有用的知识。不过，如果你使用 C、C++ 或 Python 进行开发，你可以得到一些额外的福利，因为这些是我主要使用的语言。这三个语言的额外重要性在于，Vim 的插件有可能会用到这三种语言。

## 导读｜池建强：Vim 就是四个字“唯快不破”

在文本编辑器领域，Vim 和 Emacs 是永恒的焦点。使用 Emacs 和 Vim 的程序员，平时大家各用各的，各自沿着不同的道路和目标前进，但总会在某个场景下相遇，愣一下就互相扔石头和臭鸡蛋，砸得对方鼻青脸肿，然后擦擦眼泪和口水继续前行。你看，编程也是有宗教信仰的，其实是个危险的工种，当真不是瞎扯。我工作了二十多年，写程序有十几年，用过各种编程工具，用错过，也用对过，虽然每种优秀的编辑器都有传奇的故事，每个程序员都有自己的脾气，但是，如果让我推荐一款编程工具，那一定是 Vim。

**Vim 号称编辑器之神，唯快不破，可扩展，插件遍天下。学习曲线虽然陡峭，但是学成之后，基本上就成肌肉记忆了，写程序双手不离键盘，上下翻飞，可谓快意编程。**

### 缘起
当时正值第一波互联网浪潮，我刚毕业不久，一如现在的热血青年，投身到互联网的大熔炉中。我所在的公司叫洪恩教育，公司里聚集了很多清华北大的同学，技术牛人扎堆，大家清一色使用 Vim 在服务器端编程，语法高亮都不设，内部 BBS 也是水木清华那种，通过终端访问，非常极客。走进办公室一眼望去，满目皆是黑漆漆的屏，绿瓦瓦的字，每个人都在那里噼噼啪啪地敲击键盘，韵律十足，我想，这简直酷毙了。

我最初还在使用 Editplus 编程，隶属菜鸟帮。别人的开发、编译和发布环境都在服务器端，而我则需要在本地编写好程序，通过 Editplus 的 ftp 功能上传到服务器端，再进行调试、测试和发布，不仅麻烦，而且不够酷。

那时候不酷是不行的，我这种行为遭到了小伙伴的无情嘲讽，于是我把愤怒都发泄在键盘上，每天在满天星斗的夜色中学习 Vim 技法，在清晨的微光中编译 Linux 内核，上午敲打键盘输出 Perl 程序，中午吃完五又四分之一口米饭之后开始研习 Vim 的多窗口和标签……那时候我住在公司，时间充裕到让你不好意思不学习，虽然 Vim 资料匮乏，但我周边都是牛人啊，随时随地请教，不断练习，很快小有所成，编码时鼠标锁进抽屉，双手敲击键盘上下翻飞，成就感十足。我对语法高亮情有独钟，经常把自己的界面配置得花花绿绿，没事看看也是一件乐事。自此以后，我就与 Vim 结下不解之缘，十几年过去了，工作中一直没有离开过 Vim，断断续续一直在用。到了 2009 年，我开始把工作环境完全切换到了 Mac 上，记得当时打开 Mac 的终端时，欣喜若狂地想，这不就是 Vim、Shell 和 IDE 的完美集成么？

### 场景
在不同的场景下应该采用最适合的工具，这时就会有人问了，Vim 适合什么场景呢？简单说来，Vim 比较适合 Unix/Linux 服务器端编程，如果你使用 Mac 电脑，Vim 是直接集成在你的终端环境中的，用起来十分方便。我以前用 Vim 主要用来进行 Shell/Python/C 编程。在 Unix/Linux 服务器端编辑和修改文件也离不开 Vim，另外由于我个人工作环境是 Mac，所以修改文本文件、Code Reiview、批量替换文件、比对文件等工作，用 Vim 顺手就做了。写 Java 程序、前端 HTML/CSS/JS、Objective-C 和 Swift，最优方案依次是 IDEA、VS Code、XCode 等，这些优秀的工具可以帮助我们提升效率，减少错误，但是如果你还想更进一步，那么 Vim 绝对值得拥有。

### 历史
Vim 源于 vi，但不是 vi，vi 作为计算机的文本编辑器历史极为悠远，它是由美国计算机科学家比尔·乔伊编写并于 1976 年发布的，同年苹果公司成立。比尔·乔伊是 Sun 公司的联合创始人和首席科学家，一位传奇的技术天才，我个人以为他最伟大的贡献是独立编写 BSD 操作系统，开发 vi 编辑器，创立 Sun 公司，当然，他还是 Java 语言的主要贡献者之一，任何人有幸完成其中一项工作已经足以名垂计算机发展史，而乔伊则通过一己之力完成了这些科技成果，推动了整个计算机科技的发展。

Vim 诞生得要晚一些，它的第一个版本由布莱姆·米勒在 1991 年发布，这个兄弟也是一位声名显赫的程序员，80 年代买了一台 Amiga 电脑，打开电脑一看，米勒鼻子差点气歪了，居然没有他最常用的 vi 编辑器！对于米勒来说这是不可接受的。愤怒的米勒决定自己开发一个文本编辑器，完全复制 vi 的功能，并起名为 Vi IMitation（模拟）。事实证明，优秀的程序员都具备这种品质，感到不爽了，就会写出个什么东西，要么完善一下，要么创新一下，要么是你写，要么是我写，于是很多伟大的软件程序就发明出来了。随着 Vim 的不断发展，更多更好的功能被加了进来，正式名称改成了 Vi IMproved（增强），也就形成了现代的 Vim，目前最新的稳定版本是 8.2，Vim 的开发语言是 C 和 VimScript。

### 理念
Vim 是一款完全面向程序员的软件，我很少见到用 Vim 编辑文字的普通用户，如果你是，一定要告诉我。写过程序的人都知道，编程的时候双手大部分时间都放在键盘上，或编码、或插入、或移动、或定位、或查找，这种连续操作的时间和频率远远大于阅读、翻页、设置字体、摆弄样式等文案工作，而二者往往产生很多停顿和间隙，而编程时的停顿是非常影响编程效率的，所以 Vim 的设计理念就是通过模式的转换、命令的组合和数以万计的插件，保证程序员在编程的过程中，双手尽可能保留在键盘中央的区域，并且，不需要鼠标。

想用好 Vim，先要理解 Vim 的模式转换。Vim 常用的模式有四种：
- 普通模式：Vim 启动后的默认模式，用来移动光标、删除文本、覆盖输入文本、恢复操作、粘贴文本等等。
- 插入模式：输入 i 或 a 进入插入模式，在这个模式下敲击键盘会往文字缓冲区增加文字，相当于普通编辑器的编辑模式。
- 可视模式：选择文本，可以行选、块选和依次选择，选择后可以进行复制、删除、排序等操作。
- 命令模式：执行内部和外部命令，通过“:”“/”“?”“:!”可以进入命令模式，分别对应的是：执行内部命令、向上或向下搜索、执行外部命令。

Vim 的模式和普通的编辑器有所不同，而且命令繁多千变万化，所以初期的学习曲线较高，一旦你坚持练习并且度过了最早的平台期，就会领略 Vim 的妙和全键盘的好。事实上 Vim 除了能够快速编辑文本文件之外，还能够通过简单的命令做更多的事情。



## 基础

## 01｜各平台下的 Vim 安装方法：上路前准备好你的宝马
今天第一讲，我们先来讨论一下 Vim 在 Linux、macOS、Windows 系统下的安装和配置问题。Vim 在 Linux 和 macOS 上一般是默认安装的，在 Windows 上不是。不过 Vim 的网站上提供了 Windows 下的安装包，自己安装也很容易。所以，今天的课程我不会手把手、一步步地讲，而是挑选一些重点。对于默认安装的情况，主要讨论的是版本老旧或功能不全的问题。对于其他情况，我则会给出一个基本指引，减少你走弯路的可能性。好了，下面我们就分各个不同的平台，一一来看。


### Linux 下的安装
#### Red Hat 和 CentOS 系列


在 Red Hat Linux 和 CentOS Linux 上，默认安装的 Vim 可能是一个最小功能的版本。虽然这个版本启动速度很快，但它缺少了很多对开发有用的功能，如语法加亮、Python 集成和图形界面。一般情况下，应至少安装更全功能版本的 Vim；如果能使用 X Window 的话，则应安装图形界面版本。你可以通过下面的命令来查看已经安装的 Vim 版本：
```
yum list installed | grep vim
```
如果输出只有下面这样的内容的话，就说明安装的 Vim 版本只有基本功能：


vim-minimal.x86_64 2:8.0.1763-13.el8 @System

此时，我建议使用 sudo yum install vim-X11 来安装图形界面的 Vim，或至少使用 sudo yum install vim-enhanced 来安装增强版本的 Vim（如果你不在这台机器上进行图形界面登录的话）。

只要你使用图形界面，一般而言，你都应该安装有图形界面支持的 Vim。总体而言，图形界面 Vim 的功能更丰富，并且即使你只在终端里使用 Vim，含图形界面支持的 Vim 会带剪贴板支持，跟整个图形环境的交互也就比较容易。当然，如果你只是远程通过 SSH 使用 Vim 的话，那确实图形界面支持就没有意义了。

#### Debian 和 Ubuntu 系列
在 Debian、Ubuntu 等使用 apt 的 Linux 发行版上，Vim 同样有着不同功能版本的区别，而且选择更多。我们可能会看到：


vim vim-athena vim-gnome vim-gtk vim-gtk3 vim-nox vim-tiny

它们中有编译进最小功能的 Vim 包（vim-tiny），有较全功能的文本界面 Vim 包（vim-nox），有适用于老的 X-Window 界面的版本（vim-athena），有适用于 KDE 环境的 GTK2 版本（vim-gtk），等等。

![img](https://static001.geekbang.org/resource/image/dc/94/dc83899514bd661b41d1e8a902d47294.png?wh=1162*725)

如果你不确定要装什么版本的话，那可以遵循我下面的建议：如果你使用标准的 GNOME 桌面环境的话（大部分的情况），安装 vim-gtk3 或 vim-gnome。如果你使用 KDE 桌面的话，安装 vim-gtk。如果你只使用文本界面的话，安装 vim-nox。都不是？那你是个爱自己定制的家伙，也就不需要我告诉你该安装什么了。

你可以通过下面的命令来查看已经安装的 Vim 版本：

```
apt list --installed | grep vim
```
我们先执行 sudo apt update 来确保更新环境，然后使用 sudo apt install vim-gtk3 安装 GTK3 版本的 Vim（或者其他你需要的版本）。如果你安装了图形界面的版本，不必单独再另外安装其他版本的 Vim，因为图形版本的 Vim 也是可以纯文本启动的。事实上，在 Ubuntu 上，vim 和 gvim 都是指向同一个应用程序的符号链接，且 gvim 的执行效果和 vim -g 相同。

![img](https://static001.geekbang.org/resource/image/39/5a/39d5f8bef475c6b223cee68de8376f5a.png?wh=1464*912)



#### 手工编译
如果你用的 Linux 发行版较老的话，你可能会希望手工编译 Vim 来得到最新的版本。此时需要注意的是，Vim 有很多的编译配置选项，有些缺省是不打开的。对于这个课程来讲，我们会希望至少加上 Python 支持和图形界面支持。你首先需要确保自己已经安装了所需的开发包（可以参考这个[网上的回答](https://superuser.com/a/749760/270697)）。然后，我们可以使用下面的命令来配置 Vim 和编译（根据需要，“auto”也可以替换成“gtk3”等其他需要的数值）：

```
./configure --enable-pythoninterp \
            --enable-python3interp \
            --enable-gui=auto
make -j
sudo make install
```
如果上述步骤正常没有出错，Vim 就被成功安装到 /usr/local 下了。你可以用 which vim 来检查系统是否会自动优先选择你的 vim：如果不是的话，你可能需要调整 PATH 里的顺序，或者设置别名来优先启动 /usr/local/bin/vim）。然后，你可以使用 vim --version 命令来输出 vim 的版本信息。我们希望能在输出里看到：

```
Huge version with … GUI
+python/dyn
+python3/dyn
```
目前 Python 2 已经停止支持，所以你最好可以确保上面的输出中包含“+python3”（很多 Vim 的插件已经开始要求 Python 3、不再支持 Python 2 了）；没有“+python”（即 Python 2）则没什么关系（有没有“dyn”关系也不大）。

![img](https://static001.geekbang.org/resource/image/f0/30/f05a0a02cbea3b6412790ab7a1aa6d30.png?wh=1320*1038)


好了，关于 Linux 环境下的 Vim 安装和配置要点我们就讲完了，接下来继续看在 macOS 上如何安装。


### macOS 下的安装
在 macOS 中一般已经内置了 vim，并提供了除图形界面外的较完整功能集。如果你希望使用图形界面，则需要自行安装 MacVim，一个跟现代 macOS 融合较好的独立 Vim 版本。安装 MacVim 有两种常用方式：使用 Homebrew。我推荐你使用这种方式，这样的话，以后升级也会比较容易。使用 MacVim 的独立安装包。如果你之前没有在用 Homebrew 的话，或处于不方便使用 Homebrew 的网络环境中，这种方式也可以。

由于使用 Homebrew 已经足够简单，日后升级也非常方便，我个人觉得我们没必要自己去编译 MacVim。

![img](https://static001.geekbang.org/resource/image/f4/75/f49cb907c0b34b9c2b8f7579de9d5075.png?wh=1318*1172)


#### 使用 Homebrew 安装 MacVim
首先，如果你没有 Homebrew，那你需要先安装 Homebrew。安装信息可以在 Homebrew 的主页上找到（这个网站是支持中文的）。

在安装了 Homebrew 之后，一般情况下，你需要修改你的 .bash_profile（如果使用 Bash 的话）、.zprofile（如果使用 Zsh 的话）或是相应的 shell 的配置文件，调整 PATH，把 /usr/local/bin 放到 /usr/bin 前面。我个人在 .bash_profile 里是这样配置的：

```
if [[ $PATH != "$HOME/bin"* ]]; then
  PATH=~/bin:/usr/local/bin:/usr/local/sbin:`echo $PATH|sed -e "s!:$HOME/bin!!" -e 's!:/usr/local/bin!!'`
fi
```
这样，可以确保个人的路径优先于 /usr/local，而 /usr/local 下的路径又优先于系统的路径。如果你这样配置的话，那只要执行 brew install macvim，然后在等待安装完成之后，你用 vim 启动的就是 MacVim 了。缺省用 vim 运行的仍然是纯文本界面的 Vim，但跟 Linux 一样，你可以用 vim -g 或 gvim（还有仅用在 Mac 上的 mvim）来启动 Vim 的图形界面。跟 Homebrew 里的其他软件一样，你以后要升级 MacVim 的话，只需要输入命令 brew upgrade macvim 即可。是不是很简单？这就是为什么我比较推荐这种安装方式，后期升级真的更容易。不过我下面还是会介绍下安装包的方式，以满足我们不同的应用需求。

#### 使用安装包安装 MacVim
跟大部分的 Mac 软件一样，你也可以直接使用 DMG 安装包来安装 MacVim。目前可从以下网址下载 MacVim 的安装包：

https://github.com/macvim-dev/macvim/releases

等待下载完成后，双击下载的文件，然后会打开一个访达（Finder）窗口。你只需要把 MacVim 拖拽复制到应用程序文件夹即可。在这种安装方式下，手工键入 vim、gvim 或 mvim 命令是无法启动 MacVim 的。你需要手工创建这些命令的符号链接（symlink）或别名（alias）才行。假设你的 MacVim 是直接安装在应用程序文件夹里的话，这些命令本身可以在 /Applications/MacVim.app/Contents/bin 文件夹里找到；使用下面的命令可以在你自己的 bin 目录下创建这些命令的符号链接：

```
[ -d ~/bin ] || mkdir ~/bin
ln -s /Applications/MacVim.app/Contents/bin/* ~/bin/
```
### Windows 下的安装
最后，我们来看在 Windows 下怎么安装。课程开头我提到了，Windows 上缺省是没有 Vim 的。我们可以从 Vim 的网站下载 Windows 下的安装包：


https://www.vim.org/download.php#pc


在 Linux 和 macOS 上，64 位应用程序已经成为主流。而与此不同的是，在 64 位 Windows 上，32 位应用程序仍然很常见。默认的 Vim 8 的安装包安装的仍然是一个 32 位的应用程序。不过，32 位的 Vim 也足够满足一般需求了，除非你需要编辑 2 GB 以上的大文件。安装界面会有一个选择组件的步骤，如下图所示：

![img](https://static001.geekbang.org/resource/image/3a/80/3a9291c280033a71f80d924467546580.png?wh=998*720)



这个界面中，下面几项我们可以关注一下：“安装批处理文件”（Create .bat files）：对于用 Vim 的开发者来说，通常命令行是刚需，所以我们一般需要勾上这项。“创建图标”（Create icons for Vim）：根据你自己的需要进行选择，通常我会去掉展开子项里的“桌面图标”（On the Desktop），不在桌面上创建 Vim 的图标。“创建默认配置文件”（Create Default Config）：去掉这项——我们马上会创建配置文件。“安装多语言支持”（Native Language Support）：这项功能使得 Vim 的菜单可以显示中文的命令，但实际上还是有点鸡肋，因为 Vim 的主要功能不是靠菜单驱动的，安装程序安装的帮助文件也只有英文版。所以，这项选和不选关系不大，你可以自由选择。

然后我们点“下一步”（Next），不需要修改安装目标文件夹，完成安装即可。完成安装后，Vim 会缺省打开一个 README 文件。在这个窗口中，我们应当键入“:e ~\_vimrc”，回车键，然后把下面的内容粘贴进去（这些配置项的意义我们以后会讨论）：
```
set enc=utf-8
set nocompatible
source $VIMRUNTIME/vimrc_example.vim
```
然后键入“ZZ”（大写）存盘退出即可。（或者在菜单上操作）

![img](https://static001.geekbang.org/resource/image/07/17/07ebd8b7d535e516e8d68517a6338717.gif?wh=660*507)



注意由于历史上的文件系统限制，在 Windows 下 Vim 的配置文件名称是 _vimrc 而不是 .vimrc（虽然 Windows 命令行不支持像 Unix 一样用“~”代表用户的主目录，在 Vim 里我们仍然可以使用“~\_vimrc”或“~/_vimrc”这样的写法）。这是 Unix 和 Windows 下的 Vim 配置的区别之一。其他的主要区别是以下两点：

点打头的 Vim 文件都成了“_”打头，如 .viminfo 也成了 _viminfo点打头的 Vim 配置目录 .vim 在 Windows 下则成了 vimfiles

除此之外，Vim 的配置在 Windows 下和 Unix 下（如 Linux 和 macOS）并没有根本不同。Windows 上的主要麻烦在于，由于 Vim 的生态主要在 Unix 上，某些 Vim 的插件在 Windows 上安装配置需要花费更大的力气。但就一般的文本和程序编辑而言，Vim 在 Windows 下和 Linux 下没有本质的不同。甚至 Windows 下还有一个小小的优势：Unix 下虽然 Vim 可以编译成支持 Python 2 和 Python 3，但在 Vim 里一旦执行了 Python 2 的代码，就不能再执行 Python 3 的代码了；反之亦然。Windows 下则没有这个限制。

有没有注意到我只在 Windows 的安装部分讨论了配置？这是因为 Unix 下主流的缺省编码已经是 UTF-8 了，而 Vim 只能在内码是 UTF-8 的情况下才能处理多语言的文本。而我们有自己的配置文件，是为了确保启用一些最为基本的配置选项，来保证基本行为的一致性。

Windows 上可以把 Vim 配置成跟普通的编辑器行为差不多，包括支持 Ctrl-A 全选，选择内容后输入任何内容替换选择的内容，等等。但是，这种行为跟 Vim 的标准行为是冲突的。我们要学习 Vim，还是忘了这些 Windows 特有的功能为好，去学习掌握 Vim 的跨平台标准功能。上面的配置文件也同样没有启用 Windows 下的特有行为。


### Cygwin/MSYS2
Windows 有 [Cygwin](http://cygwin.org/) 和 [MSYS2](https://www.msys2.org/)，可以提供类似于 Linux 的 POSIX shell。在这些环境里，Vim 都是标准组件，按这些环境的标准方式来安装 Vim 就行。如果你使用 [Git Bash](https://gitforwindows.org/) 的话，里面就直接包含了 MSYS2 的终端、Bash 和 Vim。唯一需要提一句的是，这些类 POSIX 环境里面的 Vim 配置应当参照 Linux 终端来，而不是 Windows 下的标准方式（也就是说，个人配置目录和配置文件是 .vim 和 .vimrc，而非 vimfiles 和 _vimrc）。我以后对这种情况就不再单独描述了。

### 远程使用 Vim
还有一种常用的环境恐怕是使用 mintty、PuTTY、SecureCRT 之类的软件在 Windows 上远程连接到 Linux 机器上。在这种情况下，需要特别注意的，是远程终端软件的远程字符集（如 PuTTY 中的“Windows > Translation > Remote character set”）应当设置成 UTF-8。这个设定跟具体的软件及其版本有关，我就不详细说明了；请自行查看你所使用的远程终端软件的设定和相关文档。


### 学习 Vim
上面我们讲解了 Vim 的安装。如果安装过程中遇到了什么问题，可以留言提问。接下来，我会给你提供一些 Vim 的学习资料，帮助你进入 Vim 的世界。你应该仔细看一下你所使用的平台上的 Vim 安装信息（其他平台的可以略过），并且应该自己打开 Vim 教程练习一遍（除非这些基础知识你都了解了）。键盘配置相关信息属于可选，可以根据自己的兴趣和需要决定是否了解一下。

### 中文帮助文件
Vim 内置了完整的英文帮助文件。如果你想要中文帮助文件的话，有个好消息是，有网友同步翻译了最新的帮助文件，而且安装过程在 Vim 8 （或将来的版本）里是非常简单的。以 Unix 下为例（Windows 下类似，但路径 .vim 需要修改为 vimfiles）：

```
cd ~/.vim
mkdir -p pack/my/start
git clone https://github.com/yianwillis/vimcdoc.git pack/my/start/vimcdoc
```
如果你不需要以后利用 Git 来快速升级文档的话， 也可以在这个 [Vim 中文文档计划](https://github.com/yianwillis/vimcdoc)的下载页面下载 tar 包，然后自行解压到 ~/.vim/pack/my/start 目录下（或 Windows 用户目录下的 vimfiles\pack\my\start 目录下）。

Windows 用户有一个简单的安装程序（当前为 vimcdoc-2.3.0-setup-unicode.exe），可以自动帮你完成中文帮助文件的安装任务。如果你的机器上没有 git 和 tar 可执行程序的话，那这个方式最简单。

![img](https://static001.geekbang.org/resource/image/fe/a7/fe5d4b5cbf08c939feb8d453f919d1a7.png?wh=1318*1014)

### Vim 教程
Vim 在安装中自带了一个教程，可供快速入手使用。如果你对 Vim 的基本操作不熟的话，建议你完整学习一下，我也就不必多费笔墨介绍一些最基础的用法了。Vim 教程支持多语言，可使用命令 vimtutor 来启动。如果启动的教程的语言不是你希望的，你可以使用环境变量 LANG 来设定希望的语言。比如，下面的命令可以在 Unix 环境中启动一个中文的 Vim 教程：

```
LANG=zh_CN.UTF-8 vimtutor
```
Windows 下你可以在开始菜单里找到 Vim tutor。但我测试下来[它有一个问题](https://github.com/vim/vim/issues/5756)。虽然我提交的解决方法已经作为补丁（8.2.0412）合并，但目前（Vim 8.2）安装程序安装的文件多半仍然是有问题的，你会无法成功地创建一个 tutor 文件的副本供编辑使用。我建议手工创建一个这个教程的副本。可以在命令提示符下输入：

```
vim --clean -c "e $VIMRUNTIME/tutor/tutor.zh_cn.utf-8" -c "w! TUTORCOPY" -c "q"
```
这样即可在当前目录下创建一个教程的副本。然后我们可以用 gvim TUTORCOPY 来打开这个副本进行学习。

![img](https://static001.geekbang.org/resource/image/20/c5/208992f818376e6010066c4a544286c5.png?wh=1318*954)

### 键盘重配置
最后，有些重度的 Vim 用户会重新配置键盘，把使用频度较低的大写锁定键（Caps Lock）重新映射成 Esc 或 Ctrl 键。对于这个问题，如果你需要的话，网上很容易就能找到攻略，如：

[Linux 下将大写锁定键 (CapsLock) 键映射为 Ctrl 键 (Ubuntu, Manjaro，CentOS)](https://blog.csdn.net/daerzei/article/details/89414610)

[mac book 更改 caps lock 键为 esc 键 /ctrl 键](https://blog.csdn.net/tbestcc/article/details/52287622)

[windows 交换大写锁定键与 ESC 键（注册表修改）](https://blog.csdn.net/P_LarT/article/details/72829425)

[在任何操作系统上，如何禁用或者重新分配 Caps Lock 键](https://www.kutu66.com/Mac/article_11233)

这当然是一件非常个人化的事情，而且有一个风险，你一旦跑到别人的机器上操作，你的“肌肉记忆”可能会让你常常按错键。鉴于你目前可能只是个 Vim 的初学者，现在不一定需要这么去做。等到你觉得按 Esc 太麻烦了，再想起这个可能性去修改键盘配置也来得及。


### 内容小结
今天我们讨论了 Vim 在常见平台上的安装过程。顺便说一句，以后在牵涉到环境问题时，我一般也会以上面提到的几种典型情况为例来进行讲解：Linux（CentOS 和 Ubuntu）macOS Windows

你可能看着多个平台的安装过程有点晕，这却是我的实际使用环境了——我就是在各个平台下都安装、配置、使用着 Vim 的，这也就是 Vim 的全平台、跨平台优势了。当然，必须得承认，Vim 还是最适合类 Unix 环境，它的生态系统也是在类 Unix 环境下最好。鉴于在 Windows 下已经越来越容易接触到类 Unix 环境（像 Git Bash、Docker 和 Windows Subsystem for Linux），服务器开发上 Linux 也已经成了主流，在 Windows 上熟悉 Vim 的完整环境对你也应该是件好事——尤其如果你是做服务器或嵌入式开发的话。

## 02｜基本概念和基础命令：应对简单的编辑任务
这一讲，我们会讨论 Vim 的基本概念和配置。先强调一下，请务必确保你在学习这一讲之前，已经通过 Vim 教程熟悉了 Vim 的基本用法。


### Vim 教程的内容概要
上节课我给你留的作业，就是花时间学习一下 Vim 教程，下面我们就来检验一下。只有你自己先对照着教程操作了一遍，今天我再带着你过一遍里面的基本概念和配置，你才能查漏补缺，发现自己遇到的问题，明确自己需要多加练习的地方。好，现在请查看下面的键盘图。简单说明一下，这张图上展示了一个键盘。图中的“•”表示，单个字母不是完整的命令，必须再有进一步的输入。比如，单个“g”没有意义，而“gg”表示跳转到文件开头。（对于命令后面明确跟一个动作的，如“c”，我们不使用“•”。）一个键最多有三排内容：最底下是直接按键的结果，中间是按下 Shift 的结果（变大写），上面偏右的小字是按下 Ctrl 的结果。我们还用了一些特殊符号来表示操作的位置，如果你已经了解了这些命令的功能，你也自然就明白它们的意义了。

![img](https://static001.geekbang.org/resource/image/76/a1/76910d1a16ed737c42078dd1255124a1.png?wh=1670*570)

请检查一下有颜色的那些键，看看你是否有任何不熟悉的地方。如果看下来有让你感到陌生的内容，请复习 Vim 教程。这张图里没有写出 Vim 的命令行命令。你现在应该已经掌握了以下这些：



“:q!”：退出 Vim“:wq”：存盘退出“:s”：执行替换“:!”：执行外部命令“:edit”（一般缩写为 “:e”）：编辑文件“:w”：写文件“:r”：读文件“:help”：查看帮助使用键 Ctrl-D 和 Tab 来进行命令行补全

同样，如果你发现上面列举的命令有你不熟悉的，也请重新打开 Vim 教程复习一下——这些属于 Vim 的最基本功能，一定要能熟练运用才行。


### Vim 的模式
接下来我们进入本讲的正题，讲述 Vim 的四种主要模式、键描述的体例和 Vim 需要的基本配置选项。掌握了这些内容之后，我们就能应对基本的编辑任务了。下面我们一一来看。Vim 最特别的地方就是它的模式了。与其他大部分编辑器不同，进入 Vim 后，缺省状态下键入的字符并不会插入到所编辑的文件之中。 Vim 的模式（mode，可以简单地理解为“状态”）是它的麻烦所在，但同时也是它的威力所在。

我们需要知道，Vim 有以下四种主要模式:正常（normal）模式（也称为普通模式），缺省的编辑模式；如果不加特殊说明，一般提到的命令都直接在正常模式下输入；在任何其他模式中，都可以通过键盘上的 Esc 键回到正常模式。插入（insert）模式，输入文本时使用；比如在正常模式下键入 i（insert）或 a（append）即可进入插入模式。可视（visual）模式，用于选定文本块；教程中已经提到可以用键 v（小写）来按字符选定，Vim 里也提供其他不同的选定方法，包括按行和按列块。命令行（command-line）模式，用于执行较长、较复杂的命令；在正常模式下键入冒号（:）即可进入该模式；使用斜杠（/）和问号（?）开始搜索也算作命令行模式。命令行模式下的命令要输入回车键（Enter）才算完成。

此外，Vim 也有个选择（select）模式，与普通的 Windows 编辑器行为较为接近，选择内容后再输入任何内容，将会替换选择的内容。在以可视模式和选择模式之一选定文本块之后，可以使用 Ctrl-G 切换到另一模式。这个模式主要是为了模拟 Windows 编辑器的行为，并不是 Vim 的主要用法，使用它反而会给 Vim 里的自动化带来麻烦，所以我们也就不多作介绍了。关于 Vim 的模式，我们重点掌握正常模式就可以了，刚刚也说过，Vim 里的大部分操作会在正常模式下完成。如果你做编辑工作时有超过几秒的停顿，就应当考虑按下 Esc 键，回到正常模式。记住，正常模式就是正常情况下你应当处于的模式。😄

### Vim 的键描述体例
清楚了 Vim 模式之后，我们来对 Vim 里的按键作一下清晰的体例描述，毕竟，Vim 里的键真的有点多。从现在开始，我会使用 Vim 里的标准键描述方式来讲解。根据 Vim 的一般习惯，我们使用尖括号来描述特殊的输入序列。下面我会提供一个列表，给出常用键的表示方式及在动图中的显示方式。这部分内容不需要记住，你用的时候作为参考就行。

- < Esc> 表示 Esc 键；显示为“⎋”
- < CR> 表示回车键；显示为“↩”
- < Space> 表示空格键；显示为“␣”
- < Tab> 表示 Tab 键；显示为“⇥”
- < BS> 表示退格键；显示为“⌫”
- < Del> 表示删除键；显示为“⌦”
- < lt> 表示 < 键；显示为“<”
- < Up> 表示光标上移键；显示为“⇡”
- < Down> 表示光标下移键；显示为“⇣”
- < Left> 表示光标左移键；显示为“⇠”
- < Right> 表示光标右移键；显示为“⇢”
- < PageUp> 表示 Page Up 键；显示为“⇞”
- < PageDown> 表示 Page Down 键；显示为“⇟”
- < Home> 表示 Home 键；显示为“↖”
- < End> 表示 End 键；显示为“↘”
- < F1> - < F12> 表示功能键 1 到 12；显示为“F1”到“F12”
- < S-…> Shift 组合键；显示为“⇧”（较少使用，因为我们需要写 ! 而不是 < S-1>；和特殊键组合时仍然有用）
- < C-…> Control 组合键；显示为“⌃”
- < M-…> Alt 组合键；显示为“⌥”（对于大部分用户，它的原始键名 Meta 应该只具有历史意义）
- < D-…> Command 组合键；显示为“⌘”（Mac 键盘）

现在回到前面的模式部分，我们提到的 Esc、Enter、v、V 和 Ctrl-V，按我们现在的描述惯例，以后就会写成 < Esc>、< CR>、v、V 和 < C-V>。这也是以后在 Vim 里对键进行重映射的写法——如果你还不了解重映射是什么也没关系，我们很快就会讨论到。这里我要强调一下，对“<”的特殊解释仅在描述输入时生效。在描述命令行和代码时，我们写“< CR>”仍表示四个字符，而非回车键。特别是，如果我们描述的命令行首是“:”，表示这是一个输入 : 开始的 Vim 命令行模式命令（以回车键结束）；如果行首是“/”或“?”，表示这是一个输入 / 或 ? 开始的搜索命令（以回车键结束）；如果行首是“$”，表示这是一个在 shell 命令行上输入的命令（以回车键结束），“$”（和后面的空格）不是命令的一部分，通常后续行也不是命令的一部分，除非行尾有“\”或“^”字符，或行首有“$”字符。也就是说，下面的命令是在 Vim 里输入“:set ft?< CR>”（用来显示当前编辑文件的文件类型）：

```
:set ft?
```
下面的命令则是在 shell 里输入“which vim< CR>”（用来检查 vim 命令的位置）：

```
$ which vim
/usr/bin/vim
```
此外，当我用“:help”描述帮助命令时，你不仅可以在 Vim 里输入这个命令来得到帮助，也可以点击这个帮助的链接，直接在线查看相应的中文帮助页面。

这节内容不需要死记。建议使用“收藏”功能，这样，你可以在以后碰到不认识的符号标记的时候，返回来查看这一节的内容。

### Vim 的选项和配置
了解了 Vim 模式和键描述，我们对 Vim 的认识又多了一些，第一步的学习成就达成。要想更好地使用 Vim，下一个关键点就是配置了，接下来我就带你看看 Vim 配置都有哪些需要注意的点。作为一个可以越用越顺手的应用程序，Vim 是需要配置的。我们才刚开始学习，所以目前我们的配置文件是相当简单的，但随着课程的进展和你使用 Vim 越来越多，你的 Vim 配置文件必然会越变越复杂。我们今天就先来做一些初步的讨论，看看能实际使用的一个最基本 Vim 配置文件是什么样子。我们上节课已经讨论过，根据 Unix 下的惯例，Vim 的配置文件放在用户的主目录下，文件名通常是 .vimrc；而它在 Windows 下名字是 _vimrc。我们前面给出最基本的配置文件是这个样子的：

```
set enc=utf-8
set nocompatible
source $VIMRUNTIME/vimrc_example.vim
```
如果你熟悉 shell 语法，你肯定能看到不少熟悉的影子在里面。这三行完成了下列功能：
- 设置编辑文件的内码是 UTF-8（非所有平台缺省，但为编辑多语言文件所必需）
- 设置 Vim 不需要和 vi 兼容（仅为万一起见，目前大部分情况下这是缺省情况）
- 导入 Vim 的示例配置（这会打开一些有用的选项，如语法加亮、搜索加亮、命令历史、记住上次的文件位置，等等）

对于现代 Unix 系统上的 Vim 8，实际上只需要最后一句就足够了。对于现代 Windows 系统上的 Vim 8，中间的这句 set nocompatible 也可以删除。如果你在较老的 Vim 版本上进行配置，那么把这三行全放进去会比较安全。接下来，我会讲一些基本的配置项，保证你的日常工作流顺畅。它们是：备份和跨会话撤销、鼠标支持、中文支持及图形界面的字体支持。除了字体支持主要牵涉到美观性，其他三项都是对编辑至关重要的基本功能。我们一一来看。

### 备份和撤销文件
上面的基本设置会产生一个有人喜欢、但也有很多人感到困惑的结果：你修改文件时会出现结尾为“~”的文件，有文件名后面直接加“~”的，还有前面加“.”后面加“.un~”的。这是因为在示例配置里，Vim 自动设置了下面两个选项：

```
set backup
set undofile
```
前一个选项使得我们每次编辑会保留上一次的备份文件，后一个选项使得 Vim 在重新打开一个文件时，仍然能够撤销之前的编辑（undo），这就会产生一个保留编辑历史的“撤销文件”（undofile）了。

![img](https://static001.geekbang.org/resource/image/a2/5e/a2ae45ebdf188cfbe11e9dfd0fb1245e.gif?wh=734*458)


我的通常做法是，不产生备份文件，但保留跨会话撤销编辑的能力；因为有了撤销文件，备份其实也就没有必要了。同时，把撤销文件放在用户个人的特定目录下，既保证了安全，又免去了其他目录下出现不必要文件的麻烦。要达到这个目的，我在 Linux/macOS 下会这么写：

```
set nobackup
set undodir=~/.vim/undodir
```
在 Windows 下这么写：

```
set nobackup
set undodir=~\vimfiles\undodir
```
无论哪种环境，你都需要创建这个目录。我们可以用下面的命令来让 Vim 在启动时自动创建这个目录：

```
if !isdirectory(&undodir)
  call mkdir(&undodir, 'p', 0700)
endif
```
如果我告诉你， &undodir 代表 undodir 这个选项的值，那么其他代码的基本作用，相信你也一定能看出来了吧？我们暂时就不做进一步分析了。如果你好奇的话，可以提前看一下下面各项的 Vim 帮助文档：:help isdirectory():help mkdir():help :call

这个跨会话撤销的能力，我还真不知道其他哪个编辑器也有。更妙的是，Vim 还有撤销树的概念，可以帮助你回到任一历史状态。这个我们以后会和相关的插件一起讨论。

### 鼠标支持
我不知道你会不会像某些资深 Vim 用户一样，只用键盘不用鼠标。我反正是做不到的，也没有动力去那样做——毕竟，浪费计算机界一项伟大的发明并不那么有必要😂。手一直在键盘上的本位排（home row）打字当然会更快，但一个程序员看代码的时间比写代码的时间要多得多，而在非线性的跳转任务上，鼠标比键盘更加快，也更加有效。在 Vim 的终端使用场景下，鼠标的选择有一定的歧义：你希望是使用 Vim 的可视模式选择内容，并且只能在 Vim 里使用呢，还是产生 Vim 外的操作系统的文本选择，用于跟其他应用程序的交互呢？这是一个基本的使用问题，两种情况都可能发生，都需要照顾。

如果你使用 xterm 兼容终端的话，通常的建议是：在不按下修饰键时，鼠标选择产生 Vim 内部的可视选择。在按下 Shift 时，鼠标选择产生操作系统的文本选择。

对于不兼容 xterm、不支持对 Shift 键做这样特殊处理的终端，我们一般会采用一种“绕过”方式，让 Vim 在某种情况下暂时不接管鼠标事件。通常的选择是在命令行模式下不使用鼠标。下面，我们就分这两种情况来配置。虽然最新的 Vim 缺省配置文件（示例配置文件会包含缺省配置），在大部分情况下已经可以自动设置合适的鼠标选项了，不过为照顾我们课程的三种不同平台，我们还是手工设置一下：

```
if has('mouse')
  if has('gui_running') || (&term =~ 'xterm' && !has('mac'))
    set mouse=a
  else
    set mouse=nvi
  endif
endif
```
上面代码说的是，如果 Vim 有鼠标支持的话，那在以下任一条件满足时：图形界面正在运行终端是 xterm 兼容，并且不是 Mac（Mac 上的终端声称自己是 xterm，但行为并不完全相同）

我们将启用完全的鼠标支持（mouse=a）。特别是，此时鼠标拖拽就会在 Vim 里使用可视模式选择内容（只能在 Vim 里使用）。而当用户按下 Shift 键时，窗口系统接管鼠标事件，用户可以使用鼠标复制 Vim 窗口里的内容供其他应用程序使用。否则（非图形界面的的终端，且终端类型不是 xterm），就只在正常模式（n）、可视模式（v）、插入模式（i）中使用鼠标。这意味着，当用户按下 : 键进入命令行模式时，Vim 将不对鼠标进行响应，这时，用户就可以使用鼠标复制 Vim 窗口里的内容到其他应用程序里去了。

非 xterm 的鼠标支持在 macOS 和 Windows 下都有效。但在 Windows 下需要注意的一点是，如果使用非图形界面的 Vim 的话，应当在命令提示符（Command Prompt）的属性里关闭“快速编辑模式”（QuickEdit Mode），否则 Vim 在运行时将无法对鼠标事件进行响应。鉴于命令提示符的行为有很多怪异和不一致之处，强烈建议你在 Windows 下，要么使用图形界面的 Vim，要么使用 Cygwin/MSYS2 里、运行在 mintty 下的 Vim。

### 中文支持
接下来我和你讲讲中文支持的问题。如果你一直在 UTF-8 下使用中文的话，那这一小节的内容可以跳过。对于大部分在 Unix 下工作的人员，应该是这样的情况。而如果你在 Windows 上工作，或者有需要跟别人交换 GB2312、GBK、GB18030 编码的文本文件，那这部分的内容还是需要看一下的。完整的 Unicode 历史和原理可以讲上整整一讲，但从实用的角度，我们就简化成下面几条吧：

- 整个世界基本上在向 UTF-8 编码靠拢。
- 微软由于历史原因，内部使用 UTF-16；UTF-16 可以跟 UTF-8 无损转换。
- GB2312、GBK、GB18030 是一系列向后兼容的中文标准编码方式，GB2312 编码的文件是合法的 GBK 文件，GBK 编码的文件是合法的 GB18030 文件。但除了 GB18030，都不能做到跟 UTF-8 无损转换；目前非 UTF-8 的简体中文文本基本上都用 GBK/GB18030 编码（繁体中文文本则以 Big5 居多）。鉴于 GB18030 是国家标准，其他两种编码也和 GB18030 兼容，我们就重点讲如何在 Vim 中支持 GB18030 了。


举一个具体的例子，“你好😄”这个字符串，在 UTF-8 编码下是下面 10 个字节（我按字符进行了分组）：e4bda0 e5a5bd f09f9884如果使用 GB18030 编码（GB2312/GBK 不能支持表情字符）的话，会编码成 8 个字节：c4e3 bac3 9439fd30这么看起来，GB18030 处理中文在存储效率上是优势的。但它也有缺点：

GBK 外的 Unicode 字符一般需要四字节编码（非中文情况会劣化）GBK 外的 Unicode 字符跟 Unicode 码点需要查表才能转换（UTF-8 则可以用非常简单的条件判断、移位、与、或操作来转换）一旦出现文件中有单字节发生损毁，后续的所有中文字符都可能发生紊乱（而 UTF-8 可以在一个字符之后恢复）

因此，GB18030 在国际化的软件中不会作为内码来使用，只会是读取 / 写入文件时使用的转换编码。我们要让 Vim 支持 GB18030 也同样是如此。由于 UTF-8 编码是有明显规律的，并非任意文件都能成功地当成 UTF-8 来解码，我们一般使用的解码顺序是：

首先，检查文件是不是有 Unicode 的 BOM（字节顺序标记）字符，有的话按照 BOM 字符来转换文件内容。其次，检查文件能不能当作 UTF-8 来解码；如果可以，就当作 UTF-8 来解释。否则，尝试用 GB18030 来解码；如果能成功，就当作 GB18030 来转换文件内容。最后，如果上面的解码都不成功，就按 Latin1 字符集来解码；由于这是单字节的编码，转换必定成功。

事实上，Vim 缺省差不多就是按这样的顺序，但第三步使用何种编码跟系统配置有关。如果你明确需要处理中文，那在配置文件里最好明确写下下面的选项设定：

```
set fileencodings=ucs-bom,utf-8,gb18030,latin1
```
### 图形界面的字体配置
图形界面的 Vim 可以自行配置使用的字体，但在大部分环境里，这只是起到美化作用，而非必需项。不过，对于高分辨率屏幕的 Windows，这是一个必需项：Vim 在 Windows 下缺省使用的不是 TrueType 字体，不进行配置的话，字体会小得没法看。

在 Windows 的缺省字体里，一般而言，Consolas 和 Courier New 还比较合适。以 Courier New 为例，在 _vimrc 里可以这样配置（Windows 上的基本写法是字体名称加冒号、“h”加字号；用“_”取代空格，否则空格需要用“\”转义）：


```
if has('gui_running')
  set guifont=Courier_New:h10
endif
```
字体名称如何写是件平台相关的事（可参见帮助文档“:help gui-font”）。如果你不确定怎么写出你需要的字体配置，或者你怎么写都写不对的话，可以先使用图形界面的菜单来选择（通常是“编辑 > 选择字体”；在 MacVim 里是“Edit > Font > Show Fonts”），然后使用命令“:set guifont?”来查看。注意，Vim 在设置选项时，空格需要用“\”进行转义。比如，如果我们要在 Ubuntu 下把字体设成 10 磅的 DejaVu Sans Mono，就需要写：

```
  " Linux 和 Windows 不同，不能用 '_' 取代空格
  set guifont=DejaVu\ Sans\ Mono\ 10
```
此外，宽字符字体（对我们来讲，就是中文字体了）是可以单独配置的。这可能就更是一件仁者见仁、智者见智的事了。对于纯中文的操作系统，这一般反而是不需要配置的；但如果你的语言设定里，中文不是第一选择的话，就有可能在显示中文时出现操作系统误用日文字体的情况。这时你会想要手工选择一个中文字体，比如在 Ubuntu 下，可以用：

```
  set guifontwide=Noto\ Sans\ Mono\ CJK\ SC\ 11
```
注意，在不同的中英文字体搭配时，并不需要字号相同。事实上，在 Windows 和 Linux 上我通常都是使用不同字号的中英文字体的。

在上面的动图中，你可以观察到设了中文字体之后，不仅中文字变大，更美观了，“将”、“适”、“关”、“复”、“启”等字的字形也同时发生了变化。由于字体在各平台上差异较大，字体配置我就不写到 Vim 的参考配置中去了，只把如何选择和配置的方法写出来供你参考。

### 内容小结
好了，这一讲我就讲到这里，我们来做个内容小结。今天我给出了一张键盘图，带你复习了 Vim 教程的内容，这里我要再强调一遍，这部分的内容如果你还有不熟悉的，一定要再去学习一下 Vim 教程，这段时间我们一定要多花点时间和精力来练习，把这一步跨过去。掌握了 Vim 教程里的基础信息还远远不够，我们还得了解 Vim 的四种主要模式，你只要记住最重要的就是正常模式就可以了。最后我带你学习了 Vim 的几个基本配置选项，包括对撤销、鼠标、中文和字体的支持，来满足最基本的编辑需要。最终的 Vim 配置文件可以在 GitHub 上找到：https://github.com/adah1972/geek_time_vim关于这个配置文件，我这里做个备注说明：主（master）分支可以用在类 Unix 平台上，windows 分支则用在 Windows 上。适用于今天这一讲的内容标签是 l2-unix 和 l2-windows：你可以用 git checkout l2-unix 或 git checkout l2-windows 来得到相应平台对应本讲的配置文件。好了，掌握了今天的内容，你就可以用 Vim 做最基本的编辑了。

## 03｜更多常用命令：应对稍复杂的编辑任务

上一讲我们通过 Vim 教程学习了 Vim 的基本命令，我还给你讲解了 Vim 的基本配置，现在你就已经可以上手基本的编辑工作了。今天，我们将学习更多 Vim 的常用命令，以便更高效地进行编辑。我会先带你过一下光标移动命令和文本修改命令，然后重点讲解文本对象，随后快速讨论一下不能搭配文本修改的光标移动命令，最后讨论如何重复命令。

### 光标移动
我们先来讨论一下可以跟文本修改、复制搭配的光标移动命令。通过前面的课程，你已经知道，Vim 里的基本光标移动是通过 h、j、k、l 四个键实现的。之所以使用这四个键，是有历史原因的。你看一下 Bill Joy 开发 vi 时使用的键盘就明白了：这个键盘上没有独立的光标键，而四个光标符号直接标注在 H、J、K、L 四个字母按键上。

当然，除了历史原因外，这四个键一直使用至今，还是有其合理性的。它们都处于打字机的本位排（home row）上，这样打字的时候，手指基本不用移动就可以敲击到。因此，即使到了键盘上全都有了光标移动键的今天，很多 Vim 的用户仍然会使用这四个键来移动光标。不过，标准的光标移动键可以在任何模式下使用，而这四个键并不能在插入模式下使用，因此，它们并不构成完全的替代关系。


顺便提一句，你有没有注意到 ADM-3A 键盘上的 Esc 键在今天 Tab 的位置？在 Bill Joy 决定使用 Esc 来退出插入模式的时候，Esc 在键盘上的位置还没像今天那样跑到遥远的左上角去……Vim 跳转到行首的命令是 0，跳转到行尾的命令是 $，这两个命令似乎没什么特别的原因，一般用 < Home> 和 < End> 也没什么不方便的，虽然技术上它们有一点点小区别。如果你感兴趣、想进一步了解的话，可以参考帮助 :help < Home>。此外，我们也有 ^，用来跳转到行首的第一个非空白字符。对于一次移动超过一个字符的情况，Vim 支持使用 b/w 和 B/W，来进行以单词为单位的跳转。它们的意思分别是 words Backward 和 Words forward，用来向后或向前跳转一个单词。小写和大写命令的区别在于，小写的跟编程语言里的标识符的规则相似，认为一个单词是由字母、数字、下划线组成的（不严格的说法），而大写的命令则认为非空格字符都是单词。

根据单个字符来进行选择也很常见。比如，现在光标在 if (frame->fr_child != NULL) 第五个字符上，如果我们想要修改括号里的所有内容，需要仔细考虑 w 的选词规则，然后输入 c5w 吗？这样显然不够方便。这种情况下，我们就需要使用 f（find）和 t（till）了。它们的作用都是找到下一个（如果在输入它们之前先输入数字 n 的话，那就是下面第 n 个）紧接着输入的字符。两者的区别是，f 会包含这个字符，而 t 不会包含这个字符。在上面的情况下，我们用 t 就可以了：ct) 就可以达到目的。如果需要反方向搜索的话，使用大写的 F 和 T 就可以。对于写文字的情况，比如给开源项目写英文的 README，下面的光标移动键也会比较有用：

( 和 ) 移到上一句和下一句{ 和 } 移到上一段和下一段

在很多环境（特别是图形界面）里，Vim 支持使用 < C-Home> 和 < C-End> 跳转到文件的开头和结尾。如果遇到困难，则可以使用 vi 兼容的 gg 和 G 跳转到开头和结尾行（小区别：G 是跳转到最后一行的第一个字符，而不是最后一个字符）。光标移动咱们就讲到这里。你需要重点掌握的就是 Vim 里除了简单的光标移动，还有“小词”、“大词”、句、段的移动，以及字符的搜索；每种方式都分向前和向后两种情况。


### 文本修改
接着，我们来看文本修改。在 Vim 的教程里，我们已经学到，c 和 d 配合方向键，可以对文本进行更改。本质上，我们可以认为 c（修改）的功能就是执行 d（删除）然后 i（插入）。在 Vim 里，一般的原则就是，常用的功能，按键应尽可能少。因此很多相近的功能在 Vim 里会有不同的按键。不仅如此，大写键也一般会重载一个相近但稍稍不同的含义：

d 加动作来进行删除（dd 删除整行）；D 则相当于 d$，删除到行尾。c 加动作来进行修改（cc 修改整行）；C 则相当于 c$，删除到行尾然后进入插入模式。s 相当于 cl，删除一个字符然后进入插入模式；S 相当于 cc，替换整行的内容。i 在当前字符前面进入插入模式；I 则相当于 ^i，把光标移到行首非空白字符上然后进入插入模式。a 在当前字符后面进入插入模式；A 相当于 $a，把光标移到行尾然后进入插入模式。o 在当前行下方插入一个新行，然后在这行进入插入模式；O 在当前行上方插入一个新行，然后在这行进入插入模式。r 替换光标下的字符；R 则进入替换模式，每次按键（直到 < Esc>）替换一个字符。u 撤销最近的一个修改动作；U 撤销当前行上的所有修改。


熟练掌握这些按键需要一定的记忆和练习。但是，当你熟练掌握之后，大部分编辑操作只需要按一两个按键就能完成；而在你还没有做到熟练掌握之前，记住最简单、最有逻辑的按键也可以让你至少能够完成需要的编辑任务。

### 文本对象选择 

好，接下来就是我们今天的重点内容，文本对象的选择了。我之所以把这部分内容作为这节课的重点，是因为这是一个很方便很强大的功能，并且特别适合程序中的逻辑块的编辑。到现在，我们已经学习过，可以使用 c、d 加动作键对这个动作选定的文本块进行操作，也可以使用 v 加动作键来选定文本块（以便后续进行操作），我们也学习了好些移动光标的动作。不过，还有几个动作只能在 c、d、v、y 这样命令之后用，我们也需要学习一下。这些选择动作的基本附加键是 a 和 i。其中，a 可以简单理解为英文单词 a，表示选定后续动作要求的完整内容，而 i 可理解为英文单词 inner，代表后续动作要求的内容的“内部”。这么说，还是有点抽象，我们来看一下具体的例子。假设有下面的文本内容：

```
if (message == "sesame open")
```
我们进一步假设光标停在“sesame”的“a”上，那么（和一般的行文惯例不同，下面在命令外面也加上了引号，避免可能的歧义）：‘dw’（理解为 delete word）会删除“ame␣”，结果是“if (message == "sesopen")”‘diw’（理解为 delete inside word）会删除“sesame”，结果是“if (message == " open")”‘daw’（理解为 delete a word）会删除“sesame␣”，结果是“if (message == "open")”‘diW’会删除“"sesame”，结果是“if (message == open")”‘daW’会删除“"sesame␣”，结果是“if (message == open")”‘di"’会删除“sesame open”，结果是“if (message == "")”‘da"’会删除“"sesame open"”，结果是“if (message ==)”‘di(’或‘di)’会删除“message == "sesame open"”，结果是“if ()”‘da(’或‘da)’会删除“(message == "sesame open")”，结果是“if␣”

上面演示了 a、i 和 w、双引号、圆括号搭配使用，这些对于任何语言的代码编辑都是非常有用的。实际上，可以搭配的还有更多：搭配 s（sentence）对句子进行操作——适合西文文本编辑搭配 p（paragraph) 对段落进行操作——适合西文文本编辑，及带空行的代码编辑搭配 t（tag）对 HTML/XML 标签进行操作——适合 HTML、XML 等语言的代码编辑搭配 ` 和 ' 对这两种引号里的内容进行操作——适合使用这些引号的代码，如 shell 和 Python搭配方括号（“[”和“]”）对方括号里的内容进行操作——适合各种语言（大部分都会用到方括号吧）搭配花括号（“{”和“}”）对花括号里的内容进行操作——适合类 C 的语言搭配角括号（“<”和“>”）对角括号里的内容进行操作——适合 C++ 的模板代码

再进一步，在 a 和 i 前可以加上数字，对多个（层）文本对象进行操作。下面图中是一个示例：

你看，无论你使用什么语言，这些快捷的文本对象选择方式是不是总会有一种可以适用？我个人觉得这些功能绝对是 Vim 的强项了，所以，我再敲一次黑板，这部分内容是重点，不要嫌内容多，挨个儿用一用、练一练，你会发现这个功能非常实用，在写代码的时候常常会用得上。


### 更快地移动
除了这讲开头提到的光标移动功能外，还有一些通常不和操作搭配的光标和屏幕移动功能。我们在这节里会快速描述一下。我们仍然可以使用 < PageUp> 和 < PageDown> 来翻页，但 Vim 更传统的用法是 < C-B> 和 < C-F>，分别代表 Backward 和 Forward。除了翻页，Vim 里还能翻半页，有时也许这种方式更方便，需要的键是 < C-U> 和 < C-D>，Up 和 Down。如果你知道出错位置的行号，那你可以用数字加 G 来跳转到指定行。类似地，你可以用数字加 | 来跳转到指定列。这在调试代码的时候非常有用，尤其适合进行自动化。下图中展示了 iTerm2 中[捕获输出](https://iterm2.com/documentation-captured-output.html)并执行 Vim 命令的过程（用 vim -c 'normal 5G36|' 来执行跳转到出错位置第 5 行第 36 列）：

（如果你用 iTerm2 并对这个功能感兴趣，我设置的正则表达式是 ^([_a-zA-Z0-9+/.-]+):([0-9]+):([0-9]+): (?:fatal error|error|warning|note):，捕获输出后执行的命令是 echo "vim -c 'normal \2G\3|' \1"。）你只关心当前屏幕的话，可以快速移动光标到屏幕的顶部、中间和底部：用 H（High）、M（Middle）和 L（Low）就可以做到。顺便提一句，vimrc_example 有一个设定，我不太喜欢：它会设 set scrolloff=5，导致只要屏幕能滚动，光标就移不到最上面的 4 行和最下面的 4 行里，因为一移进去屏幕就会自动滚动。这同样也会导致 H 和 L 的功能发生变化：本来是移动光标到屏幕的最上面和最下面，现在则变成了移动到上数第 6 行和下数第 6 行，和没有这个设定时的 6H 与 6L 一样了。所以我一般会在 Vim 配置文件里设置 set scrolloff=1（你也可以考虑设成 0），减少这个设置的干扰。只要光标还在屏幕上，你也可以滚动屏幕而不移动光标（不像某些其他编辑器，Vim 不允许光标在当前屏幕以外）。需要的按键是 < C-E> 和 < C-Y>。另外一种可能更实用的滚动屏幕方式是，把当前行“滚动”到屏幕的顶部、中部或底部。Vim 里的对应按键是 zt、zz 和 zb。和上面的几个滚动相关的按键一样，它们同样受选项 scrolloff 的影响。


### 重复，重复，再重复
今天的最后，我来带你解决一个你肯定会遇到的问题，那就是如何更高效地解决重复的操作。我们已经看到，在 Vim 里有非常多的命令，而且很多命令都需要敲好几个键。如果你要重复这样的命令，每次都要再手敲一遍，这显然是件很费力的事。作为追求高效率的编辑器，这当然是不可接受的。除了我们以后要学到的命令录制、键映射、自定义脚本等复杂操作外，Vim 对很多简单操作已经定义了重复键：

; 重复最近的字符查找（f、t 等）操作, 重复最近的字符查找操作，反方向n 重复最近的字符串查找操作（/ 和 ?）N 重复最近的字符串查找操作（/ 和 ?），反方向. 重复执行最近的修改操作
有了这些，重复操作就非常简单了。要掌握它们的方法就是多练习，多用几次自然就会了。
### 内容小结

好了，今天的内容就讲完了，我们来做个小结。我们讨论了更多的一些常用 Vim 命令，包括：基本光标移动命令（可配合 c、d 和 v）文本修改命令小汇总文本对象命令（c、d、v 后的a 和 i）更快的光标和屏幕移动功能重复功能

今天讲的内容不难，重点是文本对象。你知道吗？我见到的 Vim 命令速查表里通常也没有它们，因而连很多 Vim 的老用户都不知道这些功能呢。所以，掌握了这部分内容，我们就已经走在很多 Vim 用户的前面了。请一定要多加练习，用好这个功能会大大提升你的代码编辑效率。最后，提醒你去 GitHub 上看配置文件。配置文件我们有一处改动。类似地，适用于本讲的内容标签是 l3-unix 和 l3-windows。

## 04｜初步定制：让你的 Vim 更顺手

在前几讲，我已经介绍了不少 Vim 的常用命令，我想你已经略有心得了吧。今天我们转换一下视角，来讲一下 Vim 这个软件本身。作为一个 Vim 的使用者，光熟悉命令是不够的，你还需要定制 Vim。因为每个人的习惯和需求都是不一样的，一个高度定制化的 Vim 环境能大大提高你的工作效率。今天，我会先带你了解一下 Vim 的运行支持文件目录结构，然后我们再一起探索 Vim 8 带来的新功能，及如何对 Vim 进行初步配置来使得 Vim 更加好用。

### Vim 的目录结构
Vim 的工作环境是由运行支持文件来设定的。如果你想要定制 Vim，就要熟知 Vim 有哪些不同类型的运行支持文件，分别存放在哪里，怎样能快捷地找到它们。Vim 比较有意思的一点的是，虽然运行支持文件是在 Vim 的安装目录下，但用户自己是可以“克隆”这个目录结构的。也就是说，你自己目录下的用户配置，到你深度定制的时候，也有相似的目录结构。所以，我就先从这些文件的目录结构开始讲起。


#### 安装目录下的运行支持文件
Vim 的运行支持文件在不同的平台上有着相似的目录结构。以 Vim 8.2 为例，它们的标准安装位置分别在：


大部分 Unix 下面：/usr/share/vim/vim82macOS Homebrew 下：/usr/local/opt/macvim/MacVim.app/Contents/Resources/vim/runtimeWindows 下：C:\Program Files (x86)\Vim\vim82

在这个目录下面，你可以看到很多子目录，如 autoload、colors、doc、pack、plugin、syntax 等等。这些子目录下面就是分类放置的 Vim 支持文件。最常用的子目录应该是下面这几个：

syntax：Vim 的语法加亮文件doc：Vim 的帮助文件colors：Vim 的配色方案plugin：Vim 的“插件”，即用来增强 Vim 功能的工具


以 syntax 目录为例，当前我在下面看到有 617 个文件，也就是说，Vim 对 617 种不同的文件类型提供了语法加亮支持！这里面的文件去掉“.vim”后缀后，就是文件类型的名字，你可以用类似 :setfiletype java 这样的命令来设置文件的类型，从而进行语法加亮。目录下我们可以看到大家都很熟悉的语言，也有很多我从来都没听说过的东西。只要有正当的理由，你就可以向 Vim 的作者 Bram 提交改进版本，或是对全新的语言的支持。我就对若干种文件类型提交过补丁，新增了对《计算机编程艺术》中的 MIX 汇编语言的语法支持，并维护着微软宏汇编（MASM）的语法文件。在图形界面的 Vim 里，你可以通过“语法 > 在菜单中显示文件类型”（“Syntax > Show File Types in Menu”）来展示 Vim 的所有文件类型，然后可以选择某一类型来对当前文件进行设置。这儿的菜单项，跟 syntax 目录下的文件就基本是一一对应的了。在菜单中显示文件类型这个额外的步骤，可能是因为很久很久以前，加载所有文件类型的菜单是一个耗时的操作吧。在 menu.vim 里，目前有这样的代码：

```
" Skip setting up the individual syntax selection menus unless
" do_syntax_sel_menu is defined (it takes quite a bit of time).
if exists("do_syntax_sel_menu")
  runtime! synmenu.vim
else
  …
endif
```
不知道这段注释是什么年代加上的……但显然，我们的电脑已经不会再在乎加载几百个菜单项所占的时间了。即使我不怎么用菜单，我也找不出不直接展示这个菜单的理由；我可不想在需要使用的时候再多点一次鼠标。所以，我会在我的 vimrc 文件里写上：

```
let do_syntax_sel_menu = 1
```
同理，我会加载其他一些可能会被 Vim 延迟加载的菜单，减少需要在菜单上点击的次数：

```
let do_no_lazyload_menus = 1
```
上面两个设置在我的机器上会让我打开 Vim 的速度下降大概 20 毫秒。我想我不在乎这点时间差异……我们用“:help”命令查看的帮助文件就放在 doc 目录下。我们可以用菜单“编辑 > 配色方案”（“Edit > Color Scheme”）浏览配色方案，相应的文件就在 colors 目录下。在 plugin 目录下的系统内置插件不多，我们下面就快速讲解一下：

getscriptPlugin：获得最新的 Vim 脚本的插件（在目前广泛使用 Git 的年代，这个插件过时了，我们不讲）gzip：编辑 .gz 压缩文件（能在编辑后缀为 .gz 的文件时自动解压和压缩，你会感觉不到这个文件是压缩的）logiPat：模式匹配的逻辑运算符（允许以逻辑运算、而非标准正则表达式的方式来写模式匹配表达式）manpager：使用 Vim 来查看 man 帮助（强烈建议试一下，记得使用 Vim 的跳转键 C-] 和 C-T）matchparen：对括号进行高亮匹配（现代编辑器基本都有类似的功能）netrwPlugin：从网络上编辑文件和浏览（远程）目录（支持多种常见协议如 ftp 和 scp，可直接打开目录来选择文件）rrhelper：用于支持 --remote-wait 编辑（Vim 的多服务器会用到这一功能）spellfile：在拼写文件缺失时自动下载（Vim 一般只安装了英文的拼写文件）tarPlugin：编辑（压缩的）tar 文件（注意，和 gzip 情况不同，这儿不支持写入）tohtml：把语法加亮的结果转成 HTML（自己打开个文件，输入命令“:TOhtml”就知道效果了）vimballPlugin：创建和解开 .vba 文件（这个目前也略过时了，我们不讲）zipPlugin：编辑 zip 文件（和 tar 文件不同，zip 文件可支持写入）

除了 rrhelper 和 spellfile 属于功能支持插件，没有自己的帮助页面，其他功能都可以使用“:help”命令来查看帮助。查看帮助时，插件名称中的“Plugin”后缀需要去掉：查看 zip 文件编辑的帮助时，应当使用“:help zip”而不是“:help zipPlugin”。从这些插件当中，我们已经可以看到 Vim 的一些特殊威力了吧。下面的动图里，我们可以看到部分插件功能的展示：


#### 用户的 Vim 配置目录
Vim 的安装目录你是不应该去修改的。首先，你可能没有权限去修改这个目录；其次，即使你有修改权限，这个目录会在 Vim 升级时被覆盖，你做的修改也会丢失。用户自己的配置应当放在自己的目录下，这也就是用户自己的主目录下的 Vim 配置目录（Unix 下的 .vim，Windows 下的 vimfiles）。这个目录应和 Vim 安装目录下的运行支持文件目录有相同的结构，但下面的子目录你在需要修改 Vim 的相关行为时才有必要创建。如果一个同名文件出现用户自己的 Vim 配置目录里和 Vim 的安装目录里，用户的文件优先。换句话说，修改 Vim 行为最简单的一种方式，就是把一个系统的运行支持文件复制到自己的 Vim 配置目录下的相同位置，然后修改其内容。我自己常常用这种方式来精调 Vim 的语法加亮。显然，这种方式的缺点（在适当的时候也是优点）是，如果 Vim 的运行支持文件后来被修改 / 更新了，你也会继续使用你自己目录下的老版本修改版。如果你的修改不只是你自己的临时方案、同时也适合他人的话，最佳做法还是给 Vim 项目提交补丁，让其他所有人都能用上你的修改，这样才是开源的最佳使用方式。关于 Vim 的公用脚本，这儿再多说几句。Vim 的网站过去是用来集中获取各种脚本——如插件和配色方案——的地方，而 getscriptPlugin 可以帮助简化这个过程。今天你仍然可以使用这个方法，但 Git 和 GitHub 的广泛使用已经改变了人们获取和更新脚本的方式。现在，最主流的分发 Vim 脚本的方式是利用 GitHub，而用户则使用包管理器来调用 Git 从 GitHub（或类似的 Git 库）获取和更新脚本，下面我们很快就会讲到。

理解了 Vim 的目录结构，我们接着来看 Vim 8 的新功能。


### Vim 8 新功能
Vim 是一个持续改进中的应用程序。从 Vim 8.1（2018 年 5 月 17 日）到 Vim 8.2（2019 年 12 月 12 日），Vim 有 2424 个补丁，也就是说，平均每天超过 4 个补丁。很多 Vim 8 里的大功能，并不是一次性引入，而是在补丁中慢慢引入的。比如，Vim 里现在有终端支持，这个功能从 Vim 8.0.0693 开始引入，到了 Vim 8.1，成为一个正式的大功能。站在我个人的角度看，从 Vim 7.4 到 Vim 8.2，最大的新功能是：


Vim 软件包的支持（“:help packages”）异步任务支持（“:help channel”、“:help job”和“:help timers”）终端支持（“:help terminal”）

今天我们就重点讲一下 Vim 软件包。这是 Vim 8 里带来的一个重要功能，也让我们在扩展 Vim 的时候变得更方便了。


### Vim 软件包
Vim 的目录结构有点传统 Unix 式：一个功能用到的文件可能会分散在多个目录下。就像传统 Unix 上 Vim 的文件可能分散在 /usr/bin、/usr/share/man、/usr/share/vim 等目录下一样，一个 Vim 的插件（严格来讲，应该叫包）通常也会分散在多个目录下：

插件的主体通常在 plugin 目录下插件的帮助文件在 doc 目录下有些插件只对某些文件类型有效，会有文件放在 ftplugin 目录下有些插件有自己的文件类型检测规则，会有文件放在 ftdetect 目录下有些插件有特殊的语法加亮，会有文件放在 syntax 目录下……

以前我们安装插件，一般是一次性安装后就不管了。安装过程基本上就是到 .vim 目录（Windows 上是 vimfiles 目录）下，解出压缩包的内容，然后执行 vim -c 'helptags doc|q' 生成帮助文件的索引。到了“互联网式更新”的年代，这种方式就显得落伍了。尤其糟糕的地方在于，它是按文件类型来组织目录的，而不是按相关性，这就没法用 Git 来管理了。Vim 上后来就出现了一些包管理器，它们的基本模式都是相通的：每个包有自己的目录，然后这些目录会被加到 Vim 的运行时路径（runtimepath）选项里。最早的 runtimepath 较为简单，在 Unix 上缺省为：

```
$HOME/.vim,
$VIM/vimfiles,
$VIMRUNTIME,
$VIM/vimfiles/after,
$HOME/.vim/after```
```
而在有了包管理器之后，runtimepath 就会非常复杂，每个包都会增加一个自己的目录进去。但是，好处也是非常明显的，包的管理变得非常方便。从 Vim 8 开始，Vim 官方也采用了类似的体系。Vim 会在用户的配置目录（Unix 下是 $HOME/.vim ，Windows 下是 $HOME/vimfiles ）下识别名字叫 pack 的目录，并在这个目录的子目录的 start 和 opt 目录下寻找包的目录。听着有点绕吧？我们看一个实际的 Vim 配置目录的结构就清楚了：

```
.
├── colors
├── doc
├── pack
│   ├── minpac
│   │   ├── opt
│   │   │   ├── minpac
│   │   │   ├── vim-airline
│   │   │   └── vimcdoc
│   │   └── start
│   │       ├── VimExplorer
│   │       ├── asyncrun.vim
│   │       ├── fzf.vim
│   │       ├── gruvbox
│   │       ├── killersheep
│   │       ├── nerdcommenter
│   │       ├── nerdtree
│   │       ├── tagbar
│   │       ├── undotree
│   │       ├── vim-fugitive
│   │       ├── vim-matrix-screensaver
│   │       ├── vim-rainbow
│   │       ├── vim-repeat
│   │       ├── vim-rhubarb
│   │       └── vim-surround
│   └── my
│       ├── opt
│       │   ├── YouCompleteMe
│       │   ├── ale
│       │   ├── clang_complete
│       │   ├── cvsmenu
│       │   └── syntastic
│       └── start
│           ├── vim-gitgutter
│           └── ycmconf
├── plugin
├── syntax
└── undodir
```
可以看到，pack 目录下有 minpac 和 my 两个子目录（这些名字 Vim 不关心），每个目录下面又有 opt 和 start 两个子目录，再下面就是每个包自己的目录了，里面又可以有自己的一套 colors、doc、plugin 这样的子目录，这样就方便管理了。Vim 8 在启动时会加载所有 pack/*/start 下面的包，而用户可以用 :packadd 命令来加载某个 opt 目录下的包，如 :packadd vimcdoc 命令可加载 vimcdoc 包，来显示中文帮助信息。有了这样的目录结构，用户要自己安装、管理包就方便多了。不过，我们还是推荐使用一个包管理器。包管理器可以带来下面的好处：

根据文本的配置（一般写在 vimrc 配置文件里）决定要安装哪些包自动化安装、升级和卸载，包括帮助文件的索引生成

在我们这门课程里，我会使用 minpac，一个利用 Vim 8 功能的小巧的包管理器。如果你已经在使用其他包管理器，我接下来讲的两个小节你可以考虑跳过。

### 安装 minpac
根据 minpac 网页上的说明，我们在 Windows 下可以使用下面的命令：

```
cd /d %USERPROFILE%
git clone https://github.com/k-takata/minpac.git ^
    vimfiles\pack\minpac\opt\minpac
```
在 Linux 和 macOS 下则可以使用下面的命令：

```
git clone https://github.com/k-takata/minpac.git \
    ~/.vim/pack/minpac/opt/minpac
```
然后，我们在 vimrc 配置文件中加入以下内容（先不用理解其含义）：

```
if exists('*minpac#init')
  " Minpac is loaded.
  call minpac#init()
  call minpac#add('k-takata/minpac', {'type': 'opt'})

  " Other plugins
endif

if has('eval')
  " Minpac commands
  command! PackUpdate packadd minpac | source $MYVIMRC | call minpac#update('', {'do': 'call minpac#status()'})
  command! PackClean  packadd minpac | source $MYVIMRC | call minpac#clean()
  command! PackStatus packadd minpac | source $MYVIMRC | call minpac#status()
endif

```
存盘、重启 Vim 之后，我们就有了三个新的命令，可以用来更新（安装）包、清理包和检查当前包的状态。

### 通过 minpac 安装扩展包
下面我们就来试验一下通过 minpac 来安装扩展包。我们在“Other plugins”那行下面加入以下内容：


```
call minpac#add('tpope/vim-eunuch')
```
保存文件，然后我们使用 :PackUpdate 命令。略微等待之后，我们就能看到类似下面的界面：

![img](https://static001.geekbang.org/resource/image/10/4c/10885cf1c7406883c70838015971fb4c.png?wh=1352*928)


这就说明安装成功了。我们可以按 q 来退出这个状态窗口。我们也可以使用 :PackStatus 来重新打开这个状态窗口。要删除一个插件，在 vimrc 中删除对应的那行，保存，然后使用 :PackClean 命令就可以了。愿意的话，你现在就可以试一下。


### 最近使用的文件
安装好 Vim 软件包之后，我们进一步来实现一个小功能。Vim 的缺省安装缺了一个很多编辑器都有的功能：最近使用的文件。我们就把这个功能补上吧。你只需要按照上一节的步骤安装 yegappan/mru 包就可以了（MRU 代表 most recently used）。安装完之后，重新打开 vimrc 文件，你就可以在图形界面里看到下面的菜单了：

![img](https://static001.geekbang.org/resource/image/2c/d6/2c44030349043755a98f9e237ae534d6.png?wh=1318*952)


估计你很可能会问：如果是远程连接，没有图形界面怎么办？我们仍可以在文本界面上唤起菜单，虽然美观程度会差点。你需要在 vimrc 配置文件中加入以下内容（同样，我们暂时先不用去理解其意义）：

```
if !has('gui_running')
  " 设置文本菜单
  if has('wildmenu')
    set wildmenu
    set cpoptions-=<
    set wildcharm=<C-Z>
    nnoremap <F10>      :emenu <C-Z>
    inoremap <F10> <C-O>:emenu <C-Z>
  endif
endif
```
在增加上面的配置之后，你就可以使用键 <F10>（当然你也可以换用其他键）加 <Tab> 来唤起 Vim 的文本菜单了。如下图所示：

![img](https://static001.geekbang.org/resource/image/f4/d8/f4435e4c42a7cf2be74f563e4f0b0fd8.gif?wh=984*736)



### 内容小结
本讲我们讨论了 Vim 8 下的基本目录结构和 Vim 8 的软件包。你需要知道，Vim 的运行支持目录和用户配置目录有相似的结构，用户配置目录下的文件优先于 Vim 安装目录下的文件。因此，在用户配置目录里进行修改，可以在 Vim 版本有变化时保留自己的定制行为。而 Vim 8 的软件包使得维护 Vim 的扩展变得更为容易，每一个 Vim 软件包都是独立的目录，可以单独安装、修改和升级。包管理器，如 minpac，则可以帮助我们更方便地安装和管理 Vim 软件包。对于配置文件，适用于本讲的内容标签是 l4-unix 和 l4-windows。


## 05｜多文件打开与缓冲区：复制粘贴的正确姿势


在前面的几讲里，我们介绍了 Vim 的基本命令和配置。有了这些基本功，单个文件的基本编辑对你来说应该已经不成问题了。不过，显然我们在工作和生活中不可能只用一个文件包打天下，你肯定还会遇到需要同时编辑多个文件的情况。今天，我们就来细细讨论一下这个话题，什么是编辑多个文件的正确姿势。先来假设一个简单的使用场景，我们现在需要在某个目录下的所有 .cpp 和 .h 文件开头贴入一段版权声明，该如何操作？

### 单文件的打开方式
#### 图形界面
使用图形界面的话，我们可以在操作系统的资源管理器里进入到合适的目录，然后逐个使用 Vim 来打开文件。我们可以使用右键菜单（“Edit with Vim”、“Open with…”等），也可以直接把文件拖拽到 Vim 里。使用“文件 > 打开”（File > Open）菜单当然也是一种选择，但这需要你记住上次打开到第几个文件，并不如使用资源管理器方便。使用这几种编辑方式的话，你可以把需要粘贴的内容放到操作系统的剪贴板里，然后在图形界面的 Vim 里用以下方法之一粘贴进去（当然，如果光标不在开头的话，先用鼠标或用 gg  命令跳转到开头）：

正常模式 Vim 命令 "+P（意义我们后面再解释）快捷键 < D-V>（提醒：这是我们对 ⌘V 的标记方式；仅适用于 macOS）或 < S-Insert>（PC 键盘）鼠标右键加“粘贴”（Paste）菜单“编辑 > 粘贴”（Edit > Paste）

注意，如果你通常使用 Ctrl-V 键粘贴的话，这个快捷键在 Vim 里并不适用。即使你使用的是图形界面的 Vim 也是如此，因为这个键在 Vim 里有其他用途。顺便说一句，这个键在 Unix 终端上也一样是不能用作粘贴的。显然，在远程连接到服务器上时，以上方法不可用，我们得考虑终端 Vim 的用法。


#### 终端 Vim
如果直接把图形界面下的基本步骤，翻译成终端 Vim（非图形界面）的用法的话，应该是这样子的：


在终端里进入到目标目录下使用 vim 文件名 来逐一打开需要编辑的文件如果光标不在开头的话，用鼠标或 gg  命令跳转到开头使用命令 i 进入插入模式使用终端窗口的粘贴命令或快捷键（如 < S-Insert>）来粘贴内容按 < Esc> 回到正常模式并用 ZZ 存盘退出


或者，我们还可以采用下面的不退出 Vim 的处理方法：打开文件使用 :e 文件名；可以使用 < C-D> 来查看有哪些文件，及用 < Tab> 进行自动完成存盘使用 :w

但是如果粘贴的内容含缩进、而 Vim 又不够新的话，我们还会有特殊的麻烦。请继续往下看。
#### Vim 老版本的特殊处理

![img](https://static001.geekbang.org/resource/image/4b/0c/4b68d006f7f3b2003700b3001fb48f0c.png?wh=1468*1014)

上面的图片展示了 Vim 用户可能遇到的一种错误情况。这是因为对于终端 Vim 来说，一般而言，它是没法分辨用户输入和粘贴的。因此，在粘贴内容时，Vim 的很多功能，特别是和自动缩进相关的，就会和输入打架，导致最后的结果不对。要解决这个问题，你就得让 Vim 知道，你到底是在输入还是在粘贴。Vim 有一个 paste 选项，就是用来切换输入 / 粘贴状态的。如果这个选项打开的话（:set paste），Vim 就认为你在粘贴，智能缩进、制表符转换等功能就不会修改粘贴的内容。不过，手工设置该选项（及事后用 set nopaste 取消）是件烦人的事。所幸 xterm 里有一个“括号粘贴模式”（bracketed paste mode）可以帮 Vim 判断目前是输入还是粘贴。这个模式启用后，终端在发送剪贴板的内容之前和之后都会发送特殊的控制字符序列，来通知应用程序进行特殊的处理。启用括号粘贴模式需要向 xterm 发送启用序列 < Esc>[?2004h，关闭括号粘贴模式需要向 xterm 发送关闭序列 < Esc>[?2004l；在启用了括号粘贴模式后，xterm 在发送剪贴板内容时会在前后分别加上开始粘贴序列 < Esc>[200~ 和结束粘贴序列 < Esc>[201~。Vim 8.0.0210 开始引入了对括号粘贴模式的支持。在兼容 xterm 的终端里进行粘贴时，你不再需要使用 paste 这个选项了。更棒的是，目前你甚至都不需要进入插入模式就可以粘贴了——这是不是就方便多了？如果你使用的是 Vim 8.0.0210 之前的版本的话，那我们至少也可以通过代码来使得手工设置 paste 选项变得不必要。你可以在 vimrc 里加入下面的代码：

```
if !has('patch-8.0.210')
  " 进入插入模式时启用括号粘贴模式
  let &t_SI .= "\<Esc>[?2004h"
  " 退出插入模式时停用括号粘贴模式
  let &t_EI .= "\<Esc>[?2004l"
  " 见到 <Esc>[200~ 就调用 XTermPasteBegin
  inoremap <special> <expr> <Esc>[200~ XTermPasteBegin()

  function! XTermPasteBegin()
    " 设置使用 <Esc>[201~ 关闭粘贴模式
    set pastetoggle=<Esc>[201~
    " 开启粘贴模式
    set paste
    return ""
  endfunction
endif
```
这个功能虽然小，但解决了在远程连接上使用 Vim 粘贴代码的一个常见烦恼。因此，我认为你需要了解一下。


#### “已经存在交换文件！”
对每个文件单独使用一个 Vim 会话来编辑，很容易出现冲突的情况，所以你迟早会遇到“已经存在交换文件！”（Swap file “…” already exists!）的错误提示。出现这个提示，有两种可能的原因：你上次编辑这个文件时，发生了意外崩溃。你已经在使用另外一个 Vim 会话编辑这个文件了。

原因不同，我们处理的策略自然也不相同。当进程 ID（process ID）后面没有“STILL RUNNING”这样的字样时，那就是情况 1；否则，就是情况 2 了。

![img](https://static001.geekbang.org/resource/image/d0/27/d09c693ab664af0853139d8f04eedd27.png?wh=1280*770)

上图中没有“STILL RUNNING”的字样，说明是情况 1。这时你需要按 r 来恢复上次的编辑状态——Vim 支持即使在你没有存盘的情况下仍然保存你的编辑状态，因而这种方法可以恢复你上次没有存盘的内容。需要注意的是，在恢复之后，Vim 仍然不会删除崩溃时保留下来的那个交换文件。因此，在确定内容无误、保存文件之后，你需要重新再打开文件，并按 d 键把交换文件删除。当然，如果你确定目前保存的文件版本就是你想要的，也可以直接按 d 把交换文件删除、重新编辑文件。反过来，如果你已经在另一个 Vim 会话里编辑文件的话，我们就会在进程 ID 后面看到“STILL RUNNING”的字样；同时，Vim 界面上也没有了删除（Delete）交换文件这一选项。

![img](https://static001.geekbang.org/resource/image/a4/6f/a45521128650b2824381de6f84911b6f.png?wh=1280*770)

这时，大部分情况下我们应当使用 q 或 a（绝大部分情况下没有区别）放弃编辑，并找到目前已经打开的 Vim 窗口，从那里继续。少数情况下，我们只是要查看文件，那也可以选择 o 只读打开文件。需要使用 e 强行编辑的情况很少，需要非常谨慎——比如，你确认另外有 Vim 会话，但里面不会去做任何修改，这是我目前想得出来的唯一的合理需求。如果我们使用图形界面 Vim 8 的话，Vim 支持在文件已经打开时自动切换到已经打开的 Vim 窗口上。这个功能在文件处于一个不活跃的标签页（下一讲会讨论标签页支持）时特别有用，因为 Vim 能把这个标签页自动切到最前面。不过，这个功能不是默认激活的，我们需要在 vimrc 中加入以下内容：

```
if v:version >= 800
  packadd! editexisting
endif
```
好了，目前我们已经讨论了最简单、无聊、低效的工作方式。可以明显看到，不管是使用图形界面 Vim，还是终端 Vim，上面的方法本质上把 Vim 当成了记事本来用，完全没有体现出任何高效性或方便性。既然使用号称“高效”的 Vim，我们当然就得有更加高效的做法。下面，我们以多文件打开为例加以说明。


#### 多文件的打开方式
首先，我们需要知道，Vim 支持一次性打开多个文件，你只需要在命令行上写出多个文件即可，或者使用通配符。比如，就我们刚才所说的编辑场景，我们可以使用 vim *.cpp *.h。有可能让你吃惊的是，输入这个命令之后，Vim 只打开了一个文件，那就是所有文件中的第一个。原来，为了确保在配置较差的环境里仍然能够正常工作，Vim 绝对不会不必要地消耗内存，包括打开不必要立即打开的文件。所以在上面的命令后，Vim 建立了一个文件列表，并且暂时只打开其中的第一个文件。接下来，用户可以决定，要编辑哪个文件，或者查看列表，或者提前退出，等等。为此，Vim 提供了以下命令：

:args：可以显示“参数”，即需要编辑的多个文件的列表:args 文件名：使用新的文件名替换参数列表:next（可缩写为 :n）：打开下一个文件；如当前文件修改（未存盘）则会报错中止，但如果命令后面加 ! 则会放弃修改内容，其他命令也类似:Next（缩写 :N）或 :previous（缩写 :prev）：打开上一个文件:first 或 :rewind：回到列表中的第一个文件:last：打开列表中的最后一个文件

使用这些命令，我们的工作流当然就会发生变化了：

1. 在终端里进入到目标目录下
2. 使用 vim *.cpp *.h 或 gvim *.cpp *.h 来打开需要编辑的文件
3. 对于第一个文件，使用之前的方法贴入所需的文本
4. 使用 V 进入行选择的可视模式，移动光标选中所需的文本，然后使用 y 复制选中的各行
5. 执行命令 :set autowrite，告诉 Vim 在切换文件时自动存盘
6. 执行命令 :n|normal ggP，切换到下一个文件并执行正常模式命令 ggP，跳转到文件开头并贴入文本
7. 确认修改无误后，键入 :、上箭头和回车，重复执行上面的命令
8. 待 Vim 报错说已经在最后一个文件里，使用 :w 存盘，或 :wq（抑或更快的 ZZ）存盘退出

注意，第 6 步可以拆成 :n 和 ggP 两步，但文件数量较多时，反复手工敲 ggP 也挺累的。因此，我这儿使用了 normal 命令，在命令行模式下执行正常模式命令，下面就可以直接重复切换命令加粘贴命令，我们的编辑效率也得以大大提升。

![img](https://static001.geekbang.org/resource/image/7b/cd/7b2341087d8a34471b9c1979acdcddcd.gif?wh=984*690)


这种编辑方式，是不是就比之前的优越多了？另外，Vim 还能解决一个 shell 相关的不一致性问题。如果我们要编辑的文件除了当前目录下的，还有所有子目录下的，在大部分 shell 下，包括 Linux 上缺省的 Bash，我们需要使用`“*.cpp *.h **/*.cpp **/*.h”`来挑选这些文件，重复、麻烦。Vim 在此处采用了类似于 Zsh 的简化语法，“**”也包含了当前目录。这样，我们只需把上面第 2 步改成下面这样即可：

键入 vim 进入 Vim，然后使用 :args **/*.cpp **/*.h 来打开需要编辑的文件

#### 缓冲区的管理和切换
跟多文件相关又略微不同的一个概念是缓冲区（buffer）。它是 Vim 里的一个基本概念，和今天讲的很多其他内容有相关性和相似性，你也或迟或早终究会遇到它，我今天也一起概要描述一下。Vim 里会对每一个已打开或要打开的文件创建一个缓冲区，这个缓冲区就是文件在 Vim 中的映射。在多文件编辑的时候你也会有同样数量的缓冲区。不过，缓冲区的数量常常会更高，因为你用 :e 等命令打开的文件不会改变“命令行参数”（只被命令行或 :args 命令修改），但同样会增加缓冲区的数量。此外，:args 代表参数列表 / 文件列表，真的只是文件的列表而已。缓冲区中有更多信息的，最最基本的就是记忆了光标的位置。在 Vim 里，除了切换到下一个文件这样的批处理操作外，操作缓冲区的命令比简单操作文件的命令更为方便。作为对比，我们来看一下文件列表和缓冲区列表的命令的结果。

![img](https://static001.geekbang.org/resource/image/33/08/3395a72ee4776c49748243fac411e008.png?wh=1396*344)

![img](https://static001.geekbang.org/resource/image/0f/a4/0ff5249a78179117dfcda70715dc3aa4.png?wh=1396*172)

可以看到，两者都展示了文件，都标示出了当前编辑的文件（分别使用方括号和“%a”）。不过，缓冲区列表中明显有更多的信息：

文件名前面有编号；我们也马上就会说到利用编号的命令。除了当前活跃文件的标记“%a”，还有个文件被标成了“#”，这表示最近的缓冲区；缓冲区列表里还可能有其他标记，如“+”表示缓冲区已经被修改。文件名后面有行号，表示光标在文件中的位置。


常用的缓冲区命令跟前面文件列表相关的命令有很大的相似性，因此我在这儿一起讲，可以帮助你记忆：:buffers 或 :ls：可以显示缓冲区的列表:buffer 缓冲区列表里的编号（:buffer 可缩写为 :b）：跳转到编号对应的缓冲区；如当前缓冲区已被修改（未存盘）则会报错中止，但如果命令后面加 ! 则会放弃修改内容；其他命令也类似:bdelete 缓冲区列表里的编号（:bdelete 可缩写为 :bd）：删除编号对应的缓冲区；编号省略的话删除当前缓冲区:bnext（缩写 :bn）：跳转到下一个缓冲区:bNext（缩写 :bN）或 :bprevious（缩写 :bp）：跳转到上一个缓冲区:bfirst 或 :brewind：跳转到缓冲区列表中的第一个文件:blast：跳转到缓冲区列表中的最后一个文件

还有很常见的一种情况是，我们需要在两个文件之间切换。Vim 对最近编辑的文件（上面提到的列表里标有“#”的文件）有特殊的支持，使用快捷键 < C-^> 可以在最近的两个缓冲区之间来回切换。这个快捷键还有一个用法是在前面输入缓冲区的编号：比如，用 1< C-^> 可以跳转到第一个缓冲区（跟命令行模式的命令 :bfirst 或 :b1 效果相同）。从实际使用的角度，使用缓冲区列表有点像打开最近使用的文件菜单（但缓冲区列表不会存盘），可以当作一种快速切换到最近使用的文件的方式。缓冲区是文件在某个 Vim 会话里的映射。这意味着，如果某个 Vim 会话里不同的窗口或标签页（下一讲里会讨论）编辑的是同一个文件，它们对应到的也会是同一个缓冲区。更重要的是，文件 / 缓冲区的修改在同一个 Vim 会话里是完全同步的——这就不会像在多会话编辑时那样发生冲突和产生错误了。

### 内容小结
本讲通过讨论使用 Vim 在多个文件里粘贴代码的多种方法，我们学习了以下知识：在图形界面和终端里，粘贴系统剪贴板的内容需要使用不同的方法：前者使用 Vim 命令，后者则需进入插入模式，使用终端的粘贴命令进行粘贴Vim 能在崩溃后恢复未存盘的内容，也能在多会话编辑同一个文件时检测到这种冲突在 Vim 里我们可以使用通配符“*. 后缀”和“**/*. 后缀”来打开多个文件使用 :args 命令我们可以展示或替换参数列表，使用 :next 等命令我们可以在这些参数指定的文件中切换使用 :buffers 或 :ls 命令我们可以展示缓冲区列表，即所有已编辑和将编辑的文件，使用 :b 和 :bnext 等命令我们可以在这些缓冲区中进行切换今天讲到了一些命令行模式的命令，你应该可以看到，它们都是非常有规律的，最基本的操作就是“first”、“last”、“next”、“Next” 或 “previous”等英文单词，以及它们与前缀的组合。把命令行模式的命令记住，就能完成基本的编辑任务；至于像 < C-^> 这样的正常模式命令，万一记不住，也可以用命令行模式的命令来替代。但是，正常模式的命令更加高效，有助于提高你的编辑效率，所以最好通过多加练习来形成“肌肉记忆”。对于配置文件，本讲只有很小的更改，对应的标签是 l5-unix 和 l5-windows。


## 06｜窗口和标签页：修改、对比多个文件的正确姿势

上一讲我们讨论了多文件的编辑。不过，迄今为止，我们即使编辑多个文件，也是在单个窗口里进行的。这样做的局限在于，我们既不能同时修改两个文件，也不能在单个 Vim 会话里对比显示两个文件。当然了，在两个 Vim 会话里倒是可以做到，但有很多不足之处，其中之一就是容易出现“已经存在交换文件”这样的冲突。所以，这一讲我们就来讨论一下如何利用多窗口、多标签页编辑来实现这些功能。

### 多窗口编辑
Vim 有窗口的概念。事实上，如果你使用过 Vim 的帮助功能的话，那你就已经见过 Vim 的多窗口界面了。在那种情况下，Vim 自动打开了一个水平分割的帮助窗口。那如果我们想要自己同时查看、编辑多个文件呢？最基本的命令就是 :split（缩写 :sp）了。这个命令后面如果有文件名，表示分割窗口并打开指定的文件；如果没有文件名，那就表示仅仅把当前窗口分割开，当前编辑的文件在两个窗口里都显示。跟显示帮助文件一样，:split 默认使用水平分割的方式。既然我说了“水平分割”，聪明如你，一定想到了还有竖直分割。确实如此。由于 Vim 经常是在终端窗口里打开，而终端宽度常常不能允许在竖直分割时显示两个文件，所以 Vim 默认分割是水平方式。竖直分割要求屏幕比较宽，但如果你想对比两个文件时，竖直分割就会更方便了。我们可以在会产生分割的命令（如 help 和 split）之前加上 vertical（缩写 vert），来进行竖直分割。对于最常见的竖直分割操作，我们则可以直接写成 :vsplit（缩写 :vs）。下面的动画展示了我们进行一次竖直分割后，再进行水平分割的过程：

![img](https://static001.geekbang.org/resource/image/e0/db/e0ea398be76e787d9f06b22d62756bdb.gif?wh=1548*1082)

多窗口编辑是一个比较适宜使用鼠标的情况。你可以使用鼠标来激活想要使用的窗口，也可以使用鼠标来拖拉窗口的大小——只要启用了鼠标支持，终端窗口（包括远程连接的 mintty、PuTTY 等）里的 Vim 的窗口分割线也是可以拖动的（上面动画里的分割线拖动就是在一个终端窗口里）。

当然，作为 Vim 用户，基本的键盘使用肯定是少不了的：
```
<C-W> 加方向键（h、j、k、l、<Left> 等等）可以在窗口之间跳转
<C-W>w 跳转到下一个（往右和往下）窗口，如果已经是右下角的窗口，则跳转到左上角的窗口
<C-W>W 跳转到上一个（往左和往上）窗口，如果已经是左上角的窗口，则跳转到右下角的窗口
<C-W>n 或 :new 打开一个新窗口
<C-W>c 或 :close 关闭当前窗口；当前窗口如果已经是最后一个则无效
<C-W>q 或 :quit 退出当前窗口，当最后一个窗口退出时则退出 Vim
<C-W>o 或 :only 只保留当前窗口，关闭其他所有窗口
<C-W>s 和 :split 作用相同，把当前窗口横向一分为二
<C-W>v 和 :vsplit 作用相同，把当前窗口纵向一分为二
<C-W>= 使得所有窗口大小相同（当调整过终端或图形界面 Vim 的窗口大小后特别有用）<C-W>_ 设置窗口高度，命令前的数字表示高度行数，默认为纵向占满（想专心编辑某个文件时很有用）
<C-W>| 设置窗口宽度，命令前的数字表示宽度列数，默认为横向占满
<C-W>+ 增加窗口的高度，命令前的数字表示需要增加的行数，默认为 1
<C-W>- 减少窗口的高度，命令前的数字表示需要减少的行数，默认为 1
<C-W>> 增加窗口的宽度，命令前的数字表示需要增加的列数，默认为 1
<C-W><lt>（提醒，我们用 <lt> 表示“<”键）减少窗口的宽度，命令前的数字表示需要增加的列数，默认为 1
```
由于切换窗口是一个非常常见的操作，我通常会映射一下快捷键。为了跟一般的图形界面程序一致，我使用了 Ctrl-Tab 和 Ctrl-Shift-Tab：

```
nnoremap <C-Tab>   <C-W>w
inoremap <C-Tab>   <C-O><C-W>w
nnoremap <C-S-Tab> <C-W>W
inoremap <C-S-Tab> <C-O><C-W>W
```
简单解释一下：nnoremap 命令映射正常模式下的键盘，inoremap 命令映射插入模式下的键盘；正常模式的映射简单直白，应该不需要解释，插入模式的映射使用了临时模式切换键 < C-O>（:help i_CTRL-O），在正常模式下执行相应的窗口命令，然后返回插入模式。使用这样的键盘映射之后，这两个快捷键在正常模式和插入模式下就都可以使用了。

#### 双窗口比较
多窗口编辑中有一个非常有用的使用方式，那就是比较两个文件，Vim 对此也有特殊的支持。使用 vimdiff 或 gvimdiff 命令，后面跟两个文件名，我们就可以对这两个文件进行比较。在比较时，Vim 会自动折叠相同的代码行，并加亮两边文本的不同部分。窗口的滚动也是联动的。一个实际的截图如下所示：

![img](https://static001.geekbang.org/resource/image/fc/08/fc9a2b82ece7eaeeb940806bfcae9b08.png?wh=2434*586)


顺便说一句，因为使用双窗口比较功能要求 Vim 的宽度是平时的两倍左右，所以我通常都会对 Vim 窗口使用最大化、拖拉之类的操作。这些操作一般只影响右边的窗口的大小，因此，在放大窗口的操作后，我通常紧跟着就会执行 < C-W>= 来使两个窗口的宽度相同——事实上，我使用 < C-W>= 主要就在这种场合。你也可以试试。当然了，在 Vim 内部也可以发起这样的比较。你需要做的是打开第一个文件，然后使用命令 :vert diffsplit 第二个文件。这一点只要了解一下就好，毕竟大部分情况下你不需要这样去做。

### 多标签页编辑
接下来我们继续讨论和多窗口编辑构成互补的另外一种方式，也就是多标签页。这里我先给你一个结论：**单窗口多文件编辑最适合的场景是批量修改具有相似性质的文件，多窗口编辑最适合的场景是需要对多个文件进行对比编辑，而其他的一些同时编辑多个文件的场景，就可以考虑多标签页的编辑方式**。我把多标签页编辑归为“其他”，但仍然还是有其特殊性质的。如果你熟悉现代多标签页的其他编辑器的话，你应该已经熟悉它的基本特性了。我们这儿再温习一下：


多标签页编辑允许在编辑器里同时修改多个（未存盘的）文件   多标签页编辑一次只展示一个文件   通过选择标签页（或使用键盘）可以方便地在多个标签页中进行切换

Vim 中的标签页在图形界面或终端模式下都能支持上面描述的这些特性。

![img](https://static001.geekbang.org/resource/image/7a/71/7a8a884f991d412fc2dyy41ef5ab7971.png?wh=1420*524)


鉴于你在实际使用中对标签页这种方式应当已经相当熟悉，如何使用标签页图形界面我就不讲了。有一点需要注意一下，和某些图形界面应用程序不同，Vim 里标签页可包含多个窗口（一个标签页里默认有一个窗口），而不是窗口可包含多个标签页——这也意味着，在标签页里关闭最后一个窗口就关闭了整个标签页。此外，Vim 的标签页在纯文本的终端模式里也是可用的。在存在多个标签页的情况下，即使在终端里，你也可以用鼠标点击标签页来进行切换，双击标签栏的空白处添加新标签页，以及点击“X”标记来关闭标签页。当然，Vim 用户更经常会使用键盘：

- 在已有命令行模式命令前加 tab␣ 可以在新标签页中展示命令的结果，如 
- :tab help 可以在新标签页中打开帮助，
- :tab split 可以在新标签页中打开当前缓冲区
- :tabs 展示所有标签页的列表
- :tabnew 或 :tabedit 可以打开一个空白的新标签页，后面有文件名的话则打开该文件
- :tabclose 可以关闭当前标签页（如果标签页里只有一个窗口，使用窗口关闭命令 < C-W>c 应该更快）
- :tabnext、gt 或 < C-PageDown> 可以切换到下一个标签页
- :tabNext、:tabprevious 、gT 或 < C-PageUp> 可以切换到上一个标签页
- :tabfirst 或 :tabrewind 切换到第一个标签页
- :tablast 切换到最后一个标签页

这些命令跟多文件、多缓冲区的命令有诸多相似之处，我就不需要再多加描述了。如果一开始用多窗口编辑，后来发现不需要一直参照这个文件了，或者屏幕空间不足了，该怎么办呢？Vim 提供了一个命令，可以把当前窗口转变成一个新标签页：按下 <C-W>T 即可（仅当当前屏幕上有多个窗口时有效）。这讲我们对多窗口和多标签页编辑的基本讨论到这儿就暂告一个段落。不知道你记不记得，上一讲我们说过，如果某个 Vim 会话里不同的窗口（或标签页；以下略）编辑的是同一个文件，它们对应到的也会是同一个缓冲区。这意味着多个窗口编辑同一个文件不会有冲突，同时，如果缓冲区被修改了，但只要当前关闭的窗口不是包含这个缓冲区的唯一窗口，那关闭窗口不会有任何问题，也不会影响文件的状态。在任何一个瞬间，任何一个窗口都指向一个缓冲区，而任何一个缓冲区都属于一个或多个窗口。（例外情况是你使用了一个不那么常用的功能，隐藏缓冲区；这个功能在本课程中不会讨论。）

### NERDTree 插件
讨论了多窗口和多标签页之后，我们来看几个利用这些特性的插件。我们讨论的第一个插件就是 NERDTree。我们上一讲开始提出的问题就是对多个文件进行编辑。对于找文件这件事，NERDTree 就是你知道文件大概在哪里、但不知道文件具体名字时的一个好选择。跟很多 Vim 插件一样，NERDTree 会利用多窗口（少数情况下利用标签页）的特性。拿我们上一讲提到的在文件开头插入版权声明的例子来说，至少在文件在一个目录下的情况下，使用一个文件浏览插件也能解决问题。NERDTree 就是最为著名的一个文件浏览 / 管理插件。下面是一个功能展示截图，先给你一个直观的印象：

![img](https://static001.geekbang.org/resource/image/77/1f/776ac4fc034b3556f4639c42c1ed1b1f.png?wh=1426*1204)


#### 安装
如果使用 minpac 的话，我们需要在 vimrc 中“Other plugins”那行下面加入下面的语句，并运行 :PackUpdate 来安装一下：

```
call minpac#add('preservim/nerdtree')
```
NERDTree 缺省就会抢占 netrw 使用的路径形式，所以我们可以用 :e . 来打开 NERDTree。不过，更常用的方式仍然是使用 :NERDTreeToggle，NERDTree 窗口的切换命令。我们使用这个命令可以打开上面左侧的那个 NERDTree 窗口，也可以关闭。这样，我们如果频繁需要浏览文件系统的话，就可以把这个命令映射到一个快捷键，免得每次都要打这么长的命令。鉴于功能键只有 12 个，映射其他键容易忘记，我暂时就不帮你在 vimrc 中映射了。对我来说，这个插件是需要安装的，但使用并不那么高频。

#### 使用
在打开 NERDTree 窗口之后，使用还是相当直观的，并且按下 ? 就可以查看帮助信息，所以我也不必一一列举所有功能了。在这里，我就概要提一下最重要的几个功能点：

顾名思义，这个插件以树形方式展示文件系统，在目录上敲回车或双击即可打开或关闭光标下的目录树。在文件上敲回车或双击立即打开该文件，并且光标跳转到文件窗口中，这样你就可以立即开始编辑了。在文件上使用 go 会预览该文件，也就是光标不会跳转到文件所在的窗口中，方便快速查看多个文件的内容。按 i 会打开文件到一个新的水平分割的窗口中，按 s 会打开文件到一个新的竖直分割的窗口中，按 t 会打开文件到一个新的标签页中。NERDTree 会自动过滤隐藏文件和目录，但如果你需要看到它们的话，也可以用 I 来开启和关闭隐藏文件的显示。按 m 会出现一个菜单，允许添加、删除、更名等操作。

这些命令不需要死记硬背。从使用的角度，知道回车、双击就可以使用这个插件了，其他命令可以根据需要，在使用中慢慢掌握。

#### 类似插件
Vim 里预置了 netrw 插件，其功能包含多个网络文件协议，同时也包含了对本地文件系统的支持，使用 :e . 或 :vs . 这样的命令就可以直接启用。不过，它在本地目录浏览相关功能上比较简单，没有 NERDTree 好用。如果有条件安装 NERDTree 的话，你一定会更喜欢 NERDTree 的。我的朋友明白（mbbill）写了个叫 [VimExplorer](https://github.com/mbbill/VimExplorer) 的插件，我也挺喜欢的，一直在用。它可以把 Vim 转变成一个双面板的资源管理器，设计上也更侧重于管理，而不是纯粹的文本编辑。不过，这个插件没有像 NERDTree 一样处于积极开发状态，我就不详细介绍了。有兴趣的可以自己试一下。


### 内容小结
好了，这一讲到这里我就全部讲完了。我来简单做一下小结：今天我们讲了 Vim 里的窗口概念和标签页概念，并讨论了相关命令。窗口的命令主要是以 <C-W> 开始的双键命令，而标签页的命令则和上一讲的文件操作命令和缓冲区操作命令非常相似，也用了“first”、“last”、“next”、“Next”、“previous”等英文单词，但前缀得使用“tab”。多窗口适合你同时参照多个文件的内容，或者同一个文件的不同部分。多标签页适合其他你希望同时编辑多个文件的情况。在同一个 Vim 会话的多窗口和多标签页里编辑同一个文件不会发生任何冲突。NERDTree 是一个利用多窗口和多标签页的流行插件，可以方便地在 Vim 里浏览文件系统并打开文件进行编辑。本讲的配置文件更改也不多，对应的标签是 l6-unix 和 l6-windows。


## 07｜正则表达式：实现文件内容的搜索和替换

上面两讲里我们讨论了如何找到你想要查看 / 编辑的文件，及如何处理多个文件。今天我们来看一下如何在一个文件中搜索和替换内容，其核心主题就是正则表达式。


### 正则表达式搜索
通过 Vim 教程，你已经学到了搜索命令 / 和替换命令 :s 的基本用法。教程里没有提到的是，你输入的待查找的内容是被 Vim 当成正则表达式来看待的。正则表达式的学习资料很多（极客时间上就有专门的课程），完整学习也相当复杂，我们就不从头学习了。下面我们会简单讨论的，是 Vim 里的正则表达式，重点是它和其他常用正则表达式（正则表达式还是有很多种不同的风格的）的区别之处。如果你之前对正则表达式完全没有了解，建议你这儿暂停一下，先在网上搜索一下关于正则表达式的资料，了解它的基本概念和用法，然后继续阅读。

在一个搜索表达式里，或者称为模式（pattern；注意不要和 Vim 的 mode 混淆）里，.、*、^、$、~、[]、\ 是有特殊含义的字符：

. 可以匹配除换行符外的任何字符：如 a. 可以匹配“aa”、“ab”、“ac”等，但不能匹配“a”、“b”或“ba”。如果需要匹配换行符（跨行匹配）的话，则需要使用 \_.。* 表示之前的匹配原（最普通的情况为单个字符）重复零次或多次：如 aa* 可以匹配“a”、“aa”或“aaa”，a.* 可以匹配“a”、“aa”、“abc”等等，但两者均不能匹配“b”。^ 匹配一行的开头，如果出现在模式的开头的话；在其他位置代表字符本身。$ 匹配一行的结尾，如果出现在模式的结尾的话；在其他位置代表字符本身。~ 匹配上一次替换的字符串，即如果上一次你把“foo”替换成了“bar”，那 ~ 就匹配“bar”。[…] 匹配方括号内的任一字符；方括号内如果第一个字符是 ^，表示对结果取反；除开头之外的 - 表示范围：如 [A-Za-z] 表示任意一个拉丁字母，[^-+*/] 表示除了“+”、“-”、“*”、“/”外的任意字符。\ 的含义取决于下一个字符，在大部分的情况下，包括上面的这几个（.、*、\、^、$、~、[ 和 ]），代表后面这个字符本身；在跟某些字符时则有特殊含义（后面我们会讨论最重要的那些）。


除此之外的字符都是普通字符，没有特殊含义。不过，需要注意的是，如果使用 / 开始一个搜索命令，或者在替换命令（:s）中使用 / 作为模式的分隔符，那模式中的 / 必须写作 \/ 才行，否则 Vim 看到 / 就会以为模式结束了，导致错误发生。为了避免写模式的困扰，如果模式中使用“/”作为路径的分隔符，在替换命令中可以使用其他模式中没有的符号作为分隔符。比如，想把“/image/”全部替换成“/images/”的话，不要用 :%s/\/image\//\/images\//g，而应该用类似于 :%s!/image/!/images/!g 的写法。这只能适用于替换命令，而在使用 / 命令搜索时我们就没什么好办法了，只能把模式里的 / 写作 \/。不过我们也可以取巧一下，用 ? 向上、也就是反向搜索，只要记得 n、N 反过来用找下一个就行。

通过 \ 开始的特殊表达式有不少，如果你需要完整了解的话，可以去看看参考文档（:help pattern-overview）。我们下面先学习一下最基本的 6 个特殊模式项：

- \? 表示之前的匹配原重复零次或一次：如 aa\? 可以匹配“a”、“aa”，但不能完整匹配“aaa”（可以匹配其前两个字符、后两个或最后一个字符）。
- \+ 表示之前的匹配原重复一次或多次：如 aa\+ 可以匹配“aa”、“aaa”，但不能匹配“a”或“b”。
- \{n,m} 表示之前的匹配原重复 n 到 m 遍之间，两个数字可以省略部分或全部：如 a\{3}（可读作：3 个“a”）可以匹配“aaa” ，a\{,3}（可读作：最多 3 个“a”）可以匹配“”、“a”、“aa”和“aaa”；两个数字都省略时等价于 *，也就是之前的匹配原可以重复零次或多次。
- \( 和 \) 括起一个模式，将其组成为单个匹配原：如 \(foo\)\? 可以表示单词“foo”出现零次或一次。\( 和 \) 还有一个附加作用，是捕获匹配的内容，按 \( 出现的先后顺序，可以用 \1、\2 到 \9 来引用。如果你不需要捕获匹配内容的话，用 \%( 和 \) 的性能更高。
- \& 是分支内多个邻接（concat）的分隔符，概念上可以和与操作相比，表示每一项都需要匹配成功，然后取最后一项的结果返回：如 .*foo.*\&.*bar.* 匹配同时出现了“foo”和“bar”的完整行。相对来讲，\& 没那么常用。
- \| 是多个分支的分隔符，概念上可以和或操作相比，表示任意一项匹配成功即可：如 foo\|bar 可匹配“foo”或“bar”两单词之一。

接下来，我再和你分享 13 个特殊模式项。虽然它们相对来说不那么必需，但掌握它们可以大大地提高程序员的编辑效率。
```
\< 匹配单词的开头\> 匹配单词的结尾\s 匹配空白字符 <Space> 和 <Tab>\S 匹配非空白字符\d 匹配数字，相当于 [0-9]\D 匹配非数字，相当于 [^0-9]\x 匹配十六进制数字，相当于 [0-9A-Fa-f]\X 匹配非十六进制数字，相当于 [^0-9A-Fa-f]\w 匹配单词字符，相当于 [0-9A-Za-z_]\W 匹配非单词字符，相当于 [^0-9A-Za-z_]\h 匹配单词首字符，相当于 [A-Za-z_]\H 匹配非单词首字符，相当于 [^A-Za-z_]\c 忽略大小写进行匹配
```
以上我们讨论的实际上是 Vim 缺省设置下的正则表达式。通过选项（:help /magic），我们可以对哪些字符有特殊意义进行一定程度的调整。不过一般情况下，我认为修改这个选项只会造成混乱、增加心智负担，因此我也就不在这儿展开了。


### 搜索实例
抽象地讨论正则表达式恐怕你也不容易记住，我们还是拿一些具体的例子来看一下吧。首先，如果我们要查找某个函数，该怎么做呢？简单，按下 /，然后输入函数名，回车，不就行了？错。这种方式对函数名是部分匹配，你搜 begin 还会得到 begin1、_begin 之类的结果。正确的方法是，要在前后加上匹配单词头尾的标记，如，\<begin\>。顺便说一句，被誉为最有用的 Vim 提示，是把光标移到希望搜索的关键字上，然后按下 * 键。Vim 会提取光标下的关键字，并自动添加 \< 和 \> 进行搜索。

![img](https://static001.geekbang.org/resource/image/d0/4e/d037c4d999ccb36edc8886f1f507c14e.gif?wh=1372*1162)


如果我要搜索 begin 或 end 呢？我想，你应该已经知道了，是：`/\<\(begin\|end\)\>`。注意，写成` /\<begin\|end\>` 可是不对的。（为什么？你想明白了吗？）对于 HTML，你应该多多少少有些了解。如果我们想匹配一下 HTML 标签的话，该怎么做呢？一个标签以 < 开始，以 > 结束。所以，最简单的模式应该是 <.\+>，对吗？不对，这个写法忽略了一行里可能有多个标签的事实：对于`“<h1>title</h1>”`这样一个字符串，上面这个简单的模式会匹配整个字符串，而不是`“<h1>”`和`“</h1>”`……

![img](https://static001.geekbang.org/resource/image/c8/1d/c80f8930b2934cd315c6560dd31c661d.png?wh=1254*1002)


有一种解决方案是，排除不应该匹配的字符，把模式写成 <[^>]\+>：一对尖括号里有一个或多个不是“>”的字符。不过，这样的写法会让像 > 这样的结尾字符在模式中重复出现，因此这并不是最理想的写法。更好的方式是，使用最短匹配。

### 最长匹配和最短匹配
我们上面学到的 *、\?、\+ 和 \{} 都属于最长匹配（也叫贪婪匹配），也就是说，当模式既可以匹配一个较长的字符串，也可以匹配一个较短的字符串时，结果会是那个较长的字符串。相应地，还有一种匹配叫做最短匹配，也就是在同时可以匹配较长的字符串和较短的字符串时，产生较短的匹配。在 Vim 里，最短匹配只有一种形式，{-n,m}，其意义和之前说的 {n,m} 基本相同，但结果是较短而非较长的字符串。以上面的 HTML 标签匹配为例，使用最短匹配的话，我们可以把模式写成 <.\{-1,}>，要求在一对尖括号里至少有一个字符，但越短越好。


### 搜索加亮和取消
如果你一边学一边在试验的话，就会发现，Vim 缺省在你输入搜索模式时就会高亮跟你输入的模式匹配的文本。这对验证你输入的模式是否正确，以及进行进一步的编辑，都是非常方便和重要的。用惯了 Vim，就会把它当成是一件理所当然的事——直到你被迫使用其他编辑器时才发现，一边输入正则表达式一边就能看到匹配的结果，原来不是谁都这样做的啊……但也有些时候，我们已经做完了搜索或替换，和模式匹配的文本内容仍然还高亮着，非常碍眼。有些人就会随便搜索一个不存在的字符串来取消加亮，但这显然不是一种高效的处理方式。事实上，Vim 有一个专门命令来取消搜索加亮，这个命令就是 :nohlsearch，不要高亮搜索。鉴于这个命令使用的频度实在是太高了，我们需要给它专门分配一个快捷键。请在 vimrc 中加入：

```
" 停止搜索高亮的键映射
nnoremap <silent> <F2>      :nohlsearch<CR>
inoremap <silent> <F2> <C-O>:nohlsearch<CR>
```
这样一来，在搜索或替换工作完成之后，只要按下` <F2>` 就可以取消搜索加亮了。好，关于正则表达式的搜索部分，我们暂时就先学到这里。下面我们来看一下替换。



### 正则表达式替换
你可能要说了：替换不就是找到跟模式匹配的字符串，然后把它换成另外一个字符串么，有什么复杂的？事实上，还真是有些复杂情况的。你在看下面这些复杂的替换情况时，也可以同时考虑下自己有没有解决方案：

你可能要保留匹配中的某些字符，而替换另外一些字符  你可能要对匹配出的内容做大小写转换  你可能需要“计算”出替换结果  你可能需要决定一行里要替换单次还是多次，是自动替换还是要一一确认，等等


接下来，我们就分别看看这些复杂情况。在这些情况里，最常用的显然就是在替换结果中保留匹配出的字符串了。前面说到 \(\) 除了将一个模式转变成匹配原外，还有一个作用是捕捉匹配的内容，按 \( 的出现顺序依次编号为 1 到 9，并可以在模式和替换字符串中用 \1 到 \9 来访问。如果要在替换字符串中完整使用匹配内容的话，则可以使用 \0 或 &（字符“&”也因此要在替换字符串中写成 \&）。从搜索的角度，我们一般只关心匹配与否，而不关心匹配的大小。举个例子，如果我想找出作为函数调用的 begin，那我可以写成 `\<begin`(，虽然 ( 不是我想匹配的内容（函数名称）的一部分。但从替换的角度，我需要在替换时再处理一下多匹配的内容，也是件麻烦事；在非匹配的内容比较复杂或者会变化的时候，尤其会是这样。所以 Vim 里还有专门标识匹配开始和结束的匹配原，分别是 \zs 和 \ze。对于这个例子，搜索模式就应该是 `\<begin\ze`(。为了巩固前面学到的知识，你应该知道，这个模式也可以啰嗦地写成` \<begin(\&begin` 或 `\<begin(\&`.....。

Vim 里还有一些大小写转换的特殊替换字符串。它们是：
- \U 把下面的字符变成大写，直到 \E 出现
- \u 把下一个字符变成大写
- \L 把下面的字符变成小写，直到 \E 出现
- \l 把下一个字符变成小写
- \E 结束大小写转换

Vim 还能用 \= 开始一个返回字符串的表达式，用来计算出一个替换结果。鉴于我们目前还没有讨论 Vim 脚本，这个我们就留到后面第 14 讲再说了。跟常用的编程语言一样，Vim 的正则表达式中支持 \t、\r、\n 等特殊转义字符，但在替换表达式中，由于一些技术原因（:help NL-used-for-Nul），\n 插入的是空字符（NUL 或“\0”），而非在模式中出现时代表的 LF。如果要插入正常的行尾符 LF 的话，我们得使用 \r。这意味着如果想把一个回车变成两个的话，我们得别扭地写 :s/\n/\r\r/，略遗憾。如果有特殊需要得插入 CR 的话，就要更别扭地输入` \<C-V><CR>` 才行。还好，我们基本不会在替换时遇到要插入 CR 的情况……**Vim 有很多用来控制替换的标志**，你可以通过 :help s_flags 查看详细的介绍，我就不一一列举了。今天这一讲中，我们只会用到最常用的一个标志，g，代表可以在一行内进行多次替换；没有这个标志的话，Vim 在一行里只会对第一个成功的匹配进行替换。


### 替换实例
同样，我们还是通过例子来巩固一下对正则表达式替换的理解。先来看一个简单的，删除行尾的“//”注释。我们可以用这个命令

```
:%s!\s*//.*$!!
```
把零到多个空白字符后面出现的“//”直到行尾全部删除。如果要删除“/* */”注释，那就复杂多了。首先，匹配内容可以跨行；其次，有跟 HTML 标签类似的问题，需要使用最短匹配。我们需要使用的命令是：

```
:%s!/\*\_.\{-}\*/!!g
```
由于一行里可以有多个“/* */”注释，我们在替换命令的尾部还加上了 g 标志，允许一行里进行多次替换。假设我们目前的编码规范规定，所有的函数名应该首字母大写（简单起见，我们假设所有的类名已经是首字母大写了，因而构造函数自动符合该要求，不会发生冲突；但其他很多函数名称仍然是小写字母开头），我们能不能用 Vim 的替换命令做到呢？答案也是肯定的。所有需要的知识点我们都已经讲过了，我就直接公布答案了：


```
:%s/\<\(_*\)\([a-z]\w*\)\ze(/\1\u\2/g
```
这个命令比较长，请你慢慢体会一下，尝试去理解每一部分的意图。如果你有哪个点卡住了，可以留言给我，我再帮你详细分析一下。


### 内容小结
好了，今天的内容就讲到这里了。内容有点密集，我把要点再总结一下：Vim 支持用 / 进行搜索和用 :s 进行替换，它们都用到了正则表达式。在搜索的模式里，.、*、^、$、~、[]、\ 是有特殊含义的字符，你一定要记住它们的含义。在 \ 开始的特殊表达式中，最重要的是 \?、\+、\(\)、\| 和 \{n,m}。对于程序员来说，\<、\> 等匹配原对于提高编辑效率也非常重要。Vim 中的常用搜索命令 * 则会自动在搜索的关键字前后加上 \< 和 \>。在替换时，我们需要特别记住 \1、\2 到 \9 可以用来引用前面用 \( 和 \) 括起来的内容，字符“&”出现在替换内容中需要使用反斜杠转义成 \&，否则代表完整的被匹配字符串。正则表达式就可以算是一种独立的语言了，靠死记硬背是不行的。最后我还要建议你再把这一讲中的例子仔细看一下、尝试一下，多多练习是掌握正则表达式搜索和替换的必经之路。如果你日后遇到了这一讲没有覆盖的问题，可以再去查阅 Vim 的帮助文档 :help regexp。本讲我们在配置文件中只更改了一处，对应的标签是 l7-unix 和 l7-windows。

## 08｜基本编程支持：规避、解决编程时的常见问题
在前面的几讲里，我们已经学了很多使用 Vim 的基本知识。今天是编程专题，我来专门介绍一下 Vim 对编程的特别支持。学了这一讲之后，你会进一步了解 Vim 编辑程序时的重要特性，并能够规避、解决编程时的常见问题。

### 文件类型和关联设定
程序源代码通常由文件组成，每个文件都有一个关联的文件类型。这个文件类型决定了 Vim 对其进行处理的一些基本设定，可能包括：

如何对文件进行高亮  制表符（tab）的宽度（空格数）  是否在键入 < Tab> 时扩展为空格字符  每次缩进的空格数（是的，可以和制表符宽度不同）  采用何种自动缩进方法  其他可适用的选项


文件高亮通常需要一套相当复杂的规则，我们今天就只把它当成一个既成事实了，不讨论这些规则的细节。其他各项在 Vim 里一般以选项的形式出现。这些选项都是文件本地（local）选项，即可以在一个文件里修改其数值而不影响其他文件。对于这样的选项，可以用 :setlocal 和 :setglobal 命令分别访问本地值和全局值。一般的 :set 命令在读取数值时（如 :set tabstop?）返回本地值，在写入数值时（如 :set tabstop=4）同时设置本地值和全局值。

制表符宽度对应的选项是 tabstop。这在不同的语言里可能有不同的惯例，自然不必多说。它的缺省值是 8，但在不同的文件里可以不一样。不同的文件类型也可能会自动设定不同的数值。

是否扩展 < Tab> 为空格由 expandtab 选项控制。我们前面看到过，但没有讲过，Vim 选项有些是用等号赋值的，也有些不用等号，而只用选项名称或选项名称前面加 no，表示否定。这些就是布尔类型选项，expandtab 也是其中之一。如果打开了 expandtab 选项，那输入中的 tab 会被转变成空格；如果关闭的话，则 tab 字符会被保留。

让事情变得更复杂的是，Vim 还有个 softtabstop 选项，软制表符宽度。一旦设置了这个选项为非零值，再键入 < Tab> 和 < BS>（退格键），你就感觉像设置了这个宽度的 tabstop 一样，有相应数量的缩进或取消缩进，但实际插入的字符仍然受 expandtab 和 tabstop 两个选项控制。在设置软制表符宽度时，一种最常用的用法是同时设置 expandtab，这样，编辑时你感觉像使用了这个宽度的制表符一样，但你输入的内容里实际被保存的仍然是空格字符。

这些还不是 Vim 真正使用的“缩进”值。以 C 语言为例，当 Vim 看到你输入“{”和回车键时，会自动产生一个缩进，而这个缩进值跟 tabstop 和 softtabstop 都无关，是一个独立的选项 shiftwidth。

最后，Vim 还有很多精细的选项来控制如何进行缩进。默认情况下，Vim 没有特殊缩进，回车键回到行首。一般而言，使用选项 autoindent 可以使 Vim 至少记住上一行的缩进位置；而对于特定语言，Vim 可以设置更合适的选项，达到更佳的缩进效果——如对类 C 语言 Vim 会设置 cindent 选项，达到最优的缩进效果。我们下面还会提到，Vim 支持对类 C 语言的缩进有一些精调选项，你也可以自己进一步进行调整。


我之前提到过，Vim 会根据文件类型来设置选项。所以，相关问题就是，Vim 如何判断文件类型，如何根据文件类型来设置选项，以及我们该如何定制这些行为。我们下面就来一一作答。

### 文件类型判断
Vim 的文件类型判断是在 filetype.vim 中执行的。我们可以用下面的命令来打开这个文件：

```
:e $VIMRUNTIME/filetype.vim 
```
这个文件相当复杂，但有编程功底的你，应该可以看出大概的意思吧？其中最主要的逻辑仍然是通过后缀来进行判断，如：

```
" C++
au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
```
其中 au 是 autocmd 的缩写，代表 Vim 在发生某事件时触发某一动作。上面说的就是在创建（BufNewFile）或读入（BufRead）跟指定文件名模式匹配的文件时，把文件类型设为 C++（setf cpp， setf 是 setfiletype 的缩写）。但在后缀不足以唯一判断时，Vim 可以进一步执行代码，如：
```
au BufNewFile,BufRead *.h      call dist#ft#FTheader()
```
上面函数的定义在文件 $VIMRUNTIME/autoload/dist/ft.vim 里：

```
func dist#ft#FTheader()
  if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
    if exists("g:c_syntax_for_h")
      setf objc
    else
      setf objcpp
    endif
  elseif exists("g:c_syntax_for_h")
    setf c
  elseif exists("g:ch_syntax_for_h")
    setf ch
  else
    setf cpp
  endif
endfunc
```
它的大概意思是，如果在头 200 行里找到某行以 @interface 等内容开始，那就认为这是 Objective-C/C++，否则认为是 C/C++。具体是 C 还是 C++，则由全局变量 g:c_syntax_for_h 控制（我们忽略 Ch 这种小众情况）。详细语法我们就不展开讲述了，留待讨论 Vim 脚本的时候再看。上面讲的是 Vim 的缺省行为。我们当然也可以定制 Vim 的行为。按照惯例，一般把定制放在用户 Vim 配置目录里的 filetype.vim 里。我的定制如下所示：

```
if exists("did_load_filetypes")
  finish
endif

function! s:CheckCPP()
  if expand('%:t') !~ '\.'
    setfiletype cpp
  endif
endfunction

augroup filetypedetect
  au! BufRead,BufNewFile *.asm      setfiletype masm
  au! BufRead proxy.pac             setfiletype javascript
  au! BufRead */c++/*               call s:CheckCPP()
  au! BufRead */include/*           call s:CheckCPP()
augroup END
```
我们可以跳过一些语法方面的细节，只讨论代码里的意图。上面这段代码主要做了以下事情：当读入或创建后缀为“.asm”的文件时，设置文件类型为微软宏汇编（默认为 GNU 的汇编格式）。当读入名字为“proxy.pac”的文件时，把内容当成 JavaScript 解释。当读入路径含“c++”或“include”的文件时，调用脚本内部函数 CheckCPP，检查文件名（% 代表文件名，:t 代表尾部，即去掉路径部分）是否不含“.”，是的话当成 C++ 文件类型。这是为了处理像“memory”这样的无后缀 C++ 头文件。随后 Vim 会继续载入自带的 filetype.vim；如果文件类型还未确定的话，则继续使用 Vim 自带的规则进行判断。

### 文件类型
选项一旦确定了文件类型，Vim 会从运行支持文件目录下载入同名的文件。以 Python 为例：
- syntax/python.vim 包含了如何对 Python 进行语法加亮的设置
- indent/python.vim 包含了如何对 Python 代码进行缩进的设置（如在用户输入 if 时进行缩进等）
- ftplugin/python.vim 是文件类型插件，包含了其他跟文件类型相关的设置

文件类型插件中包含我们上面提到的制表符宽度方面的设定，具体来说，是下面这几行：

```
if !exists("g:python_recommended_style") || g:python_recommended_style != 0
    " As suggested by PEP8.
    setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=8
endif
```
默认情况下，该文件使用 [PEP 8](https://www.python.org/dev/peps/pep-0008/) 推荐的设置：把用户输入的制表符扩展成空格缩进和软制表符宽度设为 4如果文件中包含制表符的话，仍按宽度为 8 来解释

缩进和软制表符宽度设成 4 估计不需要解释，这应该是最常用的缩进值了。使用空格而不是制表符的最大好处是，在无论何种环境下，展示效果都可以完全一致，不会在 diff 时或制表符宽度不符合预期时代码就乱了。至于“硬”制表符宽度仍然是 8，则是为了确保显示文件的兼容性，尤其是在终端里 cat 文件时和在浏览器中浏览源代码时；这两种情况下，制表符宽度一般都是 8。跟 Python 不同，很多其他文件类型没有推荐的风格设定，这时就应该用户自己进行设定了。我推荐在 vimrc 配置文件里进行设置，因为比较集中、容易管理。如：


```
au FileType c,cpp,objc  setlocal expandtab shiftwidth=4 softtabstop=4 tabstop=4 cinoptions=:0,g0,(0,w1
au FileType json        setlocal expandtab shiftwidth=2 softtabstop=2
au FileType vim         setlocal expandtab shiftwidth=2 softtabstop=2
```
上面设置了几种不同文件类型的编辑选项。大部分我们都已经知道了，下面这个则是新的：cinoptions 可以精调 C 风格缩进的方式；上面 :0 表示 switch 下面的 case 语句不进行额外缩进，g0 代表作用域声明（public:、private: 等）不额外缩进，(0 和 w1 配合代表没结束的圆括号里的内容折行时不额外缩进。



我们也可以根据文件类型以外的条件来进行设定，如下面设定是要把 /usr/include 目录下的文件按 [GNU 编码风格](https://www.gnu.org/prep/standards/)来解释：
```
function! GnuIndent()
  setlocal cinoptions=>4,n-2,{2,^-2,:2,=2,g0,h2,p5,t0,+2,(0,u0,w1,m1
  setlocal shiftwidth=2
  setlocal tabstop=8
endfunction

au BufRead /usr/include/*  call GnuIndent()
```
![img](https://static001.geekbang.org/resource/image/32/2e/327950d78fafccce8aab31db624aaf2e.png?wh=1396*1212)

当然，除了设定选项，我们也可以做其他事情，比如下面的代码是在 Vim 帮助文件中，将 q 设定为关闭窗口的按键，映射中的 <buffer> 表示该映射只对这个缓冲区有效。
```
au FileType help  nnoremap <buffer> q <C-W>c
```
### Tags 支持
Vim 对一种叫 tags 的文本索引格式有特殊支持。事实上，Vim 自己的帮助文件都是用 tags 来索引的。我们用过了 Vim 帮助，也就用过了 tags 文件。下面展示了 $VIMRUNTIME/doc/tags 文件中的一部分：

```
?       pattern.txt     /*?*
?<CR>   pattern.txt     /*?<CR>*
@       repeat.txt      /*@*
@/      change.txt      /*@\/*
@:      repeat.txt      /*@:*
@=      change.txt      /*@=*
@@      repeat.txt      /*@@*
@r      eval.txt        /*@r*
A       insert.txt      /*A*
ACL     editing.txt     /*ACL*
ANSI-C  develop.txt     /*ANSI-C*
```
我们可以清楚地看到，其中内容分为三列：第一列是关键字，第二列是文件名，第三列是在目标文件中的匹配文本。当你在 Vim 的帮助文件中使用双击或 <C-]> 等命令跳转时，Vim 就会在 tags 文件中搜索，寻找到匹配项的时候就跳转到指定的文件，并利用匹配文本跳转到指定的位置。注意我们有不止一个 tags 文件。单单从 Vim 帮助的角度，个人 Vim 配置目录下的 doc 目录里有一个 tags 文件；每当你装了一个新的带帮助文件的 Vim 插件时，你都需要到这个 doc 目录下运行 helptags . 来重新生成索引。每个 Vim 软件包的 doc 目录下也同样需要有 tags 文件，不过包管理器能够在安装、更新时自动帮我们在 doc 目录下生成 tags 文件。Vim 在你使用 :help 命令查帮助时，会自动在你的所有运行时目录（可以使用 :set runtimepath? 查看）下的 doc/tags 里查找第一个匹配项。

### 生成 tags 文件的工具
如果 tags 文件只支持 Vim 帮助文件的话，那我就没必要对其进行详细讨论了。之所以在这里讨论 tags，是因为它可以用在编程语言上。要生成 Vim 可以使用的支持常用编程语言的 tags 文件，我们需要使用下列两个工具之一：

[Exubertant Ctags](http://ctags.sourceforge.net/)
[Universal Ctags](https://ctags.io/)


Exuberant Ctags 是已经存在了好多年的老牌工具。Windows 下可直接下载可执行程序，而 Linux 和 macOS 上的包管理器一般也直接支持。如：

- Ubuntu 下可使用 sudo apt install exuberant-ctags
- CentOS 下可使用 sudo yum install ctags
- macOS Homebrew 可使用 brew install ctags（但需要注意 macOS 本身提供了一个功能较简单的 ctags 命令，你可能需要将 /usr/local/bin 在路径里移到 /usr/bin 前面，或自己设置 alias，确保优先使用 /usr/local/bin/ctags）


Universal Ctags 还比较新，目前各操作系统的包管理器里多半还没有它，所以安装会麻烦一点。你需要自己查看文档，找到在你的操作系统上的安装方式。（我是直接从源代码编译了一个版本。）我之所以要推荐 Universal Ctags，是因为虽然 Exuberant Ctags 和 Universal Ctags 都支持超过 40 种的常见编程语言，但 Exuberant Ctags 的最后一个版本 5.8，发布于 2009 年，之后就一直没有更新了。Universal Ctags 是基于 Exuberant Ctags 代码的改进版本，并把开发移到了 GitHub 上，项目一直处于活跃状态。想偷懒的话，可以直接使用 Exuberant Ctags；如果愿意折腾一下，或者明确遇到 Exuberant Ctags 的问题，则可以试试 Universal Ctags。对于现代 C++ 代码，使用 Universal Ctags 还是挺重要的。老的 Exuberant Ctags 不能处理 C++11 以来的新语法——这当然也是件显而易见的事。



### 生成 tags 文件的命令
要生成 tags 文件时，你可以简单地进入到一个目录下，然后执行下面的语句对该目录及子目录下的程序源文件生成一个 tags 文件：

```
ctags -R .
```
但根据场景和语言不同，你可能需要使用更多的选项。比如，对于 C++，我一般使用：

```
ctags --fields=+iaS --extra=+q -R .
```
如果是对系统的头文件生成 tags 文件——可以用来查找函数的原型信息——那我们一般还需要加上 --c-kinds=+p 选项。为了一次性地对系统头文件简单地生成 tags 文件，我还专门写了个脚本 [gen_systags](https://github.com/adah1972/gen_systags) 来自动化这项工作。你如果感兴趣的话，也可以点进去看一下。鉴于我们主要讲 Vim 而不是 Ctags，这个话题我暂时就点到为止、不展开了。你可以通过我给出的链接，以及 man ctags 或 ctags --help 的输出，自己进一步学习一下。讲到 C 的工作环境时，我们会再回到 Ctags。


### 使用 tags 文件
如果当前目录下或当前文件所在目录下存在 tags 文件，Vim 会自动使用这个文件，不需要你做额外的设定。你所需要做的就是在待搜索的关键字上（也可以在可视模式下选中需要的关键字）使用正常模式命令 < C-]>，或者按 g（g 可理解成 go）键加鼠标单击。你愿意的话，也可以手工输入命令 :tag 后面跟空格和待搜索的符号加回车键。这样 Vim 即会跳转到该符号的定义或声明位置。

![img](https://static001.geekbang.org/resource/image/d2/5e/d205869f3312918f8e39a40c2592325e.gif?wh=924*576)

如果待搜索的符号找不到，Vim 会报错“E426: tag not found”。如果存在一个或多个匹配项，Vim 会跳转到第一个匹配的位置。下面我列举一下其他相关的常用命令：


```
:tnext（缩写 :tn）跳转到下一个标签匹配位置
:tNext（缩写 :tN）或 :tprevious（缩写 :tp）跳转到上一个标签匹配位置
:tfirst 或 :trewind 跳转到第一个标签匹配位置
:tlast 跳转到最后一个标签匹配位置
:tselect 名称（:tselect 可缩写为 :ts）跟 :tag 类似，但会列举可能的匹配项，让你自己选择（而非跳转到第一个匹配位置）
g] 跟 <C-]> 类似，但跟 :tselect 一样会给出一个列表而非直接跳转:tjump 名称（
:tjump 可缩写为 :tj）跟 :tselect 类似，但在只有一个匹配项的时候会直接跳转到匹配位置
g<C-]> 跟 g] 类似，但跟 :tjump 一样在只有一个匹配项时会直接跳转到匹配位置:stselect 名称（:stselect 可缩写为 :sts）跟 
:tselect 类似，但结果会打开到一个新分割的窗口中
:stjump 名称（:stjump 可缩写为 :stj）跟 :tjump 类似，但结果会打开到一个新分割的窗口中
```
我们的标签跳转分为 :tag、:tselect 和 :tjump 三种不同方法，正常模式和可视模式的命令 `<C-] `也同样有后两种方法的变体，对应的命令分别是 g] 和 `g<C-]>`。这三个命令前面也都可以额外加上 `<C-W>`，表示结果打开到新窗口中而非当前窗口。

![img](https://static001.geekbang.org/resource/image/10/ec/1017481027bdbca5862acc8b1356e9ec.gif?wh=924*576)

Vim 默认只在当前目录下和文件所在目录下寻找 tags 文件。对于含多层目录的项目，这个设定就不合适了。解决方法是使用 Vim 的选项 tags。一个小技巧是根据项目的可能深度，检查上层存在的 tags 文件：


```
" 加入记录系统头文件的标签文件和上层的 tags 文件
set tags=./tags,../tags,../../tags,tags,/usr/local/etc/systags
```
tags 选项的默认值是 ./tags,tags，即检查文件所在目录下的 tags 文件和当前目录下的 tags 文件。上面这样的写法还会额外检查父目录下的 tags 文件，祖父目录下的 tags 文件，以及我们上面用 gen_systags 生成的 systags 文件。这对一个有不超过三层目录结构的项目来讲就足够了。如果你的项目目录层次更深，也只需要在 tags 选项里添加 ../../../tags 这样的内容即可。


### Tagbar 插件
根据上面的描述，我们可以看到 Ctags 是一个可以从源代码中提取符号的工具。事实上，这个工具在我们不生成 tags 文件也都是有用的。Vim 的插件 tagbar 就可以利用 Ctags 来提取符号，生成源代码的结构图。只要 Ctags 能支持这种语言，插件就能“识别” 这种语言，来生成结构图；识别的好坏程度也视 Ctags 对其的支持程度而定。下面是一个示例：

![img](https://static001.geekbang.org/resource/image/01/c8/01c7599a78c335d5279f4ec261bdc8c8.png?wh=1700*1359)

跟之前类似，假设使用 minpac 的话，我们需要在 vimrc 中“Other plugins”那行下面加入下面的语句，并运行 :PackUpdate 来安装一下：

```
call minpac#add('majutsushi/tagbar')
```
我给它映射了快捷键 < F9>，可以快速打开和关闭 Tagbar 的窗口：

```
" 开关 Tagbar 插件的键映射
nnoremap <F9>      :TagbarToggle<CR>
inoremap <F9> <C-O>:TagbarToggle<CR>
```
### Quickfix 窗口
Vim 里有一种特殊类型的窗口，被称作 quickfix（快速修复）。这个窗口中会展示外部命令的结果，并可以通过这个窗口中的内容直接跳转到特定文件的特定位置。这个设计最初是用来加速“编辑 - 编译 - 编辑”这个循环的，但它的实际用处并不只是用来编译程序。我们先来看一下 Vim 的 :make 命令。如果你的代码可以简单执行 make 来编译的话（也就是说，你已经写了或者生成了合适的 Makefile），你可以尝试直接在 Vim 里执行 :make。你会看到正常的执行过程。唯一不一样的地方是，如果编译失败了，Vim 会自动跳转到第一个出错的位置！

![img](https://static001.geekbang.org/resource/image/f5/d0/f515a16bcb32114edab186520b2a47d0.gif?wh=1174*988)


如果使用 :copen 命令，我们就可以打开 quickfix 窗口。在里面我们可以看到完整的出错信息，并能通过颜色看出 Vim 解析了文件名和行号。我们在带文件名的行上双击即可跳转到对应位置。另外，我们在 quickfix 窗口中也有跟之前类似的“next”类命令：:cnext（缩写 :cn）跳转到下一个出错位置:cNext（缩写 :cN）或 :cprevious（缩写 :cp）跳转到上一个出错位置:cfirst 或 :crewind 跳转到第一个出错位置:clast 跳转到最后一个出错位置

事实上，在这些下一个、上一个的命令中，我用得最多的就是这个快速修复里的跳转了。为了方便记忆，我对它们都映射了相似的快捷键。


```
" 用于 quickfix、标签和文件跳转的键映射
nmap <F11>   :cn<CR>
nmap <F12>   :cp<CR>
nmap <M-F11> :copen<CR>
nmap <M-F12> :cclose<CR>
nmap <C-F11> :tn<CR>
nmap <C-F12> :tp<CR>
nmap <S-F11> :n<CR>
nmap <S-F12> :prev<CR>
```
这是我的映射，你可以根据自己的需要进行调整。另外要留意的一点是，取决于环境，不是所有的快捷键都能被 Vim 接收到，尤其在使用终端和远程连接的时候。比如，在 Mac 上有些快捷键已经被系统占用，并且终端基本不接受修饰键；在 Windows 的远程连接客户端里，PuTTY 不支持使用 Alt 的快捷键，但 mintty 就可以。

### :make 命令的其他细节
Vim 里的 :make 命令缺省会执行 make 命令，并且这是可以通过选项 makeprg 来进行配置的。比如，如果你希望启用四路并发编译，你就可以设置 :set makeprg=make\ -j4。你也可以使用 GNU Make 之外的构建工具，但需要注意的是，如果发现 Vim 不能识别你使用的构建工具产生的错误信息，你可能需要利用 errorformat（:help errorformat）选项来告诉 Vim 如何处理错误信息。


### :grep 命令
对我而言，跟构建使用频度至少一样高的命令是搜索，也就是根据关键字找到相关的源代码。这就可以使用 Vim 的 :grep 命令。跟 :make 命令相似，Vim 会调用一个合适的外部程序（可通过 grepprg 选项来进行配置）来进行搜索，并从结果中找到文件名、行号等信息。注意：在 Windows 上如果 Vim 没找到 grep 的话，它会调用 Windows 自带的 findstr 命令行工具；为了获得跟其他平台相同的体验和跟 Vim 本身相似的正则表达式，我强烈推荐你在 Windows 上也安装 grep 工具。我们上一讲讲到的搜索模式，大部分在 grep 里可以原封不动地使用，尤其是对 \?、\+、\< 和 \> 的解释。考虑到 vi 源自 Bill Joy，grep 源自 Ken Thompson，两者的老祖宗都是 ed，这自然也不是件令人意外的事。

如果使用 grep 命令的话，我们的命令大致如下所示：

```
:grep '要查找的符号' 文件名列表
```
当然，grep 支持的复杂参数我们都可以用上。比如，下面的命令可以在所有的子目录里查找用到了 printf 的 .c 和 .h 文件：

```
:grep -R --include='*.c' --include='*.h' '\<printf\>' .
```
小提示：在查看搜索结果时，适时使用 zz（或 zt、zb）重定位当前行在屏幕上的位置，可能可以更清晰地查看前后的相关代码。

### 异步支持
上面这些命令，都有一个缺点：在执行过程中你干不了其他事情。对于执行过程可能较慢的 make，这个问题尤其严重。幸好，在 Vim 8 支持异步任务之后，这个问题也得到了解决。我们利用一个插件，就可以获得类似在一些集成开发环境中的体验，在构建过程中仍然可以继续做其他事情。

我们首先需要安装一个插件 asyncrun.vim。跟前面类似，假设我们使用 minpac 的话，我们需要在 vimrc 中的合适位置加入下面这行：

```
call minpac#add('skywind3000/asyncrun.vim')
```
我们还需要一个跟 :make 相似的命令。我使用下面的命令定义（今天我们重点看使用，定义的细节就不讨论了）：

```
" 和 asyncrun 一起用的异步 make 命令
command! -bang -nargs=* -complete=file Make AsyncRun -program=make @ <args>
```
这个命令同样会使用 makeprg 选项。不过，还有个问题是默认情况下屏幕上看不到执行过程的信息。我们可以让 asyncrun 在执行命令时立即打开 quickfix 窗口：

```
" 异步运行命令时打开 quickfix 窗口，高度为 10 行
let g:asyncrun_open = 10
```
对于 C/C++ 程序员来讲，启动和停止构建应该是一个很频繁的操作吧。所以，我也给它分配了一个快捷键：

```
" 映射按键来快速启停构建
nnoremap <F5>  :if g:asyncrun_status != 'running'<bar>
                 \if &modifiable<bar>
                   \update<bar>
                 \endif<bar>
                 \exec 'Make'<bar>
               \else<bar>
                 \AsyncStop<bar>
               \endif<CR>
```
上面的代码通过判断异步任务状态和窗口是否可修改，还会自动执行保存文件和终止构建等操作。建议你自己尝试一下。鉴于我们本讲内容已经很多了，我们暂时就不讲解了。

![img](https://static001.geekbang.org/resource/image/12/65/12a729849d86ef08263622929ed05a65.gif?wh=1174*990)



### 查看文档
Vim 里快捷键 K 可以用来查看光标下关键字的相关文档。它的行为是由选项 keywordprg（:help 'keywordprg'）控制的。这个选项的缺省值是 man，表示查看 Unix 的 man 手册，很多文件类型插件会对当前缓冲区设置一个更合适的值，如 Vim 脚本就会直接把行为改成调用 :help 命令。查看 man 手册的默认行为通常只在终端工作良好，而在图形界面 Vim 里会出现显示问题。我推荐使用 Vim 内置的 man 插件，并把全局的 keywordprg 设成 :Man：

```
" 启用 man 插件
source $VIMRUNTIME/ftplugin/man.vim

set keywordprg=:Man
```
这样，我们在使用 K 命令时，将在 Vim 里直接打开 man 手册，效果如下所示：

![img](https://static001.geekbang.org/resource/image/yy/08/yy9c761e5cbaa5ff91d5f2c0952f6208.png?wh=1316*1068)


### 内容小结
今天我们讨论了 Vim 中对编程的基本支持，包括：
- Vim 使用编程规则来判断文件类型，逻辑放在文件 filetype.vim 里。
- Vim 里有很多设置文件格式的选项，自动设置一般在 ftplugin 和 indent 目录下；我们可以简单地在 vimrc 配置文件中进行定制。Vim 通过 cindent 和 cinoptions 选项，对类 C 的语言提供了相当细颗粒的缩进风格支持。
- Vim 对 tags 文件提供了完整的支持，Ctags 工具可以对超过 40 种主流编程语言生成 tags 文件，供 Vim 和 Tagbar 使用。
- Vim 里通过 quickfix 窗口，对构建和搜索提供了内置支持；从 Vim 8 开始，我们可以使用异步支持，在构建时继续进行编辑。
- Vim 里通过 K 命令，可以快速地查阅文档；通过 man 插件，我们可以直接在 Vim 里查阅 man 手册。

本讲我们的配置文件更改较多，请仔细检查一下其中内容。对应的标签是 l8-unix 和 l8-windows。




## 09｜七大常用技巧：让编辑效率再上一个台阶

学到这里，你应该已经初步掌握 Vim 了。我们这一讲来重点看一下 Vim 里的七大常用编辑技巧。有些技巧你直接就可以用，有些则需要安装第三方插件。但无论是哪种情况，它们都可以大大提高你的编辑效率。从这一讲开始，我们将不再讨论插件的安装过程，而只是给出像 skywind3000/asyncrun.vim 这样的名称。相信你学到现在应该已经不需要我再详细讲述这样的基础知识了。如果你对安装插件还不太熟练的话，请复习第 4 讲。接下来，我们正式开始今天的内容。


### 自动完成
自动完成是一个编辑器中很主流的功能了。通常，我们希望编辑器能在我们输入一部分内容时就能猜到我们希望输入的是什么，并能够予以提示。自动完成可以节约我们输入的工作量，是一件编辑中非常必要的利器。Vim 内置有自动完成功能。
最基本的自动完成功能有两种：
- 基于当前文件文本的自动完成
- 基于文件系统的自动完成

我们先说基于当前文件文本的自动完成。在当前文件里，或当前文件用 #include（C 类语言的情况）包含的文件里包含某个关键字时，你可以输入头若干个字母并按下 <C-P>（表示 previous）或 <C-N>（表示 next）来进行自动完成。这两者的区别是，<C-P> 是从当前位置往前找，而 <C-N> 是从当前位置往后找。当只有一个匹配项时，Vim 直接给出完成结果，再次按下 <C-P> 或 <C-N> 则取消自动完成。当存在多个匹配项时，Vim 会根据搜索顺序给出匹配项列表并使用第一个匹配项；再次按下 <C-P> 或 <C-N> 则可以在列表里进行选择。Vim 的缺省选项能帮你在 Unix 系统上找到系统的头文件，利用里面出现的关键字来完成。想要在其他语言或平台里找到当前文件“包含”的文件里的关键字，请参考下列选项帮助：

```
:help include:help includeexpr:help isfname:help path
```
![img](https://static001.geekbang.org/resource/image/72/68/7231db664f67cb5403c287d5e4b70c68.gif?wh=1324*902)

我们再看一下基于文件系统的自动完成。当你在插入模式下输入一个绝对路径或者当前目录下的文件 / 目录名称的一部分时，你可以使用 <C-X><C-F> 来启动文件自动完成。在此之后，操作就和前面一样了，你可以使用 <C-P> 和 <C-N> 在匹配项中跳转和取消。Vim 里还有其他一些以 <C-X> 开始的自动完成功能。比如，你可以用 <C-X><C-K> 从配置的词典中选择合适的单词，可以用 <C-X><C-O> 进行“代码自动完成”。但这些功能要么不常用，要么在缺省配置下工作得并不好。所以，今天我就暂时不讨论其他自动完成功能了。等到了提高篇和拓展篇，我们再来看英文文本编辑和代码自动完成这两个话题。最后，要注意任何自动完成功能都可能会重复你的错误。如果你一开始拼错了，后面又拼对了，很可能会发现前面的错误。而一旦使用自动完成，你要是一开始就拼错了，后面可能就会不断重复之前的错误。这当然不是编辑器的错，但作为我曾经见到发生过的问题，我觉得值得提醒你一下。


### 文本目标跳转
如果光标下面是一个计算机可以找到的文件，你一定希望我们有办法可以一下子打开这个文件吧。这正是我们这一节要讨论的技巧。当光标下的文件名可以在 path 选项标识的目录下找到时，我们可以很方便地跳转过去。你需要的是正常模式命令 gf 和 <C-W>f。估计你很容易猜到，前者是直接跳转到文件（理解为“goto file”），后者则会打开一个新窗口（window），在新窗口里打开该文件。

如果光标下面是一个链接，或者非文本文件，那我们该怎么办呢？显然，即使 Vim 可以打开这个文件，看到的内容也多半不是你想要的（你想看图片，还是把图片当成文本的乱码？）。这时候，最简单的解决方式是使用 netrw 插件提供的 gx 命令。它的缺省行为是使用操作系统提供的机制来打开光标下的文件或链接。比较让人伤心的是，最新版本的 netrw 插件在打开链接时的行为不正常。[这个问题](https://github.com/vim/vim/issues/4738)已经报告有一年了，还没有解决。作为临时方案，我在 Vim 配置的目录放了一个可以工作的老版本，你可以把这个文件复制到你的 Vim 配置目录下的 plugin 子目录下来绕过这个问题。此外，gx 只适合本机，不适合在远程连接上使用。

### Vim 寄存器 / 剪贴板
我们已经学到，Vim 的删除和复制命令（如 d 和 y）会把内容存起来，以供粘贴命令（如 p 和 P）使用。我们还没有讨论这种内容存储有什么特别的地方。首先，估计你已经知道的是，Vim 把要粘贴的内容存在 Vim 内部的“寄存器”（register）里，而非系统的剪贴板。你不一定知道的是，Vim 里的寄存器有好多个。事实上，Vim 有超过 40 个不同的寄存器！我们挨个来看一下：

首先是无名寄存器。当操作没有用 " 加寄存器名称指定寄存器时，我们默认使用无名寄存器。不过，我们仍可以使用 "" 来指定使用无名寄存器，也就是说，""p 和 p 效果相同。其次是数字寄存器 0 到 9。0 号寄存器中放的永远是最近一次复制（yank）的内容。这和无名寄存器很不一样，它里面放的是最近操作的结果，也包括了 d、x、c 等命令，特别是包括了粘贴命令所替换的内容。1 到 9 号寄存器中放的则是上一次、倒数第二次、直到倒数第九次被删除或修改命令删除的文本。在做少量的用一个名字替换另一个名字、而又懒得使用替换命令时，"0p 是一个接近图形界面里的粘贴命令的常用选择。然后有小删除寄存器 -。上面我说得不全，删除内容进入 1 到 9 号寄存器的前提条件是被删除的内容至少有一行，或者使用了移动命令 %、(、)、`、/、?、n、N、{ 和 } 进行删除。否则，删除的内容只会进入 - 而不是 1 到 9 号寄存器。常用的有名寄存器 a 到 z。这些寄存器仅在用户手工指定时才会使用，内容在下一次打开 Vim 时仍然存在。比如，我们可以用 "ayy 代替 yy 把当前行复制到 a 寄存器中，以后就一直可以用 "ap 来进行粘贴了，直到 a 寄存器的内容被替换为止。不常用的特殊寄存器 . 、:、# 和 %。这些相对来说不那么常用，请自行查看帮助文件 :help ". 等。黑洞寄存器 _。专门用来删除，目的就是不要影响无名寄存器的内容。搜索寄存器 /。存放是上一次搜索使用的模式。表达式寄存器 =。可以把 Vim 表达式估值的结果作为寄存器的内容。这个我们以后讲 Vim 脚本编程的时候再探讨。最后是图形界面剪贴板寄存器 +、* 和 ~。一般而言，+ 寄存器代表操作系统的剪贴板，和图形界面应用程序交互用这个就好；你用图形界面 Vim 菜单里的拷贝和粘贴访问的也是系统剪贴板。* 和 ~ 在 X11 和 GTK 环境下有一些特殊用途，我们目前就不展开了。想深入钻研的话，可以查看帮助文档 :help "+、:help "* 和 :help "~。


寄存器在正常模式下可以用 d、y、p 等命令来访问，你现在应当已经很清楚了。它们在插入模式和命令行模式下也可以用 C-R 加寄存器名来访问，这经常也会省去你很多打字的麻烦。这些寄存器当然不是每个都常用。具体你是否会用到它们，取决你的工作方式。下面我说几个我自己编辑时的常用场景。


### 常用的寄存器使用场景
如果要交换两行内容，可以直接利用删除命令会把删除的内容放到无名寄存器这个特性。我们在第一行上面按下 dd，然后直接按 p 粘贴即可。如果要交换两处文本内容，可以类似地使用删除和粘贴替换都会把内容放到无名寄存器这个特性。我们选中第一处文本，按下 d 进行删除；然后选中第二处文本，按下 p 进行粘贴；最后回到第一处文本的原来位置，使用 P 把文本粘贴回去即可。

![img](https://static001.geekbang.org/resource/image/fe/b8/fe8e4ee739357cecdcd2a3f1f354e1b8.gif?wh=1324*902)

如果要少量修改某一变量名称（多的话使用 :s 替换命令更合适），可以把光标移到变量名称上，用 * 进行开启自动搜索，然后编辑变量名称到合适；随后复制新的变量名称，反复使用 n 命令搜索，并用 ve"0p 进行替换即可。当然，反复打 ve"0p 真的会感觉这个命令有点长。鉴于这个组合键使用的频度还挺高，我觉得映射一个更短的按键比较好，我的选择是 \v，同时，我做了点更通用的处理：

```
" 替换光标下单词的键映射
nnoremap <Leader>v viw"0p
vnoremap <Leader>v    "0p
```
关于 <Leader> 的含义，可查看帮助文档 :help <Leader>，里面说得很清楚，我就不重复了。如果你忘了 viw 的意义，请复习一下第 3 讲里的文本对象。

![img](https://static001.geekbang.org/resource/image/fd/cc/fd28ec0d43a977c62dc2b4dcacd40fcc.gif?wh=1324*902)

### 宏的录制和播放
Vim 里可以用 q 把动作记录到寄存器里，然后使用 @ 来播放这些动作。上面这个变量更名，如果用宏来做也可以：

用 * 开启搜索 键入 qa 开始录制宏到 a 寄存器；当然我们可以使用其他寄存器，只要被录制的命令不会修改这个寄存器即可，所以一般使用 a 到 z 这 26 个有名寄存器 键入 n 进行搜索；先行搜索的目的是，如果搜索不到内容，命令出错，宏的剩余部分就不会被执行 键入 eabar<Esc> 把 foo 修改为 foobar 键入 q 结束宏录制 键入 @a 播放录制的宏重复上一步直到 Vim 报告找不到 foo 为止

![img](https://static001.geekbang.org/resource/image/58/1d/588f5bd4416945d442924ac24ba0261d.gif?wh=1324*902)

关于宏的进一步细节可以查看帮助文件（:help q），我就不展开了。从上一节的 \v 到宏再到 :s 命令，对我们当前的任务而言，自动化程度逐步上升，但交互性逐步下降，“僵硬”性也逐步上升。对于重复遍数较多、信心较高的修改，我们应当偏向使用更自动化的方式，对于重复遍数较少或信心较低的修改，我认为使用不那么自动化的方式更有助于实时检查修改的效果。今天关于寄存器和复制粘贴我们就讲到这里。我们以后还会有讨论到寄存器的时候。

### 文本对象增强
Vim 对文本对象的支持我已经在第 3 讲里讨论过了。那些当然是很不错的功能，不过，能不能在那些功能的基础上再进一步，做出更有用的功能呢？对于写了多个 Vim 插件的 Tim Pope 来说，答案是肯定的。具体来说，如果你安装了他的 tpope/vim-surround 插件，你可以实现下面这些功能：

在一个单词的外面加上引号，如把 word 变成 "word"，可以使用命令 ysiw"把一个单词的外面的双引号变成单引号（有强迫症的 Python 程序员很可能有这样的需求），如把 "word" 变成 'word'，可以使用命令 cs"'把外面的引号或括号变成 HTML 标签也没有问题，如把 [my choice] 变成 <em>my choice</em>，可以使用命令 cs[<em>可视模式也有类似的命令，如可以在选中 my choice 后，输入 S<em> 把文本变成 <em>my choice</em>当然，你也可以把加上的包围符号移除，命令是 ds 后面跟包围符号，如 ds" 可以移除外围的双引号；要移除 HTML 标签则使用 t 来表达，即使用 dst 来移除文本外面的第一个 HTML 标签

注意 Vim 命令 . 只能用来重复 Vim 的内置命令，而不能用来重复上面这样的用户自定义命令。为了解决这个问题，我也会安装 tpope/vim-repeat 插件，使得重复命令对上面这样的情况依然能够生效。

![img](https://static001.geekbang.org/resource/image/27/2a/270e5c5a2cc9ccccf295b7f59db99d2a.gif?wh=1324*902)



### 撤销树
Vim 不仅支持多级撤销，而且有撤销树的概念。利用撤销树，你可以转回到编辑中的任何一个历史状态。不过，问题是，Vim 用来管理撤销树的命令不那么直观。在使用撤销树的图形化插件之前，我自己也没有把相关的命令真正用好。著名的撤销树插件我知道两个，一个是 mbbill/undotree，一个是 sjl/gundo.vim。两者功能相似，界面风格和快捷键有所不同。鉴于 undotree 功能更加丰富，我就以它为例来介绍一下。从下图中可以看到，undotree 可以展示完整修改历史。你可以用 J 和 K 在历史中跳转，左下角的预览窗口中就会显示修改的内容，右侧文件直接会回到相应的历史状态，并加亮最近的那次修改。一旦用上这个插件，就真的回不到没有这个插件的环境了。

![img](https://static001.geekbang.org/resource/image/3c/18/3c99c626290b302139e086ce05eebb18.png?wh=1582*1140)

另外需要稍加注意的一点是，一旦这个文件在其他编辑器里修改了，Vim 发现内容对不上，就无法保留编辑的历史。有一个绕过方法是，当你需要使用其他编辑器修改前，确保你在 Vim 里打开了该文件并且所有修改已保存；这样，在修改完成之后，只要在 Vim 里用 :e 命令重新载入该文件，Vim 就可以把外部的修改也保存在撤销历史记录里，保留完整的编辑历史。此外要注意的是，最后得在 Vim 里使用 :w 存盘一次，才能把编辑历史真正保存下来——即使你在 Vim 里没有进行任何修改，也需要这样做一下才能保存修改的历史。




### 对当前缓冲区的更名和移动
你肯定遇见过文件需要更名或者移动吧。这当然很简单，你可以通过图形界面或命令行进行操作。但这样操作之后，有一个问题是 Vim 的撤销历史跟文件就再也对不上了，你也没法再继续撤销更名或移动前的编辑操作了。有一个 Vim 插件，也是 Tim Pope 写的 tpope/vim-eunuch，可以解决这个问题。事实上，这个插件的功能远不止更名和移动。它实际上是把 Unix 的很多命令行工具搬到了 Vim 里（比较一下 Unix 和 eunuch 的发音你就知道这个插件的名字是什么意思了）。对我来说，最重要的就是它提供的 :Rename 和 :Move 命令，后面跟的参数就是新的名字或路径。这样操作之后，以后再打开这个更名或移动后的文件，仍然能够访问它的一切编辑历史。

### 模糊文件查找
使用 NERDTree 的话，你可以通过浏览目录来打开文件。这种方式，对于你知道文件在哪个目录下、但不知道文件名的时候特别有用。另外一种可能的情况是，你知道文件名或其中的关键部分，但你不知道或不关心文件在哪里。这种情况下，Fzf 的模糊匹配就非常有用了。我们先来看一下动画演示，有一个初步的印象：

![img](https://static001.geekbang.org/resource/image/da/36/da779a8796a771f3cbbce130c13a1036.gif?wh=1840*1198)


从动画可以看到，插件使用的是模糊匹配的方式，可以动态展示搜索的结果，并能直接预览当前选中的文件内容（在窗口足够宽的情况下）。因而这种方式不仅快，而且非常直观。跟其他插件不同的是，fzf.vim 插件依赖于 fzf 命令行工具。在 [fzf](https://github.com/junegunn/fzf) 的页面上列出了具体安装方式，支持各个平台。但由于这个软件比较新，老一点的 Linux 发布版（如 Ubuntu 18.04 和 CentOS 7）在包管理器里还没有 fzf。所以我的安装建议是：

对于 macOS，使用 Homebrew 命令 brew install fzf 安装。对于 Ubuntu 19.10 或更新版本，使用 sudo apt-get install fzf 安装。对于较老的 Ubuntu、CentOS 7 和其他页面中没有列出的 Linux 发布版，直接使用二进制发布版本，一般使用后缀为“linux_amd64.tgz”的文件。对于 Windows，也使用二进制发布版本，使用后缀为“windows386.zip”（32 位）或“windows_amd64.zip”（64 位）的文件。

在安装了 fzf 后（可以执行 fzf 来验证一下，它会枚举当前目录下的所有文件，并在你输入字符时缩小匹配；按 <CR> 选择文件，按 <Esc> 取消选择），就可以安装插件了。使用 minpac 的话，我们需要在 vimrc 中加入下面两行：

```
  call minpac#add('junegunn/fzf', {'do': {-> fzf#install()}})
  call minpac#add('junegunn/fzf.vim')
```
在安装完成之后，你就可以像我前面展示的那样使用 :Files 命令了。更多高级用法可以查看 fzf.vim 的页面。顺便说一句，如果你对安装一个可执行文件有点发怵的话，插件也可以自动帮你下载 fzf 命令。但这样做的缺点是，fzf 就只能在 Vim 里面使用了。如果你使用包管理器安装或手工安装，fzf 可以在 Vim 里使用，也可以在 Bash 等其他地方使用——fzf 的 Bash 集成是可以大大提升 shell 的使用体验的，不过这不属于我们 Vim 课程要讨论的话题，就请你自行参阅文档了。这个插件可以跟其他工具进一步配合。如果你安装了 ripgrep 和 bat 的话，可以获得更好的效果。动图中右下角文件预览的语法加亮的效果就依赖于系统里有 bat。如果你装了 ripgrep 的话，可以考虑设置下面的环境变量：

```
export FZF_DEFAULT_COMMAND='rg --files --sortr modified'
```
这样的话，fzf 可以利用 ripgrep 来自动过滤掉被 Git 忽略的文件、隐藏文件、二进制文件等程序员通常不关心的内容，并将结果以修改时间倒排，确保最新修改的文件在最下面，大大提高了迅速找到你需要的文件的概率。

### 内容小结
今天我们讲述了不少编辑中的技巧。鉴于这些内容比较散、单项内容又比较小，我在这儿只对它们适用的场合作一下快速总结：

Vim 里有自动完成功能，可以让你只输入文本或文件名 / 路径的一部分，让 Vim 来帮你完成剩余部分。反过来，对于文件中出现的文件名和超链接，Vim 也支持打开它们。Vim 里的寄存器相当于几十个不同用途的自动剪贴板，用好它们，能更加高效地完成常见的编辑动作。Vim 里的文本对象是个特色功能，vim-surround 和 vim-repeat 插件又对其进行了进一步增强。我觉得这对前端程序员和 Python 程序员会特别有用。跨会话撤销已经很强大了，而撤销树则让你能够充分发挥这个强大功能的潜力。Vim-eunuch 插件可以让你在对文件进行更名和移动时仍然保留其编辑 / 撤销历史。Fzf.vim 插件提供若干快速查找文件的工具，它的最基本命令 :Files 可以让你使用部分匹配的文件名快速地在当前目录或指定的目录下面的任一目录里找到你需要的文件。

本讲我们的配置文件修改也不少，包含了我们今天讲到的这些插件。对应的标签是 l9-unix 和 l9-windows。


## 10｜代码重构实验：在实战中提高编辑熟练度

在前几讲中，我们已经学了很多关于 Vim 的知识，现在需要好好消化一下。今天是基础篇的最后一讲，我们就基本上不学新的内容了，而是通过一个假想的代码重构实验，来复习、巩固已经学到的编辑技能。

### 开始前的准备工作
这是一堂实验课，你需要跟着我一步步地操作。跟只学习文字内容相比，实践操作能让你收获更多。所以，就请你现在把电脑准备好，跟我来吧。今天我们将要做的是，签出我为极客时间写的 C++ 示例程序，并对其中的代码进行重构。别紧张，你不需要精通 C++，因为我会在必要的时候对代码进行解释。你学习的重点在于，我是如何进行编辑的，而不是我写的代码是什么意思。首先，你需要先为工作代码找一个合适的父目录，然后用下面的命令签出代码（Windows 下面去掉“\”全部写一行，或者把“\”换成“^”））：
```
git clone --recurse-submodules \
          --shallow-submodules \
    https://github.com/adah1972/geek_time_cpp.git
```
万一我以后更改代码的话，就有可能造成内容或路径发生变化。所以，请把我们今天编辑的 commit id 记下来：632b067。如果你用 git log 看到 HEAD 的 commit id 不是它，可使用 git checkout 632b067 这个命令来签出跟今天完全相同的版本。下面，我们就开始了！

### 类模板 smart_ptr 更名
我们第一步要做的，是把示例的 smart_ptr 类模板更名为 shared_ptr。同时，为了避免跟标准的 shared_ptr 发生冲突，我们要把它放到名空间 gt里面去（当然，你可以用其他名字；这只是我们的示例）。大体思路是，先需要找到 shared_ptr 定义所在的文件，对其进行修改；然后找到使用该文件的地方，也进行相应的修改。下面我们就来做一下。

#### 修改类定义
首先，我们需要进入 geek_time_cpp 所在的目录。如果你前面的命令就是 git clone 的话，那现在使用 cd geek_time_cpp 就可以了。然后，我们当然是启动 Vim 了。假设我们知道 smart_ptr 被定义在 smart_ptr.h 头文件里，那我们最快的打开方式就是使用 :Files 命令，然后输入“sm”，即可看到“common/smart_ptr.h”成了第一选择。我们此时按下回车键即可打开文件。

![img](https://static001.geekbang.org/resource/image/da/5e/daa9009fe8f7c74a2c14fb64da06155e.gif?wh=1828*1084)

进入文件后，我们先来看一下文件的结构。根据目前的 Vim 配置，我们可以使用 <F9> 打开 tagbar 插件。注意，这个文件使用了 C++11，Exuberant Ctags 会有错误的识别。下面的截图是安装了 Universal Ctags 之后的结果：

![img](https://static001.geekbang.org/resource/image/bc/34/bc206cdd5b2094d6676a8ba283410c34.png?wh=1828*1084)



我们可以看到这个文件比较简单，里面主要就是两个类的定义和一些全局函数。不过，我们还是要确认一下，文件中没有任何会被错误匹配替换的内容。我们可以在右侧窗口里双击“smart_ptr”，这样左侧窗口就会跳转到 smart_ptr 的定义上，并且光标停留在类名上面。这样，我们只需使用 * 启动搜索和加亮即可。使用 n 继续搜索，我们很快就能确认文件中确实没有冲突的内容。下面，我们进行替换操作，需要键入的是 :%s/<C-R>//shared_ptr/g<CR>（<C-R> 和 <CR> 都是按键，而非小于符号后面跟其他字符）。我们不需要手工输入 `\<smart_ptr\>`，因为搜索寄存器 / 中已经有我们要的内容了。

![img](https://static001.geekbang.org/resource/image/fb/98/fbcc22dd7a2424afbfac32045b3e1e98.gif?wh=1828*1084)



最后，我们在第一个类定义的前面加上 namespace gt {、在最后的 #endif 前面加上 } /* namespace gt *／，就完成了定义的修改。不过，现在文件名还没有更改，文件里的包含保护（即宏 SMART_PTR_H）也没有更改。包含保护需要简单的重命名，就请你用我们目前介绍的任一方法自己完成了。随后，我们用命令 :Rename shared_ptr.h 即可完成更名和存盘操作。


#### 修改使用 smart_ptr 的地方
我们先试着用下面的命令搜索一下：

```
:grep -R --include="*.cpp" --include="*.h" "\<smart_ptr\>" .

```
（小提示：在查看搜索结果的时候，适时使用 zz、zt 和 zb 命令，可以把周边的代码看得更清楚。）使用 :cn （或我们定义的快捷键）仔细检查搜索出来的结果，我们会发现有一些误匹配：有 smart_ptr 是 unique_ptr 的情况，也有 smart_ptr 是策略类的情况。我们稍微改换一下方法，搜索对 smart_ptr.h 的使用：

```
:grep -R --include="*.cpp" --include="*.h" "\<smart_ptr\.h\>" .
```
这样的话，我们会发现结果只有一个匹配，那就简单了。在上一讲里，我们已经讨论了在这种情况下进行修改的三种不同方法（忘了？请回过去复习一下）。今天，我们用第四种方法。这种方法的每一步我们实际上都讲过，但串起来用，你可能就没有试过了。我们使用的基本命令是 cw、n 和 .。由于之前搜索过 smart_ptr，我们现在仍然可以继续使用 n 找到需要修改的地方。我们随即需要键入的，是 cwgt::shared_ptr<Esc>。这样输入虽然有点长、有点啰嗦，但它的好处是整个修改会被 Vim 看作是一步，因而可以用 . 命令来重复。这样，下面我们只需要反复利用 n 和 . 命令，把除了 #include 那行之外的所有 smart_ptr 都改成 gt::shared_ptr 即可。



![img](https://static001.geekbang.org/resource/image/d4/20/d4bb5a96e3951b71c9ecb1c00191b020.gif?wh=1828*1084)



很显然，这并不是唯一的方法，也不一定是最好的方法。所以，我建议你在这里暂停一下，用 :e! 重新载入这个文件，试试使用上一讲提到的其他方法。我这里就仅仅再给你展示一下如何使用替换命令，同时又不会误匹配文件名：

```
:%s/\<smart_ptr\>\ze\%([^.]\|$\)/gt::shared_ptr/g
```
这个匹配模式说的是，我要查找完整的单词“smart_ptr”（这就是要替换的内容了），但是，在匹配结束（\ze）后，我还有两个额外的匹配要求（用 \%( 和 \) 括起来），要么不是句点（[^.]），要么（\|）是行尾（$）。我们最后把唯一残留的 smart_ptr.h 修改成 shared_ptr.h，就完成了 smart_ptr 的更名任务。



### 编译执行（可选）
如果你懂 C++，并且有 geek_time_cpp 的 [README](https://github.com/adah1972/geek_time_cpp/blob/master/README.md) 文件里要求的执行环境的话，可以选择体验一下编译执行。

我们需要先在 02 目录下创建并进入 build 子目录，然后运行 cmake ..。随后，在 Unix 环境下，一般可立即使用快捷键 <F5> 进行编译；想要在 Windows 下也能正常进行编译，我们则应当设置 set makeprg=cmake\ --build\ .\ -j（老版本的 cmake 可能不支持 -j 命令行参数的话，这样的话，我们会没法用 cmake 进行并发编译；不过对于我们的小例子没啥关系）。另外一个要注意的地方是，Vim 在缺省配置下不能识别 Visual C++ 的错误输出格式 。为了能进行识别，并在发生错误时跳转到文件的指定位置，我们需要设置下面的选项：
```
set errorformat=\ %#%f(%l\\\,%c):\ %m
```
目前来讲，环境没问题的话，我们就会……遇到编译错误。

![img](https://static001.geekbang.org/resource/image/23/a2/2379fd36a653d5725129d0ecaebcb3a2.png?wh=1238*1287)

原因是 dynamic_pointer_cast 前面也需要加上 gt::。做了这个修改之后，我们就应该可以顺利编译出可执行文件了。在 Windows 下使用命令 :!.\Debug\sp_test02_shared_ptr，或在 Unix 平台下使用命令 :!./sp_test02_shared_ptr，我们即可在终端看到下面的输出：

```
circle()use count of ptr1 is 1use count of ptr2 was 0use count of ptr2 is now 2ptr1 is not emptyuse count of ptr3 is 3~circle()

```
同时，如果愿意的话，我们也可以使用 AsyncRun 提供的机制，在 Windows 下使用命令 :AsyncRun .\Debug\sp_test02_shared_ptr，或在 Unix 平台下使用命令 :AsyncRun ./sp_test02_shared_ptr，异步运行程序并把输出重定向到 quickfix 窗口里。


### 添加跟踪语句
假设我们对这个代码执行过程有些疑问，想添加些跟踪语句，该怎么做呢？我们首先需要在一个新窗口中打开 common/smart_ptr.h。由于我们第一个打开的文件就是它，所以它的缓冲区编号为 1，我们可在用 <C-W>n 打开一个新窗口后，使用 1<C-^> 飞速地重新打开文件。我们希望对引用计数的增、减、删除等操作进行跟踪。最简单的方式，当然就是执行对应操作的时候，把执行的语句也输出一下。像这样简单的机械化操作，显然就是宏的天下了。我们来试一下。我们先来改造一下 smart_ptr 析构函数里面的第一个 delete ptr_。一个可能的操作步骤是：

复制当前行粘贴当前行选中行首缩进后、结尾分号前的内容，套上双引号在这个新对象前后插入输出所必须的命令

我们需要录制的宏的内容是 yyPv$hS"gvS)iputs<Esc>l%a;<Esc>，而你把这一串东西用 nmap 命令映射给某个按键上也完全可行（注意，此处不能用 nnoremap，因为我们需要使用 vim-surround 插件带来的新的 S 按键的定义）。当然，在交互的环境中，录制按键会比眼睛看这个字符串容易理解多了。Vim 的宏，就其本质而言，可算是一种只写不读的简单过程式语言。

![img](https://static001.geekbang.org/resource/image/b7/73/b7e972e2c310b493f31bf18d16264873.gif?wh=1828*1084)

我们用到的命令里，只有 gv 是之前没有学过的。我们当然也有其他方法来选中行中的内容，但 gv 的作用是重新选中刚才选中的内容，最快，也最方便。利用这个宏，我们可以把添加调试语句变成按两个键。哦，对了，宏一旦执行过后，第二次执行同一个宏只需要键入 @@ 即可，这样还能更快些。在我们把所有的 delete 语句和 add_count 函数调用行上执行了这个宏之后，我们运行程序可以得到下面的结果：

```
circle()use count of ptr1 is 1use count of ptr2 was 0other.shared_count_->add_count();use count of ptr2 is now 2ptr1 is not emptyother.shared_count_->add_count();use count of ptr3 is 3delete ptr_;~circle()delete shared_count_;
```
如果想对这个代码作进一步调整，类似操作即可，相当容易吧？


### 调整测试用例
我们现在使用鼠标点击或者 <C-W>j 等命令跳转到测试代码 test02_shared_ptr.cpp 中。我们随即使用 <C-W>_ 命令来最大化窗口，因为似乎暂时用不着编辑 smart_ptr.h（但还不那么确定，否则就可以直接关闭那个窗口了）。我们打算在 ptr1 不为空的那个条件判断下面再加点内容。那行输出看着也挺无聊的，我们就直接把它干掉了。我们可以在那组大括号内的任意地方点击后，使用 ci{ 开始编辑，然后输入以下内容：

```
printf("ptr1 %s ptr2\n",
       ptr1 == ptr2 ? '==' : '!=');
```
代码编译居然有奇怪的告警出现……我是 Python 写多了，脑子没转回来吗？没关系，在第一处单引号内部键入 cs'"，然后在第二处单引号内部键入 . 重复一下就好，现在代码应该是正确的了：
```
printf("ptr1 %s ptr2\n",
       ptr1 == ptr2 ? "==" : "!=");
```
再次编译，完美，没有问题了！运行程序，我们得到：
```
circle()use count of ptr1 is 1use count of ptr2 was 0other.shared_count_->add_count();use count of ptr2 is now 2ptr1 == ptr2other.shared_count_->add_count();use count of ptr3 is 3delete ptr_;~circle()delete shared_count_;
```
### 内容小结
今天我们尝试对一小段 C++ 代码进行了简单的重构。在这个过程中，我们使用和复习了下面这些编辑技巧：

使用 fzf.vim 来根据部分文件名迅速打开文件使用 tagbar 来浏览文件的结构使用 vim-eunuch 来进行文件更名使用替换命令来进行批量代码更名使用 . 命令技巧来进行批量代码更名使用 <C-R> 在插入模式和命令行模式中使用寄存器的内容使用 :grep 命令在文件中进行文本搜索使用异步的构建命令，并设置选项使得错误信息解析在 Visual Studio 工具里也能工作使用文本对象命令对用括号、引号等符号包起来的文本进行统一的修改使用宏，在一次操作之后，在遇到类似场景时可以快速修改

虽然今天的代码是 C++ 的，但这些编辑方式适用于任何语言。请你一定要牢牢掌握。我们也应该慢慢看到了，编辑的一个要点，在于把需要重复的工作自动化和简单化。Vim 作为一个程序员的编辑器，提供了灵活而强大的编辑机制——最终用户，或扩展包的开发者，都可以利用这些底层机制，使编辑变得更加高效。本讲我们对 Windows 下的 vimrc 配置文件有一处小修改，对应的标签是“l10-windows”。

