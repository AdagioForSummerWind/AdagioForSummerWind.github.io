# 管理集群守护进程

## 对 DaemonSet 执行滚动更新

本文介绍了如何对 DaemonSet 执行滚动更新。

### 准备开始[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B)

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

- [Killercoda](https://killercoda.com/playgrounds/scenario/kubernetes)
- [玩转 Kubernetes](http://labs.play-with-k8s.com/)

### DaemonSet 更新策略[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#daemonset-update-strategy)

DaemonSet 有两种更新策略：

- `OnDelete`: 使用 `OnDelete` 更新策略时，在更新 DaemonSet 模板后，只有当你手动删除老的 DaemonSet pods 之后，新的 DaemonSet Pod **才会**被自动创建。跟 Kubernetes 1.6 以前的版本类似。
- `RollingUpdate`: 这是默认的更新策略。使用 `RollingUpdate` 更新策略时，在更新 DaemonSet 模板后， 老的 DaemonSet Pod 将被终止，并且将以受控方式自动创建新的 DaemonSet Pod。 更新期间，最多只能有 DaemonSet 的一个 Pod 运行于每个节点上。

### 执行滚动更新[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#performing-a-rolling-update)

要启用 DaemonSet 的滚动更新功能，必须设置 `.spec.updateStrategy.type` 为 `RollingUpdate`。

你可能想设置 [`.spec.updateStrategy.rollingUpdate.maxUnavailable`](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec) (默认为 1)， [`.spec.minReadySeconds`](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec) (默认为 0) 和 [`.spec.updateStrategy.rollingUpdate.maxSurge`](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/#DaemonSetSpec) （默认为 0）。

#### 创建带有 `RollingUpdate` 更新策略的 DaemonSet[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#creating-a-daemonset-with-rollingupdate-update-strategy)

下面的 YAML 包含一个 DaemonSet，其更新策略为 'RollingUpdate'：

[`controllers/fluentd-daemonset.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/fluentd-daemonset.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/fluentd-daemonset.yaml to clipboard")

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        name: fluentd-elasticsearch
    spec:
      tolerations:
      # 这些容忍度设置是为了让该守护进程集在控制平面节点上运行
      # 如果你不希望自己的控制平面节点运行 Pod，可以删除它们
      - key: node-role.kubernetes.io/master
        effect: NoSchedule
      containers:
      - name: fluentd-elasticsearch
        image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
```

检查了 DaemonSet 清单中更新策略的设置之后，创建 DaemonSet：

```shell
kubectl create -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml
```

另一种方式是如果你希望使用 `kubectl apply` 来更新 DaemonSet 的话， 也可以使用 `kubectl apply` 来创建 DaemonSet：

```shell
kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml
```

#### 检查 DaemonSet 的滚动更新策略[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#checking-daemonset-rollingupdate-update-strategy)

首先，检查 DaemonSet 的更新策略，确保已经将其设置为 `RollingUpdate`:

```shell
kubectl get ds/fluentd-elasticsearch -o go-template='{{.spec.updateStrategy.type}}{{"\n"}}' -n kube-system
```

如果还没在系统中创建 DaemonSet，请使用以下命令检查 DaemonSet 的清单：

```shell
kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset.yaml --dry-run=client -o go-template='{{.spec.updateStrategy.type}}{{"\n"}}'
```

两个命令的输出都应该为：

```
RollingUpdate
```

如果输出不是 `RollingUpdate`，请返回并相应地修改 DaemonSet 对象或者清单。

#### 更新 DaemonSet 模板[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#updating-a-daemonset-template)

对 `RollingUpdate` DaemonSet 的 `.spec.template` 的任何更新都将触发滚动更新。 这可以通过几个不同的 `kubectl` 命令来完成。

[`controllers/fluentd-daemonset-update.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/fluentd-daemonset-update.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/fluentd-daemonset-update.yaml to clipboard")

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
  template:
    metadata:
      labels:
        name: fluentd-elasticsearch
    spec:
      tolerations:
      # 这些容忍度设置是为了让该守护进程集在控制平面节点上运行
      # 如果你不希望自己的控制平面节点运行 Pod，可以删除它们
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:
      - name: fluentd-elasticsearch
        image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
```

##### 声明式命令[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#declarative-commands)

如果你使用[配置文件](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/declarative-config/)来更新 DaemonSet，请使用 `kubectl apply`：

```shell
kubectl apply -f https://k8s.io/examples/controllers/fluentd-daemonset-update.yaml
```

##### 指令式命令[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#imperative-commands)

如果你使用[指令式命令](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/imperative-command/)来更新 DaemonSets，请使用 `kubectl edit`：

```shell
kubectl edit ds/fluentd-elasticsearch -n kube-system
```

###### 只更新容器镜像[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#updating-only-the-container-image)

如果你只需要更新 DaemonSet 模板里的容器镜像，比如 `.spec.template.spec.containers[*].image`， 请使用 `kubectl set image`：

```shell
kubectl set image ds/fluentd-elasticsearch fluentd-elasticsearch=quay.io/fluentd_elasticsearch/fluentd:v2.6.0 -n kube-system
```

#### 监视滚动更新状态[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#watching-the-rolling-update-status)

最后，观察 DaemonSet 最新滚动更新的进度：

```shell
kubectl rollout status ds/fluentd-elasticsearch -n kube-system
```

当滚动更新完成时，输出结果如下：

```shell
daemonset "fluentd-elasticsearch" successfully rolled out
```

### 故障排查[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#troubleshooting)

#### DaemonSet 滚动更新卡住[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#daemonset-rolling-update-is-stuck)

有时，DaemonSet 滚动更新可能卡住，以下是一些可能的原因：

##### 一些节点可用资源耗尽[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#some-nodes-run-out-of-resources)

DaemonSet 滚动更新可能会卡住，其 Pod 至少在某个节点上无法调度运行。 当节点上[可用资源耗尽](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/)时， 这是可能的。

发生这种情况时，通过对 `kubectl get nodes` 和下面命令行的输出作比较， 找出没有调度 DaemonSet Pod 的节点：

```shell
kubectl get pods -l name=fluentd-elasticsearch -o wide -n kube-system
```

一旦找到这些节点，从节点上删除一些非 DaemonSet Pod，为新的 DaemonSet Pod 腾出空间。

**说明：** 当所删除的 Pod 不受任何控制器管理，也不是多副本的 Pod时，上述操作将导致服务中断。 同时，上述操作也不会考虑 [PodDisruptionBudget](https://kubernetes.io/zh-cn/docs/tasks/run-application/configure-pdb/) 所施加的约束。

##### 不完整的滚动更新[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#broken-rollout)

如果最近的 DaemonSet 模板更新被破坏了，比如，容器处于崩溃循环状态或者容器镜像不存在 （通常由于拼写错误），就会发生 DaemonSet 滚动更新中断。

要解决此问题，需再次更新 DaemonSet 模板。新的滚动更新不会被以前的不健康的滚动更新阻止。

##### 时钟偏差[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#clock-skew)

如果在 DaemonSet 中指定了 `.spec.minReadySeconds`，主控节点和工作节点之间的时钟偏差会使 DaemonSet 无法检测到正确的滚动更新进度。

### 清理[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#clean-up)

从名字空间中删除 DaemonSet：

```shell
kubectl delete ds fluentd-elasticsearch -n kube-system
```

### 接下来[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 查看[在 DaemonSet 上执行回滚](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/)
- 查看[创建 DaemonSet 以收养现有 DaemonSet Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/)

## 对 DaemonSet 执行回滚

本文展示了如何对 [DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/) 执行回滚。

### 准备开始[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B)

你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。 建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。 如果你还没有集群，你可以通过 [Minikube](https://minikube.sigs.k8s.io/docs/tutorials/multi_node/) 构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：

- [Killercoda](https://killercoda.com/playgrounds/scenario/kubernetes)
- [玩转 Kubernetes](http://labs.play-with-k8s.com/)

你的 Kubernetes 服务器版本必须不低于版本 1.7. 要获知版本信息，请输入 `kubectl version`.

你应该已经了解如何[为 DaemonSet 执行滚东更新](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/)。

### 对 DaemonSet 执行回滚[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E5%AF%B9-daemonset-%E6%89%A7%E8%A1%8C%E5%9B%9E%E6%BB%9A)

#### 步骤 1：找到想要 DaemonSet 回滚到的历史修订版本（revision）[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E6%AD%A5%E9%AA%A4-1-%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81-daemonset-%E5%9B%9E%E6%BB%9A%E5%88%B0%E7%9A%84%E5%8E%86%E5%8F%B2%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC-revision)

如果只想回滚到最后一个版本，可以跳过这一步。

列出 DaemonSet 的所有版本：

```shell
kubectl rollout history daemonset <daemonset-name>
```

此命令返回 DaemonSet 版本列表：

```shell
daemonsets "<daemonset-name>"
REVISION        CHANGE-CAUSE
1               ...
2               ...
...
```

- 在创建时，DaemonSet 的变化原因从 `kubernetes.io/change-cause` 注解（annotation） 复制到其修订版本中。用户可以在 `kubectl` 命令中设置 `--record=true`， 将执行的命令记录在变化原因注解中。

执行以下命令，来查看指定版本的详细信息：

```shell
kubectl rollout history daemonset <daemonset-name> --revision=1
```

该命令返回相应修订版本的详细信息：

```shell
daemonsets "<daemonset-name>" with revision #1
Pod Template:
Labels:       foo=bar
Containers:
app:
 Image:        ...
 Port:         ...
 Environment:  ...
 Mounts:       ...
Volumes:      ...
```

#### 步骤 2：回滚到指定版本[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E6%AD%A5%E9%AA%A4-2-%E5%9B%9E%E6%BB%9A%E5%88%B0%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC)

```shell
# 在 --to-revision 中指定你从步骤 1 中获取的修订版本
kubectl rollout undo daemonset <daemonset-name> --to-revision=<revision>
```

如果成功，命令会返回：

```shell
daemonset "<daemonset-name>" rolled back
```

**说明：** 如果 `--to-revision` 参数未指定，将选中最近的版本。

#### 步骤 3：监视 DaemonSet 回滚进度[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E6%AD%A5%E9%AA%A4-3-%E7%9B%91%E8%A7%86-daemonset-%E5%9B%9E%E6%BB%9A%E8%BF%9B%E5%BA%A6)

`kubectl rollout undo daemonset` 向服务器表明启动 DaemonSet 回滚。 真正的回滚是在集群的 [控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane) 异步完成的。

执行以下命令，来监视 DaemonSet 回滚进度：

```shell
kubectl rollout status ds/<daemonset-name>
```

回滚完成时，输出形如：

```
daemonset "<daemonset-name>" successfully rolled out
```

### 理解 DaemonSet 修订版本[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E7%90%86%E8%A7%A3-daemonset-%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC)

在前面的 `kubectl rollout history` 步骤中，你获得了一个修订版本列表，每个修订版本都存储在名为 `ControllerRevision` 的资源中。

要查看每个修订版本中保存的内容，可以找到 DaemonSet 修订版本的原生资源：

```shell
kubectl get controllerrevision -l <daemonset-selector-key>=<daemonset-selector-value>
```

该命令返回 `ControllerRevisions` 列表：

```
NAME                               CONTROLLER                     REVISION   AGE
<daemonset-name>-<revision-hash>   DaemonSet/<daemonset-name>     1          1h
<daemonset-name>-<revision-hash>   DaemonSet/<daemonset-name>     2          1h
```

每个 `ControllerRevision` 中存储了相应 DaemonSet 版本的注解和模板。

`kubectl rollout undo` 选择特定的 `ControllerRevision`，并用 `ControllerRevision` 中存储的模板代替 DaemonSet 的模板。 `kubectl rollout undo` 相当于通过其他命令（如 `kubectl edit` 或 `kubectl apply`） 将 DaemonSet 模板更新至先前的版本。

**说明：** 注意 DaemonSet 修订版本只会正向变化。也就是说，回滚完成后，所回滚到的 `ControllerRevision` 版本号 (`.revision` 字段) 会增加。 例如，如果用户在系统中有版本 1 和版本 2，并从版本 2 回滚到版本 1， 带有 `.revision: 1` 的 `ControllerRevision` 将变为 `.revision: 3`。

### 故障排查[](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/#%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5)

- 参阅 [DaemonSet 滚动升级故障排除](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/#troubleshooting)。