# 概念

## 概述

Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。Kubernetes 拥有一个庞大且快速增长的生态系统，其服务、支持和工具的使用范围广泛。

此页面是 Kubernetes 的概述。

Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态，其服务、支持和工具的使用范围相当广泛。

**Kubernetes** 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 [Google 大规模运行生产工作负载十几年经验](https://research.google/pubs/pub43438)的基础上， 结合了社区中最优秀的想法和实践。

### 时光回溯[](https://kubernetes.io/zh-cn/docs/concepts/overview/#going-back-in-time)

让我们回顾一下为何 Kubernetes 能够裨益四方。

![部署演进](https://d33wubrfki0l68.cloudfront.net/26a177ede4d7b032362289c6fccd448fc4a91174/eb693/images/docs/container_evolution.svg)

**传统部署时代：**

早期，各个组织是在物理服务器上运行应用程序。 由于无法限制在物理服务器中运行的应用程序资源使用，因此会导致资源分配问题。 例如，如果在同一台物理服务器上运行多个应用程序， 则可能会出现一个应用程序占用大部分资源的情况，而导致其他应用程序的性能下降。 一种解决方案是将每个应用程序都运行在不同的物理服务器上， 但是当某个应用程式资源利用率不高时，剩余资源无法被分配给其他应用程式， 而且维护许多物理服务器的成本很高。

**虚拟化部署时代：**

因此，虚拟化技术被引入了。虚拟化技术允许你在单个物理服务器的 CPU 上运行多台虚拟机（VM）。 虚拟化能使应用程序在不同 VM 之间被彼此隔离，且能提供一定程度的安全性， 因为一个应用程序的信息不能被另一应用程序随意访问。

虚拟化技术能够更好地利用物理服务器的资源，并且因为可轻松地添加或更新应用程序， 而因此可以具有更高的可扩缩性，以及降低硬件成本等等的好处。 通过虚拟化，你可以将一组物理资源呈现为可丢弃的虚拟机集群。

每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。

**容器部署时代：**

容器类似于 VM，但是更宽松的隔离特性，使容器之间可以共享操作系统（OS）。 因此，容器比起 VM 被认为是更轻量级的。且与 VM 类似，每个容器都具有自己的文件系统、CPU、内存、进程空间等。 由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。

容器因具有许多优势而变得流行起来，例如：

- 敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。
- 持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性）， 提供可靠且频繁的容器镜像构建和部署。
- 关注开发与运维的分离：在构建、发布时创建应用程序容器镜像，而不是在部署时， 从而将应用程序与基础架构分离。
- 可观察性：不仅可以显示 OS 级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。
- 跨开发、测试和生产的环境一致性：在笔记本计算机上也可以和在云中运行一样的应用程序。
- 跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。
- 以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。
- 松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。
- 资源隔离：可预测的应用程序性能。
- 资源利用：高效率和高密度。

### 为什么需要 Kubernetes，它能做什么？[](https://kubernetes.io/zh-cn/docs/concepts/overview/#why-you-need-kubernetes-and-what-can-it-do)

容器是打包和运行应用程序的好方式。在生产环境中， 你需要管理运行着应用程序的容器，并确保服务不会下线。 例如，如果一个容器发生故障，则你需要启动另一个容器。 如果此行为交由给系统处理，是不是会更容易一些？

这就是 Kubernetes 要来做的事情！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。 Kubernetes 会满足你的扩展要求、故障转移你的应用、提供部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary (金丝雀) 部署。

Kubernetes 为你提供：

- **服务发现和负载均衡**
    
    Kubernetes 可以使用 DNS 名称或自己的 IP 地址来暴露容器。 如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。
    

- **存储编排**
    
    Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。
    

- **自动部署和回滚**
    
    你可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。
    

- **自动完成装箱计算**
    
    你为 Kubernetes 提供许多节点组成的集群，在这个集群上运行容器化的任务。 你告诉 Kubernetes 每个容器需要多少 CPU 和内存 (RAM)。 Kubernetes 可以将这些容器按实际情况调度到你的节点上，以最佳方式利用你的资源。
    

- **自我修复**
    
    Kubernetes 将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端。
    

- **密钥与配置管理**
    
    Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。
    

### Kubernetes 不是什么[](https://kubernetes.io/zh-cn/docs/concepts/overview/#what-kubernetes-is-not)

Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 由于 Kubernetes 是在容器级别运行，而非在硬件级别，它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡，允许用户集成他们的日志记录、监控和警报方案。 但是，Kubernetes 不是单体式（monolithic）系统，那些默认解决方案都是可选、可插拔的。 Kubernetes 为构建开发人员平台提供了基础，但是在重要的地方保留了用户选择权，能有更高的灵活性。

Kubernetes：

- 不限制支持的应用程序类型。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。
- 不部署源代码，也不构建你的应用程序。 持续集成（CI）、交付和部署（CI/CD）工作流取决于组织的文化和偏好以及技术要求。
- 不提供应用程序级别的服务作为内置服务，例如中间件（例如消息中间件）、 数据处理框架（例如 Spark）、数据库（例如 MySQL）、缓存、集群存储系统 （例如 Ceph）。这样的组件可以在 Kubernetes 上运行，并且/或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如[开放服务代理](https://openservicebrokerapi.org/)）来访问。

- 不是日志记录、监视或警报的解决方案。 它集成了一些功能作为概念证明，并提供了收集和导出指标的机制。
- 不提供也不要求配置用的语言、系统（例如 jsonnet），它提供了声明性 API， 该声明性 API 可以由任意形式的声明性规范所构成。
- 不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。
- 此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 而 Kubernetes 包含了一组独立可组合的控制过程，可以持续地将当前状态驱动到所提供的预期状态。 你不需要在乎如何从 A 移动到 C，也不需要集中控制，这使得系统更易于使用且功能更强大、 系统更健壮，更为弹性和可扩展。

### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 查阅 [Kubernetes 组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/)
- 查阅 [Kubernetes API](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/)
- 查阅 [Cluster 架构](https://kubernetes.io/zh-cn/docs/concepts/architecture/)
- 开始 [Kubernetes 的建置](https://kubernetes.io/zh-cn/docs/setup/)吧！


### Kubernetes 组件

Kubernetes 集群由控制平面的组件和一组称为节点的机器组成。

A Kubernetes cluster consists of 一组工作机器，称为 [节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)， 会运行容器化应用程序。每个集群至少有一个工作节点。

工作节点会托管 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) ，而 Pod 就是作为应用负载的组件。 [控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。

This document outlines the various components you need to have for a complete and working Kubernetes cluster.

![Components of Kubernetes](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

The components of a Kubernetes cluster

\-->

当你部署完 Kubernetes，便拥有了一个完整的集群。

一组工作机器，称为 [节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)， 会运行容器化应用程序。每个集群至少有一个工作节点。

工作节点会托管 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) ，而 Pod 就是作为应用负载的组件。 [控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)管理集群中的工作节点和 Pod。 在生产环境中，控制平面通常跨多台计算机运行， 一个集群通常运行多个节点，提供容错性和高可用性。

本文档概述了一个正常运行的 Kubernetes 集群所需的各种组件。

![Kubernetes 的组件](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

Kubernetes 集群的组件

#### 控制平面组件（Control Plane Components）[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components)

控制平面组件会为集群做出全局决策，比如资源的调度。 以及检测和响应集群事件，例如当不满足部署的 `replicas` 字段时， 要启动新的 [pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)）。

控制平面组件可以在集群中的任何节点上运行。 然而，为了简单起见，设置脚本通常会在同一个计算机上启动所有控制平面组件， 并且不会在此计算机上运行用户容器。 请参阅[使用 kubeadm 构建高可用性集群](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/high-availability/) 中关于跨多机器控制平面设置的示例。

##### kube-apiserver[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)

API 服务器是 Kubernetes [控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。

Kubernetes API 服务器的主要实现是 [kube-apiserver](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/)。 `kube-apiserver` 设计上考虑了水平扩缩，也就是说，它可通过部署多个实例来进行扩缩。 你可以运行 `kube-apiserver` 的多个实例，并在这些实例之间平衡流量。

##### etcd[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#etcd)

一致且高可用的键值存储，用作 Kubernetes 所有集群数据的后台数据库。

如果你的 Kubernetes 集群使用 etcd 作为其后台数据库， 请确保你针对这些数据有一份 [备份](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster)计划。

你可以在官方[文档](https://etcd.io/docs/)中找到有关 etcd 的深入知识。

##### kube-scheduler[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-scheduler)

`kube-scheduler` 是[控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)的组件， 负责监视新创建的、未指定运行[节点（node）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)的 [Pods](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)， 并选择节点来让 Pod 在上面运行。

调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。

##### kube-controller-manager[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-controller-manager)

[kube-controller-manager](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/) 是[控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)的组件， 负责运行[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)进程。

从逻辑上讲， 每个[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在同一个进程中运行。

这些控制器包括：

- 节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应
- 任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成
- 端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。
- 服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。

##### cloud-controller-manager[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#cloud-controller-manager)

一个 Kubernetes [控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。

`cloud-controller-manager` 仅运行特定于云平台的控制器。 因此如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的集群不需要有云控制器管理器。

与 `kube-controller-manager` 类似，`cloud-controller-manager` 将若干逻辑上独立的控制回路组合到同一个可执行文件中， 供你以同一进程的方式运行。 你可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。

下面的控制器都包含对云平台驱动的依赖：

- 节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除
- 路由控制器（Route Controller）：用于在底层云基础架构中设置路由
- 服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器

#### Node 组件[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components)

节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。

##### kubelet[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kubelet)

`kubelet` 会在集群中每个[节点（node）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)上运行。 它保证[容器（containers）](https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers)都运行在 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 中。

kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器。

##### kube-proxy[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-proxy)

[kube-proxy](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/) 是集群中每个[节点（node）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)上所运行的网络代理， 实现 Kubernetes [服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 概念的一部分。

kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。

如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发。

##### 容器运行时（Container Runtime）[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-runtime)

容器运行环境是负责运行容器的软件。

Kubernetes 支持许多容器运行环境，例如 [containerd](https://containerd.io/docs/)、 [CRI-O](https://cri-o.io/#what-is-cri-o) 以及 [Kubernetes CRI (容器运行环境接口)](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md) 的其他任何实现。

#### 插件（Addons）[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#addons)

插件使用 Kubernetes 资源（[DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/)、 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 等）实现集群功能。 因为这些插件提供集群级别的功能，插件中命名空间域的资源属于 `kube-system` 命名空间。

下面描述众多插件中的几种。有关可用插件的完整列表，请参见 [插件（Addons）](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/)。

##### DNS[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#dns)

尽管其他插件都并非严格意义上的必需组件，但几乎所有 Kubernetes 集群都应该有[集群 DNS](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/)， 因为很多示例都需要 DNS 服务。

集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。

Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。

##### Web 界面（仪表盘）[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#web-ui-dashboard)

[Dashboard](https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/) 是 Kubernetes 集群的通用的、基于 Web 的用户界面。 它使用户可以管理集群中运行的应用程序以及集群本身， 并进行故障排除。

##### 容器资源监控[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-resource-monitoring)

[容器资源监控](https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/) 将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中， 并提供浏览这些数据的界面。

##### 集群层面日志[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#cluster-level-logging)

[集群层面日志](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/logging/)机制负责将容器的日志数据保存到一个集中的日志存储中， 这种集中日志存储提供搜索和浏览接口。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)
- 进一步了解[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)
- 进一步了解 [kube-scheduler](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/)
- 阅读 etcd 官方[文档](https://etcd.io/docs/)



### Kubernetes API

Kubernetes API 使你可以查询和操纵 Kubernetes 中对象的状态。 Kubernetes 控制平面的核心是 API 服务器和它暴露的 HTTP API。 用户、集群的不同部分以及外部组件都通过 API 服务器相互通信。

Kubernetes [控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)的核心是 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)。 API 服务器负责提供 HTTP API，以供用户、集群中的不同部分和集群外部组件相互通信。

Kubernetes API 使你可以查询和操纵 Kubernetes API 中对象（例如：Pod、Namespace、ConfigMap 和 Event）的状态。

大部分操作都可以通过 [kubectl](https://kubernetes.io/zh-cn/docs/reference/kubectl/) 命令行接口或类似 [kubeadm](https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/) 这类命令行工具来执行， 这些工具在背后也是调用 API。不过，你也可以使用 REST 调用来访问这些 API。

如果你正在编写程序来访问 Kubernetes API， 可以考虑使用[客户端库](https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/)之一。

#### OpenAPI 规范[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#api-specification)

完整的 API 细节是用 [OpenAPI](https://www.openapis.org/) 来表述的。

##### OpenAPI V2[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#openapi-v2)

Kubernetes API 服务器通过 `/openapi/v2` 端点提供聚合的 OpenAPI v2 规范。 你可以按照下表所给的请求头部，指定响应的格式：

| 头部 | 可选值 | 说明 |
| --- | --- | --- |
| `Accept-Encoding` | `gzip` | _不指定此头部也是可以的_ |
| `Accept` | `application/com.github.proto-openapi.spec.v2@v1.0+protobuf` | _主要用于集群内部_ |
| `application/json` | _默认值_ |
| `*` | _提供_`application/json` |

Kubernetes 为 API 实现了一种基于 Protobuf 的序列化格式，主要用于集群内部通信。 关于此格式的详细信息，可参考 [Kubernetes Protobuf 序列化](https://git.k8s.io/design-proposals-archive/api-machinery/protobuf.md)设计提案。 每种模式对应的接口描述语言（IDL）位于定义 API 对象的 Go 包中。

##### OpenAPI V3[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#openapi-v3)

**特性状态：** `Kubernetes v1.24 [beta]`

Kubernetes v1.26 提供将其 API 以 OpenAPI v3 形式发布的 beta 支持； 这一功能特性处于 beta 状态，默认被开启。 你可以通过为 kube-apiserver 组件关闭 `OpenAPIV3` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)来禁用此 beta 特性。

发现端点 `/openapi/v3` 被提供用来查看可用的所有组、版本列表。 此列表仅返回 JSON。这些组、版本以下面的格式提供：

```yaml
{
    "paths": {
        ...,
        "api/v1": {
            "serverRelativeURL": "/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF"
        },
        "apis/admissionregistration.k8s.io/v1": {
            "serverRelativeURL": "/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597"
        },
        ....
    }
}
```

为了改进客户端缓存，相对的 URL 会指向不可变的 OpenAPI 描述。 为了此目的，API 服务器也会设置正确的 HTTP 缓存标头 （`Expires` 为未来 1 年，和 `Cache-Control` 为 `immutable`）。 当一个过时的 URL 被使用时，API 服务器会返回一个指向最新 URL 的重定向。

Kubernetes API 服务器会在端点 `/openapi/v3/apis/<group>/<version>?hash=<hash>` 发布一个 Kubernetes 组版本的 OpenAPI v3 规范。

请参阅下表了解可接受的请求头部。

| 头部 | 可选值 | 说明 |
| --- | --- | --- |
| `Accept-Encoding` | `gzip` | _不提供此头部也是可接受的_ |
| `Accept` | `application/com.github.proto-openapi.spec.v3@v1.0+protobuf` | _主要用于集群内部使用_ |
| `application/json` | _默认_ |
| `*` | _以_ `application/json` 形式返回 |

#### 持久化[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#persistence)

Kubernetes 通过将序列化状态的对象写入到 [etcd](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/) 中完成存储操作。

#### API 组和版本控制[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning)

为了更容易消除字段或重组资源的呈现方式，Kubernetes 支持多个 API 版本，每个版本位于不同的 API 路径， 例如 `/api/v1` 或 `/apis/rbac.authorization.k8s.io/v1alpha1`。

版本控制是在 API 级别而不是在资源或字段级别完成的，以确保 API 呈现出清晰、一致的系统资源和行为视图， 并能够控制对生命结束和/或实验性 API 的访问。

为了更容易演进和扩展其 API，Kubernetes 实现了 [API 组](https://kubernetes.io/zh-cn/docs/reference/using-api/#api-groups)， 这些 API 组可以被[启用或禁用](https://kubernetes.io/zh-cn/docs/reference/using-api/#enabling-or-disabling)。

API 资源通过其 API 组、资源类型、名字空间（用于名字空间作用域的资源）和名称来区分。 API 服务器透明地处理 API 版本之间的转换：所有不同的版本实际上都是相同持久化数据的呈现。 API 服务器可以通过多个 API 版本提供相同的底层数据。

例如，假设针对相同的资源有两个 API 版本：`v1` 和 `v1beta1`。 如果你最初使用其 API 的 `v1beta1` 版本创建了一个对象， 你稍后可以使用 `v1beta1` 或 `v1` API 版本来读取、更新或删除该对象， 直到 `v1beta1` 版本被废弃和移除为止。此后，你可以使用 `v1` API 继续访问和修改该对象。

##### API 变更[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#api-changes)

任何成功的系统都要随着新的使用案例的出现和现有案例的变化来成长和变化。 为此，Kubernetes 已设计了 Kubernetes API 来持续变更和成长。 Kubernetes 项目的目标是 **不要** 给现有客户端带来兼容性问题，并在一定的时期内维持这种兼容性， 以便其他项目有机会作出适应性变更。

一般而言，新的 API 资源和新的资源字段可以被频繁地添加进来。 删除资源或者字段则要遵从 [API 废弃策略](https://kubernetes.io/zh-cn/docs/reference/using-api/deprecation-policy/)。

Kubernetes 对维护达到正式发布（GA）阶段的官方 API 的兼容性有着很强的承诺，通常这一 API 版本为 `v1`。 此外，Kubernetes 保持与 Kubernetes 官方 API 的 **Beta** API 版本持久化数据的兼容性， 并确保在该功能特性已进入稳定期时数据可以通过 GA API 版本进行转换和访问。

如果你采用一个 Beta API 版本，一旦该 API 进阶，你将需要转换到后续的 Beta 或稳定的 API 版本。 执行此操作的最佳时间是 Beta API 处于弃用期，因为此时可以通过两个 API 版本同时访问那些对象。 一旦 Beta API 结束其弃用期并且不再提供服务，则必须使用替换的 API 版本。

**说明：**

尽管 Kubernetes 也努力为 **Alpha** API 版本维护兼容性，在有些场合兼容性是无法做到的。 如果你使用了任何 Alpha API 版本，需要在升级集群时查看 Kubernetes 发布说明， 如果 API 确实以不兼容的方式发生变更，则需要在升级之前删除所有现有的 Alpha 对象。

关于 API 版本分级的定义细节，请参阅 [API 版本参考](https://kubernetes.io/zh-cn/docs/reference/using-api/#api-versioning)页面。

#### API 扩展[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#api-extension)

有两种途径来扩展 Kubernetes API：

1. 你可以使用[自定义资源](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/)来以声明式方式定义 API 服务器如何提供你所选择的资源 API。
2. 你也可以选择实现自己的[聚合层](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)来扩展 Kubernetes API。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解如何通过添加你自己的 [CustomResourceDefinition](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/) 来扩展 Kubernetes API。
- [控制 Kubernetes API 访问](https://kubernetes.io/zh-cn/docs/concepts/security/controlling-access/)页面描述了集群如何针对 API 访问管理身份认证和鉴权。
- 通过阅读 [API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/)了解 API 端点、资源类型以及示例。
- 阅读 [API 变更（英文）](https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme) 以了解什么是兼容性的变更以及如何变更 API。


### 使用 Kubernetes 对象

Kubernetes 对象是 Kubernetes 系统中的持久性实体。Kubernetes 使用这些实体表示你的集群状态。 了解 Kubernetes 对象模型以及如何使用这些对象。

---

#### [理解 Kubernetes 对象](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/)

本页说明了在 Kubernetes API 中是如何表示 Kubernetes 对象的， 以及使用 `.yaml` 格式的文件表示 Kubernetes 对象。

##### 理解 Kubernetes 对象[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects)

在 Kubernetes 系统中，**Kubernetes 对象** 是持久化的实体。 Kubernetes 使用这些实体去表示整个集群的状态。 比较特别地是，它们描述了如下信息：

- 哪些容器化应用正在运行（以及在哪些节点上运行）
- 可以被应用使用的资源
- 关于应用运行时表现的策略，比如重启策略、升级策略以及容错策略

Kubernetes 对象是“目标性记录” —— 一旦创建该对象，Kubernetes 系统将不断工作以确保该对象存在。 通过创建对象，你就是在告知 Kubernetes 系统，你想要的集群工作负载状态看起来应是什么样子的， 这就是 Kubernetes 集群所谓的 **期望状态（Desired State）**。

操作 Kubernetes 对象 —— 无论是创建、修改或者删除 —— 需要使用 [Kubernetes API](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api)。 比如，当使用 `kubectl` 命令行接口（CLI）时，CLI 会调用必要的 Kubernetes API； 也可以在程序中使用[客户端库](https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/)， 来直接调用 Kubernetes API。

###### 对象规约（Spec）与状态（Status）[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#object-spec-and-status)

几乎每个 Kubernetes 对象包含两个嵌套的对象字段，它们负责管理对象的配置： 对象 **`spec`（规约）** 和 对象 **`status`（状态）**。 对于具有 `spec` 的对象，你必须在创建对象时设置其内容，描述你希望对象所具有的特征： **期望状态（Desired State）**。

`status` 描述了对象的**当前状态（Current State）**，它是由 Kubernetes 系统和组件设置并更新的。 在任何时刻，Kubernetes [控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane) 都一直都在积极地管理着对象的实际状态，以使之达成期望状态。

例如，Kubernetes 中的 Deployment 对象能够表示运行在集群中的应用。 当创建 Deployment 时，可能会去设置 Deployment 的 `spec`，以指定该应用要有 3 个副本运行。 Kubernetes 系统读取 Deployment 的 `spec`， 并启动我们所期望的应用的 3 个实例 —— 更新状态以与规约相匹配。 如果这些实例中有的失败了（一种状态变更），Kubernetes 系统会通过执行修正操作来响应 `spec` 和状态间的不一致 —— 意味着它会启动一个新的实例来替换。

关于对象 spec、status 和 metadata 的更多信息，可参阅 [Kubernetes API 约定](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md)。

###### 描述 Kubernetes 对象[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#describing-a-kubernetes-object)

创建 Kubernetes 对象时，必须提供对象的 `spec`，用来描述该对象的期望状态， 以及关于对象的一些基本信息（例如名称）。 当使用 Kubernetes API 创建对象时（直接创建，或经由 `kubectl`）， API 请求必须在请求本体中包含 JSON 格式的信息。 **大多数情况下，你需要提供 `.yaml` 文件为 kubectl 提供这些信息**。 `kubectl` 在发起 API 请求时，将这些信息转换成 JSON 格式。

这里有一个 `.yaml` 示例文件，展示了 Kubernetes Deployment 的必需字段和对象 `spec`：

[`application/deployment.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/deployment.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy application/deployment.yaml to clipboard")

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # 告知 Deployment 运行 2 个与该模板匹配的 Pod
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

相较于上面使用 `.yaml` 文件来创建 Deployment，另一种类似的方式是使用 `kubectl` 命令行接口（CLI）中的 [`kubectl apply`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply) 命令， 将 `.yaml` 文件作为参数。下面是一个示例：

```shell
kubectl apply -f https://k8s.io/examples/application/deployment.yaml
```

输出类似下面这样：

```
deployment.apps/nginx-deployment created
```

###### 必需字段[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#required-fields)

在想要创建的 Kubernetes 对象所对应的 `.yaml` 文件中，需要配置的字段如下：

- `apiVersion` - 创建该对象所使用的 Kubernetes API 的版本
- `kind` - 想要创建的对象的类别
- `metadata` - 帮助唯一标识对象的一些数据，包括一个 `name` 字符串、`UID` 和可选的 `namespace`
- `spec` - 你所期望的该对象的状态

对每个 Kubernetes 对象而言，其 `spec` 之精确格式都是不同的，包含了特定于该对象的嵌套字段。 [Kubernetes API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/)可以帮助你找到想要使用 Kubernetes 创建的所有对象的规约格式。

例如，参阅 Pod API 参考文档中 [`spec` 字段](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec)。 对于每个 Pod，其 `.spec` 字段设置了 Pod 及其期望状态（例如 Pod 中每个容器的容器镜像名称）。 另一个对象规约的例子是 StatefulSet API 中的 [`spec` 字段](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec)。 对于 StatefulSet 而言，其 `.spec` 字段设置了 StatefulSet 及其期望状态。 在 StatefulSet 的 `.spec` 内，有一个为 Pod 对象提供的[模板](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)。 该模板描述了 StatefulSet 控制器为了满足 StatefulSet 规约而要创建的 Pod。 不同类型的对象可以由不同的 `.status` 信息。API 参考页面给出了 `.status` 字段的详细结构， 以及针对不同类型 API 对象的具体内容。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

进一步了解以下信息：

- 最重要的 Kubernetes 基本对象 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)。
- [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 对象。
- Kubernetes 中的[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)。
- 解释了一些 API 概念的 [Kubernetes API 概述](https://kubernetes.io/zh-cn/docs/reference/using-api/)。
- [kubectl](https://kubernetes.io/zh-cn/docs/reference/kubectl/) 和 [kubectl 命令](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands)。
#### [Kubernetes 对象管理](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/)
`kubectl` 命令行工具支持多种不同的方式来创建和管理 Kubernetes 对象。 本文档概述了不同的方法。 阅读 [Kubectl book](https://kubectl.docs.kubernetes.io/zh/) 来了解 kubectl 管理对象的详细信息。

##### 管理技巧[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E7%AE%A1%E7%90%86%E6%8A%80%E5%B7%A7)

**警告：**

应该只使用一种技术来管理 Kubernetes 对象。混合和匹配技术作用在同一对象上将导致未定义行为。

| 管理技术 | 作用于 | 建议的环境 | 支持的写者 | 学习难度 |
| --- | --- | --- | --- | --- |
| 指令式命令 | 活跃对象 | 开发项目 | 1+ | 最低 |
| 指令式对象配置 | 单个文件 | 生产项目 | 1 | 中等 |
| 声明式对象配置 | 文件目录 | 生产项目 | 1+ | 最高 |

##### 指令式命令[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E6%8C%87%E4%BB%A4%E5%BC%8F%E5%91%BD%E4%BB%A4)

使用指令式命令时，用户可以在集群中的活动对象上进行操作。用户将操作传给 `kubectl` 命令作为参数或标志。

这是开始或者在集群中运行一次性任务的推荐方法。因为这个技术直接在活跃对象 上操作，所以它不提供以前配置的历史记录。

###### 例子[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E4%BE%8B%E5%AD%90)

通过创建 Deployment 对象来运行 nginx 容器的实例：

```sh
kubectl create deployment nginx --image nginx
```

###### 权衡[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E6%9D%83%E8%A1%A1)

与对象配置相比的优点：

- 命令用单个动词表示。
- 命令仅需一步即可对集群进行更改。

与对象配置相比的缺点：

- 命令不与变更审查流程集成。
- 命令不提供与更改关联的审核跟踪。
- 除了实时内容外，命令不提供记录源。
- 命令不提供用于创建新对象的模板。

##### 指令式对象配置[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E6%8C%87%E4%BB%A4%E5%BC%8F%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE)

在指令式对象配置中，kubectl 命令指定操作（创建，替换等），可选标志和 至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。

有关对象定义的详细信息，请查看 [API 参考](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/)。

**警告：**

`replace` 指令式命令将现有规范替换为新提供的规范，并放弃对配置文件中 缺少的对象的所有更改。此方法不应与对象规约被独立于配置文件进行更新的 资源类型一起使用。比如类型为 `LoadBalancer` 的服务，它的 `externalIPs` 字段就是独立于集群配置进行更新。

###### 例子[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E4%BE%8B%E5%AD%90-1)

创建配置文件中定义的对象：

```sh
kubectl create -f nginx.yaml
```

删除两个配置文件中定义的对象：

```sh
kubectl delete -f nginx.yaml -f redis.yaml
```

通过覆盖活动配置来更新配置文件中定义的对象：

```sh
kubectl replace -f nginx.yaml
```

###### 权衡[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E6%9D%83%E8%A1%A1-1)

与指令式命令相比的优点：

- 对象配置可以存储在源控制系统中，比如 Git。
- 对象配置可以与流程集成，例如在推送和审计之前检查更新。
- 对象配置提供了用于创建新对象的模板。

与指令式命令相比的缺点：

- 对象配置需要对对象架构有基本的了解。
- 对象配置需要额外的步骤来编写 YAML 文件。

与声明式对象配置相比的优点：

- 指令式对象配置行为更加简单易懂。
- 从 Kubernetes 1.5 版本开始，指令对象配置更加成熟。

与声明式对象配置相比的缺点：

- 指令式对象配置更适合文件，而非目录。
- 对活动对象的更新必须反映在配置文件中，否则会在下一次替换时丢失。

##### 声明式对象配置[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE)

使用声明式对象配置时，用户对本地存储的对象配置文件进行操作，但是用户 未定义要对该文件执行的操作。 `kubectl` 会自动检测每个文件的创建、更新和删除操作。 这使得配置可以在目录上工作，根据目录中配置文件对不同的对象执行不同的操作。

**说明：**

声明式对象配置保留其他编写者所做的修改，即使这些更改并未合并到对象配置文件中。 可以通过使用 `patch` API 操作仅写入观察到的差异，而不是使用 `replace` API 操作来替换整个对象配置来实现。

###### 例子[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E4%BE%8B%E5%AD%90-2)

处理 `configs` 目录中的所有对象配置文件，创建并更新活跃对象。 可以首先使用 `diff` 子命令查看将要进行的更改，然后在进行应用：

```sh
kubectl diff -f configs/
kubectl apply -f configs/
```

递归处理目录：

```sh
kubectl diff -R -f configs/
kubectl apply -R -f configs/
```

###### 权衡[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E6%9D%83%E8%A1%A1-2)

与指令式对象配置相比的优点：

- 对活动对象所做的更改即使未合并到配置文件中，也会被保留下来。
- 声明性对象配置更好地支持对目录进行操作并自动检测每个文件的操作类型（创建，修补，删除）。

与指令式对象配置相比的缺点：

- 声明式对象配置难于调试并且出现异常时结果难以理解。
- 使用 diff 产生的部分更新会创建复杂的合并和补丁操作。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- [使用指令式命令管理 Kubernetes 对象](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/imperative-command/)
- [使用配置文件对 Kubernetes 对象进行命令式管理](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/imperative-config/)
- [使用配置文件对 Kubernetes 对象进行声明式管理](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/declarative-config/)
- [使用 Kustomize 对 Kubernetes 对象进行声明式管理](https://kubernetes.io/zh-cn/docs/tasks/manage-kubernetes-objects/kustomization/)
- [Kubectl 命令参考](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands/)
- [Kubectl Book](https://kubectl.docs.kubernetes.io/zh/)
- [Kubernetes API 参考](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/)
#### [对象名称和 ID](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/)
集群中的每一个对象都有一个[**名称**](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#names)来标识在同类资源中的唯一性。

每个 Kubernetes 对象也有一个 [**UID**](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#uids) 来标识在整个集群中的唯一性。

比如，在同一个[名字空间](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/) 中只能有一个名为 `myapp-1234` 的 Pod，但是可以命名一个 Pod 和一个 Deployment 同为 `myapp-1234`。

对于用户提供的非唯一性的属性，Kubernetes 提供了[标签（Label）](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)和 [注解（Annotation）](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/)机制。

##### 名称[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#names)

客户端提供的字符串，引用资源 URL 中的对象，如`/api/v1/pods/some name`。

某一时刻，只能有一个给定类型的对象具有给定的名称。但是，如果删除该对象，则可以创建同名的新对象。

**名称在同一资源的所有 [API 版本](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning)中必须是唯一的。 这些 API 资源通过各自的 API 组、资源类型、名字空间（对于划分名字空间的资源）和名称来区分。 换言之，API 版本在此上下文中是不相关的。**

**说明：**

当对象所代表的是一个物理实体（例如代表一台物理主机的 Node）时， 如果在 Node 对象未被删除并重建的条件下，重新创建了同名的物理主机， 则 Kubernetes 会将新的主机看作是老的主机，这可能会带来某种不一致性。

以下是比较常见的四种资源命名约束。

###### DNS 子域名[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names)

很多资源类型需要可以用作 DNS 子域名的名称。 DNS 子域名的定义可参见 [RFC 1123](https://tools.ietf.org/html/rfc1123)。 这一要求意味着名称必须满足如下规则：

- 不能超过 253 个字符
- 只能包含小写字母、数字，以及 '-' 和 '.'
- 必须以字母数字开头
- 必须以字母数字结尾

###### RFC 1123 标签名[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-label-names)

某些资源类型需要其名称遵循 [RFC 1123](https://tools.ietf.org/html/rfc1123) 所定义的 DNS 标签标准。也就是命名必须满足如下规则：

- 最多 63 个字符
- 只能包含小写字母、数字，以及 '-'
- 必须以字母数字开头
- 必须以字母数字结尾

###### RFC 1035 标签名[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#rfc-1035-label-names)

某些资源类型需要其名称遵循 [RFC 1035](https://tools.ietf.org/html/rfc1035) 所定义的 DNS 标签标准。也就是命名必须满足如下规则：

- 最多 63 个字符
- 只能包含小写字母、数字，以及 '-'
- 必须以字母开头
- 必须以字母数字结尾

###### 路径分段名称[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#path-segment-names)

某些资源类型要求名称能被安全地用作路径中的片段。 换句话说，其名称不能是 `.`、`..`，也不可以包含 `/` 或 `%` 这些字符。

下面是一个名为 `nginx-demo` 的 Pod 的配置清单：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-demo
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

**说明：**

某些资源类型可能具有额外的命名约束。

##### UID[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#uid)

Kubernetes 系统生成的字符串，唯一标识对象。

在 Kubernetes 集群的整个生命周期中创建的每个对象都有一个不同的 UID，它旨在区分类似实体的历史事件。

Kubernetes UID 是全局唯一标识符（也叫 UUID）。 UUID 是标准化的，见 ISO/IEC 9834-8 和 ITU-T X.667。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解 Kubernetes [标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)和[注解](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/)。
- 参阅 [Kubernetes 标识符和名称](https://git.k8s.io/design-proposals-archive/architecture/identifiers.md)的设计文档
#### [标签和选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)
**标签（Labels）** 是附加到 Kubernetes 对象（比如 Pod）上的键值对。 标签旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 标签可以用于组织和选择对象的子集。标签可以在创建时附加到对象，随后可以随时添加和修改。 每个对象都可以定义一组键/值标签。每个键对于给定对象必须是唯一的。

```json
"metadata": {
  "labels": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
```

标签能够支持高效的查询和监听操作，对于用户界面和命令行是很理想的。 应使用[注解](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/)记录非识别信息。

##### 动机[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#motivation)

标签使用户能够以松散耦合的方式将他们自己的组织结构映射到系统对象，而无需客户端存储这些映射。

服务部署和批处理流水线通常是多维实体（例如，多个分区或部署、多个发行序列、多个层，每层多个微服务）。 管理通常需要交叉操作，这打破了严格的层次表示的封装，特别是由基础设施而不是用户确定的严格的层次结构。

示例标签：

- `"release" : "stable"`, `"release" : "canary"`
- `"environment" : "dev"`, `"environment" : "qa"`, `"environment" : "production"`
- `"tier" : "frontend"`, `"tier" : "backend"`, `"tier" : "cache"`
- `"partition" : "customerA"`, `"partition" : "customerB"`
- `"track" : "daily"`, `"track" : "weekly"`

有一些[常用标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/)的例子；你可以任意制定自己的约定。 请记住，标签的 Key 对于给定对象必须是唯一的。

##### 语法和字符集[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set)

**标签**是键值对。有效的标签键有两个段：可选的前缀和名称，用斜杠（`/`）分隔。 名称段是必需的，必须小于等于 63 个字符，以字母数字字符（`[a-z0-9A-Z]`）开头和结尾， 带有破折号（`-`），下划线（`_`），点（ `.`）和之间的字母数字。 前缀是可选的。如果指定，前缀必须是 DNS 子域：由点（`.`）分隔的一系列 DNS 标签，总共不超过 253 个字符， 后跟斜杠（`/`）。

如果省略前缀，则假定标签键对用户是私有的。 向最终用户对象添加标签的自动系统组件（例如 `kube-scheduler`、`kube-controller-manager`、 `kube-apiserver`、`kubectl` 或其他第三方自动化工具）必须指定前缀。

`kubernetes.io/` 和 `k8s.io/` 前缀是为 Kubernetes 核心组件[保留的](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/)。

有效标签值：

- 必须为 63 个字符或更少（可以为空）
- 除非标签值为空，必须以字母数字字符（`[a-z0-9A-Z]`）开头和结尾
- 包含破折号（`-`）、下划线（`_`）、点（`.`）和字母或数字

例如，以下是一个清单 (manifest)，适用于具有 `environment: production` 和 `app: nginx` 这两个标签的 Pod：

```yaml

apiVersion: v1
kind: Pod
metadata:
  name: label-demo
  labels:
    environment: production
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

##### 标签选择算符[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors)

与[名称和 UID](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/) 不同， 标签不支持唯一性。通常，我们希望许多对象携带相同的标签。

通过**标签选择算符**，客户端/用户可以识别一组对象。标签选择算符是 Kubernetes 中的核心分组原语。

API 目前支持两种类型的选择算符：**基于等值的**和**基于集合的**。 标签选择算符可以由逗号分隔的多个**需求**组成。 在多个需求的情况下，必须满足所有要求，因此逗号分隔符充当逻辑**与**（`&&`）运算符。

空标签选择算符或者未指定的选择算符的语义取决于上下文， 支持使用选择算符的 API 类别应该将算符的合法性和含义用文档记录下来。

**说明：**

对于某些 API 类别（例如 ReplicaSet）而言，两个实例的标签选择算符不得在命名空间内重叠， 否则它们的控制器将互相冲突，无法确定应该存在的副本个数。

**注意：**

对于基于等值的和基于集合的条件而言，不存在逻辑或（`||`）操作符。 你要确保你的过滤语句按合适的方式组织。

###### **基于等值的**需求[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#%E5%9F%BA%E4%BA%8E%E7%AD%89%E5%80%BC%E7%9A%84-%E9%9C%80%E6%B1%82)

**基于等值**或**基于不等值**的需求允许按标签键和值进行过滤。 匹配对象必须满足所有指定的标签约束，尽管它们也可能具有其他标签。 可接受的运算符有 `=`、`==` 和 `!=` 三种。 前两个表示**相等**（并且是同义词），而后者表示**不相等**。例如：

```
environment = production
tier != frontend
```

前者选择所有资源，其键名等于 `environment`，值等于 `production`。 后者选择所有资源，其键名等于 `tier`，值不同于 `frontend`，所有资源都没有带有 `tier` 键的标签。 可以使用逗号运算符来过滤 `production` 环境中的非 `frontend` 层资源：`environment=production,tier!=frontend`。

基于等值的标签要求的一种使用场景是 Pod 要指定节点选择标准。 例如，下面的示例 Pod 选择带有标签 "`accelerator=nvidia-tesla-p100`"。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: cuda-test
spec:
  containers:
    - name: cuda-test
      image: "registry.k8s.io/cuda-vector-add:v0.1"
      resources:
        limits:
          nvidia.com/gpu: 1
  nodeSelector:
    accelerator: nvidia-tesla-p100
```

###### **基于集合**的需求[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#%E5%9F%BA%E4%BA%8E%E9%9B%86%E5%90%88-%E7%9A%84%E9%9C%80%E6%B1%82)

**基于集合**的标签需求允许你通过一组值来过滤键。 支持三种操作符：`in`、`notin` 和 `exists`（只可以用在键标识符上）。例如：

```
environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
```

- 第一个示例选择了所有键等于 `environment` 并且值等于 `production` 或者 `qa` 的资源。
- 第二个示例选择了所有键等于 `tier` 并且值不等于 `frontend` 或者 `backend` 的资源，以及所有没有 `tier` 键标签的资源。
- 第三个示例选择了所有包含了有 `partition` 标签的资源；没有校验它的值。
- 第四个示例选择了所有没有 `partition` 标签的资源；没有校验它的值。

类似地，逗号分隔符充当**与**运算符。因此，使用 `partition` 键（无论为何值）和 `environment` 不同于 `qa` 来过滤资源可以使用 `partition, environment notin (qa)` 来实现。

**基于集合**的标签选择算符是相等标签选择算符的一般形式，因为 `environment=production` 等同于 `environment in (production)`；`!=` 和 `notin` 也是类似的。

**基于集合**的要求可以与基于**相等**的要求混合使用。例如：`partition in (customerA, customerB),environment!=qa`。

##### API[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#api)

###### LIST 和 WATCH 过滤[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#list-%E5%92%8C-watch-%E8%BF%87%E6%BB%A4)

LIST 和 WATCH 操作可以使用查询参数指定标签选择算符过滤一组对象。 两种需求都是允许的。（这里显示的是它们出现在 URL 查询字符串中）

- **基于等值**的需求：`?labelSelector=environment%3Dproduction,tier%3Dfrontend`
- **基于集合**的需求：`?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29`

两种标签选择算符都可以通过 REST 客户端用于 list 或者 watch 资源。 例如，使用 `kubectl` 定位 `apiserver`，可以使用**基于等值**的标签选择算符可以这么写：

```shell
kubectl get pods -l environment=production,tier=frontend
```

或者使用**基于集合的**需求：

```shell
kubectl get pods -l 'environment in (production),tier in (frontend)'
```

正如刚才提到的，**基于集合**的需求更具有表达力。例如，它们可以实现值的**或**操作：

```shell
kubectl get pods -l 'environment in (production, qa)'
```

或者通过**notin**运算符限制不匹配：

```shell
kubectl get pods -l 'environment,environment notin (frontend)'
```

###### 在 API 对象中设置引用[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#%E5%9C%A8-api-%E5%AF%B9%E8%B1%A1%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%BC%95%E7%94%A8)

一些 Kubernetes 对象，例如 [`services`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 和 [`replicationcontrollers`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/)， 也使用了标签选择算符去指定了其他资源的集合，例如 [pods](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)。

####### Service 和 ReplicationController[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#service-%E5%92%8C-replicationcontroller)

一个 `Service` 指向的一组 Pod 是由标签选择算符定义的。同样，一个 `ReplicationController` 应该管理的 Pod 的数量也是由标签选择算符定义的。

两个对象的标签选择算符都是在 `json` 或者 `yaml` 文件中使用映射定义的，并且只支持 **基于等值**需求的选择算符：

```json
"selector": {
    "component" : "redis",
}
```

或者

```yaml
selector:
  component: redis
```

这个选择算符（分别在 `json` 或者 `yaml` 格式中）等价于 `component=redis` 或 `component in (redis)`。

####### 支持基于集合需求的资源[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#%E6%94%AF%E6%8C%81%E5%9F%BA%E4%BA%8E%E9%9B%86%E5%90%88%E9%9C%80%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90)

比较新的资源，例如 [`Job`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/)、 [`Deployment`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)、 [`ReplicaSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 和 [`DaemonSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/)， 也支持**基于集合的**需求。

```yaml
selector:
  matchLabels:
    component: redis
  matchExpressions:
    - { key: tier, operator: In, values: [cache] }
    - { key: environment, operator: NotIn, values: [dev] }
```

`matchLabels` 是由 `{key,value}` 对组成的映射。 `matchLabels` 映射中的单个 `{key,value}` 等同于 `matchExpressions` 的元素， 其 `key` 字段为 "key"，`operator` 为 "In"，而 `values` 数组仅包含 "value"。 `matchExpressions` 是 Pod 选择算符需求的列表。 有效的运算符包括 `In`、`NotIn`、`Exists` 和 `DoesNotExist`。 在 `In` 和 `NotIn` 的情况下，设置的值必须是非空的。 来自 `matchLabels` 和 `matchExpressions` 的所有要求都按逻辑与的关系组合到一起 -- 它们必须都满足才能匹配。

####### 选择节点集[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#%E9%80%89%E6%8B%A9%E8%8A%82%E7%82%B9%E9%9B%86)

通过标签进行选择的一个用例是确定节点集，方便 Pod 调度。 有关更多信息，请参阅[选择节点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/)文档。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 学习如何[给节点添加标签](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-pods-nodes/#add-a-label-to-a-node)
- 查阅[众所周知的标签、注解和污点](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/)
- 参见[推荐使用的标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/)
- [使用名字空间标签来实施 Pod 安全性标准](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/)
- [有效使用标签](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively)管理 Deployment。
- 阅读[为 Pod 标签编写控制器](https://kubernetes.io/blog/2021/06/21/writing-a-controller-for-pod-labels/)的博文
#### [名字空间](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/)
在 Kubernetes 中，**名字空间（Namespace）** 提供一种机制，将同一集群中的资源划分为相互隔离的组。 同一名字空间内的资源名称要唯一，但跨名字空间时没有这个要求。 名字空间作用域仅针对带有名字空间的对象，例如 Deployment、Service 等， 这种作用域对集群访问的对象不适用，例如 StorageClass、Node、PersistentVolume 等。

##### 何时使用多个名字空间[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#when-to-use-multiple-namespaces)

名字空间适用于存在很多跨多个团队或项目的用户的场景。对于只有几到几十个用户的集群，根本不需要创建或考虑名字空间。当需要名字空间提供的功能时，请开始使用它们。

名字空间为名称提供了一个范围。资源的名称需要在名字空间内是唯一的，但不能跨名字空间。 名字空间不能相互嵌套，每个 Kubernetes 资源只能在一个名字空间中。

名字空间是在多个用户之间划分集群资源的一种方法（通过[资源配额](https://kubernetes.io/zh-cn/docs/concepts/policy/resource-quotas/)）。

不必使用多个名字空间来分隔仅仅轻微不同的资源，例如同一软件的不同版本： 应该使用[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)来区分同一名字空间中的不同资源。

**说明：**

对于生产集群，请考虑**不要**使用 `default` 名字空间，而是创建其他名字空间来使用。

##### 初始名字空间[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#initial-namespaces)

Kubernetes 启动时会创建四个初始名字空间：

`default`

Kubernetes 包含这个名字空间，以便于你无需创建新的名字空间即可开始使用新集群。

`kube-node-lease`

该名字空间包含用于与各个节点关联的 [Lease（租约）](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/)对象。 节点租约允许 kubelet 发送[心跳](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats)， 由此控制面能够检测到节点故障。

`kube-public`

**所有**的客户端（包括未经身份验证的客户端）都可以读取该名字空间。 该名字空间主要预留为集群使用，以便某些资源需要在整个集群中可见可读。 该名字空间的公共属性只是一种约定而非要求。

`kube-system`

该名字空间用于 Kubernetes 系统创建的对象。

##### 使用名字空间[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#working-with-namespaces)

名字空间的创建和删除在[名字空间的管理指南文档](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/namespaces/)描述。

**说明：**

避免使用前缀 `kube-` 创建名字空间，因为它是为 Kubernetes 系统名字空间保留的。

###### 查看名字空间[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#viewing-namespaces)

你可以使用以下命令列出集群中现存的名字空间：

```shell
kubectl get namespace
```

```
NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
```

###### 为请求设置名字空间[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-for-a-request)

要为当前请求设置名字空间，请使用 `--namespace` 参数。

例如：

```shell
kubectl run nginx --image=nginx --namespace=<名字空间名称>
kubectl get pods --namespace=<名字空间名称>
```

###### 设置名字空间偏好[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#setting-the-namespace-preference)

你可以永久保存名字空间，以用于对应上下文中所有后续 kubectl 命令。

```shell
kubectl config set-context --current --namespace=<名字空间名称>
# 验证
kubectl config view --minify | grep namespace:
```

##### 名字空间和 DNS[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#namespaces-and-dns)

当你创建一个[服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)时， Kubernetes 会创建一个相应的 [DNS 条目](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/)。

该条目的形式是 `<服务名称>.<名字空间名称>.svc.cluster.local`，这意味着如果容器只使用 `<服务名称>`，它将被解析到本地名字空间的服务。这对于跨多个名字空间（如开发、测试和生产） 使用相同的配置非常有用。如果你希望跨名字空间访问，则需要使用完全限定域名（FQDN）。

因此，所有的名字空间名称都必须是合法的 [RFC 1123 DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-label-names)。

**警告：**

通过创建与[公共顶级域名](https://data.iana.org/TLD/tlds-alpha-by-domain.txt)同名的名字空间， 这些名字空间中的服务可以拥有与公共 DNS 记录重叠的、较短的 DNS 名称。 所有名字空间中的负载在执行 DNS 查找时， 如果查找的名称没有[尾部句点](https://datatracker.ietf.org/doc/html/rfc1034#page-8)， 就会被重定向到这些服务上，因此呈现出比公共 DNS 更高的优先序。

为了缓解这类问题，需要将创建名字空间的权限授予可信的用户。 如果需要，你可以额外部署第三方的安全控制机制， 例如以[准入 Webhook](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/) 的形式，阻止用户创建与公共 [TLD](https://data.iana.org/TLD/tlds-alpha-by-domain.txt) 同名的名字空间。

##### 并非所有对象都在名字空间中[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#not-all-objects-are-in-a-namespace)

大多数 kubernetes 资源（例如 Pod、Service、副本控制器等）都位于某些名字空间中。 但是名字空间资源本身并不在名字空间中。而且底层资源， 例如[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)和[持久化卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/)不属于任何名字空间。

查看哪些 Kubernetes 资源在名字空间中，哪些不在名字空间中：

```shell
# 位于名字空间中的资源
kubectl api-resources --namespaced=true

# 不在名字空间中的资源
kubectl api-resources --namespaced=false
```

##### 自动打标签[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#automatic-labelling)

**特性状态：** `Kubernetes 1.22 [stable]`

Kubernetes 控制面会为所有名字空间设置一个不可变更的[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/) `kubernetes.io/metadata.name`，只要 `NamespaceDefaultLabelName` 这一[特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)被启用。 标签的值是名字空间的名称。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解[建立新的名字空间](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace)。
- 进一步了解[删除名字空间](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace)。
#### [注解](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/)
你可以使用 Kubernetes 注解为对象附加任意的非标识的元数据。客户端程序（例如工具和库）能够获取这些元数据信息。

##### 为对象附加元数据[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/#%E4%B8%BA%E5%AF%B9%E8%B1%A1%E9%99%84%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE)

你可以使用标签或注解将元数据附加到 Kubernetes 对象。 标签可以用来选择对象和查找满足某些条件的对象集合。 相反，注解不用于标识和选择对象。 注解中的元数据，可以很小，也可以很大，可以是结构化的，也可以是非结构化的，能够包含标签不允许的字符。

注解和标签一样，是键/值对：

```json
"metadata": {
  "annotations": {
    "key1" : "value1",
    "key2" : "value2"
  }
}
```

**说明：**

Map 中的键和值必须是字符串。 换句话说，你不能使用数字、布尔值、列表或其他类型的键或值。

以下是一些例子，用来说明哪些信息可以使用注解来记录：

- 由声明性配置所管理的字段。 将这些字段附加为注解，能够将它们与客户端或服务端设置的默认值、 自动生成的字段以及通过自动调整大小或自动伸缩系统设置的字段区分开来。
- 构建、发布或镜像信息（如时间戳、发布 ID、Git 分支、PR 数量、镜像哈希、仓库地址）。
- 指向日志记录、监控、分析或审计仓库的指针。

- 可用于调试目的的客户端库或工具信息：例如，名称、版本和构建信息。
    
- 用户或者工具/系统的来源信息，例如来自其他生态系统组件的相关对象的 URL。
    
- 轻量级上线工具的元数据信息：例如，配置或检查点。
    
- 负责人员的电话或呼机号码，或指定在何处可以找到该信息的目录条目，如团队网站。
    
- 从用户到最终运行的指令，以修改行为或使用非标准功能。
    

你可以将这类信息存储在外部数据库或目录中而不使用注解， 但这样做就使得开发人员很难生成用于部署、管理、自检的客户端共享库和工具。

##### 语法和字符集[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/#%E8%AF%AD%E6%B3%95%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86)

**注解（Annotations）** 存储的形式是键/值对。有效的注解键分为两部分： 可选的前缀和名称，以斜杠（`/`）分隔。 名称段是必需项，并且必须在 63 个字符以内，以字母数字字符（`[a-z0-9A-Z]`）开头和结尾， 并允许使用破折号（`-`），下划线（`_`），点（`.`）和字母数字。 前缀是可选的。如果指定，则前缀必须是 DNS 子域：一系列由点（`.`）分隔的 DNS 标签， 总计不超过 253 个字符，后跟斜杠（`/`）。 如果省略前缀，则假定注解键对用户是私有的。 由系统组件添加的注解 （例如，`kube-scheduler`，`kube-controller-manager`，`kube-apiserver`，`kubectl` 或其他第三方组件），必须为终端用户添加注解前缀。

`kubernetes.io/` 和 `k8s.io/` 前缀是为 Kubernetes 核心组件保留的。

例如，下面是一个 Pod 的清单，其注解中包含 `imageregistry: https://hub.docker.com/`：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: annotations-demo
  annotations:
    imageregistry: "https://hub.docker.com/"
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

进一步了解[标签和选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)。
#### [字段选择器](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/field-selectors/)
“字段选择器（Field selectors）”允许你根据一个或多个资源字段的值 [筛选 Kubernetes 资源](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects)。 下面是一些使用字段选择器查询的例子：

- `metadata.name=my-service`
- `metadata.namespace!=default`
- `status.phase=Pending`

下面这个 `kubectl` 命令将筛选出 [`status.phase`](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase) 字段值为 `Running` 的所有 Pod：

```shell
kubectl get pods --field-selector status.phase=Running
```

**说明：**

字段选择器本质上是资源“过滤器（Filters）”。默认情况下，字段选择器/过滤器是未被应用的， 这意味着指定类型的所有资源都会被筛选出来。 这使得 `kubectl get pods` 和 `kubectl get pods --field-selector ""` 这两个 `kubectl` 查询是等价的。

##### 支持的字段[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/field-selectors/#supported-fields)

不同的 Kubernetes 资源类型支持不同的字段选择器。 所有资源类型都支持 `metadata.name` 和 `metadata.namespace` 字段。 使用不被支持的字段选择器会产生错误。例如：

```shell
kubectl get ingress --field-selector foo.bar=baz
```

```
Error from server (BadRequest): Unable to find "ingresses" that match label selector "", field selector "foo.bar=baz": "foo.bar" is not a known field selector: only "metadata.name", "metadata.namespace"
```

##### 支持的操作符[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/field-selectors/#supported-operators)

你可在字段选择器中使用 `=`、`==` 和 `!=` （`=` 和 `==` 的意义是相同的）操作符。 例如，下面这个 `kubectl` 命令将筛选所有不属于 `default` 命名空间的 Kubernetes 服务：

```shell
kubectl get services  --all-namespaces --field-selector metadata.namespace!=default
```

##### 链式选择器[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/field-selectors/#chained-selectors)

同[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)和其他选择器一样， 字段选择器可以通过使用逗号分隔的列表组成一个选择链。 下面这个 `kubectl` 命令将筛选 `status.phase` 字段不等于 `Running` 同时 `spec.restartPolicy` 字段等于 `Always` 的所有 Pod：

```shell
kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always
```

##### 多种资源类型[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/field-selectors/#multiple-resource-types)

你能够跨多种资源类型来使用字段选择器。 下面这个 `kubectl` 命令将筛选出所有不在 `default` 命名空间中的 StatefulSet 和 Service：

```shell
kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default
```

#### [Finalizers](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/)
Finalizer 是带有命名空间的键，告诉 Kubernetes 等到特定的条件被满足后， 再完全删除被标记为删除的资源。 Finalizer 提醒[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)清理被删除的对象拥有的资源。

当你告诉 Kubernetes 删除一个指定了 Finalizer 的对象时， Kubernetes API 通过填充 `.metadata.deletionTimestamp` 来标记要删除的对象， 并返回 `202` 状态码(HTTP "已接受") 使其进入只读状态。 此时控制平面或其他组件会采取 Finalizer 所定义的行动， 而目标对象仍然处于终止中（Terminating）的状态。 这些行动完成后，控制器会删除目标对象相关的 Finalizer。 当 `metadata.finalizers` 字段为空时，Kubernetes 认为删除已完成并删除对象。

你可以使用 Finalizer 控制资源的[垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/)。 例如，你可以定义一个 Finalizer，在删除目标资源前清理相关资源或基础设施。

你可以通过使用 Finalizers 提醒[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 在删除目标资源前执行特定的清理任务， 来控制资源的[垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/)。

Finalizers 通常不指定要执行的代码。 相反，它们通常是特定资源上的键的列表，类似于注解。 Kubernetes 自动指定了一些 Finalizers，但你也可以指定你自己的。

##### Finalizers 如何工作[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/#how-finalizers-work)

当你使用清单文件创建资源时，你可以在 `metadata.finalizers` 字段指定 Finalizers。 当你试图删除该资源时，处理删除请求的 API 服务器会注意到 `finalizers` 字段中的值， 并进行以下操作：

- 修改对象，将你开始执行删除的时间添加到 `metadata.deletionTimestamp` 字段。
- 禁止对象被删除，直到其 `metadata.finalizers` 字段为空。
- 返回 `202` 状态码（HTTP "Accepted"）。

管理 finalizer 的控制器注意到对象上发生的更新操作，对象的 `metadata.deletionTimestamp` 被设置，意味着已经请求删除该对象。然后，控制器会试图满足资源的 Finalizers 的条件。 每当一个 Finalizer 的条件被满足时，控制器就会从资源的 `finalizers` 字段中删除该键。 当 `finalizers` 字段为空时，`deletionTimestamp` 字段被设置的对象会被自动删除。 你也可以使用 Finalizers 来阻止删除未被管理的资源。

一个常见的 Finalizer 的例子是 `kubernetes.io/pv-protection`， 它用来防止意外删除 `PersistentVolume` 对象。 当一个 `PersistentVolume` 对象被 Pod 使用时， Kubernetes 会添加 `pv-protection` Finalizer。 如果你试图删除 `PersistentVolume`，它将进入 `Terminating` 状态， 但是控制器因为该 Finalizer 存在而无法删除该资源。 当 Pod 停止使用 `PersistentVolume` 时， Kubernetes 清除 `pv-protection` Finalizer，控制器就会删除该卷。

##### 属主引用、标签和 Finalizers[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/#owners-labels-finalizers)

与[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)类似， [属主引用](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/) 描述了 Kubernetes 中对象之间的关系，但它们作用不同。 当一个[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 管理类似于 Pod 的对象时，它使用标签来跟踪相关对象组的变化。 例如，当 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 创建一个或多个 Pod 时， Job 控制器会给这些 Pod 应用上标签，并跟踪集群中的具有相同标签的 Pod 的变化。

Job 控制器还为这些 Pod 添加了“属主引用”，指向创建 Pod 的 Job。 如果你在这些 Pod 运行的时候删除了 Job， Kubernetes 会使用属主引用（而不是标签）来确定集群中哪些 Pod 需要清理。

当 Kubernetes 识别到要删除的资源上的属主引用时，它也会处理 Finalizers。

在某些情况下，Finalizers 会阻止依赖对象的删除， 这可能导致目标属主对象被保留的时间比预期的长，而没有被完全删除。 在这些情况下，你应该检查目标属主和附属对象上的 Finalizers 和属主引用，来排查原因。

**说明：**

在对象卡在删除状态的情况下，要避免手动移除 Finalizers，以允许继续删除操作。 Finalizers 通常因为特殊原因被添加到资源上，所以强行删除它们会导致集群出现问题。 只有了解 finalizer 的用途时才能这样做，并且应该通过一些其他方式来完成 （例如，手动清除其余的依赖对象）。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 在 Kubernetes 博客上阅读[使用 Finalizers 控制删除](https://kubernetes.io/blog/2021/05/14/using-finalizers-to-control-deletion/)。
#### [属主与附属](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/)
在 Kubernetes 中，一些对象是其他对象的“属主（Owner）”。 例如，[ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 是一组 Pod 的属主。 具有属主的对象是属主的“附属（Dependent）”。

属主关系不同于一些资源使用的[标签和选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)机制。 例如，有一个创建 `EndpointSlice` 对象的 Service， 该 Service 使用标签来让控制平面确定，哪些 `EndpointSlice` 对象属于该 Service。 除开标签，每个代表 Service 所管理的 `EndpointSlice` 都有一个属主引用。 属主引用避免 Kubernetes 的不同部分干扰到不受它们控制的对象。

##### 对象规约中的属主引用[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/#owner-references-in-object-specifications)

附属对象有一个 `metadata.ownerReferences` 字段，用于引用其属主对象。 一个有效的属主引用，包含与附属对象同在一个命名空间下的对象名称和一个 UID。 Kubernetes 自动为一些对象的附属资源设置属主引用的值， 这些对象包含 ReplicaSet、DaemonSet、Deployment、Job、CronJob、ReplicationController 等。 你也可以通过改变这个字段的值，来手动配置这些关系。 然而，通常不需要这么做，你可以让 Kubernetes 自动管理附属关系。

附属对象还有一个 `ownerReferences.blockOwnerDeletion` 字段，该字段使用布尔值， 用于控制特定的附属对象是否可以阻止垃圾收集删除其属主对象。 如果[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)（例如 Deployment 控制器） 设置了 `metadata.ownerReferences` 字段的值，Kubernetes 会自动设置 `blockOwnerDeletion` 的值为 `true`。 你也可以手动设置 `blockOwnerDeletion` 字段的值，以控制哪些附属对象会阻止垃圾收集。

Kubernetes 准入控制器根据属主的删除权限控制用户访问，以便为附属资源更改此字段。 这种控制机制可防止未经授权的用户延迟属主对象的删除。

**说明：**

根据设计，kubernetes 不允许跨名字空间指定属主。 名字空间范围的附属可以指定集群范围的或者名字空间范围的属主。 名字空间范围的属主**必须**和该附属处于相同的名字空间。 如果名字空间范围的属主和附属不在相同的名字空间，那么该属主引用就会被认为是缺失的， 并且当附属的所有属主引用都被确认不再存在之后，该附属就会被删除。

集群范围的附属只能指定集群范围的属主。 在 v1.20+ 版本，如果一个集群范围的附属指定了一个名字空间范围类型的属主， 那么该附属就会被认为是拥有一个不可解析的属主引用，并且它不能够被垃圾回收。

在 v1.20+ 版本，如果垃圾收集器检测到无效的跨名字空间的属主引用， 或者一个集群范围的附属指定了一个名字空间范围类型的属主， 那么它就会报告一个警告事件。该事件的原因是 `OwnerRefInvalidNamespace`， `involvedObject` 属性中包含无效的附属。 你可以运行 `kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace` 来获取该类型的事件。

##### 属主关系与 Finalizer[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/#ownership-and-finalizers)

当你告诉 Kubernetes 删除一个资源，API 服务器允许管理控制器处理该资源的任何 [Finalizer 规则](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/)。 [Finalizer](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/) 防止意外删除你的集群所依赖的、用于正常运作的资源。 例如，如果你试图删除一个仍被 Pod 使用的 `PersistentVolume`，该资源不会被立即删除， 因为 `PersistentVolume` 有 `kubernetes.io/pv-protection` Finalizer。 相反，它将进入 `Terminating` 状态，直到 Kubernetes 清除这个 Finalizer， 而这种情况只会发生在 `PersistentVolume` 不再被挂载到 Pod 上时。

当你使用[前台或孤立级联删除](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#cascading-deletion)时， Kubernetes 也会向属主资源添加 Finalizer。 在前台删除中，会添加 `foreground` Finalizer，这样控制器必须在删除了拥有 `ownerReferences.blockOwnerDeletion=true` 的附属资源后，才能删除属主对象。 如果你指定了孤立删除策略，Kubernetes 会添加 `orphan` Finalizer， 这样控制器在删除属主对象后，会忽略附属资源。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解更多关于 [Kubernetes Finalizer](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/)。
- 了解关于[垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection)。
- 阅读[对象元数据](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/common-definitions/object-meta/#System)的 API 参考文档。
#### [推荐使用的标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/)
除了 kubectl 和 dashboard 之外，你还可以使用其他工具来可视化和管理 Kubernetes 对象。 一组通用的标签可以让多个工具之间相互操作，用所有工具都能理解的通用方式描述对象。

除了支持工具外，推荐的标签还以一种可以查询的方式描述了应用程序。

元数据围绕 **应用（application）** 的概念进行组织。Kubernetes 不是平台即服务（PaaS），没有或强制执行正式的应用程序概念。 相反，应用程序是非正式的，并使用元数据进行描述。应用程序包含的定义是松散的。

**说明：**

这些是推荐的标签。它们使管理应用程序变得更容易但不是任何核心工具所必需的。

共享标签和注解都使用同一个前缀：`app.kubernetes.io`。没有前缀的标签是用户私有的。 共享前缀可以确保共享标签不会干扰用户自定义的标签。

##### 标签[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/#labels)

为了充分利用这些标签，应该在每个资源对象上都使用它们。

| 键 | 描述 | 示例 | 类型 |
| --- | --- | --- | --- |
| `app.kubernetes.io/name` | 应用程序的名称 | `mysql` | 字符串 |
| `app.kubernetes.io/instance` | 用于唯一确定应用实例的名称 | `mysql-abcxzy` | 字符串 |
| `app.kubernetes.io/version` | 应用程序的当前版本（例如[语义版本 1.0](https://semver.org/spec/v1.0.0.html)、修订版哈希等） | `5.7.21` | 字符串 |
| `app.kubernetes.io/component` | 架构中的组件 | `database` | 字符串 |
| `app.kubernetes.io/part-of` | 此级别的更高级别应用程序的名称 | `wordpress` | 字符串 |
| `app.kubernetes.io/managed-by` | 用于管理应用程序的工具 | `helm` | 字符串 |

为说明这些标签的实际使用情况，请看下面的 [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 对象：

```yaml
# 这是一段节选
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/name: mysql
    app.kubernetes.io/instance: mysql-abcxzy
    app.kubernetes.io/version: "5.7.21"
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: wordpress
    app.kubernetes.io/managed-by: helm
```

##### 应用和应用实例[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/#application-and-instances-of-applications)

应用可以在 Kubernetes 集群中安装一次或多次。在某些情况下，可以安装在同一命名空间中。 例如，可以不止一次地为不同的站点安装不同的 WordPress。

应用的名称和实例的名称是分别记录的。例如，WordPress 应用的 `app.kubernetes.io/name` 为 `wordpress`，而其实例名称 `app.kubernetes.io/instance` 为 `wordpress-abcxzy`。 这使得应用和应用的实例均可被识别，应用的每个实例都必须具有唯一的名称。

##### 示例[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/#examples)

为了说明使用这些标签的不同方式，以下示例具有不同的复杂性。

###### 一个简单的无状态服务[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1)

考虑使用 `Deployment` 和 `Service` 对象部署的简单无状态服务的情况。 以下两个代码段表示如何以最简单的形式使用标签。

下面的 `Deployment` 用于监督运行应用本身的那些 Pod。

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/name: myservice
    app.kubernetes.io/instance: myservice-abcxzy
...
```

下面的 `Service` 用于暴露应用。

```yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/name: myservice
    app.kubernetes.io/instance: myservice-abcxzy
...
```

###### 带有一个数据库的 Web 应用程序[](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/common-labels/#%E5%B8%A6%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84-web-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)

考虑一个稍微复杂的应用：一个使用 Helm 安装的 Web 应用（WordPress）， 其中使用了数据库（MySQL）。以下代码片段说明用于部署此应用程序的对象的开始。

以下 `Deployment` 的开头用于 WordPress：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/name: wordpress
    app.kubernetes.io/instance: wordpress-abcxzy
    app.kubernetes.io/version: "4.9.4"
    app.kubernetes.io/managed-by: helm
    app.kubernetes.io/component: server
    app.kubernetes.io/part-of: wordpress
...
```

这个 `Service` 用于暴露 WordPress：

```yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/name: wordpress
    app.kubernetes.io/instance: wordpress-abcxzy
    app.kubernetes.io/version: "4.9.4"
    app.kubernetes.io/managed-by: helm
    app.kubernetes.io/component: server
    app.kubernetes.io/part-of: wordpress
...
```

MySQL 作为一个 `StatefulSet` 暴露，包含它和它所属的较大应用程序的元数据：

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  labels:
    app.kubernetes.io/name: mysql
    app.kubernetes.io/instance: mysql-abcxzy
    app.kubernetes.io/version: "5.7.21"
    app.kubernetes.io/managed-by: helm
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: wordpress
...
```

`Service` 用于将 MySQL 作为 WordPress 的一部分暴露：

```yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app.kubernetes.io/name: mysql
    app.kubernetes.io/instance: mysql-abcxzy
    app.kubernetes.io/version: "5.7.21"
    app.kubernetes.io/managed-by: helm
    app.kubernetes.io/component: database
    app.kubernetes.io/part-of: wordpress
...
```

使用 MySQL `StatefulSet` 和 `Service`，你会注意到有关 MySQL 和 WordPress 的信息，包括更广泛的应用程序。


## Kubernetes 架构

### [节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)
Kubernetes 通过将容器放入在节点（Node）上运行的 Pod 中来执行你的[工作负载](https://kubernetes.io/zh-cn/docs/concepts/workloads/)。 节点可以是一个虚拟机或者物理机器，取决于所在的集群配置。 每个节点包含运行 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 所需的服务； 这些节点由[控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)负责管理。

通常集群中会有若干个节点；而在一个学习所用或者资源受限的环境中，你的集群中也可能只有一个节点。

节点上的[组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components)包括 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet)、 [容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)以及 [kube-proxy](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/)。

#### 管理[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#management)

向 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)添加节点的方式主要有两种：

1. 节点上的 `kubelet` 向控制面执行自注册；
2. 你（或者别的什么人）手动添加一个 Node 对象。

在你创建了 Node [对象](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects)或者节点上的 `kubelet` 执行了自注册操作之后，控制面会检查新的 Node 对象是否合法。 例如，如果你尝试使用下面的 JSON 对象来创建 Node 对象：

```json
{
  "kind": "Node",
  "apiVersion": "v1",
  "metadata": {
    "name": "10.240.79.157",
    "labels": {
      "name": "my-first-k8s-node"
    }
  }
}
```

Kubernetes 会在内部创建一个 Node 对象作为节点的表示。Kubernetes 检查 `kubelet` 向 API 服务器注册节点时使用的 `metadata.name` 字段是否匹配。 如果节点是健康的（即所有必要的服务都在运行中），则该节点可以用来运行 Pod。 否则，直到该节点变为健康之前，所有的集群活动都会忽略该节点。

**说明：**

Kubernetes 会一直保存着非法节点对应的对象，并持续检查该节点是否已经变得健康。

你，或者某个[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)必须显式地删除该 Node 对象以停止健康检查操作。

Node 对象的名称必须是合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)。

##### 节点名称唯一性[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-name-uniqueness)

节点的[名称](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#names)用来标识 Node 对象。 没有两个 Node 可以同时使用相同的名称。 Kubernetes 还假定名字相同的资源是同一个对象。 就 Node 而言，隐式假定使用相同名称的实例会具有相同的状态（例如网络配置、根磁盘内容） 和类似节点标签这类属性。这可能在节点被更改但其名称未变时导致系统状态不一致。 如果某个 Node 需要被替换或者大量变更，需要从 API 服务器移除现有的 Node 对象， 之后再在更新之后重新将其加入。

##### 节点自注册[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#self-registration-of-nodes)

当 kubelet 标志 `--register-node` 为 true（默认）时，它会尝试向 API 服务注册自己。 这是首选模式，被绝大多数发行版选用。

对于自注册模式，kubelet 使用下列参数启动：

- `--kubeconfig` - 用于向 API 服务器执行身份认证所用的凭据的路径。
- `--cloud-provider` - 与某[云驱动](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cloud-provider) 进行通信以读取与自身相关的元数据的方式。
- `--register-node` - 自动向 API 服务注册。
- `--register-with-taints` - 使用所给的[污点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)列表 （逗号分隔的 `<key>=<value>:<effect>`）注册节点。当 `register-node` 为 false 时无效。
- `--node-ip` - 节点 IP 地址。
- `--node-labels` - 在集群中注册节点时要添加的[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)。 （参见 [NodeRestriction 准入控制插件](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#noderestriction)所实施的标签限制）。
- `--node-status-update-frequency` - 指定 kubelet 向 API 服务器发送其节点状态的频率。

当 [Node 鉴权模式](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/node/)和 [NodeRestriction 准入插件](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#noderestriction)被启用后， 仅授权 kubelet 创建/修改自己的 Node 资源。

**说明：**

正如[节点名称唯一性](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-name-uniqueness)一节所述，当 Node 的配置需要被更新时， 一种好的做法是重新向 API 服务器注册该节点。例如，如果 kubelet 重启时其 `--node-labels` 是新的值集，但同一个 Node 名称已经被使用，则所作变更不会起作用， 因为节点标签是在 Node 注册时完成的。

如果在 kubelet 重启期间 Node 配置发生了变化，已经被调度到某 Node 上的 Pod 可能会出现行为不正常或者出现其他问题，例如，已经运行的 Pod 可能通过污点机制设置了与 Node 上新设置的标签相排斥的规则，也有一些其他 Pod， 本来与此 Pod 之间存在不兼容的问题，也会因为新的标签设置而被调到同一节点。 节点重新注册操作可以确保节点上所有 Pod 都被排空并被正确地重新调度。

##### 手动节点管理[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#manual-node-administration)

你可以使用 [kubectl](https://kubernetes.io/docs/user-guide/kubectl-overview/) 来创建和修改 Node 对象。

如果你希望手动创建节点对象时，请设置 kubelet 标志 `--register-node=false`。

你可以修改 Node 对象（忽略 `--register-node` 设置）。 例如，你可以修改节点上的标签或并标记其为不可调度。

你可以结合使用 Node 上的标签和 Pod 上的选择算符来控制调度。 例如，你可以限制某 Pod 只能在符合要求的节点子集上运行。

如果标记节点为不可调度（unschedulable），将阻止新 Pod 调度到该 Node 之上， 但不会影响任何已经在其上的 Pod。 这是重启节点或者执行其他维护操作之前的一个有用的准备步骤。

要标记一个 Node 为不可调度，执行以下命令：

```shell
kubectl cordon $NODENAME
```

更多细节参考[安全地腾空节点](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/safely-drain-node/)。

**说明：**

被 [DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/) 控制器创建的 Pod 能够容忍节点的不可调度属性。 DaemonSet 通常提供节点本地的服务，即使节点上的负载应用已经被腾空， 这些服务也仍需运行在节点之上。

#### 节点状态[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-status)

一个节点的状态包含以下信息:

- [地址（Addresses）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#addresses)
- [状况（Condition）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#condition)
- [容量与可分配（Capacity）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#capacity)
- [信息（Info）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#info)

你可以使用 `kubectl` 来查看节点状态和其他细节信息：

```shell
kubectl describe node <节点名称>
```

下面对输出的每个部分进行详细描述。

##### 地址[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#addresses)

这些字段的用法取决于你的云服务商或者物理机配置。

- HostName：由节点的内核报告。可以通过 kubelet 的 `--hostname-override` 参数覆盖。
- ExternalIP：通常是节点的可外部路由（从集群外可访问）的 IP 地址。
- InternalIP：通常是节点的仅可在集群内部路由的 IP 地址。

##### 状况[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#condition)

`conditions` 字段描述了所有 `Running` 节点的状况。状况的示例包括：

| 节点状况 | 描述 |
| --- | --- |
| `Ready` | 如节点是健康的并已经准备好接收 Pod 则为 `True`；`False` 表示节点不健康而且不能接收 Pod；`Unknown` 表示节点控制器在最近 `node-monitor-grace-period` 期间（默认 40 秒）没有收到节点的消息 |
| `DiskPressure` | `True` 表示节点存在磁盘空间压力，即磁盘可用量低, 否则为 `False` |
| `MemoryPressure` | `True` 表示节点存在内存压力，即节点内存可用量低，否则为 `False` |
| `PIDPressure` | `True` 表示节点存在进程压力，即节点上进程过多；否则为 `False` |
| `NetworkUnavailable` | `True` 表示节点网络配置不正确；否则为 `False` |

**说明：**

如果使用命令行工具来打印已保护（Cordoned）节点的细节，其中的 Condition 字段可能包括 `SchedulingDisabled`。`SchedulingDisabled` 不是 Kubernetes API 中定义的 Condition，被保护起来的节点在其规约中被标记为不可调度（Unschedulable）。

在 Kubernetes API 中，节点的状况表示节点资源中 `.status` 的一部分。 例如，以下 JSON 结构描述了一个健康节点：

```json
"conditions": [
  {
    "type": "Ready",
    "status": "True",
    "reason": "KubeletReady",
    "message": "kubelet is posting ready status",
    "lastHeartbeatTime": "2019-06-05T18:38:35Z",
    "lastTransitionTime": "2019-06-05T11:41:27Z"
  }
]
```

如果 Ready 状况的 `status` 处于 `Unknown` 或者 `False` 状态的时间超过了 `pod-eviction-timeout` 值（一个传递给 [kube-controller-manager](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/) 的参数），[节点控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-controller)会对节点上的所有 Pod 触发 [API 发起的驱逐](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/api-eviction/)。 默认的逐出超时时长为 **5 分钟**。

某些情况下，当节点不可达时，API 服务器不能和其上的 kubelet 通信。 删除 Pod 的决定不能传达给 kubelet，直到它重新建立和 API 服务器的连接为止。 与此同时，被计划删除的 Pod 可能会继续在游离的节点上运行。

节点控制器在确认 Pod 在集群中已经停止运行前，不会强制删除它们。 你可以看到可能在这些无法访问的节点上运行的 Pod 处于 `Terminating` 或者 `Unknown` 状态。 如果 Kubernetes 不能基于下层基础设施推断出某节点是否已经永久离开了集群， 集群管理员可能需要手动删除该节点对象。 从 Kubernetes 删除节点对象将导致 API 服务器删除节点上所有运行的 Pod 对象并释放它们的名字。

当节点上出现问题时，Kubernetes 控制面会自动创建与影响节点的状况对应的 [污点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)。 调度器在将 Pod 指派到某 Node 时会考虑 Node 上的污点设置。 Pod 也可以设置[容忍度](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)， 以便能够在设置了特定污点的 Node 上运行。

进一步的细节可参阅[根据状况为节点设置污点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition)。

##### 容量（Capacity）与可分配（Allocatable）[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#capacity)

这两个值描述节点上的可用资源：CPU、内存和可以调度到节点上的 Pod 的个数上限。

`capacity` 块中的字段标示节点拥有的资源总量。 `allocatable` 块指示节点上可供普通 Pod 消耗的资源量。

可以在学习如何在节点上[预留计算资源](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable) 的时候了解有关容量和可分配资源的更多信息。

##### 信息（Info）[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#info)

Info 指的是节点的一般信息，如内核版本、Kubernetes 版本（`kubelet` 和 `kube-proxy` 版本）、 容器运行时详细信息，以及节点使用的操作系统。 `kubelet` 从节点收集这些信息并将其发布到 Kubernetes API。

#### 心跳[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats)

Kubernetes 节点发送的心跳帮助你的集群确定每个节点的可用性，并在检测到故障时采取行动。

对于节点，有两种形式的心跳:

- 更新节点的 `.status`
- `kube-node-lease` [名字空间](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/)中的 [Lease（租约）](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/)对象。 每个节点都有一个关联的 Lease 对象。

与 Node 的 `.status` 更新相比，Lease 是一种轻量级资源。 使用 Lease 来表达心跳在大型集群中可以减少这些更新对性能的影响。

kubelet 负责创建和更新节点的 `.status`，以及更新它们对应的 Lease。

- 当节点状态发生变化时，或者在配置的时间间隔内没有更新事件时，kubelet 会更新 `.status`。 `.status` 更新的默认间隔为 5 分钟（比节点不可达事件的 40 秒默认超时时间长很多）。
- `kubelet` 会创建并每 10 秒（默认更新间隔时间）更新 Lease 对象。 Lease 的更新独立于 Node 的 `.status` 更新而发生。 如果 Lease 的更新操作失败，kubelet 会采用指数回退机制，从 200 毫秒开始重试， 最长重试间隔为 7 秒钟。

#### 节点控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-controller)

节点[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)是 Kubernetes 控制面组件， 管理节点的方方面面。

节点控制器在节点的生命周期中扮演多个角色。 第一个是当节点注册时为它分配一个 CIDR 区段（如果启用了 CIDR 分配）。

第二个是保持节点控制器内的节点列表与云服务商所提供的可用机器列表同步。 如果在云环境下运行，只要某节点不健康，节点控制器就会询问云服务是否节点的虚拟机仍可用。 如果不可用，节点控制器会将该节点从它的节点列表删除。

第三个是监控节点的健康状况。节点控制器负责：

- 在节点不可达的情况下，在 Node 的 `.status` 中更新 `Ready` 状况。 在这种情况下，节点控制器将 NodeReady 状况更新为 `Unknown`。
- 如果节点仍然无法访问：对于不可达节点上的所有 Pod 触发 [API 发起的逐出](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/api-eviction/)操作。 默认情况下，节点控制器在将节点标记为 `Unknown` 后等待 5 分钟提交第一个驱逐请求。

默认情况下，节点控制器每 5 秒检查一次节点状态，可以使用 `kube-controller-manager` 组件上的 `--node-monitor-period` 参数来配置周期。

##### 逐出速率限制[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#rate-limits-on-eviction)

大部分情况下，节点控制器把逐出速率限制在每秒 `--node-eviction-rate` 个（默认为 0.1）。 这表示它每 10 秒钟内至多从一个节点驱逐 Pod。

当一个可用区域（Availability Zone）中的节点变为不健康时，节点的驱逐行为将发生改变。 节点控制器会同时检查可用区域中不健康（`Ready` 状况为 `Unknown` 或 `False`） 的节点的百分比：

- 如果不健康节点的比例超过 `--unhealthy-zone-threshold` （默认为 0.55）， 驱逐速率将会降低。
- 如果集群较小（意即小于等于 `--large-cluster-size-threshold` 个节点 - 默认为 50）， 驱逐操作将会停止。
- 否则驱逐速率将降为每秒 `--secondary-node-eviction-rate` 个（默认为 0.01）。

在逐个可用区域中实施这些策略的原因是， 当一个可用区域可能从控制面脱离时其它可用区域可能仍然保持连接。 如果你的集群没有跨越云服务商的多个可用区域，那（整个集群）就只有一个可用区域。

跨多个可用区域部署你的节点的一个关键原因是当某个可用区域整体出现故障时， 工作负载可以转移到健康的可用区域。 因此，如果一个可用区域中的所有节点都不健康时，节点控制器会以正常的速率 `--node-eviction-rate` 进行驱逐操作。 在所有的可用区域都不健康（也即集群中没有健康节点）的极端情况下， 节点控制器将假设控制面与节点间的连接出了某些问题，它将停止所有驱逐动作 （如果故障后部分节点重新连接，节点控制器会从剩下不健康或者不可达节点中驱逐 Pod）。

节点控制器还负责驱逐运行在拥有 `NoExecute` 污点的节点上的 Pod， 除非这些 Pod 能够容忍此污点。 节点控制器还负责根据节点故障（例如节点不可访问或没有就绪） 为其添加[污点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)。 这意味着调度器不会将 Pod 调度到不健康的节点上。

##### 资源容量跟踪[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-capacity)

Node 对象会跟踪节点上资源的容量（例如可用内存和 CPU 数量）。 通过[自注册](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#self-registration-of-nodes)机制生成的 Node 对象会在注册期间报告自身容量。 如果你[手动](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#manual-node-administration)添加了 Node， 你就需要在添加节点时手动设置节点容量。

Kubernetes [调度器](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/) 保证节点上有足够的资源供其上的所有 Pod 使用。 它会检查节点上所有容器的请求的总和不会超过节点的容量。 总的请求包括由 kubelet 启动的所有容器，但不包括由容器运行时直接启动的容器， 也不包括不受 `kubelet` 控制的其他进程。

**说明：**

如果要为非 Pod 进程显式保留资源。 请参考[为系统守护进程预留资源](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved)。

#### 节点拓扑[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#node-topology)

**特性状态：** `Kubernetes v1.18 [beta]`

如果启用了 `TopologyManager` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， `kubelet` 可以在作出资源分配决策时使用拓扑提示。 参考[控制节点上拓扑管理策略](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/topology-manager/)了解详细信息。

#### 节点体面关闭[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#graceful-node-shutdown)

**特性状态：** `Kubernetes v1.21 [beta]`

kubelet 会尝试检测节点系统关闭事件并终止在节点上运行的所有 Pod。

在节点终止期间，kubelet 保证 Pod 遵从常规的 [Pod 终止流程](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)。

节点体面关闭特性依赖于 systemd，因为它要利用 [systemd 抑制器锁](https://www.freedesktop.org/wiki/Software/systemd/inhibit/)机制， 在给定的期限内延迟节点关闭。

节点体面关闭特性受 `GracefulNodeShutdown` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)控制， 在 1.21 版本中是默认启用的。

注意，默认情况下，下面描述的两个配置选项，`shutdownGracePeriod` 和 `shutdownGracePeriodCriticalPods` 都是被设置为 0 的，因此不会激活节点体面关闭功能。 要激活此功能特性，这两个 kubelet 配置选项要适当配置，并设置为非零值。

在体面关闭节点过程中，kubelet 分两个阶段来终止 Pod：

1. 终止在节点上运行的常规 Pod。
2. 终止在节点上运行的[关键 Pod](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical)。

节点体面关闭的特性对应两个 [`KubeletConfiguration`](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubelet-config-file/) 选项：

- `shutdownGracePeriod`：
    - 指定节点应延迟关闭的总持续时间。此时间是 Pod 体面终止的时间总和，不区分常规 Pod 还是[关键 Pod](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical)。
- `shutdownGracePeriodCriticalPods`：
    - 在节点关闭期间指定用于终止[关键 Pod](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical) 的持续时间。该值应小于 `shutdownGracePeriod`。

例如，如果设置了 `shutdownGracePeriod=30s` 和 `shutdownGracePeriodCriticalPods=10s`， 则 kubelet 将延迟 30 秒关闭节点。 在关闭期间，将保留前 20（30 - 10）秒用于体面终止常规 Pod， 而保留最后 10 秒用于终止[关键 Pod](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical)。

**说明：**

当 Pod 在正常节点关闭期间被驱逐时，它们会被标记为关闭。 运行 `kubectl get pods` 时，被驱逐的 Pod 的状态显示为 `Terminated`。 并且 `kubectl describe pod` 表示 Pod 因节点关闭而被驱逐：

```
Reason:         Terminated
Message:        Pod was terminated in response to imminent node shutdown.
```

##### 基于 Pod 优先级的节点体面关闭[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#pod-priority-graceful-node-shutdown)

**特性状态：** `Kubernetes v1.23 [alpha]`

为了在节点体面关闭期间提供更多的灵活性，尤其是处理关闭期间的 Pod 排序问题， 节点体面关闭机制能够关注 Pod 的 PriorityClass 设置，前提是你已经在集群中启用了此功能特性。 此功能特性允许集群管理员基于 Pod 的[优先级类（Priority Class）](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass) 显式地定义节点体面关闭期间 Pod 的处理顺序。

前文所述的[节点体面关闭](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#graceful-node-shutdown)特性能够分两个阶段关闭 Pod， 首先关闭的是非关键的 Pod，之后再处理关键 Pod。 如果需要显式地以更细粒度定义关闭期间 Pod 的处理顺序，需要一定的灵活度， 这时可以使用基于 Pod 优先级的体面关闭机制。

当节点体面关闭能够处理 Pod 优先级时，节点体面关闭的处理可以分为多个阶段， 每个阶段关闭特定优先级类的 Pod。kubelet 可以被配置为按确切的阶段处理 Pod， 且每个阶段可以独立设置关闭时间。

假设集群中存在以下自定义的 Pod [优先级类](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass)。

| Pod 优先级类名称 | Pod 优先级类数值 |
| --- | --- |
| `custom-class-a` | 100000 |
| `custom-class-b` | 10000 |
| `custom-class-c` | 1000 |
| `regular/unset` | 0 |

在 [kubelet 配置](https://kubernetes.io/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)中， `shutdownGracePeriodByPodPriority` 可能看起来是这样：

| Pod 优先级类数值 | 关闭期限 |
| --- | --- |
| 100000 | 10 秒 |
| 10000 | 180 秒 |
| 1000 | 120 秒 |
| 0 | 60 秒 |

对应的 kubelet 配置 YAML 将会是：

```yaml
shutdownGracePeriodByPodPriority:
  - priority: 100000
    shutdownGracePeriodSeconds: 10
  - priority: 10000
    shutdownGracePeriodSeconds: 180
  - priority: 1000
    shutdownGracePeriodSeconds: 120
  - priority: 0
    shutdownGracePeriodSeconds: 60
```

上面的表格表明，所有 `priority` 值大于等于 100000 的 Pod 会得到 10 秒钟期限停止， 所有 `priority` 值介于 10000 和 100000 之间的 Pod 会得到 180 秒钟期限停止， 所有 `priority` 值介于 1000 和 10000 之间的 Pod 会得到 120 秒钟期限停止， 所有其他 Pod 将获得 60 秒的时间停止。

用户不需要为所有的优先级类都设置数值。例如，你也可以使用下面这种配置：

| Pod 优先级类数值 | 关闭期限 |
| --- | --- |
| 100000 | 300 秒 |
| 1000 | 120 秒 |
| 0 | 60 秒 |

在上面这个场景中，优先级类为 `custom-class-b` 的 Pod 会与优先级类为 `custom-class-c` 的 Pod 在关闭时按相同期限处理。

如果在特定的范围内不存在 Pod，则 kubelet 不会等待对应优先级范围的 Pod。 kubelet 会直接跳到下一个优先级数值范围进行处理。

如果此功能特性被启用，但没有提供配置数据，则不会出现排序操作。

使用此功能特性需要启用 `GracefulNodeShutdownBasedOnPodPriority` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， 并将 [kubelet 配置](https://kubernetes.io/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/) 中的 `shutdownGracePeriodByPodPriority` 设置为期望的配置， 其中包含 Pod 的优先级类数值以及对应的关闭期限。

**说明：**

在节点体面关闭期间考虑 Pod 优先级的能力是作为 Kubernetes v1.23 中的 Alpha 功能引入的。 在 Kubernetes 1.26 中该功能是 Beta 版，默认启用。

kubelet 子系统中会生成 `graceful_shutdown_start_time_seconds` 和 `graceful_shutdown_end_time_seconds` 度量指标以便监视节点关闭行为。

#### 节点非体面关闭[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#non-graceful-node-shutdown)

**特性状态：** `Kubernetes v1.26 [beta]`

节点关闭的操作可能无法被 kubelet 的节点关闭管理器检测到， 是因为该命令不会触发 kubelet 所使用的抑制锁定机制，或者是因为用户错误的原因， 即 ShutdownGracePeriod 和 ShutdownGracePeriodCriticalPod 配置不正确。 请参考以上[节点体面关闭](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#graceful-node-shutdown)部分了解更多详细信息。

当某节点关闭但 kubelet 的节点关闭管理器未检测到这一事件时， 在那个已关闭节点上、属于 [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 的 Pod 将停滞于终止状态，并且不能移动到新的运行节点上。 这是因为已关闭节点上的 kubelet 已不存在，亦无法删除 Pod， 因此 StatefulSet 无法创建同名的新 Pod。 如果 Pod 使用了卷，则 VolumeAttachments 不会从原来的已关闭节点上删除， 因此这些 Pod 所使用的卷也无法挂接到新的运行节点上。 所以，那些以 StatefulSet 形式运行的应用无法正常工作。 如果原来的已关闭节点被恢复，kubelet 将删除 Pod，新的 Pod 将被在不同的运行节点上创建。 如果原来的已关闭节点没有被恢复，那些在已关闭节点上的 Pod 将永远滞留在终止状态。

为了缓解上述情况，用户可以手动将具有 `NoExecute` 或 `NoSchedule` 效果的 `node.kubernetes.io/out-of-service` 污点添加到节点上，标记其无法提供服务。 如果在 [kube-controller-manager](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/) 上启用了 `NodeOutOfServiceVolumeDetach` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， 并且节点被通过污点标记为无法提供服务，如果节点 Pod 上没有设置对应的容忍度， 那么这样的 Pod 将被强制删除，并且该在节点上被终止的 Pod 将立即进行卷分离操作。 这样就允许那些在无法提供服务节点上的 Pod 能在其他节点上快速恢复。

在非体面关闭期间，Pod 分两个阶段终止：

1. 强制删除没有匹配的 `out-of-service` 容忍度的 Pod。
2. 立即对此类 Pod 执行分离卷操作。

**说明：**

- 在添加 `node.kubernetes.io/out-of-service` 污点之前， 应该验证节点已经处于关闭或断电状态（而不是在重新启动中）。
- 将 Pod 移动到新节点后，用户需要手动移除停止服务的污点， 并且用户要检查关闭节点是否已恢复，因为该用户是最初添加污点的用户。

#### 交换内存管理[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#swap-memory)

**特性状态：** `Kubernetes v1.22 [alpha]`

在 Kubernetes 1.22 之前，节点不支持使用交换内存，并且默认情况下， 如果在节点上检测到交换内存配置，kubelet 将无法启动。 在 1.22 以后，可以逐个节点地启用交换内存支持。

要在节点上启用交换内存，必须启用 kubelet 的 `NodeSwap` 特性门控， 同时使用 `--fail-swap-on` 命令行参数或者将 `failSwapOn` [配置](https://kubernetes.io/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration)设置为 false。

**警告：**

当内存交换功能被启用后，Kubernetes 数据（如写入 tmpfs 的 Secret 对象的内容）可以被交换到磁盘。

用户还可以选择配置 `memorySwap.swapBehavior` 以指定节点使用交换内存的方式。例如:

```yaml
memorySwap:
  swapBehavior: LimitedSwap
```

可用的 `swapBehavior` 的配置选项有：

- `LimitedSwap`：Kubernetes 工作负载的交换内存会受限制。 不受 Kubernetes 管理的节点上的工作负载仍然可以交换。
- `UnlimitedSwap`：Kubernetes 工作负载可以使用尽可能多的交换内存请求， 一直到达到系统限制为止。

如果启用了特性门控但是未指定 `memorySwap` 的配置，默认情况下 kubelet 将使用 `LimitedSwap` 设置。

`LimitedSwap` 这种设置的行为取决于节点运行的是 v1 还是 v2 的控制组（也就是 `cgroups`）：

- **cgroupsv1:** Kubernetes 工作负载可以使用内存和交换，上限为 Pod 的内存限制值（如果设置了的话）。
- **cgroupsv2:** Kubernetes 工作负载不能使用交换内存。

如需更多信息以及协助测试和提供反馈，请参见 [KEP-2400](https://github.com/kubernetes/enhancements/issues/2400) 及其[设计提案](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md)。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

进一步了解以下资料：

- 构成节点的[组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components)。
- [Node 的 API 定义](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#node-v1-core)。
- 架构设计文档中有关 [Node](https://git.k8s.io/design-proposals-archive/architecture/architecture.md#the-kubernetes-node) 的章节。
- [污点和容忍度](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)。
- [节点资源管理器](https://kubernetes.io/zh-cn/docs/concepts/policy/node-resource-managers/)。
- [Windows 节点的资源管理](https://kubernetes.io/zh-cn/docs/concepts/configuration/windows-resource-management/)。
### [节点与控制面之间的通信](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/)
本文列举控制面节点（确切地说是 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)）和 Kubernetes [集群](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster)之间的通信路径。 目的是为了让用户能够自定义他们的安装，以实现对网络配置的加固， 使得集群能够在不可信的网络上（或者在一个云服务商完全公开的 IP 上）运行。

#### 节点到控制面[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#node-to-control-plane)

Kubernetes 采用的是中心辐射型（Hub-and-Spoke）API 模式。 所有从节点（或运行于其上的 Pod）发出的 API 调用都终止于 API 服务器。 其它控制面组件都没有被设计为可暴露远程服务。 API 服务器被配置为在一个安全的 HTTPS 端口（通常为 443）上监听远程连接请求， 并启用一种或多种形式的客户端[身份认证](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/)机制。 一种或多种客户端[鉴权机制](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authorization/)应该被启用， 特别是在允许使用[匿名请求](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/#anonymous-requests) 或[服务账户令牌](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/#service-account-tokens)的时候。

应该使用集群的公共根[证书](https://kubernetes.io/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/)开通节点， 这样它们就能够基于有效的客户端凭据安全地连接 API 服务器。 一种好的方法是以客户端证书的形式将客户端凭据提供给 kubelet。 请查看 [kubelet TLS 启动引导](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/) 以了解如何自动提供 kubelet 客户端证书。

想要连接到 API 服务器的 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 可以使用服务账号安全地进行连接。 当 Pod 被实例化时，Kubernetes 自动把公共根证书和一个有效的持有者令牌注入到 Pod 里。 `kubernetes` 服务（位于 `default` 名字空间中）配置了一个虚拟 IP 地址， 用于（通过 `[kube-proxy](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/)`）转发请求到 API 服务器的 HTTPS 末端。

控制面组件也通过安全端口与集群的 API 服务器通信。

这样，从集群节点和节点上运行的 Pod 到控制面的连接的缺省操作模式即是安全的， 能够在不可信的网络或公网上运行。

#### 控制面到节点[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#control-plane-to-node)

从控制面（API 服务器）到节点有两种主要的通信路径。 第一种是从 API 服务器到集群中每个节点上运行的 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 进程。 第二种是从 API 服务器通过它的**代理**功能连接到任何节点、Pod 或者服务。

##### API 服务器到 kubelet[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#api-server-to-kubelet)

从 API 服务器到 kubelet 的连接用于：

- 获取 Pod 日志。
- 挂接（通过 kubectl）到运行中的 Pod。
- 提供 kubelet 的端口转发功能。

这些连接终止于 kubelet 的 HTTPS 末端。 默认情况下，API 服务器不检查 kubelet 的服务证书。这使得此类连接容易受到中间人攻击， 在非受信网络或公开网络上运行也是 **不安全的**。

为了对这个连接进行认证，使用 `--kubelet-certificate-authority` 标志给 API 服务器提供一个根证书包，用于 kubelet 的服务证书。

如果无法实现这点，又要求避免在非受信网络或公共网络上进行连接，可在 API 服务器和 kubelet 之间使用 [SSH 隧道](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#ssh-tunnels)。

最后，应该启用 [Kubelet 认证/鉴权](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/kubelet-authn-authz/) 来保护 kubelet API。

##### API 服务器到节点、Pod 和服务[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#api-server-to-nodes-pods-and-services)

从 API 服务器到节点、Pod 或服务的连接默认为纯 HTTP 方式，因此既没有认证，也没有加密。 这些连接可通过给 API URL 中的节点、Pod 或服务名称添加前缀 `https:` 来运行在安全的 HTTPS 连接上。 不过这些连接既不会验证 HTTPS 末端提供的证书，也不会提供客户端证书。 因此，虽然连接是加密的，仍无法提供任何完整性保证。 这些连接 **目前还不能安全地** 在非受信网络或公共网络上运行。

##### SSH 隧道[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#ssh-tunnels)

Kubernetes 支持使用 [SSH 隧道](https://www.ssh.com/academy/ssh/tunneling)来保护从控制面到节点的通信路径。 在这种配置下，API 服务器建立一个到集群中各节点的 SSH 隧道（连接到在 22 端口监听的 SSH 服务器） 并通过这个隧道传输所有到 kubelet、节点、Pod 或服务的请求。 这一隧道保证通信不会被暴露到集群节点所运行的网络之外。

**说明：**

SSH 隧道目前已被废弃。除非你了解个中细节，否则不应使用。 [Konnectivity 服务](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#konnectivity-service)是 SSH 隧道的替代方案。

##### Konnectivity 服务[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#konnectivity-service)

**特性状态：** `Kubernetes v1.18 [beta]`

作为 SSH 隧道的替代方案，Konnectivity 服务提供 TCP 层的代理，以便支持从控制面到集群的通信。 Konnectivity 服务包含两个部分：Konnectivity 服务器和 Konnectivity 代理， 分别运行在控制面网络和节点网络中。 Konnectivity 代理建立并维持到 Konnectivity 服务器的网络连接。 启用 Konnectivity 服务之后，所有控制面到节点的通信都通过这些连接传输。

请浏览 [Konnectivity 服务任务](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/setup-konnectivity/) 在你的集群中配置 Konnectivity 服务。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/control-plane-node-communication/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读 [Kubernetes 控制面组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components)
- 进一步了解 [Hubs and Spoke model](https://book.kubebuilder.io/multiversion-tutorial/conversion-concepts.html#hubs-spokes-and-other-wheel-metaphors)
- 进一步了解如何[保护集群](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/securing-a-cluster/)
- 进一步了解 [Kubernetes API](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/)
- [设置 Konnectivity 服务](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/setup-konnectivity/)
- [使用端口转发来访问集群中的应用](https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/port-forward-access-application-cluster/)
- 学习如何[检查 Pod 的日志](https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/#examine-pod-logs) 以及如何[使用 kubectl 端口转发](https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/port-forward-access-application-cluster/#forward-a-local-port-to-a-port-on-the-pod)
### [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)
在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。

这是一个控制环的例子：房间里的温度自动调节器。

当你设置了温度，告诉了温度自动调节器你的**期望状态（Desired State）**。 房间的实际温度是**当前状态（Current State）**。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。

在 Kubernetes 中，控制器通过监控[集群](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster) 的公共状态，并致力于将当前状态转变为期望的状态。

#### 控制器模式[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#controller-pattern)

一个控制器至少追踪一种类型的 Kubernetes 资源。这些 [对象](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects) 有一个代表期望状态的 `spec` 字段。 该资源的控制器负责确保其当前状态接近期望状态。

控制器可能会自行执行操作；在 Kubernetes 中更常见的是一个控制器会发送信息给 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)，这会有副作用。 具体可参看后文的例子。

##### 通过 API 服务器来控制[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#control-via-API-server)

[Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 控制器是一个 Kubernetes 内置控制器的例子。 内置控制器通过和集群 API 服务器交互来管理状态。

Job 是一种 Kubernetes 资源，它运行一个或者多个 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)， 来执行一个任务然后停止。 （一旦[被调度了](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/)，对 `kubelet` 来说 Pod 对象就会变成了期望状态的一部分）。

在集群中，当 Job 控制器拿到新任务时，它会保证一组 Node 节点上的 `kubelet` 可以运行正确数量的 Pod 来完成工作。 Job 控制器不会自己运行任何的 Pod 或者容器。Job 控制器是通知 API 服务器来创建或者移除 Pod。 [控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)中的其它组件 根据新的消息作出反应（调度并运行新 Pod）并且最终完成工作。

创建新 Job 后，所期望的状态就是完成这个 Job。Job 控制器会让 Job 的当前状态不断接近期望状态：创建为 Job 要完成工作所需要的 Pod，使 Job 的状态接近完成。

控制器也会更新配置对象。例如：一旦 Job 的工作完成了，Job 控制器会更新 Job 对象的状态为 `Finished`。

（这有点像温度自动调节器关闭了一个灯，以此来告诉你房间的温度现在到你设定的值了）。

##### 直接控制[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#direct-control)

相比 Job 控制器，有些控制器需要对集群外的一些东西进行修改。

例如，如果你使用一个控制回路来保证集群中有足够的 [节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)，那么控制器就需要当前集群外的 一些服务在需要时创建新节点。

和外部状态交互的控制器从 API 服务器获取到它想要的状态，然后直接和外部系统进行通信 并使当前状态更接近期望状态。

（实际上有一个[控制器](https://github.com/kubernetes/autoscaler/) 可以水平地扩展集群中的节点。）

这里的重点是，控制器做出了一些变更以使得事物更接近你的期望状态， 之后将当前状态报告给集群的 API 服务器。 其他控制回路可以观测到所汇报的数据的这种变化并采取其各自的行动。

在温度计的例子中，如果房间很冷，那么某个控制器可能还会启动一个防冻加热器。 就 Kubernetes 集群而言，控制面间接地与 IP 地址管理工具、存储服务、云驱动 APIs 以及其他服务协作，通过[扩展 Kubernetes](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/) 来实现这点。

#### 期望状态与当前状态[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#desired-vs-current)

Kubernetes 采用了系统的云原生视图，并且可以处理持续的变化。

在任务执行时，集群随时都可能被修改，并且控制回路会自动修复故障。 这意味着很可能集群永远不会达到稳定状态。

只要集群中的控制器在运行并且进行有效的修改，整体状态的稳定与否是无关紧要的。

#### 设计[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#design)

作为设计原则之一，Kubernetes 使用了很多控制器，每个控制器管理集群状态的一个特定方面。 最常见的一个特定的控制器使用一种类型的资源作为它的期望状态， 控制器管理控制另外一种类型的资源向它的期望状态演化。 例如，Job 的控制器跟踪 Job 对象（以发现新的任务）和 Pod 对象（以运行 Job，然后查看任务何时完成）。 在这种情况下，新任务会创建 Job，而 Job 控制器会创建 Pod。

使用简单的控制器而不是一组相互连接的单体控制回路是很有用的。 控制器会失败，所以 Kubernetes 的设计正是考虑到了这一点。

**说明：**

可以有多个控制器来创建或者更新相同类型的对象。 在后台，Kubernetes 控制器确保它们只关心与其控制资源相关联的资源。

例如，你可以创建 Deployment 和 Job；它们都可以创建 Pod。 Job 控制器不会删除 Deployment 所创建的 Pod，因为有信息 （[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)）让控制器可以区分这些 Pod。

#### 运行控制器的方式[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#running-controllers)

Kubernetes 内置一组控制器，运行在 [kube-controller-manager](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/) 内。 这些内置的控制器提供了重要的核心功能。

Deployment 控制器和 Job 控制器是 Kubernetes 内置控制器的典型例子。 Kubernetes 允许你运行一个稳定的控制平面，这样即使某些内置控制器失败了， 控制平面的其他部分会接替它们的工作。

你会遇到某些控制器运行在控制面之外，用以扩展 Kubernetes。 或者，如果你愿意，你也可以自己编写新控制器。 你可以以一组 Pod 来运行你的控制器，或者运行在 Kubernetes 之外。 最合适的方案取决于控制器所要执行的功能是什么。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读 [Kubernetes 控制平面组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components)
- 了解 [Kubernetes 对象](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/) 的一些基本知识
- 进一步学习 [Kubernetes API](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/)
- 如果你想编写自己的控制器，请看 Kubernetes 的 [扩展模式](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/#extension-patterns)。
### [租约](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/)
分布式系统通常需要**租约（Lease）**；租约提供了一种机制来锁定共享资源并协调集合成员之间的活动。 在 Kubernetes 中，租约概念表示为 `coordination.k8s.io` [API 组](https://kubernetes.io/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning)中的 [Lease](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/cluster-resources/lease-v1/) 对象， 常用于类似节点心跳和组件级领导者选举等系统核心能力。

#### 节点心跳[](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/#node-heart-beats)

Kubernetes 使用 Lease API 将 kubelet 节点心跳传递到 Kubernetes API 服务器。 对于每个 `Node`，在 `kube-node-lease` 名字空间中都有一个具有匹配名称的 `Lease` 对象。 在此基础上，每个 kubelet 心跳都是对该 `Lease` 对象的 **update** 请求，更新该 Lease 的 `spec.renewTime` 字段。 Kubernetes 控制平面使用此字段的时间戳来确定此 `Node` 的可用性。

更多细节请参阅 [Node Lease 对象](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats)。

#### 领导者选举[](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/#leader-election)

Kubernetes 也使用 Lease 确保在任何给定时间某个组件只有一个实例在运行。 这在高可用配置中由 `kube-controller-manager` 和 `kube-scheduler` 等控制平面组件进行使用， 这些组件只应有一个实例激活运行，而其他实例待机。

#### API 服务器身份[](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/#api-server-identity)

**特性状态：** `Kubernetes v1.26 [beta]`

从 Kubernetes v1.26 开始，每个 `kube-apiserver` 都使用 Lease API 将其身份发布到系统中的其他位置。 虽然它本身并不是特别有用，但为客户端提供了一种机制来发现有多少个 `kube-apiserver` 实例正在操作 Kubernetes 控制平面。kube-apiserver 租约的存在使得未来可以在各个 kube-apiserver 之间协调新的能力。

你可以检查 `kube-system` 名字空间中名为 `kube-apiserver-<sha256-hash>` 的 Lease 对象来查看每个 kube-apiserver 拥有的租约。你还可以使用标签选择算符 `k8s.io/component=kube-apiserver`：

```shell
kubectl -n kube-system get lease -l k8s.io/component=kube-apiserver
```

```
NAME                                        HOLDER                                                                           AGE
kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a   kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a_9cbf54e5-1136-44bd-8f9a-1dcd15c346b4   5m33s
kube-apiserver-dz2dqprdpsgnm756t5rnov7yka   kube-apiserver-dz2dqprdpsgnm756t5rnov7yka_84f2a85d-37c1-4b14-b6b9-603e62e4896f   4m23s
kube-apiserver-fyloo45sdenffw2ugwaz3likua   kube-apiserver-fyloo45sdenffw2ugwaz3likua_c5ffa286-8a9a-45d4-91e7-61118ed58d2e   4m43s
```

租约名称中使用的 SHA256 哈希基于 API 服务器所看到的操作系统主机名生成。 每个 kube-apiserver 都应该被配置为使用集群中唯一的主机名。 使用相同主机名的 kube-apiserver 新实例将使用新的持有者身份接管现有 Lease，而不是实例化新的 Lease 对象。 你可以通过检查 `kubernetes.io/hostname` 标签的值来查看 kube-apisever 所使用的主机名：

```shell
kubectl -n kube-system get lease kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a -o yaml
```

```yaml
apiVersion: coordination.k8s.io/v1
kind: Lease
metadata:
  creationTimestamp: "2022-11-30T15:37:15Z"
  labels:
    k8s.io/component: kube-apiserver
    kubernetes.io/hostname: kind-control-plane
  name: kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a
  namespace: kube-system
  resourceVersion: "18171"
  uid: d6c68901-4ec5-4385-b1ef-2d783738da6c
spec:
  holderIdentity: kube-apiserver-c4vwjftbvpc5os2vvzle4qg27a_9cbf54e5-1136-44bd-8f9a-1dcd15c346b4
  leaseDurationSeconds: 3600
  renewTime: "2022-11-30T18:04:27.912073Z"
```

kube-apiserver 中不再存续的已到期租约将在到期 1 小时后被新的 kube-apiserver 作为垃圾收集。

你可以通过禁用 `APIServerIdentity` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)来禁用 API 服务器身份租约。

#### 工作负载[](https://kubernetes.io/zh-cn/docs/concepts/architecture/leases/#custom-workload)

你自己的工作负载可以定义自己使用的 Lease。例如， 你可以运行自定义的[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)， 让主要成员或领导者成员在其中执行其对等方未执行的操作。 你定义一个 Lease，以便控制器副本可以使用 Kubernetes API 进行协调以选择或选举一个领导者。 如果你使用 Lease，良好的做法是为明显关联到产品或组件的 Lease 定义一个名称。 例如，如果你有一个名为 Example Foo 的组件，可以使用名为 `example-foo` 的 Lease。

如果集群操作员或其他终端用户可以部署一个组件的多个实例， 则选择名称前缀并挑选一种机制（例如 Deployment 名称的哈希）以避免 Lease 的名称冲突。

你可以使用另一种方式来达到相同的效果：不同的软件产品不相互冲突。
### [云控制器管理器](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/)
**特性状态：** `Kubernetes v1.11 [beta]`

使用云基础设施技术，你可以在公有云、私有云或者混合云环境中运行 Kubernetes。 Kubernetes 的信条是基于自动化的、API 驱动的基础设施，同时避免组件间紧密耦合。

组件 cloud-controller-manager 是指云控制器管理器， 一个 Kubernetes [控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)组件， 嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。

通过分离 Kubernetes 和底层云基础设置之间的互操作性逻辑， `cloud-controller-manager` 组件使云提供商能够以不同于 Kubernetes 主项目的步调发布新特征。

`cloud-controller-manager` 组件是基于一种插件机制来构造的， 这种机制使得不同的云厂商都能将其平台与 Kubernetes 集成。

#### 设计[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#design)

![Kubernetes 组件](https://d33wubrfki0l68.cloudfront.net/2475489eaf20163ec0f54ddc1d92aa8d4c87c96b/e7c81/images/docs/components-of-kubernetes.svg)

云控制器管理器以一组多副本的进程集合的形式运行在控制面中，通常表现为 Pod 中的容器。每个 `cloud-controller-manager` 在同一进程中实现多个[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)。

**说明：**

你也可以用 Kubernetes [插件](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/) 的形式而不是控制面中的一部分来运行云控制器管理器。

#### 云控制器管理器的功能[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#functions-of-the-ccm)

云控制器管理器中的控制器包括：

##### 节点控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#node-controller)

节点控制器负责在云基础设施中创建了新服务器时为之更新[节点（Node）](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)对象。 节点控制器从云提供商获取当前租户中主机的信息。节点控制器执行以下功能：

1. 使用从云平台 API 获取的对应服务器的唯一标识符更新 Node 对象；
2. 利用特定云平台的信息为 Node 对象添加注解和标签，例如节点所在的区域 （Region）和所具有的资源（CPU、内存等等）；
3. 获取节点的网络地址和主机名；
4. 检查节点的健康状况。如果节点无响应，控制器通过云平台 API 查看该节点是否已从云中禁用、删除或终止。如果节点已从云中删除， 则控制器从 Kubernetes 集群中删除 Node 对象。

某些云驱动实现中，这些任务被划分到一个节点控制器和一个节点生命周期控制器中。

##### 路由控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#route-controller)

Route 控制器负责适当地配置云平台中的路由，以便 Kubernetes 集群中不同节点上的容器之间可以相互通信。

取决于云驱动本身，路由控制器可能也会为 Pod 网络分配 IP 地址块。

##### 服务控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#service-controller)

[服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)与受控的负载均衡器、 IP 地址、网络包过滤、目标健康检查等云基础设施组件集成。 服务控制器与云驱动的 API 交互，以配置负载均衡器和其他基础设施组件。 你所创建的 Service 资源会需要这些组件服务。

#### 鉴权[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#authorization)

本节分别讲述云控制器管理器为了完成自身工作而产生的对各类 API 对象的访问需求。

##### 节点控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#authorization-node-controller)

节点控制器只操作 Node 对象。它需要读取和修改 Node 对象的完全访问权限。

`v1/Node`：

- get
- list
- create
- update
- patch
- watch
- delete

##### 路由控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#authorization-route-controller)

路由控制器会监听 Node 对象的创建事件，并据此配置路由设施。 它需要读取 Node 对象的 Get 权限。

`v1/Node`：

- get

##### 服务控制器[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#authorization-service-controller)

服务控制器监测 Service 对象的 **create**、**update** 和 **delete** 事件， 并配置对应服务的 Endpoints 对象 （对于 EndpointSlices，kube-controller-manager 按需对其进行管理）。

为了访问 Service 对象，它需要 **list** 和 **watch** 访问权限。 为了更新 Service 对象，它需要 **patch** 和 **update** 访问权限。

为了能够配置 Service 对应的 Endpoints 资源， 它需要 **create**、**list**、**get**、**watch** 和 **update** 等访问权限。

`v1/Service`：

- list
- get
- watch
- patch
- update

##### 其他[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#authorization-miscellaneous)

在云控制器管理器的实现中，其核心部分需要创建 Event 对象的访问权限， 并创建 ServiceAccount 资源以保证操作安全性的权限。

`v1/Event`:

- create
- patch
- update

`v1/ServiceAccount`:

- create

用于云控制器管理器 [RBAC](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/) 的 ClusterRole 如下例所示：

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cloud-controller-manager
rules:
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - patch
  - update
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - '*'
- apiGroups:
  - ""
  resources:
  - nodes/status
  verbs:
  - patch
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - serviceaccounts
  verbs:
  - create
- apiGroups:
  - ""
  resources:
  - persistentvolumes
  verbs:
  - get
  - list
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - endpoints
  verbs:
  - create
  - get
  - list
  - watch
  - update
```

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

[云控制器管理器的管理](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager) 给出了运行和管理云控制器管理器的指南。

要升级 HA 控制平面以使用云控制器管理器， 请参见[将复制的控制平面迁移以使用云控制器管理器](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/controller-manager-leader-migration/)。

想要了解如何实现自己的云控制器管理器，或者对现有项目进行扩展么？

云控制器管理器使用 Go 语言的接口，从而使得针对各种云平台的具体实现都可以接入。 其中使用了在 [kubernetes/cloud-provider](https://github.com/kubernetes/cloud-provider) 项目中 [`cloud.go`](https://github.com/kubernetes/cloud-provider/blob/release-1.26/cloud.go#L43-L69) 文件所定义的 `CloudProvider` 接口。

本文中列举的共享控制器（节点控制器、路由控制器和服务控制器等）的实现以及其他一些生成具有 CloudProvider 接口的框架的代码，都是 Kubernetes 的核心代码。 特定于云驱动的实现虽不是 Kubernetes 核心成分，仍要实现 `CloudProvider` 接口。

关于如何开发插件的详细信息， 可参考[开发云控制器管理器](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/developing-cloud-controller-manager/)文档。
### [关于 cgroup v2](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/)
在 Linux 上，[控制组](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cgroup)约束分配给进程的资源。

[kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 和底层容器运行时都需要对接 cgroup 来强制执行[为 Pod 和容器管理资源](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/)， 这包括为容器化工作负载配置 CPU/内存请求和限制。

Linux 中有两个 cgroup 版本：cgroup v1 和 cgroup v2。cgroup v2 是新一代的 `cgroup` API。

#### 什么是 cgroup v2？[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#cgroup-v2)

**特性状态：** `Kubernetes v1.25 [stable]`

cgroup v2 是 Linux `cgroup` API 的下一个版本。cgroup v2 提供了一个具有增强资源管理能力的统一控制系统。

cgroup v2 对 cgroup v1 进行了多项改进，例如：

- API 中单个统一的层次结构设计
- 更安全的子树委派给容器
- 更新的功能特性， 例如[压力阻塞信息（Pressure Stall Information，PSI）](https://www.kernel.org/doc/html/latest/accounting/psi.html)
- 跨多个资源的增强资源分配管理和隔离
    - 统一核算不同类型的内存分配（网络内存、内核内存等）
    - 考虑非即时资源变化，例如页面缓存回写

一些 Kubernetes 特性专门使用 cgroup v2 来增强资源管理和隔离。 例如，[MemoryQoS](https://kubernetes.io/blog/2021/11/26/qos-memory-resources/) 特性改进了内存 QoS 并依赖于 cgroup v2 原语。

#### 使用 cgroup v2[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#using-cgroupv2)

使用 cgroup v2 的推荐方法是使用一个默认启用 cgroup v2 的 Linux 发行版。

要检查你的发行版是否使用 cgroup v2，请参阅[识别 Linux 节点上的 cgroup 版本](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#check-cgroup-version)。

##### 要求[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#requirements)

cgroup v2 具有以下要求：

- 操作系统发行版启用 cgroup v2
- Linux 内核为 5.8 或更高版本
- 容器运行时支持 cgroup v2。例如：
    - [containerd](https://containerd.io/) v1.4 和更高版本
    - [cri-o](https://cri-o.io/) v1.20 和更高版本
- kubelet 和容器运行时被配置为使用 [systemd cgroup 驱动](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver)

##### Linux 发行版 cgroup v2 支持[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#linux-distribution-cgroup-v2-support)

有关使用 cgroup v2 的 Linux 发行版的列表， 请参阅 [cgroup v2 文档](https://github.com/opencontainers/runc/blob/main/docs/cgroup-v2.md)。

- Container-Optimized OS（从 M97 开始）
- Ubuntu（从 21.10 开始，推荐 22.04+）
- Debian GNU/Linux（从 Debian 11 Bullseye 开始）
- Fedora（从 31 开始）
- Arch Linux（从 2021 年 4 月开始）
- RHEL 和类似 RHEL 的发行版（从 9 开始）

要检查你的发行版是否使用 cgroup v2， 请参阅你的发行版文档或遵循[识别 Linux 节点上的 cgroup 版本](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#check-cgroup-version)中的指示说明。

你还可以通过修改内核 cmdline 引导参数在你的 Linux 发行版上手动启用 cgroup v2。 如果你的发行版使用 GRUB，则应在 `/etc/default/grub` 下的 `GRUB_CMDLINE_LINUX` 中添加 `systemd.unified_cgroup_hierarchy=1`， 然后执行 `sudo update-grub`。不过，推荐的方法仍是使用一个默认已启用 cgroup v2 的发行版。

##### 迁移到 cgroup v2[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#migrating-cgroupv2)

要迁移到 cgroup v2，需确保满足[要求](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#requirements)，然后升级到一个默认启用 cgroup v2 的内核版本。

kubelet 能够自动检测操作系统是否运行在 cgroup v2 上并相应调整其操作，无需额外配置。

切换到 cgroup v2 时，用户体验应没有任何明显差异，除非用户直接在节点上或从容器内访问 cgroup 文件系统。

cgroup v2 使用一个与 cgroup v1 不同的 API，因此如果有任何应用直接访问 cgroup 文件系统， 则需要将这些应用更新为支持 cgroup v2 的版本。例如：

- 一些第三方监控和安全代理可能依赖于 cgroup 文件系统。你要将这些代理更新到支持 cgroup v2 的版本。
- 如果以独立的 DaemonSet 的形式运行 [cAdvisor](https://github.com/google/cadvisor) 以监控 Pod 和容器， 需将其更新到 v0.43.0 或更高版本。
- 如果你使用 JDK，推荐使用 JDK 11.0.16 及更高版本或 JDK 15 及更高版本， 以便[完全支持 cgroup v2](https://bugs.openjdk.org/browse/JDK-8230305)。
- 如果你正在使用 [uber-go/automaxprocs](https://github.com/uber-go/automaxprocs) 包， 确保你使用的版本是 v1.5.1 或者更高。

#### 识别 Linux 节点上的 cgroup 版本[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#check-cgroup-version)

cgroup 版本取决于正在使用的 Linux 发行版和操作系统上配置的默认 cgroup 版本。 要检查你的发行版使用的是哪个 cgroup 版本，请在该节点上运行 `stat -fc %T /sys/fs/cgroup/` 命令：

```shell
stat -fc %T /sys/fs/cgroup/
```

对于 cgroup v2，输出为 `cgroup2fs`。

对于 cgroup v1，输出为 `tmpfs`。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cgroups/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解 [cgroups](https://man7.org/linux/man-pages/man7/cgroups.7.html)
- 进一步了解[容器运行时](https://kubernetes.io/zh-cn/docs/concepts/architecture/cri)
- 进一步了解 [cgroup 驱动](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes#cgroup-drivers)
### [容器运行时接口（CRI）](https://kubernetes.io/zh-cn/docs/concepts/architecture/cri/)
CRI 是一个插件接口，它使 kubelet 能够使用各种容器运行时，无需重新编译集群组件。

你需要在集群中的每个节点上都有一个可以正常工作的[容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)， 这样 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 能启动 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 及其容器。

容器运行时接口（CRI）是 kubelet 和容器运行时之间通信的主要协议。

Kubernetes 容器运行时接口（Container Runtime Interface；CRI）定义了主要 [gRPC](https://grpc.io/) 协议， 用于[集群组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#node-components) [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 和 [容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)之间的通信。

#### API[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cri/#api)

**特性状态：** `Kubernetes v1.23 [stable]`

当通过 gRPC 连接到容器运行时，kubelet 将充当客户端。运行时和镜像服务端点必须在容器运行时中可用， 可以使用 `--image-service-endpoint` 和 `--container-runtime-endpoint` [命令行标志](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet)在 kubelet 中单独配置。

对 Kubernetes v1.26，kubelet 偏向于使用 CRI `v1` 版本。 如果容器运行时不支持 CRI 的 `v1` 版本，那么 kubelet 会尝试协商较老的、仍被支持的所有版本。 v1.26 版本的 kubelet 也可协商 CRI `v1alpha2` 版本，但该版本被视为已弃用。 如果 kubelet 无法协商出可支持的 CRI 版本，则 kubelet 放弃并且不会注册为节点。

#### 升级[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cri/#upgrading)

升级 Kubernetes 时，kubelet 会尝试在组件重启时自动选择最新的 CRI 版本。 如果失败，则将如上所述进行回退。如果由于容器运行时已升级而需要 gRPC 重拨， 则容器运行时还必须支持最初选择的版本，否则重拨预计会失败。 这需要重新启动 kubelet。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/cri/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解更多有关 CRI [协议定义](https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto)
### [垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/)
垃圾收集（Garbage Collection）是 Kubernetes 用于清理集群资源的各种机制的统称。 垃圾收集允许系统清理如下资源：

- [终止的 Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)
- [已完成的 Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/)
- [不再存在属主引用的对象](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#owners-dependents)
- [未使用的容器和容器镜像](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#containers-images)
- [动态制备的、StorageClass 回收策略为 Delete 的 PV 卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#delete)
- [阻滞或者过期的 CertificateSigningRequest (CSR)](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process)
- 在以下情形中删除了的[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)对象：
    - 当集群使用[云控制器管理器](https://kubernetes.io/zh-cn/docs/concepts/architecture/cloud-controller/)运行于云端时；
    - 当集群使用类似于云控制器管理器的插件运行在本地环境中时。
- [节点租约对象](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#heartbeats)

#### 属主与依赖[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#owners-dependents)

Kubernetes 中很多对象通过[**属主引用**](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/) 链接到彼此。属主引用（Owner Reference）可以告诉控制面哪些对象依赖于其他对象。 Kubernetes 使用属主引用来为控制面以及其他 API 客户端在删除某对象时提供一个清理关联资源的机会。 在大多数场合，Kubernetes 都是自动管理属主引用的。

属主关系与某些资源所使用的[标签和选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)不同。 例如，考虑一个创建 `EndpointSlice` 对象的 [Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)。 Service 使用**标签**来允许控制面确定哪些 `EndpointSlice` 对象被该 Service 使用。 除了标签，每个被 Service 托管的 `EndpointSlice` 对象还有一个属主引用属性。 属主引用可以帮助 Kubernetes 中的不同组件避免干预并非由它们控制的对象。

**说明：**

根据设计，系统不允许出现跨名字空间的属主引用。名字空间作用域的依赖对象可以指定集群作用域或者名字空间作用域的属主。 名字空间作用域的属主**必须**存在于依赖对象所在的同一名字空间。 如果属主位于不同名字空间，则属主引用被视为不存在，而当检查发现所有属主都已不存在时，依赖对象会被删除。

集群作用域的依赖对象只能指定集群作用域的属主。 在 1.20 及更高版本中，如果一个集群作用域的依赖对象指定了某个名字空间作用域的类别作为其属主， 则该对象被视为拥有一个无法解析的属主引用，因而无法被垃圾收集处理。

在 1.20 及更高版本中，如果垃圾收集器检测到非法的跨名字空间 `ownerReference`， 或者某集群作用域的依赖对象的 `ownerReference` 引用某名字空间作用域的类别， 系统会生成一个警告事件，其原因为 `OwnerRefInvalidNamespace`，`involvedObject` 设置为非法的依赖对象。你可以通过运行 `kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace` 来检查是否存在这类事件。

#### 级联删除[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#cascading-deletion)

Kubernetes 会检查并删除那些不再拥有属主引用的对象，例如在你删除了 ReplicaSet 之后留下来的 Pod。当你删除某个对象时，你可以控制 Kubernetes 是否去自动删除该对象的依赖对象， 这个过程称为 **级联删除（Cascading Deletion）**。 级联删除有两种类型，分别如下：

- 前台级联删除
- 后台级联删除

你也可以使用 Kubernetes [Finalizers](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/) 来控制垃圾收集机制如何以及何时删除包含属主引用的资源。

##### 前台级联删除[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#foreground-deletion)

在前台级联删除中，正在被你删除的属主对象首先进入 **deletion in progress** 状态。 在这种状态下，针对属主对象会发生以下事情：

- Kubernetes API 服务器将某对象的 `metadata.deletionTimestamp` 字段设置为该对象被标记为要删除的时间点。
- Kubernetes API 服务器也会将 `metadata.finalizers` 字段设置为 `foregroundDeletion`。
- 在删除过程完成之前，通过 Kubernetes API 仍然可以看到该对象。

当属主对象进入删除过程中状态后，控制器删除其依赖对象。控制器在删除完所有依赖对象之后， 删除属主对象。这时，通过 Kubernetes API 就无法再看到该对象。

在前台级联删除过程中，唯一可能阻止属主对象被删除的是那些带有 `ownerReference.blockOwnerDeletion=true` 字段的依赖对象。 参阅[使用前台级联删除](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion) 以了解进一步的细节。

##### 后台级联删除[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#background-deletion)

在后台级联删除过程中，Kubernetes 服务器立即删除属主对象，控制器在后台清理所有依赖对象。 默认情况下，Kubernetes 使用后台级联删除方案，除非你手动设置了要使用前台删除， 或者选择遗弃依赖对象。

参阅[使用后台级联删除](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion) 以了解进一步的细节。

##### 被遗弃的依赖对象[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#orphaned-dependents)

当 Kubernetes 删除某个属主对象时，被留下来的依赖对象被称作被遗弃的（Orphaned）对象。 默认情况下，Kubernetes 会删除依赖对象。要了解如何重载这种默认行为，可参阅 [删除属主对象和遗弃依赖对象](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy)。

#### 未使用容器和镜像的垃圾收集[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#containers-images)

[kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 会每五分钟对未使用的镜像执行一次垃圾收集， 每分钟对未使用的容器执行一次垃圾收集。 你应该避免使用外部的垃圾收集工具，因为外部工具可能会破坏 kubelet 的行为，移除应该保留的容器。

要配置对未使用容器和镜像的垃圾收集选项，可以使用一个 [配置文件](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/kubelet-config-file/)，基于 [`KubeletConfiguration`](https://kubernetes.io/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration) 资源类型来调整与垃圾收集相关的 kubelet 行为。

##### 容器镜像生命周期[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#container-image-lifecycle)

Kubernetes 通过其**镜像管理器（Image Manager）** 来管理所有镜像的生命周期， 该管理器是 kubelet 的一部分，工作时与 [cadvisor](https://github.com/google/cadvisor/) 协同。 kubelet 在作出垃圾收集决定时会考虑如下磁盘用量约束：

- `HighThresholdPercent`
- `LowThresholdPercent`

磁盘用量超出所配置的 `HighThresholdPercent` 值时会触发垃圾收集， 垃圾收集器会基于镜像上次被使用的时间来按顺序删除它们，首先删除的是最近未使用的镜像。 kubelet 会持续删除镜像，直到磁盘用量到达 `LowThresholdPercent` 值为止。

##### 容器垃圾收集[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection)

kubelet 会基于如下变量对所有未使用的容器执行垃圾收集操作，这些变量都是你可以定义的：

- `MinAge`：kubelet 可以垃圾回收某个容器时该容器的最小年龄。设置为 `0` 表示禁止使用此规则。
- `MaxPerPodContainer`：每个 Pod 可以包含的已死亡的容器个数上限。设置为小于 `0` 的值表示禁止使用此规则。
- `MaxContainers`：集群中可以存在的已死亡的容器个数上限。设置为小于 `0` 的值意味着禁止应用此规则。

除以上变量之外，kubelet 还会垃圾收集除无标识的以及已删除的容器，通常从最近未使用的容器开始。

当保持每个 Pod 的最大数量的容器（`MaxPerPodContainer`）会使得全局的已死亡容器个数超出上限 （`MaxContainers`）时，`MaxPerPodContainers` 和 `MaxContainers` 之间可能会出现冲突。 在这种情况下，kubelet 会调整 `MaxPerPodContainer` 来解决这一冲突。 最坏的情形是将 `MaxPerPodContainer` 降格为 `1`，并驱逐最近未使用的容器。 此外，当隶属于某已被删除的 Pod 的容器的年龄超过 `MinAge` 时，它们也会被删除。

**说明：**

kubelet 仅会回收由它所管理的容器。

#### 配置垃圾收集[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#configuring-gc)

你可以通过配置特定于管理资源的控制器来调整资源的垃圾收集行为。 下面的页面为你展示如何配置垃圾收集：

- [配置 Kubernetes 对象的级联删除](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/use-cascading-deletion/)
- [配置已完成 Job 的清理](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/)

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解 [Kubernetes 对象的属主关系](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/)。
- 进一步了解 Kubernetes [finalizers](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/)。
- 进一步了解 [TTL 控制器](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/) (Beta)， 该控制器负责清理已完成的 Job。


## 容器

打包应用及其运行依赖环境的技术。

每个运行的容器都是可重复的； 包含依赖环境在内的标准，意味着无论你在哪里运行它都会得到相同的行为。

容器将应用程序从底层的主机设施中解耦。 这使得在不同的云或 OS 环境中部署更加容易。

Kubernetes 集群中的每个[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)都会运行容器， 这些容器构成分配给该节点的 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)。 单个 Pod 中的容器会在共同调度下，于同一位置运行在相同的节点上。

### 容器镜像[](https://kubernetes.io/zh-cn/docs/concepts/containers/#container-images)

[容器镜像](https://kubernetes.io/zh-cn/docs/concepts/containers/images/)是一个随时可以运行的软件包， 包含运行应用程序所需的一切：代码和它需要的所有运行时、应用程序和系统库，以及一些基本设置的默认值。

容器旨在设计成无状态且[不可变的](https://glossary.cncf.io/immutable-infrastructure/)： 你不应更改已经运行的容器的代码。如果有一个容器化的应用程序需要修改， 正确的流程是：先构建包含更改的新镜像，再基于新构建的镜像重新运行容器。

### 容器运行时[](https://kubernetes.io/zh-cn/docs/concepts/containers/#container-runtimes)

容器运行环境是负责运行容器的软件。

Kubernetes 支持许多容器运行环境，例如 [containerd](https://containerd.io/docs/)、 [CRI-O](https://cri-o.io/#what-is-cri-o) 以及 [Kubernetes CRI (容器运行环境接口)](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md) 的其他任何实现。

通常，你可以允许集群为一个 Pod 选择其默认的容器运行时。如果你需要在集群中使用多个容器运行时， 你可以为一个 Pod 指定 [RuntimeClass](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/)， 以确保 Kubernetes 会使用特定的容器运行时来运行这些容器。

你还可以通过 RuntimeClass，使用相同的容器运行时，但使用不同设定的配置来运行不同的 Pod。

---

### 镜像

容器镜像（Image）所承载的是封装了应用程序及其所有软件依赖的二进制数据。 容器镜像是可执行的软件包，可以单独运行；该软件包对所处的运行时环境具有良定（Well Defined）的假定。

你通常会创建应用的容器镜像并将其推送到某仓库（Registry），然后在 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 中引用它。

本页概要介绍容器镜像的概念。

**说明：**

如果你正在寻找 Kubernetes 某个发行版本（如最新次要版本 v1.26） 的容器镜像，请访问[下载 Kubernetes](https://kubernetes.io/zh-cn/releases/download/)。

#### 镜像名称[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#image-names)

容器镜像通常会被赋予 `pause`、`example/mycontainer` 或者 `kube-apiserver` 这类的名称。 镜像名称也可以包含所在仓库的主机名。例如：`fictional.registry.example/imagename`。 还可以包含仓库的端口号，例如：`fictional.registry.example:10443/imagename`。

如果你不指定仓库的主机名，Kubernetes 认为你在使用 Docker 公共仓库。

在镜像名称之后，你可以添加一个**标签（Tag）**（与使用 `docker` 或 `podman` 等命令时的方式相同）。 使用标签能让你辨识同一镜像序列中的不同版本。

镜像标签可以包含小写字母、大写字母、数字、下划线（`_`）、句点（`.`）和连字符（`-`）。 关于在镜像标签中何处可以使用分隔字符（`_`、`-` 和 `.`）还有一些额外的规则。 如果你不指定标签，Kubernetes 认为你想使用标签 `latest`。

#### 更新镜像[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#updating-images)

当你最初创建一个 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)、 [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/)、Pod 或者其他包含 Pod 模板的对象时，如果没有显式设定的话， Pod 中所有容器的默认镜像拉取策略是 `IfNotPresent`。这一策略会使得 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 在镜像已经存在的情况下直接略过拉取镜像的操作。

##### 镜像拉取策略[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#image-pull-policy)

容器的 `imagePullPolicy` 和镜像的标签会影响 [kubelet](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/) 尝试拉取（下载）指定的镜像。

以下列表包含了 `imagePullPolicy` 可以设置的值，以及这些值的效果：

`IfNotPresent`

只有当镜像在本地不存在时才会拉取。

`Always`

每当 kubelet 启动一个容器时，kubelet 会查询容器的镜像仓库， 将名称解析为一个镜像[摘要](https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier)。 如果 kubelet 有一个容器镜像，并且对应的摘要已在本地缓存，kubelet 就会使用其缓存的镜像； 否则，kubelet 就会使用解析后的摘要拉取镜像，并使用该镜像来启动容器。

`Never`

Kubelet 不会尝试获取镜像。如果镜像已经以某种方式存在本地， kubelet 会尝试启动容器；否则，会启动失败。 更多细节见[提前拉取镜像](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#pre-pulled-images)。

只要能够可靠地访问镜像仓库，底层镜像提供者的缓存语义甚至可以使 `imagePullPolicy: Always` 高效。 你的容器运行时可以注意到节点上已经存在的镜像层，这样就不需要再次下载。

**说明：**

在生产环境中部署容器时，你应该避免使用 `:latest` 标签，因为这使得正在运行的镜像的版本难以追踪，并且难以正确地回滚。

相反，应指定一个有意义的标签，如 `v1.42.0`。

为了确保 Pod 总是使用相同版本的容器镜像，你可以指定镜像的摘要； 将 `<image-name>:<tag>` 替换为 `<image-name>@<digest>`，例如 `image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2`。

当使用镜像标签时，如果镜像仓库修改了代码所对应的镜像标签，可能会出现新旧代码混杂在 Pod 中运行的情况。 镜像摘要唯一标识了镜像的特定版本，因此 Kubernetes 每次启动具有指定镜像名称和摘要的容器时，都会运行相同的代码。 通过摘要指定镜像可固定你运行的代码，这样镜像仓库的变化就不会导致版本的混杂。

有一些第三方的[准入控制器](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/) 在创建 Pod（和 Pod 模板）时产生变更，这样运行的工作负载就是根据镜像摘要，而不是标签来定义的。 无论镜像仓库上的标签发生什么变化，你都想确保你所有的工作负载都运行相同的代码，那么指定镜像摘要会很有用。

###### 默认镜像拉取策略[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#imagepullpolicy-defaulting)

当你（或控制器）向 API 服务器提交一个新的 Pod 时，你的集群会在满足特定条件时设置 `imagePullPolicy` 字段：

- 如果你省略了 `imagePullPolicy` 字段，并且容器镜像的标签是 `:latest`， `imagePullPolicy` 会自动设置为 `Always`。
- 如果你省略了 `imagePullPolicy` 字段，并且没有指定容器镜像的标签， `imagePullPolicy` 会自动设置为 `Always`。
- 如果你省略了 `imagePullPolicy` 字段，并且为容器镜像指定了非 `:latest` 的标签， `imagePullPolicy` 就会自动设置为 `IfNotPresent`。

**说明：**

容器的 `imagePullPolicy` 的值总是在对象初次 _创建_ 时设置的，如果后来镜像的标签发生变化，则不会更新。

例如，如果你用一个 **非** `:latest` 的镜像标签创建一个 Deployment， 并在随后更新该 Deployment 的镜像标签为 `:latest`，则 `imagePullPolicy` 字段 **不会** 变成 `Always`。 你必须手动更改已经创建的资源的拉取策略。

###### 必要的镜像拉取[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#required-image-pull)

如果你想总是强制执行拉取，你可以使用下述的一中方式：

- 设置容器的 `imagePullPolicy` 为 `Always`。
- 省略 `imagePullPolicy`，并使用 `:latest` 作为镜像标签； 当你提交 Pod 时，Kubernetes 会将策略设置为 `Always`。
- 省略 `imagePullPolicy` 和镜像的标签； 当你提交 Pod 时，Kubernetes 会将策略设置为 `Always`。
- 启用准入控制器 [AlwaysPullImages](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages)。

##### ImagePullBackOff[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#imagepullbackoff)

当 kubelet 使用容器运行时创建 Pod 时，容器可能因为 `ImagePullBackOff` 导致状态为 [Waiting](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting)。

`ImagePullBackOff` 状态意味着容器无法启动， 因为 Kubernetes 无法拉取容器镜像（原因包括无效的镜像名称，或从私有仓库拉取而没有 `imagePullSecret`）。 `BackOff` 部分表示 Kubernetes 将继续尝试拉取镜像，并增加回退延迟。

Kubernetes 会增加每次尝试之间的延迟，直到达到编译限制，即 300 秒（5 分钟）。

#### 带镜像索引的多架构镜像[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#multi-architecture-images-with-image-indexes)

除了提供二进制的镜像之外， 容器仓库也可以提供[容器镜像索引](https://github.com/opencontainers/image-spec/blob/master/image-index.md)。 镜像索引可以指向镜像的多个[镜像清单](https://github.com/opencontainers/image-spec/blob/master/manifest.md)， 提供特定于体系结构版本的容器。 这背后的理念是让你可以为镜像命名（例如：`pause`、`example/mycontainer`、`kube-apiserver`） 的同时，允许不同的系统基于它们所使用的机器体系结构取回正确的二进制镜像。

Kubernetes 自身通常在命名容器镜像时添加后缀 `-$(ARCH)`。 为了向前兼容，请在生成较老的镜像时也提供后缀。 这里的理念是为某镜像（如 `pause`）生成针对所有平台都适用的清单时， 生成 `pause-amd64` 这类镜像，以便较老的配置文件或者将镜像后缀硬编码到其中的 YAML 文件也能兼容。

#### 使用私有仓库[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#using-a-private-registry)

从私有仓库读取镜像时可能需要密钥。 凭据可以用以下方式提供:

- 配置节点向私有仓库进行身份验证
    - 所有 Pod 均可读取任何已配置的私有仓库
    - 需要集群管理员配置节点
- kubelet 凭据提供程序，动态获取私有仓库的凭据
    - kubelet 可以被配置为使用凭据提供程序 exec 插件来访问对应的私有镜像库
- 预拉镜像
    - 所有 Pod 都可以使用节点上缓存的所有镜像
    - 需要所有节点的 root 访问权限才能进行设置
- 在 Pod 中设置 ImagePullSecrets
    - 只有提供自己密钥的 Pod 才能访问私有仓库
- 特定于厂商的扩展或者本地扩展
    - 如果你在使用定制的节点配置，你（或者云平台提供商）可以实现让节点向容器仓库认证的机制

下面将详细描述每一项。

##### 配置 Node 对私有仓库认证[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#configuring-nodes-to-authenticate-to-a-private-registry)

设置凭据的具体说明取决于你选择使用的容器运行时和仓库。 你应该参考解决方案的文档来获取最准确的信息。

有关配置私有容器镜像仓库的示例， 请参阅任务[从私有镜像库中拉取镜像](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry)。 该示例使用 Docker Hub 中的私有镜像仓库。

**说明：**

此方法尤其适合 kubelet 需要动态获取仓库凭据时。 最常用于由云提供商提供的仓库，其中身份认证令牌的生命期是短暂的。

你可以配置 kubelet，以调用插件可执行文件的方式来动态获取容器镜像的仓库凭据。 这是为私有仓库获取凭据最稳健和最通用的方法，但也需要 kubelet 级别的配置才能启用。

有关更多细节请参见[配置 kubelet 镜像凭据提供程序](https://kubernetes.io/docs/tasks/administer-cluster/kubelet-credential-provider/)。

##### config.json 说明[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#config-json)

对于 `config.json` 的解释在原始 Docker 实现和 Kubernetes 的解释之间有所不同。 在 Docker 中，`auths` 键只能指定根 URL，而 Kubernetes 允许 glob URLs 以及前缀匹配的路径。 这意味着，像这样的 `config.json` 是有效的：

```json
{
    "auths": {
        "*my-registry.io/images": {
            "auth": "…"
        }
    }
}
```

使用以下语法匹配根 URL （`*my-registry.io`）：

```
pattern:
    { term }

term:
    '*'         匹配任何无分隔符字符序列
    '?'         匹配任意单个非分隔符
    '[' [ '^' ] 字符范围
                  字符集（必须非空）
    c           匹配字符 c （c 不为 '*', '?', '\\', '['）
    '\\' c      匹配字符 c

字符范围: 
    c           匹配字符 c （c 不为 '\\', '?', '-', ']'）
    '\\' c      匹配字符 c
    lo '-' hi   匹配字符范围在 lo 到 hi 之间字符
```

现在镜像拉取操作会将每种有效模式的凭据都传递给 CRI 容器运行时。例如下面的容器镜像名称会匹配成功：

- `my-registry.io/images`
- `my-registry.io/images/my-image`
- `my-registry.io/images/another-image`
- `sub.my-registry.io/images/my-image`
- `a.sub.my-registry.io/images/my-image`

kubelet 为每个找到的凭据的镜像按顺序拉取。这意味着在 `config.json` 中可能有多项：

```json
{
    "auths": {
        "my-registry.io/images": {
            "auth": "…"
        },
        "my-registry.io/images/subpath": {
            "auth": "…"
        }
    }
}
```

如果一个容器指定了要拉取的镜像 `my-registry.io/images/subpath/my-image`， 并且其中一个失败，kubelet 将尝试从另一个身份验证源下载镜像。

##### 提前拉取镜像[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#pre-pulled-images)

**说明：**

该方法适用于你能够控制节点配置的场合。 如果你的云供应商负责管理节点并自动置换节点，这一方案无法可靠地工作。

默认情况下，`kubelet` 会尝试从指定的仓库拉取每个镜像。 但是，如果容器属性 `imagePullPolicy` 设置为 `IfNotPresent` 或者 `Never`， 则会优先使用（对应 `IfNotPresent`）或者一定使用（对应 `Never`）本地镜像。

如果你希望使用提前拉取镜像的方法代替仓库认证，就必须保证集群中所有节点提前拉取的镜像是相同的。

这一方案可以用来提前载入指定的镜像以提高速度，或者作为向私有仓库执行身份认证的一种替代方案。

所有的 Pod 都可以使用节点上提前拉取的镜像。

##### 在 Pod 上指定 ImagePullSecrets[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod)

**说明：**

运行使用私有仓库中镜像的容器时，建议使用这种方法。

Kubernetes 支持在 Pod 中设置容器镜像仓库的密钥。 `imagePullSecrets` 必须全部与 Pod 位于同一个名字空间中。 引用的 Secret 必须是 `kubernetes.io/dockercfg` 或 `kubernetes.io/dockerconfigjson` 类型。

###### 使用 Docker Config 创建 Secret[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#creating-a-secret-with-docker-config)

你需要知道用于向仓库进行身份验证的用户名、密码和客户端电子邮件地址，以及它的主机名。 运行以下命令，注意替换适当的大写值：

```shell
kubectl create secret docker-registry <name> \
  --docker-server=DOCKER_REGISTRY_SERVER \
  --docker-username=DOCKER_USER \
  --docker-password=DOCKER_PASSWORD \
  --docker-email=DOCKER_EMAIL
```

如果你已经有 Docker 凭据文件，则可以将凭据文件导入为 Kubernetes [Secret](https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/)， 而不是执行上面的命令。 [基于已有的 Docker 凭据创建 Secret](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials) 解释了如何完成这一操作。

如果你在使用多个私有容器仓库，这种技术将特别有用。 原因是 `kubectl create secret docker-registry` 创建的是仅适用于某个私有仓库的 Secret。

**说明：**

Pod 只能引用位于自身所在名字空间中的 Secret，因此需要针对每个名字空间重复执行上述过程。

###### 在 Pod 中引用 ImagePullSecrets[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#referring-to-an-imagepullsecrets-on-a-pod)

现在，在创建 Pod 时，可以在 Pod 定义中增加 `imagePullSecrets` 部分来引用该 Secret。 `imagePullSecrets` 数组中的每一项只能引用同一名字空间中的 Secret。

例如：

```shell
cat <<EOF > pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: foo
  namespace: awesomeapps
spec:
  containers:
    - name: foo
      image: janedoe/awesomeapp:v1
  imagePullSecrets:
    - name: myregistrykey
EOF

cat <<EOF >> ./kustomization.yaml
resources:
- pod.yaml
EOF
```

你需要对使用私有仓库的每个 Pod 执行以上操作。不过， 设置该字段的过程也可以通过为[服务账号](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/)资源设置 `imagePullSecrets` 来自动完成。 有关详细指令， 可参见[将 ImagePullSecrets 添加到服务账号](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account)。

你也可以将此方法与节点级别的 `.docker/config.json` 配置结合使用。 来自不同来源的凭据会被合并。

#### 使用案例[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#use-cases)

配置私有仓库有多种方案，以下是一些常用场景和建议的解决方案。

1. 集群运行非专有镜像（例如，开源镜像）。镜像不需要隐藏。
    - 使用来自公共仓库的公共镜像
        - 无需配置
        - 某些云厂商会自动为公开镜像提供高速缓存，以便提升可用性并缩短拉取镜像所需时间

2. 集群运行一些专有镜像，这些镜像需要对公司外部隐藏，对所有集群用户可见
    - 使用托管的私有仓库
        - 在需要访问私有仓库的节点上可能需要手动配置
    - 或者，在防火墙内运行一个组织内部的私有仓库，并开放读取权限
        - 不需要配置 Kubernetes
    - 使用控制镜像访问的托管容器镜像仓库服务
        - 与手动配置节点相比，这种方案能更好地处理集群自动扩缩容
    - 或者，在不方便更改节点配置的集群中，使用 `imagePullSecrets`

3. 集群使用专有镜像，且有些镜像需要更严格的访问控制
    - 确保 [AlwaysPullImages 准入控制器](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages)被启用。否则，所有 Pod 都可以使用所有镜像。
    - 确保将敏感数据存储在 Secret 资源中，而不是将其打包在镜像里

4. 集群是多租户的并且每个租户需要自己的私有仓库
    - 确保 [AlwaysPullImages 准入控制器](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages)。否则，所有租户的所有的 Pod 都可以使用所有镜像。
    - 为私有仓库启用鉴权
    - 为每个租户生成访问仓库的凭据，放置在 Secret 中，并将 Secret 发布到各租户的名字空间下。
    - 租户将 Secret 添加到每个名字空间中的 imagePullSecrets

如果你需要访问多个仓库，可以为每个仓库创建一个 Secret。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/containers/images/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读 [OCI Image Manifest 规范](https://github.com/opencontainers/image-spec/blob/master/manifest.md)。
- 了解[容器镜像垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#container-image-garbage-collection)。
- 了解[从私有仓库拉取镜像](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry)。
### [容器环境](https://kubernetes.io/zh-cn/docs/concepts/containers/container-environment/)
本页描述了在容器环境里容器可用的资源。

#### 容器环境[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-environment/#container-environment)

Kubernetes 的容器环境给容器提供了几个重要的资源：

- 文件系统，其中包含一个[镜像](https://kubernetes.io/zh-cn/docs/concepts/containers/images/) 和一个或多个的[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)
- 容器自身的信息
- 集群中其他对象的信息

##### 容器信息[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-environment/#%E5%AE%B9%E5%99%A8%E4%BF%A1%E6%81%AF)

一个容器的 **hostname** 是该容器运行所在的 Pod 的名称。通过 `hostname` 命令或者调用 libc 中的 [`gethostname`](https://man7.org/linux/man-pages/man2/gethostname.2.html) 函数可以获取该名称。

Pod 名称和命名空间可以通过 [下行 API](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/) 转换为环境变量。

Pod 定义中的用户所定义的环境变量也可在容器中使用，就像在 container 镜像中静态指定的任何环境变量一样。

##### 集群信息[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-environment/#%E9%9B%86%E7%BE%A4%E4%BF%A1%E6%81%AF)

创建容器时正在运行的所有服务都可用作该容器的环境变量。 这里的服务仅限于新容器的 Pod 所在的名字空间中的服务，以及 Kubernetes 控制面的服务。

对于名为 **foo** 的服务，当映射到名为 **bar** 的容器时，定义了以下变量：

```shell
FOO_SERVICE_HOST=<其上服务正运行的主机>
FOO_SERVICE_PORT=<其上服务正运行的端口>
```

服务具有专用的 IP 地址。如果启用了 [DNS 插件](https://releases.k8s.io/v1.26.0/cluster/addons/dns/)， 可以在容器中通过 DNS 来访问服务。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-environment/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 学习更多有关[容器生命周期回调](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/)的知识。
- 动手[为容器的生命周期事件设置处理函数](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/)。

### 容器运行时类（Runtime Class）

**特性状态：** `Kubernetes v1.20 [stable]`

本页面描述了 RuntimeClass 资源和运行时的选择机制。

RuntimeClass 是一个用于选择容器运行时配置的特性，容器运行时配置用于运行 Pod 中的容器。

#### 动机[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#motivation)

你可以在不同的 Pod 设置不同的 RuntimeClass，以提供性能与安全性之间的平衡。 例如，如果你的部分工作负载需要高级别的信息安全保证，你可以决定在调度这些 Pod 时尽量使它们在使用硬件虚拟化的容器运行时中运行。 这样，你将从这些不同运行时所提供的额外隔离中获益，代价是一些额外的开销。

你还可以使用 RuntimeClass 运行具有相同容器运行时但具有不同设置的 Pod。

#### 设置[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#setup)

1. 在节点上配置 CRI 的实现（取决于所选用的运行时）
2. 创建相应的 RuntimeClass 资源

##### 1\. 在节点上配置 CRI 实现[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#1-%E5%9C%A8%E8%8A%82%E7%82%B9%E4%B8%8A%E9%85%8D%E7%BD%AE-cri-%E5%AE%9E%E7%8E%B0)

RuntimeClass 的配置依赖于运行时接口（CRI）的实现。 根据你使用的 CRI 实现，查阅相关的文档（[下方](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#cri-configuration)）来了解如何配置。

**说明：**

RuntimeClass 假设集群中的节点配置是同构的（换言之，所有的节点在容器运行时方面的配置是相同的）。 如果需要支持异构节点，配置方法请参阅下面的[调度](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#scheduling)。

所有这些配置都具有相应的 `handler` 名，并被 RuntimeClass 引用。 handler 必须是有效的 [DNS 标签名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-label-names)。

##### 2\. 创建相应的 RuntimeClass 资源[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#2-%E5%88%9B%E5%BB%BA%E7%9B%B8%E5%BA%94%E7%9A%84-runtimeclass-%E8%B5%84%E6%BA%90)

在上面步骤 1 中，每个配置都需要有一个用于标识配置的 `handler`。 针对每个 handler 需要创建一个 RuntimeClass 对象。

RuntimeClass 资源当前只有两个重要的字段：RuntimeClass 名 (`metadata.name`) 和 handler (`handler`)。 对象定义如下所示：

```yaml
# RuntimeClass 定义于 node.k8s.io API 组
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  # 用来引用 RuntimeClass 的名字
  # RuntimeClass 是一个集群层面的资源
  name: myclass
# 对应的 CRI 配置的名称
handler: myconfiguration
```

RuntimeClass 对象的名称必须是有效的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)。

**说明：**

建议将 RuntimeClass 写操作（create、update、patch 和 delete）限定于集群管理员使用。 通常这是默认配置。参阅[授权概述](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authorization/)了解更多信息。

#### 使用说明[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#usage)

一旦完成集群中 RuntimeClasses 的配置， 你可以在 Pod spec 中指定 `runtimeClassName` 来使用它。例如:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  runtimeClassName: myclass
  # ...
```

这一设置会告诉 kubelet 使用所指的 RuntimeClass 来运行该 Pod。 如果所指的 RuntimeClass 不存在或者 CRI 无法运行相应的 handler， 那么 Pod 将会进入 `Failed` 终止[阶段](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)。 你可以查看相应的[事件](https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/)， 获取执行过程中的错误信息。

如果未指定 `runtimeClassName`，则将使用默认的 RuntimeHandler，相当于禁用 RuntimeClass 功能特性。

##### CRI 配置[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#cri-configuration)

关于如何安装 CRI 运行时，请查阅 [CRI 安装](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/)。

###### [containerd](https://containerd.io/docs/)[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#hahahugoshortcode-s3-hbhb)

通过 containerd 的 `/etc/containerd/config.toml` 配置文件来配置运行时 handler。 handler 需要配置在 runtimes 块中：

```
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.${HANDLER_NAME}]
```

更详细信息，请查阅 containerd 的[配置指南](https://github.com/containerd/containerd/blob/main/docs/cri/config.md)

###### [CRI-O](https://cri-o.io/#what-is-cri-o)[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#hahahugoshortcode-s4-hbhb)

通过 CRI-O 的 `/etc/crio/crio.conf` 配置文件来配置运行时 handler。 handler 需要配置在 [crio.runtime 表](https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table)之下：

```
[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = "${PATH_TO_BINARY}"
```

更详细信息，请查阅 CRI-O [配置文档](https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md)。

#### 调度[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#scheduling)

**特性状态：** `Kubernetes v1.16 [beta]`

通过为 RuntimeClass 指定 `scheduling` 字段， 你可以通过设置约束，确保运行该 RuntimeClass 的 Pod 被调度到支持该 RuntimeClass 的节点上。 如果未设置 `scheduling`，则假定所有节点均支持此 RuntimeClass。

为了确保 pod 会被调度到支持指定运行时的 node 上，每个 node 需要设置一个通用的 label 用于被 `runtimeclass.scheduling.nodeSelector` 挑选。在 admission 阶段，RuntimeClass 的 nodeSelector 将会与 Pod 的 nodeSelector 合并，取二者的交集。如果有冲突，Pod 将会被拒绝。

如果 node 需要阻止某些需要特定 RuntimeClass 的 Pod，可以在 `tolerations` 中指定。 与 `nodeSelector` 一样，tolerations 也在 admission 阶段与 Pod 的 tolerations 合并，取二者的并集。

更多有关 node selector 和 tolerations 的配置信息，请查阅 [将 Pod 分派到节点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/)。

##### Pod 开销[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#pod-overhead)

**特性状态：** `Kubernetes v1.24 [stable]`

你可以指定与运行 Pod 相关的**开销**资源。声明开销即允许集群（包括调度器）在决策 Pod 和资源时将其考虑在内。

Pod 开销通过 RuntimeClass 的 `overhead` 字段定义。 通过使用这个字段，你可以指定使用该 RuntimeClass 运行 Pod 时的开销并确保 Kubernetes 将这些开销计算在内。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- [RuntimeClass 设计](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md)
- [RuntimeClass 调度设计](https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling)
- 阅读关于 [Pod 开销](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-overhead/)的概念
- [PodOverhead 特性设计](https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead)

### [容器生命周期回调](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/)
这个页面描述了 kubelet 管理的容器如何使用容器生命周期回调框架， 藉由其管理生命周期中的事件触发，运行指定代码。

#### 概述[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#%E6%A6%82%E8%BF%B0)

类似于许多具有生命周期回调组件的编程语言框架，例如 Angular、Kubernetes 为容器提供了生命周期回调。 回调使容器能够了解其管理生命周期中的事件，并在执行相应的生命周期回调时运行在处理程序中实现的代码。

#### 容器回调[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#container-hooks)

有两个回调暴露给容器：

`PostStart`

这个回调在容器被创建之后立即被执行。 但是，不能保证回调会在容器入口点（ENTRYPOINT）之前执行。 没有参数传递给处理程序。

`PreStop`

在容器因 API 请求或者管理事件（诸如存活态探针、启动探针失败、资源抢占、资源竞争等） 而被终止之前，此回调会被调用。 如果容器已经处于已终止或者已完成状态，则对 preStop 回调的调用将失败。 在用来停止容器的 TERM 信号被发出之前，回调必须执行结束。 Pod 的终止宽限周期在 `PreStop` 回调被执行之前即开始计数， 所以无论回调函数的执行结果如何，容器最终都会在 Pod 的终止宽限期内被终止。 没有参数会被传递给处理程序。

有关终止行为的更详细描述，请参见 [终止 Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)。

##### 回调处理程序的实现[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#%E5%9B%9E%E8%B0%83%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0)

容器可以通过实现和注册该回调的处理程序来访问该回调。 针对容器，有两种类型的回调处理程序可供实现：

- Exec - 在容器的 cgroups 和名字空间中执行特定的命令（例如 `pre-stop.sh`）。 命令所消耗的资源计入容器的资源消耗。
- HTTP - 对容器上的特定端点执行 HTTP 请求。

##### 回调处理程序执行[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#%E5%9B%9E%E8%B0%83%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C)

当调用容器生命周期管理回调时，Kubernetes 管理系统根据回调动作执行其处理程序， `httpGet` 和 `tcpSocket` 在 kubelet 进程执行，而 `exec` 则由容器内执行。

回调处理程序调用在包含容器的 Pod 上下文中是同步的。 这意味着对于 `PostStart` 回调，容器入口点和回调异步触发。 但是，如果回调运行或挂起的时间太长，则容器无法达到 `running` 状态。

`PreStop` 回调并不会与停止容器的信号处理程序异步执行；回调必须在可以发送信号之前完成执行。 如果 `PreStop` 回调在执行期间停滞不前，Pod 的阶段会变成 `Terminating`并且一直处于该状态， 直到其 `terminationGracePeriodSeconds` 耗尽为止，这时 Pod 会被杀死。 这一宽限期是针对 `PreStop` 回调的执行时间及容器正常停止时间的总和而言的。 例如，如果 `terminationGracePeriodSeconds` 是 60，回调函数花了 55 秒钟完成执行， 而容器在收到信号之后花了 10 秒钟来正常结束，那么容器会在其能够正常结束之前即被杀死， 因为 `terminationGracePeriodSeconds` 的值小于后面两件事情所花费的总时间（55+10）。

如果 `PostStart` 或 `PreStop` 回调失败，它会杀死容器。

用户应该使他们的回调处理程序尽可能的轻量级。 但也需要考虑长时间运行的命令也很有用的情况，比如在停止容器之前保存状态。

##### 回调递送保证[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#%E5%9B%9E%E8%B0%83%E9%80%92%E9%80%81%E4%BF%9D%E8%AF%81)

回调的递送应该是**至少一次**，这意味着对于任何给定的事件， 例如 `PostStart` 或 `PreStop`，回调可以被调用多次。 如何正确处理被多次调用的情况，是回调实现所要考虑的问题。

通常情况下，只会进行单次递送。 例如，如果 HTTP 回调接收器宕机，无法接收流量，则不会尝试重新发送。 然而，偶尔也会发生重复递送的可能。 例如，如果 kubelet 在发送回调的过程中重新启动，回调可能会在 kubelet 恢复后重新发送。

##### 调试回调处理程序[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#%E8%B0%83%E8%AF%95%E5%9B%9E%E8%B0%83%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F)

回调处理程序的日志不会在 Pod 事件中公开。 如果处理程序由于某种原因失败，它将播放一个事件。 对于 `PostStart`，这是 `FailedPostStartHook` 事件，对于 `PreStop`，这是 `FailedPreStopHook` 事件。 要自己生成失败的 `FailedPostStartHook` 事件，请修改 [lifecycle-events.yaml](https://raw.githubusercontent.com/kubernetes/website/main/content/en/examples/pods/lifecycle-events.yaml) 文件将 postStart 命令更改为 “badcommand” 并应用它。 以下是通过运行 `kubectl describe pod lifecycle-demo` 后你看到的一些结果事件的示例输出：

```
Events:
  Type     Reason               Age              From               Message
  ----     ------               ----             ----               -------
  Normal   Scheduled            7s               default-scheduler  Successfully assigned default/lifecycle-demo to ip-XXX-XXX-XX-XX.us-east-2...
  Normal   Pulled               6s               kubelet            Successfully pulled image "nginx" in 229.604315ms
  Normal   Pulling              4s (x2 over 6s)  kubelet            Pulling image "nginx"
  Normal   Created              4s (x2 over 5s)  kubelet            Created container lifecycle-demo-container
  Normal   Started              4s (x2 over 5s)  kubelet            Started container lifecycle-demo-container
  Warning  FailedPostStartHook  4s (x2 over 5s)  kubelet            Exec lifecycle hook ([badcommand]) for Container "lifecycle-demo-container" in Pod "lifecycle-demo_default(30229739-9651-4e5a-9a32-a8f1688862db)" failed - error: command 'badcommand' exited with 126: , message: "OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: \"badcommand\": executable file not found in $PATH: unknown\r\n"
  Normal   Killing              4s (x2 over 5s)  kubelet            FailedPostStartHook
  Normal   Pulled               4s               kubelet            Successfully pulled image "nginx" in 215.66395ms
  Warning  BackOff              2s (x2 over 3s)  kubelet            Back-off restarting failed container
```

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解[容器环境](https://kubernetes.io/zh-cn/docs/concepts/containers/container-environment/)。
- 动手[为容器的生命周期事件设置处理函数](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/)。


## Kubernetes 中的 Windows

---

### [Kubernetes 中的 Windows 容器](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/)
在许多组织中，所运行的很大一部分服务和应用是 Windows 应用。 [Windows 容器](https://aka.ms/windowscontainers)提供了一种封装进程和包依赖项的方式， 从而简化了 DevOps 实践，令 Windows 应用程序同样遵从云原生模式。

对于同时投入基于 Windows 应用和 Linux 应用的组织而言，他们不必寻找不同的编排系统来管理其工作负载， 使其跨部署的运营效率得以大幅提升，而不必关心所用的操作系统。

#### Kubernetes 中的 Windows 节点[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#windows-nodes-in-k8s)

若要在 Kubernetes 中启用对 Windows 容器的编排，可以在现有的 Linux 集群中包含 Windows 节点。 在 Kubernetes 上调度 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 中的 Windows 容器与调度基于 Linux 的容器类似。

为了运行 Windows 容器，你的 Kubernetes 集群必须包含多个操作系统。 尽管你只能在 Linux 上运行[控制平面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)， 你可以部署运行 Windows 或 Linux 的工作节点。

支持 Windows [节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)的前提是操作系统为 Windows Server 2019。

本文使用术语 **Windows 容器**表示具有进程隔离能力的 Windows 容器。 Kubernetes 不支持使用 [Hyper-V 隔离能力](https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/manage-containers/hyperv-container)来运行 Windows 容器。

#### 兼容性与局限性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#limitations)

某些节点层面的功能特性仅在使用特定[容器运行时](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#container-runtime)时才可用； 另外一些特性则在 Windows 节点上不可用，包括：

- 巨页（HugePages）：Windows 容器当前不支持。
- 特权容器：Windows 容器当前不支持。 [HostProcess 容器](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/create-hostprocess-pod/)提供类似功能。
- TerminationGracePeriod：需要 containerD。

Windows 节点并不支持共享命名空间的所有功能特性。 有关更多详细信息，请参考 [API 兼容性](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#api)。

有关 Kubernetes 测试时所使用的 Windows 版本的详细信息，请参考 [Windows 操作系统版本兼容性](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#windows-os-version-support)。

从 API 和 kubectl 的角度来看，Windows 容器的行为与基于 Linux 的容器非常相似。 然而，在本节所概述的一些关键功能上，二者存在一些显著差异。

##### 与 Linux 比较[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#comparison-with-Linux-similarities)

Kubernetes 关键组件在 Windows 上的工作方式与在 Linux 上相同。 本节介绍几个关键的工作负载抽象及其如何映射到 Windows。

- [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)
    
    Pod 是 Kubernetes 的基本构建块，是可以创建或部署的最小和最简单的单元。 你不可以在同一个 Pod 中部署 Windows 和 Linux 容器。 Pod 中的所有容器都调度到同一 Node 上，每个 Node 代表一个特定的平台和体系结构。 Windows 容器支持以下 Pod 能力、属性和事件：
    
    - 每个 Pod 有一个或多个容器，具有进程隔离和卷共享能力
    - Pod `status` 字段
    - 就绪、存活和启动探针
    - postStart 和 preStop 容器生命周期回调
    - ConfigMap 和 Secret：作为环境变量或卷
    - `emptyDir` 卷
    - 命名管道形式的主机挂载
    - 资源限制
    
    - 操作系统字段：
    
    `.spec.os.name` 字段应设置为 `windows` 以表明当前 Pod 使用 Windows 容器。
    
    **说明：**
    
    ```
    从 1.25 开始，`IdentifyPodOS` 特性门控进入 GA 阶段，默认启用。
    ```
    
    ```
    如果你将 `.spec.os.name` 字段设置为 `windows`，
    ```
    
    则你必须不能在对应 Pod 的 `.spec` 中设置以下字段：
    
    - `spec.hostPID`
    - `spec.hostIPC`
    - `spec.securityContext.seLinuxOptions`
    - `spec.securityContext.seccompProfile`
    - `spec.securityContext.fsGroup`
    - `spec.securityContext.fsGroupChangePolicy`
    - `spec.securityContext.sysctls`
    - `spec.shareProcessNamespace`
    - `spec.securityContext.runAsUser`
    - `spec.securityContext.runAsGroup`
    - `spec.securityContext.supplementalGroups`
    - `spec.containers[*].securityContext.seLinuxOptions`
    - `spec.containers[*].securityContext.seccompProfile`
    - `spec.containers[*].securityContext.capabilities`
    - `spec.containers[*].securityContext.readOnlyRootFilesystem`
    - `spec.containers[*].securityContext.privileged`
    - `spec.containers[*].securityContext.allowPrivilegeEscalation`
    - `spec.containers[*].securityContext.procMount`
    - `spec.containers[*].securityContext.runAsUser`
    - `spec.containers[*].securityContext.runAsGroup`
    
    ```
    在上述列表中，通配符（`*`）表示列表中的所有项。
    ```
    
    例如，`spec.containers[*].securityContext` 指代所有容器的 SecurityContext 对象。 如果指定了这些字段中的任意一个，则 API 服务器不会接受此 Pod。
    

- [工作负载资源](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/)包括：
    
    - ReplicaSet
    - Deployment
    - StatefulSet
    - DaemonSet
    - Job
    - CronJob
    - ReplicationController
- [Services](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)
    
    有关更多详细信息，请参考[负载均衡和 Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#load-balancing-and-services)。
    

Pod、工作负载资源和 Service 是在 Kubernetes 上管理 Windows 工作负载的关键元素。 然而，它们本身还不足以在动态的云原生环境中对 Windows 工作负载进行恰当的生命周期管理。

- `kubectl exec`
- Pod 和容器度量指标
- [Pod 水平自动扩缩容](https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/)
- [资源配额](https://kubernetes.io/zh-cn/docs/concepts/policy/resource-quotas/)
- 调度器抢占

##### kubelet 的命令行选项[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#kubelet-compatibility)

某些 kubelet 命令行选项在 Windows 上的行为不同，如下所述：

- `--windows-priorityclass` 允许你设置 kubelet 进程的调度优先级 （参考 [CPU 资源管理](https://kubernetes.io/zh-cn/docs/concepts/configuration/windows-resource-management/#resource-management-cpu)）。
- `--kube-reserved`、`--system-reserved` 和 `--eviction-hard` 标志更新 [NodeAllocatable](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable)。
- 未实现使用 `--enforce-node-allocable` 驱逐。
- 未实现使用 `--eviction-hard` 和 `--eviction-soft` 驱逐。
- 在 Windows 节点上运行时，kubelet 没有内存或 CPU 限制。 `--kube-reserved` 和 `--system-reserved` 仅从 `NodeAllocatable` 中减去，并且不保证为工作负载提供的资源。 有关更多信息，请参考 [Windows 节点的资源管理](https://kubernetes.io/zh-cn/docs/concepts/configuration/windows-resource-management/#resource-reservation)。
- 未实现 `MemoryPressure` 条件。
- kubelet 不会执行 OOM 驱逐操作。

##### API 兼容性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#api)

由于操作系统和容器运行时的缘故，Kubernetes API 在 Windows 上的工作方式存在细微差异。 某些工作负载属性是为 Linux 设计的，无法在 Windows 上运行。

从较高的层面来看，以下操作系统概念是不同的：

- 身份 - Linux 使用 userID（UID）和 groupID（GID），表示为整数类型。 用户名和组名是不规范的，它们只是 `/etc/groups` 或 `/etc/passwd` 中的别名， 作为 UID+GID 的后备标识。 Windows 使用更大的二进制[安全标识符](https://docs.microsoft.com/zh-cn/windows/security/identity-protection/access-control/security-identifiers)（SID）， 存放在 Windows 安全访问管理器（Security Access Manager，SAM）数据库中。 此数据库在主机和容器之间或容器之间不共享。
- 文件权限 - Windows 使用基于 SID 的访问控制列表， 而像 Linux 使用基于对象权限和 UID+GID 的位掩码（POSIX 系统）以及**可选的**访问控制列表。
- 文件路径 - Windows 上的约定是使用 `\` 而不是 `/`。 Go IO 库通常接受两者，能让其正常工作，但当你设置要在容器内解读的路径或命令行时， 可能需要用 `\`。

- 信号 - Windows 交互式应用处理终止的方式不同，可以实现以下一种或多种：
    - UI 线程处理包括 `WM_CLOSE` 在内准确定义的消息。
    - 控制台应用使用控制处理程序（Control Handler）处理 Ctrl-C 或 Ctrl-Break。
    - 服务会注册可接受 `SERVICE_CONTROL_STOP` 控制码的服务控制处理程序（Service Control Handler）函数。

容器退出码遵循相同的约定，其中 0 表示成功，非零表示失败。 具体的错误码在 Windows 和 Linux 中可能不同。 但是，从 Kubernetes 组件（kubelet、kube-proxy）传递的退出码保持不变。

###### 容器规约的字段兼容性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#compatibility-v1-pod-spec-containers)

以下列表记录了 Pod 容器规约在 Windows 和 Linux 之间的工作方式差异：

- 巨页（Huge page）在 Windows 容器运行时中未实现，且不可用。 巨页需要不可为容器配置的[用户特权生效](https://docs.microsoft.com/zh-cn/windows/win32/memory/large-page-support)。
- `requests.cpu` 和 `requests.memory` - 从节点可用资源中减去请求，因此请求可用于避免一个节点过量供应。 但是，请求不能用于保证已过量供应的节点中的资源。 如果运营商想要完全避免过量供应，则应将设置请求作为最佳实践应用到所有容器。

- `securityContext.allowPrivilegeEscalation` - 不能在 Windows 上使用；所有权能字都无法生效。
- `securityContext.capabilities` - POSIX 权能未在 Windows 上实现。
- `securityContext.privileged` - Windows 不支持特权容器， 可使用 [HostProcess 容器](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/create-hostprocess-pod/)代替。
- `securityContext.procMount` - Windows 没有 `/proc` 文件系统。
- `securityContext.readOnlyRootFilesystem` - 不能在 Windows 上使用；对于容器内运行的注册表和系统进程，写入权限是必需的。
- `securityContext.runAsGroup` - 不能在 Windows 上使用，因为不支持 GID。

- `securityContext.runAsNonRoot` - 此设置将阻止以 `ContainerAdministrator` 身份运行容器，这是 Windows 上与 root 用户最接近的身份。
- `securityContext.runAsUser` - 改用 [`runAsUserName`](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-runasusername)。
- `securityContext.seLinuxOptions` - 不能在 Windows 上使用，因为 SELinux 特定于 Linux。
- `terminationMessagePath` - 这个字段有一些限制，因为 Windows 不支持映射单个文件。 默认值为 `/dev/termination-log`，因为默认情况下它在 Windows 上不存在，所以能生效。

###### Pod 规约的字段兼容性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#compatibility-v1-pod)

以下列表记录了 Pod 规约在 Windows 和 Linux 之间的工作方式差异：

- `hostIPC` 和 `hostpid` - 不能在 Windows 上共享主机命名空间。
- `hostNetwork` - [参见下文](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#compatibility-v1-pod-spec-containers-hostnetwork)
- `dnsPolicy` - Windows 不支持将 Pod `dnsPolicy` 设为 `ClusterFirstWithHostNet`， 因为未提供主机网络。Pod 始终用容器网络运行。
- `podSecurityContext` [参见下文](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#compatibility-v1-pod-spec-containers-securitycontext)
- `shareProcessNamespace` - 这是一个 beta 版功能特性，依赖于 Windows 上未实现的 Linux 命名空间。 Windows 无法共享进程命名空间或容器的根文件系统（root filesystem）。 只能共享网络。

- `terminationGracePeriodSeconds` - 这在 Windows 上的 Docker 中没有完全实现， 请参考 [GitHub issue](https://github.com/moby/moby/issues/25982)。 目前的行为是通过 CTRL\_SHUTDOWN\_EVENT 发送 ENTRYPOINT 进程，然后 Windows 默认等待 5 秒， 最后使用正常的 Windows 关机行为终止所有进程。 5 秒默认值实际上位于[容器内](https://github.com/moby/moby/issues/25982#issuecomment-426441183)的 Windows 注册表中， 因此在构建容器时可以覆盖这个值。
- `volumeDevices` - 这是一个 beta 版功能特性，未在 Windows 上实现。 Windows 无法将原始块设备挂接到 Pod。
- `volumes`
    - 如果你定义一个 `emptyDir` 卷，则你无法将卷源设为 `memory`。
- 你无法为卷挂载启用 `mountPropagation`，因为这在 Windows 上不支持。

###### hostNetwork 的字段兼容性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#compatibility-v1-pod-spec-containers-hostnetwork)

**特性状态：** `Kubernetes v1.26 [alpha]`

现在，kubelet 可以请求在 Windows 节点上运行的 Pod 使用主机的网络命名空间，而不是创建新的 Pod 网络命名空间。 要启用此功能，请将 `--feature-gates=WindowsHostNetwork=true` 传递给 kubelet。

**说明：**

此功能需要支持该功能的容器运行时。

###### Pod 安全上下文的字段兼容性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#compatibility-v1-pod-spec-containers-securitycontext)

Pod 的 [`securityContext`](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context) 中只有 `securityContext.runAsNonRoot` 和 `securityContext.windowsOptions` 字段在 Windows 上生效。

#### 节点问题检测器[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#node-problem-detector)

节点问题检测器（参考[节点健康监测](https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/monitor-node-health/)）初步支持 Windows。 有关更多信息，请访问该项目的 [GitHub 页面](https://github.com/kubernetes/node-problem-detector#windows)。

#### Pause 容器[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#pause-container)

在 Kubernetes Pod 中，首先创建一个基础容器或 “pause” 容器来承载容器。 在 Linux 中，构成 Pod 的 cgroup 和命名空间维持持续存在需要一个进程； 而 pause 进程就提供了这个功能。 属于同一 Pod 的容器（包括基础容器和工作容器）共享一个公共网络端点 （相同的 IPv4 和/或 IPv6 地址，相同的网络端口空间）。 Kubernetes 使用 pause 容器以允许工作容器崩溃或重启，而不会丢失任何网络配置。

Kubernetes 维护一个多体系结构的镜像，包括对 Windows 的支持。 对于 Kubernetes v1.26，推荐的 pause 镜像为 `registry.k8s.io/pause:3.6`。 可在 GitHub 上获得[源代码](https://github.com/kubernetes/kubernetes/tree/master/build/pause)。

Microsoft 维护一个不同的多体系结构镜像，支持 Linux 和 Windows amd64， 你可以找到的镜像类似 `mcr.microsoft.com/oss/kubernetes/pause:3.6`。 此镜像的构建与 Kubernetes 维护的镜像同源，但所有 Windows 可执行文件均由 Microsoft 进行了[验证码签名](https://docs.microsoft.com/zh-cn/windows-hardware/drivers/install/authenticode)。 如果你正部署到一个需要签名可执行文件的生产或类生产环境， Kubernetes 项目建议使用 Microsoft 维护的镜像。

#### 容器运行时[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#container-runtime)

你需要将[容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)安装到集群中的每个节点， 这样 Pod 才能在这些节点上运行。

以下容器运行时适用于 Windows：

**说明：** 本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循[CNCF 网站指南](https://github.com/cncf/foundation/blob/master/website-guidelines.md)，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读[内容指南](https://kubernetes.io/docs/contribute/style/content-guide/#third-party-content)。

##### ContainerD[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#containerd)

**特性状态：** `Kubernetes v1.20 [stable]`

对于运行 Windows 的 Kubernetes 节点，你可以使用 [ContainerD](https://containerd.io/docs/) 1.4.0+ 作为容器运行时。

学习如何[在 Windows 上安装 ContainerD](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/#install-containerd)。

**说明：**

将 GMSA 和 containerd 一起用于访问 Windows 网络共享时存在[已知限制](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-gmsa/#gmsa-limitations)， 这需要一个内核补丁。

##### Mirantis 容器运行时[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#mcr)

[Mirantis 容器运行时](https://docs.mirantis.com/mcr/20.10/overview.html)（MCR） 可作为所有 Windows Server 2019 和更高版本的容器运行时。

有关更多信息，请参考[在 Windows Server 上安装 MCR](https://docs.mirantis.com/mcr/20.10/install/mcr-windows.html)。

#### Windows 操作系统版本兼容性[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#windows-os-version-support)

在 Windows 节点上，如果主机操作系统版本必须与容器基础镜像操作系统版本匹配， 则会应用严格的兼容性规则。 仅 Windows Server 2019 作为容器操作系统时，才能完全支持 Windows 容器。

对于 Kubernetes v1.26，Windows 节点（和 Pod）的操作系统兼容性如下：

Windows Server LTSC release

Windows Server 2019

Windows Server 2022

Windows Server SAC release

Windows Server version 20H2

也适用 Kubernetes [版本偏差策略](https://kubernetes.io/zh-cn/releases/version-skew-policy/)。

#### 获取帮助和故障排查[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#troubleshooting)

对 Kubernetes 集群进行故障排查的主要帮助来源应始于[故障排查](https://kubernetes.io/zh-cn/docs/tasks/debug/)页面。

本节包括了一些其他特定于 Windows 的故障排查帮助。 日志是解决 Kubernetes 中问题的重要元素。 确保在任何时候向其他贡献者寻求故障排查协助时随附了日志信息。 遵照 SIG Windows [日志收集贡献指南](https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#gathering-logs)中的指示说明。

##### 报告问题和功能请求[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#report-issue-and-feature-request)

如果你发现疑似 bug，或者你想提出功能请求，请按照 [SIG Windows 贡献指南](https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md#reporting-issues-and-feature-requests) 新建一个 Issue。 你应该先搜索 issue 列表，以防之前报告过这个问题，凭你对该问题的经验添加评论， 并随附日志信息。 Kubernetes Slack 上的 SIG Windows 频道也是一个很好的途径， 可以在创建工单之前获得一些初始支持和故障排查思路。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

#### 部署工具[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#deployment-tools)

kubeadm 工具帮助你部署 Kubernetes 集群，提供管理集群的控制平面以及运行工作负载的节点。

Kubernetes [集群 API](https://cluster-api.sigs.k8s.io/) 项目也提供了自动部署 Windows 节点的方式。

#### Windows 分发渠道[](https://kubernetes.io/zh-cn/docs/concepts/windows/intro/#windows-distribution-channels)

有关 Windows 分发渠道的详细阐述，请参考 [Microsoft 文档](https://docs.microsoft.com/zh-cn/windows-server/get-started-19/servicing-channels-19)。

有关支持模型在内的不同 Windows Server 服务渠道的信息，请参考 [Windows Server 服务渠道](https://docs.microsoft.com/zh-cn/windows-server/get-started/servicing-channels-comparison)。

### [Kubernetes 中的 Windows 容器调度指南](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/)
在许多组织中运行的服务和应用程序中，Windows 应用程序构成了很大一部分。 本指南将引导你完成在 Kubernetes 中配置和部署 Windows 容器的步骤。

#### 目标[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#objectives)

- 配置 Deployment 样例以在 Windows 节点上运行 Windows 容器
- 在 Kubernetes 中突出 Windows 特定的功能

#### 在你开始之前[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#before-you-begin)

- 创建一个 Kubernetes 集群，其中包含一个控制平面和一个运行 Windows Server 的工作节点。
- 务必请注意，在 Kubernetes 上创建和部署服务和工作负载的行为方式与 Linux 和 Windows 容器的行为方式大致相同。 与集群交互的 [kubectl 命令](https://kubernetes.io/zh-cn/docs/reference/kubectl/)是一致的。 下一小节的示例旨在帮助你快速开始使用 Windows 容器。

#### 快速开始：部署 Windows 容器[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#getting-started-deploying-a-windows-container)

以下示例 YAML 文件部署了一个在 Windows 容器内运行的简单 Web 服务器的应用程序。

创建一个名为 `win-webserver.yaml` 的 Service 规约，其内容如下：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: win-webserver
  labels:
    app: win-webserver
spec:
  ports:
    # 此 Service 服务的端口
    - port: 80
      targetPort: 80
  selector:
    app: win-webserver
  type: NodePort
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: win-webserver
  name: win-webserver
spec:
  replicas: 2
  selector:
    matchLabels:
      app: win-webserver
  template:
    metadata:
      labels:
        app: win-webserver
      name: win-webserver
    spec:
     containers:
      - name: windowswebserver
        image: mcr.microsoft.com/windows/servercore:ltsc2019
        command:
        - powershell.exe
        - -command
        - "<#code used from https://gist.github.com/19WAS85/5424431#> ; $$listener = New-Object System.Net.HttpListener ; $$listener.Prefixes.Add('http://*:80/') ; $$listener.Start() ; $$callerCounts = @{} ; Write-Host('Listening at http://*:80/') ; while ($$listener.IsListening) { ;$$context = $$listener.GetContext() ;$$requestUrl = $$context.Request.Url ;$$clientIP = $$context.Request.RemoteEndPoint.Address ;$$response = $$context.Response ;Write-Host '' ;Write-Host('> {0}' -f $$requestUrl) ;  ;$$count = 1 ;$$k=$$callerCounts.Get_Item($$clientIP) ;if ($$k -ne $$null) { $$count += $$k } ;$$callerCounts.Set_Item($$clientIP, $$count) ;$$ip=(Get-NetAdapter | Get-NetIpAddress); $$header='<html><body><H1>Windows Container Web Server</H1>' ;$$callerCountsString='' ;$$callerCounts.Keys | % { $$callerCountsString+='<p>IP {0} callerCount {1} ' -f $$ip[1].IPAddress,$$callerCounts.Item($$_) } ;$$footer='</body></html>' ;$$content='{0}{1}{2}' -f $$header,$$callerCountsString,$$footer ;Write-Output $$content ;$$buffer = [System.Text.Encoding]::UTF8.GetBytes($$content) ;$$response.ContentLength64 = $$buffer.Length ;$$response.OutputStream.Write($$buffer, 0, $$buffer.Length) ;$$response.Close() ;$$responseStatus = $$response.StatusCode ;Write-Host('< {0}' -f $$responseStatus)  } ; "
     nodeSelector:
      kubernetes.io/os: windows
```

**说明：**

端口映射也是支持的，但为简单起见，此示例将容器的端口 80 直接暴露给服务。

1. 检查所有节点是否健康
    
    ```bash
    kubectl get nodes
    ```
    

1. 部署 Service 并监视 Pod 更新：
    
    ```bash
    kubectl apply -f win-webserver.yaml
    kubectl get pods -o wide -w
    ```
    
    当 Service 被正确部署时，两个 Pod 都被标记为就绪（Ready）。要退出 watch 命令，请按 Ctrl+C。
    

1. 检查部署是否成功。请验证：
    
    - 当执行 `kubectl get pods` 命令时，能够从 Linux 控制平面所在的节点上列出两个 Pod。
    - 跨网络的节点到 Pod 通信，从 Linux 控制平面所在的节点上执行 `curl` 命令来访问 Pod IP 的 80 端口以检查 Web 服务器响应。
    - Pod 间通信，使用 `docker exec` 或 `kubectl exec` 命令进入容器，并在 Pod 之间（以及跨主机，如果你有多个 Windows 节点）相互进行 ping 操作。
    - Service 到 Pod 的通信，在 Linux 控制平面所在的节点以及独立的 Pod 中执行 `curl` 命令来访问虚拟的服务 IP（在 `kubectl get services` 命令下查看）。
    - 服务发现，执行 `curl` 命令来访问带有 Kubernetes [默认 DNS 后缀](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#services)的服务名称。
    - 入站连接，在 Linux 控制平面所在的节点上或集群外的机器上执行 `curl` 命令来访问 NodePort 服务。
    - 出站连接，使用 `kubectl exec`，从 Pod 内部执行 `curl` 访问外部 IP。

**说明：**

由于当前 Windows 平台的网络堆栈限制，Windows 容器主机无法访问调度到其上的 Service 的 IP。 只有 Windows Pod 能够访问 Service IP。

#### 可观察性[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#observability)

##### 捕捉来自工作负载的日志[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#capturing-logs-from-workloads)

日志是可观察性的重要元素；它们使用户能够深入了解工作负载的运行情况，并且是解决问题的关键因素。 由于 Windows 容器和 Windows 容器中的工作负载与 Linux 容器的行为不同，因此用户很难收集日志，从而限制了操作可见性。 例如，Windows 工作负载通常配置为记录到 ETW（Windows 事件跟踪）或向应用程序事件日志推送条目。 [LogMonitor](https://github.com/microsoft/windows-container-tools/tree/master/LogMonitor) 是一个微软开源的工具，是监视 Windows 容器内所配置的日志源的推荐方法。 LogMonitor 支持监视事件日志、ETW 提供程序和自定义应用程序日志，将它们传送到 STDOUT 以供 `kubectl logs <pod>` 使用。

按照 LogMonitor GitHub 页面中的说明，将其二进制文件和配置文件复制到所有容器， 并为 LogMonitor 添加必要的入口点以将日志推送到标准输出（STDOUT）。

#### 配置容器用户[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#configuring-container-user)

##### 使用可配置的容器用户名[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#using-configurable-container-usernames)

Windows 容器可以配置为使用不同于镜像默认值的用户名来运行其入口点和进程。 [在这里](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-runasusername/)了解更多信息。

##### 使用组托管服务帐户（GMSA）管理工作负载身份[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#managing-workload-identity-with-group-managed-service-accounts)

Windows 容器工作负载可以配置为使用组托管服务帐户（Group Managed Service Accounts，GMSA）。 组托管服务帐户是一种特定类型的活动目录（Active Directory）帐户，可提供自动密码管理、 简化的服务主体名称（Service Principal Name，SPN）管理，以及将管理委派给多个服务器上的其他管理员的能力。 配置了 GMSA 的容器可以携带使用 GMSA 配置的身份访问外部活动目录域资源。 在[此处](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-gmsa/)了解有关为 Windows 容器配置和使用 GMSA 的更多信息。

#### 污点和容忍度[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#taints-and-tolerations)

用户需要使用某种污点（Taint）和节点选择器的组合，以便将 Linux 和 Windows 工作负载各自调度到特定操作系统的节点。 下面概述了推荐的方法，其主要目标之一是该方法不应破坏现有 Linux 工作负载的兼容性。

从 1.25 开始，你可以（并且应该）将每个 Pod 的 `.spec.os.name` 设置为 Pod 中的容器设计所用于的操作系统。 对于运行 Linux 容器的 Pod，将 `.spec.os.name` 设置为 `linux`。 对于运行 Windows 容器的 Pod，将 `.spec.os.name` 设置为 `windows`。

**说明：**

从 1.25 开始，`IdentifyPodOS` 特性处于 GA 阶段，默认启用。

调度器在将 Pod 分配到节点时并不使用 `.spec.os.name` 的值。 你应该使用正常的 Kubernetes 机制[将 Pod 分配给节点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/)， 以确保集群的控制平面将 Pod 放置到运行适当操作系统的节点上。

`.spec.os.name` 值对 Windows Pod 的调度没有影响， 因此仍然需要污点和容忍以及节点选择器来确保 Windows Pod 落在适当的 Windows 节点。

##### 确保特定于操作系统的工作负载落到合适的容器主机上[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#ensuring-os-specific-workloads-land-on-the-appropriate-container-host)

用户可以使用污点（Taint）和容忍度（Toleration）确保将 Windows 容器调度至合适的主机上。 现在，所有的 Kubernetes 节点都有以下默认标签：

- kubernetes.io/os = \[windows|linux\]
- kubernetes.io/arch = \[amd64|arm64|...\]

如果 Pod 规约没有指定像 `"kubernetes.io/os": windows` 这样的 nodeSelector， 则 Pod 可以被调度到任何主机上，Windows 或 Linux。 这可能会有问题，因为 Windows 容器只能在 Windows 上运行，而 Linux 容器只能在 Linux 上运行。 最佳实践是使用 nodeSelector。

但是，我们了解到，在许多情况下，用户已经预先存在大量 Linux 容器部署， 以及现成配置的生态系统，例如社区中的 Helm Chart 包和程序化的 Pod 生成案例，例如 Operator。 在这些情况下，你可能不愿更改配置来添加节点选择器。 另一种方法是使用污点。因为 kubelet 可以在注册过程中设置污点， 所以可以很容易地修改为，当只能在 Windows 上运行时，自动添加污点。

例如：`--register-with-taints='os=windows:NoSchedule'`

通过向所有 Windows 节点添加污点，任何负载都不会被调度到这些节点上（包括现有的 Linux Pod）。 为了在 Windows 节点上调度 Windows Pod，它需要 nodeSelector 和匹配合适的容忍度来选择 Windows。

```yaml
nodeSelector:
    kubernetes.io/os: windows
    node.kubernetes.io/windows-build: '10.0.17763'
tolerations:
    - key: "os"
      operator: "Equal"
      value: "windows"
      effect: "NoSchedule"
```

##### 处理同一集群中的多个 Windows 版本[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#handling-multiple-windows-versions-in-the-same-cluster)

每个 Pod 使用的 Windows Server 版本必须与节点的版本匹配。 如果要在同一个集群中使用多个 Windows Server 版本，则应设置额外的节点标签和节点选择器。

Kubernetes 1.17 自动添加了一个新标签 `node.kubernetes.io/windows-build` 来简化这一点。 如果你运行的是旧版本，则建议手动将此标签添加到 Windows 节点。

此标签反映了需要匹配以实现兼容性的 Windows 主要、次要和内部版本号。 以下是目前用于每个 Windows Server 版本的值。

| 产品名称 | 构建号 |
| --- | --- |
| Windows Server 2019 | 10.0.17763 |
| Windows Server, Version 20H2 | 10.0.19042 |
| Windows Server 2022 | 10.0.20348 |

##### 使用 RuntimeClass 进行简化[](https://kubernetes.io/zh-cn/docs/concepts/windows/user-guide/#simplifying-with-runtimeclass)

[RuntimeClass](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/) 可用于简化使用污点和容忍度的流程。 集群管理员可以创建一个用于封装这些污点和容忍度的 `RuntimeClass` 对象。

1. 将此文件保存到 `runtimeClasses.yml`。它包括针对 Windows 操作系统、架构和版本的 `nodeSelector`。

```yaml
apiVersion: node.k8s.io/v1
kind: RuntimeClass
metadata:
  name: windows-2019
handler: 'docker'
scheduling:
  nodeSelector:
    kubernetes.io/os: 'windows'
    kubernetes.io/arch: 'amd64'
    node.kubernetes.io/windows-build: '10.0.17763'
  tolerations:
  - effect: NoSchedule
    key: os
    operator: Equal
    value: "windows"
```

1. 以集群管理员身份运行 `kubectl create -f runtimeClasses.yml`
2. 根据情况，向 Pod 规约中添加 `runtimeClassName: windows-2019`

例如：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: iis-2019
  labels:
    app: iis-2019
spec:
  replicas: 1
  template:
    metadata:
      name: iis-2019
      labels:
        app: iis-2019
    spec:
      runtimeClassName: windows-2019
      containers:
      - name: iis
        image: mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019
        resources:
          limits:
            cpu: 1
            memory: 800Mi
          requests:
            cpu: .1
            memory: 300Mi
        ports:
          - containerPort: 80
 selector:
    matchLabels:
      app: iis-2019
---
apiVersion: v1
kind: Service
metadata:
  name: iis
spec:
  type: LoadBalancer
  ports:
  - protocol: TCP
    port: 80
  selector:
    app: iis-2019
```

## 工作负载

理解 Pods，Kubernetes 中可部署的最小计算对象，以及辅助它运行它们的高层抽象对象。

工作负载是在 Kubernetes 上运行的应用程序。

在 Kubernetes 中，无论你的负载是由单个组件还是由多个一同工作的组件构成， 你都可以在一组 [**Pod**](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods) 中运行它。 在 Kubernetes 中，`Pod` 代表的是集群上处于运行状态的一组 [容器](https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers) 的集合。

Kubernetes Pod 遵循[预定义的生命周期](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/)。 例如，当在你的集群中运行了某个 Pod，但是 Pod 所在的 [节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/) 出现致命错误时， 所有该节点上的 Pod 的状态都会变成失败。Kubernetes 将这类失败视为最终状态： 即使该节点后来恢复正常运行，你也需要创建新的 `Pod` 以恢复应用。

不过，为了减轻用户的使用负担，通常不需要用户直接管理每个 `Pod`。 而是使用**负载资源**来替用户管理一组 Pod。 这些负载资源通过配置 [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 来确保正确类型的、处于运行状态的 Pod 个数是正确的，与用户所指定的状态相一致。

Kubernetes 提供若干种内置的工作负载资源：

- [`Deployment`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 和 [`ReplicaSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) （替换原来的资源 [ReplicationController](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-replication-controller)）。 `Deployment` 很适合用来管理你的集群上的无状态应用，`Deployment` 中的所有 `Pod` 都是相互等价的，并且在需要的时候被替换。
- [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 让你能够运行一个或者多个以某种方式跟踪应用状态的 Pod。 例如，如果你的负载会将数据作持久存储，你可以运行一个 `StatefulSet`，将每个 `Pod` 与某个 [`PersistentVolume`](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/) 对应起来。你在 `StatefulSet` 中各个 `Pod` 内运行的代码可以将数据复制到同一 `StatefulSet` 中的其它 `Pod` 中以提高整体的服务可靠性。

- [DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/) 定义提供节点本地支撑设施的 `Pod`。这些 Pod 可能对于你的集群的运维是 非常重要的，例如作为网络链接的辅助工具或者作为网络 [插件](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/) 的一部分等等。每次你向集群中添加一个新节点时，如果该节点与某 `DaemonSet` 的规约匹配，则控制平面会为该 `DaemonSet` 调度一个 `Pod` 到该新节点上运行。
- [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 和 [CronJob](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/)。 定义一些一直运行到结束并停止的任务。`Job` 用来执行一次性任务，而 `CronJob` 用来执行的根据时间规划反复运行的任务。

在庞大的 Kubernetes 生态系统中，你还可以找到一些提供额外操作的第三方工作负载相关的资源。 通过使用[定制资源定义（CRD）](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/)， 你可以添加第三方工作负载资源，以完成原本不是 Kubernetes 核心功能的工作。 例如，如果你希望运行一组 `Pod`，但要求**所有** Pod 都可用时才执行操作 （比如针对某种高吞吐量的分布式任务），你可以基于定制资源实现一个能够满足这一需求的扩展， 并将其安装到集群中运行。

### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

除了阅读了解每类资源外，你还可以了解与这些资源相关的任务：

- [使用 `Deployment` 运行一个无状态的应用](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/)
- 以[单实例](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-single-instance-stateful-application/)或者[多副本集合](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-replicated-stateful-application/) 的形式运行有状态的应用；
- [使用 `CronJob` 运行自动化的任务](https://kubernetes.io/zh-cn/docs/tasks/job/automated-tasks-with-cron-jobs/)

要了解 Kubernetes 将代码与配置分离的实现机制，可参阅[配置部分](https://kubernetes.io/zh-cn/docs/concepts/configuration/)。

关于 Kubernetes 如何为应用管理 Pod，还有两个支撑概念能够提供相关背景信息：

- [垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/)机制负责在 对象的**属主资源**被删除时在集群中清理这些对象。
- [**Time-to-Live** 控制器](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/)会在 Job 结束之后的指定时间间隔之后删除它们。

一旦你的应用处于运行状态，你就可能想要以 [`Service`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 的形式使之可在互联网上访问；或者对于 Web 应用而言，使用 [`Ingress`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress) 资源将其暴露到互联网上。

---

### [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/)
**Pod** 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。

**Pod**（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） [容器](https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers)； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。

除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 [Init 容器](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/)。 你也可以在集群支持[临时性容器](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/)的情况下， 为调试的目的注入临时性容器。

#### 什么是 Pod？[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#what-is-a-pod)

**说明：** 除了 Docker 之外，Kubernetes 支持很多其他[容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)， [Docker](https://www.docker.com/) 是最有名的运行时， 使用 Docker 的术语来描述 Pod 会很有帮助。

Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离[容器](https://kubernetes.io/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers)的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。

Pod 类似于共享名字空间并共享文件系统卷的一组容器。

#### 使用 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#using-pods)

下面是一个 Pod 示例，它由一个运行镜像 `nginx:1.14.2` 的容器组成。

[`pods/simple-pod.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/simple-pod.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy pods/simple-pod.yaml to clipboard")

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

要创建上面显示的 Pod，请运行以下命令：

```shell
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
```

Pod 通常不是直接创建的，而是使用工作负载资源创建的。 有关如何将 Pod 用于工作负载资源的更多信息，请参阅[使用 Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#working-with-pods)。

##### 用于管理 pod 的工作负载资源[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#workload-resources-for-managing-pods)

通常你不需要直接创建 Pod，甚至单实例 Pod。 相反，你会使用诸如 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 或 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 这类工作负载资源来创建 Pod。 如果 Pod 需要跟踪状态，可以考虑 [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 资源。

Kubernetes 集群中的 Pod 主要有两种用法：

- **运行单个容器的 Pod**。"每个 Pod 一个容器" 模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。
    
- **运行多个协同工作的容器的 Pod**。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众， 而另一个单独的 “边车”（sidecar）容器则刷新或更新这些文件。 Pod 将这些容器和存储资源打包为一个可管理的实体。
    
    **说明：**
    
    将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。 只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。
    

每个 Pod 都旨在运行给定应用程序的单个实例。如果希望横向扩展应用程序 （例如，运行多个实例以提供更多的资源），则应该使用多个 Pod，每个实例使用一个 Pod。 在 Kubernetes 中，这通常被称为**副本（Replication）**。 通常使用一种工作负载资源及其[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)来创建和管理一组 Pod 副本。

参见 [Pod 和控制器](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pods-and-controllers)以了解 Kubernetes 如何使用工作负载资源及其控制器以实现应用的扩缩和自动修复。

##### Pod 怎样管理多个容器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#how-pods-manage-multiple-containers)

Pod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。 Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身。

例如，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的 "边车 (sidercar)" 容器负责从远端更新这些文件，如下图所示：

![Pod 创建示意图](https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg)

有些 Pod 具有 [Init 容器](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-init-container)和 [应用容器](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-app-container)。 Init 容器会在启动应用容器之前运行并完成。

Pod 天生地为其成员容器提供了两种共享资源：[网络](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-networking)和[存储](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-storage)。

#### 使用 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#working-with-pods)

你很少在 Kubernetes 中直接创建一个个的 Pod，甚至是单实例（Singleton）的 Pod。 这是因为 Pod 被设计成了相对临时性的、用后即抛的一次性实体。 当 Pod 由你或者间接地由[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 创建时，它被调度在集群中的[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)上运行。 Pod 会保持在该节点上运行，直到 Pod 结束执行、Pod 对象被删除、Pod 因资源不足而被**驱逐**或者节点失效为止。

**说明：** 重启 Pod 中的容器不应与重启 Pod 混淆。 Pod 不是进程，而是容器运行的环境。 在被删除之前，Pod 会一直存在。

Pod 的名称必须是一个合法的 [DNS 子域](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)值， 但这可能对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规则。

##### Pod 操作系统[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-os)

**特性状态：** `Kubernetes v1.25 [stable]`

你应该将 `.spec.os.name` 字段设置为 `windows` 或 `linux` 以表示你希望 Pod 运行在哪个操作系统之上。 这两个是 Kubernetes 目前支持的操作系统。将来，这个列表可能会被扩充。

在 Kubernetes v1.26 中，为此字段设置的值对 Pod 的[调度](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/)没有影响。 设置 `. spec.os.name` 有助于确定性地标识 Pod 的操作系统并用于验证。 如果你指定的 Pod 操作系统与运行 kubelet 所在节点的操作系统不同， 那么 kubelet 将会拒绝运行该 Pod。 [Pod 安全标准](https://kubernetes.io/zh-cn/docs/concepts/security/pod-security-standards/)也使用这个字段来避免强制执行与该操作系统无关的策略。

##### Pod 和控制器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pods-and-controllers)

你可以使用工作负载资源来创建和管理多个 Pod。 资源的控制器能够处理副本的管理、上线，并在 Pod 失效时提供自愈能力。 例如，如果一个节点失败，控制器注意到该节点上的 Pod 已经停止工作， 就可以创建替换性的 Pod。调度器会将替身 Pod 调度到一个健康的节点执行。

下面是一些管理一个或者多个 Pod 的工作负载资源的示例：

- [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)
- [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/)
- [DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/)

##### Pod 模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)

[工作负载](https://kubernetes.io/zh-cn/docs/concepts/workloads/)资源的控制器通常使用 **Pod 模板（Pod Template）** 来替你创建 Pod 并管理它们。

Pod 模板是包含在工作负载对象中的规范，用来创建 Pod。这类负载资源包括 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)、 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 和 [DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/) 等。

工作负载的控制器会使用负载对象中的 `PodTemplate` 来生成实际的 Pod。 `PodTemplate` 是你用来运行应用时指定的负载资源的目标状态的一部分。

下面的示例是一个简单的 Job 的清单，其中的 `template` 指示启动一个容器。 该 Pod 中的容器会打印一条消息之后暂停。

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # 这里是 Pod 模板
    spec:
      containers:
      - name: hello
        image: busybox:1.28
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
    # 以上为 Pod 模板
```

修改 Pod 模板或者切换到新的 Pod 模板都不会对已经存在的 Pod 直接起作用。 如果改变工作负载资源的 Pod 模板，工作负载资源需要使用更新后的模板来创建 Pod， 并使用新创建的 Pod 替换旧的 Pod。

例如，StatefulSet 控制器针对每个 StatefulSet 对象确保运行中的 Pod 与当前的 Pod 模板匹配。如果编辑 StatefulSet 以更改其 Pod 模板， StatefulSet 将开始基于更新后的模板创建新的 Pod。

每个工作负载资源都实现了自己的规则，用来处理对 Pod 模板的更新。 如果你想了解更多关于 StatefulSet 的具体信息， 请阅读 StatefulSet 基础教程中的[更新策略](https://kubernetes.io/zh-cn/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets)。

在节点上，[kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 并不直接监测或管理与 Pod 模板相关的细节或模板的更新，这些细节都被抽象出来。 这种抽象和关注点分离简化了整个系统的语义， 并且使得用户可以在不改变现有代码的前提下就能扩展集群的行为。

#### Pod 更新与替换[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-update-and-replacement)

正如前面章节所述，当某工作负载的 Pod 模板被改变时， 控制器会基于更新的模板创建新的 Pod 对象而不是对现有 Pod 执行更新或者修补操作。

Kubernetes 并不禁止你直接管理 Pod。对运行中的 Pod 的某些字段执行就地更新操作还是可能的。不过，类似 [`patch`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#patch-pod-v1-core) 和 [`replace`](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#replace-pod-v1-core) 这类更新操作有一些限制：

- Pod 的绝大多数元数据都是不可变的。例如，你不可以改变其 `namespace`、`name`、 `uid` 或者 `creationTimestamp` 字段；`generation` 字段是比较特别的， 如果更新该字段，只能增加字段取值而不能减少。
    
- 如果 `metadata.deletionTimestamp` 已经被设置，则不可以向 `metadata.finalizers` 列表中添加新的条目。
    
- Pod 更新不可以改变除 `spec.containers[*].image`、`spec.initContainers[*].image`、 `spec.activeDeadlineSeconds` 或 `spec.tolerations` 之外的字段。 对于 `spec.tolerations`，你只被允许添加新的条目到其中。
    
- 在更新 `spec.activeDeadlineSeconds` 字段时，以下两种更新操作是被允许的：
    
    1. 如果该字段尚未设置，可以将其设置为一个正数；
    2. 如果该字段已经设置为一个正数，可以将其设置为一个更小的、非负的整数。

##### 资源共享和通信[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#resource-sharing-and-communication)

Pod 使它的成员容器间能够进行数据共享和通信。

##### Pod 中的存储[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-storage)

一个 Pod 可以设置一组共享的存储[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)。 Pod 中的所有容器都可以访问该共享卷，从而允许这些容器共享数据。 卷还允许 Pod 中的持久数据保留下来，即使其中的容器需要重新启动。 有关 Kubernetes 如何在 Pod 中实现共享存储并将其提供给 Pod 的更多信息， 请参考[存储](https://kubernetes.io/zh-cn/docs/concepts/storage/)。

##### Pod 联网[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-networking)

每个 Pod 都在每个地址族中获得一个唯一的 IP 地址。 Pod 中的每个容器共享网络名字空间，包括 IP 地址和网络端口。 **Pod 内**的容器可以使用 `localhost` 互相通信。 当 Pod 中的容器与 **Pod 之外**的实体通信时，它们必须协调如何使用共享的网络资源（例如端口）。

在同一个 Pod 内，所有容器共享一个 IP 地址和端口空间，并且可以通过 `localhost` 发现对方。 他们也能通过如 SystemV 信号量或 POSIX 共享内存这类标准的进程间通信方式互相通信。 不同 Pod 中的容器的 IP 地址互不相同，如果没有特殊配置，就无法通过 OS 级 IPC 进行通信。 如果某容器希望与运行于其他 Pod 中的容器通信，可以通过 IP 联网的方式实现。

Pod 中的容器所看到的系统主机名与为 Pod 配置的 `name` 属性值相同。 [网络](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/)部分提供了更多有关此内容的信息。

#### 容器的特权模式[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#privileged-mode-for-containers)

**说明：**

你的[容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)必须支持特权容器的概念才能使用这一配置。

Pod 中的所有容器都可以在特权模式下运行，以使用原本无法访问的操作系统管理权能。 此模式同时适用于 Windows 和 Linux。

##### Linux 特权容器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#linux-privileged-containers)

在 Linux 中，Pod 中的所有容器都可以使用容器规约中的 [安全性上下文](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/)中的 `privileged`（Linux）参数启用特权模式。 这对于想要使用操作系统管理权能（Capabilities，如操纵网络堆栈和访问硬件设备）的容器很有用。

##### Windows 特权容器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#windows-privileged-containers)

**特性状态：** `Kubernetes v1.26 [stable]`

在 Windows 中，你可以使用 Pod 规约中安全上下文的 `windowsOptions.hostProcess` 参数来创建 [Windows HostProcess Pod](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/create-hostprocess-pod/)。 这些 Pod 中的所有容器都必须以 Windows HostProcess 容器方式运行。 HostProcess Pod 可以直接运行在主机上，它也能像 Linux 特权容器一样，用于执行管理任务。 想要使用此特性，`WindowsHostProcessContainers` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)必须被启用。

#### 静态 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#static-pods)

**静态 Pod（Static Pod）** 直接由特定节点上的 `kubelet` 守护进程管理， 不需要 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)看到它们。 尽管大多数 Pod 都是通过控制面（例如，[Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)） 来管理的，对于静态 Pod 而言，`kubelet` 直接监控每个 Pod，并在其失效时重启之。

静态 Pod 通常绑定到某个节点上的 [kubelet](https://kubernetes.io/docs/reference/generated/kubelet)。 其主要用途是运行自托管的控制面。 在自托管场景中，使用 `kubelet` 来管理各个独立的[控制面组件](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#control-plane-components)。

`kubelet` 自动尝试为每个静态 Pod 在 Kubernetes API 服务器上创建一个[镜像 Pod](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-mirror-pod)。 这意味着在节点上运行的 Pod 在 API 服务器上是可见的，但不可以通过 API 服务器来控制。

**说明：**

静态 Pod 的 `spec` 不能引用其他的 API 对象（例如： [ServiceAccount](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/)、 [ConfigMap](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/)、 [Secret](https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/) 等）。

#### 容器探针[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#container-probes)

**Probe** 是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 可以执行三种动作：

- `ExecAction`（借助容器运行时执行）
- `TCPSocketAction`（由 kubelet 直接检测）
- `HTTPGetAction`（由 kubelet 直接检测）

你可以参阅 Pod 的生命周期文档中的[探针](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)部分。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod 生命周期](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/)。
- 了解 [RuntimeClass](https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/)， 以及如何使用它来配置不同的 Pod 使用不同的容器运行时配置。
- 了解 [PodDisruptionBudget](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/)， 以及你可以如何利用它在出现干扰因素时管理应用的可用性。
- Pod 在 Kubernetes REST API 中是一个顶层资源。 [Pod](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/) 对象的定义中包含了更多的细节信息。
- 博客[分布式系统工具箱：复合容器模式](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns/)中解释了在同一 Pod 中包含多个容器时的几种常见布局。
- 了解 [Pod 拓扑分布约束](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/)。

要了解为什么 Kubernetes 会在其他资源 （如 [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 或 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)） 封装通用的 Pod API，相关的背景信息可以在前人的研究中找到。具体包括：

- [Aurora](https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema)
- [Borg](https://research.google.com/pubs/pub43438.html)
- [Marathon](https://mesosphere.github.io/marathon/docs/rest-api.html)
- [Omega](https://research.google/pubs/pub41684/)
- [Tupperware](https://engineering.fb.com/data-center-engineering/tupperware/).

### Pod 的生命周期

本页面讲述 Pod 的生命周期。 Pod 遵循预定义的生命周期，起始于 `Pending` [阶段](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)， 如果至少其中有一个主要容器正常启动，则进入 `Running`，之后取决于 Pod 中是否有容器以失败状态结束而进入 `Succeeded` 或者 `Failed` 阶段。

在 Pod 运行期间，`kubelet` 能够重启容器以处理一些失效场景。 在 Pod 内部，Kubernetes 跟踪不同容器的[状态](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-states)并确定使 Pod 重新变得健康所需要采取的动作。

在 Kubernetes API 中，Pod 包含规约部分和实际状态部分。 Pod 对象的状态包含了一组 [Pod 状况（Conditions）](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions)。 如果应用需要的话，你也可以向其中注入[自定义的就绪态信息](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate)。

Pod 在其生命周期中只会被[调度](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/)一次。 一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod 停止或者被[终止](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)。

#### Pod 生命期[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-lifetime)

和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。 Pod 会被创建、赋予一个唯一的 ID（[UID](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#uids)）， 并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。

如果一个[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)死掉了，调度到该节点的 Pod 也被计划在给定超时期限结束后[删除](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)。

Pod 自身不具有自愈能力。如果 Pod 被调度到某[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)而该节点之后失效， Pod 会被删除；类似地，Pod 无法在因节点资源耗尽或者节点维护而被驱逐期间继续存活。 Kubernetes 使用一种高级抽象来管理这些相对而言可随时丢弃的 Pod 实例， 称作[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)。

任何给定的 Pod （由 UID 定义）从不会被“重新调度（rescheduled）”到不同的节点； 相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。 如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。

如果某物声称其生命期与某 Pod 相同，例如存储[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)， 这就意味着该对象在此 Pod （UID 亦相同）存在期间也一直存在。 如果 Pod 因为任何原因被删除，甚至某完全相同的替代 Pod 被创建时， 这个相关的对象（例如这里的卷）也会被删除并重建。

![](https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg)

###### Pod 结构图例

_一个包含多个容器的 Pod 中包含一个用来拉取文件的程序和一个 Web 服务器， 均使用持久卷作为容器间共享的存储。_

#### Pod 阶段[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)

Pod 的 `status` 字段是一个 [PodStatus](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#podstatus-v1-core) 对象，其中包含一个 `phase` 字段。

Pod 的阶段（Phase）是 Pod 在其生命周期中所处位置的简单宏观概述。 该阶段并不是对容器或 Pod 状态的综合汇总，也不是为了成为完整的状态机。

Pod 阶段的数量和含义是严格定义的。 除了本文档中列举的内容外，不应该再假定 Pod 有其他的 `phase` 值。

下面是 `phase` 可能的值：

| 取值 | 描述 |
| --- | --- |
| `Pending`（悬决） | Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。 |
| `Running`（运行中） | Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。 |
| `Succeeded`（成功） | Pod 中的所有容器都已成功终止，并且不会再重启。 |
| `Failed`（失败） | Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。 |
| `Unknown`（未知） | 因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。 |

**说明：**

当一个 Pod 被删除时，执行一些 kubectl 命令会展示这个 Pod 的状态为 `Terminating`（终止）。 这个 `Terminating` 状态并不是 Pod 阶段之一。 Pod 被赋予一个可以体面终止的期限，默认为 30 秒。 你可以使用 `--force` 参数来[强制终止 Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced)。

如果某节点死掉或者与集群中其他节点失联，Kubernetes 会实施一种策略，将失去的节点上运行的所有 Pod 的 `phase` 设置为 `Failed`。

#### 容器状态[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-states)

Kubernetes 会跟踪 Pod 中每个容器的状态，就像它跟踪 Pod 总体上的[阶段](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase)一样。 你可以使用[容器生命周期回调](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/) 来在容器生命周期中的特定时间点触发事件。

一旦[调度器](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/)将 Pod 分派给某个节点，`kubelet` 就通过[容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)开始为 Pod 创建容器。容器的状态有三种：`Waiting`（等待）、`Running`（运行中）和 `Terminated`（已终止）。

要检查 Pod 中容器的状态，你可以使用 `kubectl describe pod <pod 名称>`。 其输出中包含 Pod 中每个容器的状态。

每种状态都有特定的含义：

##### `Waiting` （等待）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-state-waiting)

如果容器并不处在 `Running` 或 `Terminated` 状态之一，它就处在 `Waiting` 状态。 处于 `Waiting` 状态的容器仍在运行它完成启动所需要的操作：例如， 从某个容器镜像仓库拉取容器镜像，或者向容器应用 [Secret](https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/) 数据等等。 当你使用 `kubectl` 来查询包含 `Waiting` 状态的容器的 Pod 时，你也会看到一个 Reason 字段，其中给出了容器处于等待状态的原因。

##### `Running`（运行中）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-state-running)

`Running` 状态表明容器正在执行状态并且没有问题发生。 如果配置了 `postStart` 回调，那么该回调已经执行且已完成。 如果你使用 `kubectl` 来查询包含 `Running` 状态的容器的 Pod 时， 你也会看到关于容器进入 `Running` 状态的信息。

##### `Terminated`（已终止）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-state-terminated)

处于 `Terminated` 状态的容器已经开始执行并且或者正常结束或者因为某些原因失败。 如果你使用 `kubectl` 来查询包含 `Terminated` 状态的容器的 Pod 时， 你会看到容器进入此状态的原因、退出代码以及容器执行期间的起止时间。

如果容器配置了 `preStop` 回调，则该回调会在容器进入 `Terminated` 状态之前执行。

#### 容器重启策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy)

Pod 的 `spec` 中包含一个 `restartPolicy` 字段，其可能取值包括 Always、OnFailure 和 Never。默认值是 Always。

`restartPolicy` 适用于 Pod 中的所有容器。`restartPolicy` 仅针对同一节点上 `kubelet` 的容器重启动作。当 Pod 中的容器退出时，`kubelet` 会按指数回退方式计算重启的延迟（10s、20s、40s、...），其最长延迟为 5 分钟。 一旦某容器执行了 10 分钟并且没有出现问题，`kubelet` 对该容器的重启回退计时器执行重置操作。

#### Pod 状况[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions)

Pod 有一个 PodStatus 对象，其中包含一个 [PodConditions](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#podcondition-v1-core) 数组。Pod 可能通过也可能未通过其中的一些状况测试。 Kubelet 管理以下 PodCondition：

- `PodScheduled`：Pod 已经被调度到某节点；
- `PodHasNetwork`：Pod 沙箱被成功创建并且配置了网络（Alpha 特性，必须被[显式启用](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-has-network)）；
- `ContainersReady`：Pod 中所有容器都已就绪；
- `Initialized`：所有的 [Init 容器](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/)都已成功完成；
- `Ready`：Pod 可以为请求提供服务，并且应该被添加到对应服务的负载均衡池中。

| 字段名称 | 描述 |
| --- | --- |
| `type` | Pod 状况的名称 |
| `status` | 表明该状况是否适用，可能的取值有 "`True`"、"`False`" 或 "`Unknown`" |
| `lastProbeTime` | 上次探测 Pod 状况时的时间戳 |
| `lastTransitionTime` | Pod 上次从一种状态转换到另一种状态时的时间戳 |
| `reason` | 机器可读的、驼峰编码（UpperCamelCase）的文字，表述上次状况变化的原因 |
| `message` | 人类可读的消息，给出上次状态转换的详细信息 |

##### Pod 就绪态[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-gate)

**特性状态：** `Kubernetes v1.14 [stable]`

你的应用可以向 PodStatus 中注入额外的反馈或者信号：**Pod Readiness（Pod 就绪态）**。 要使用这一特性，可以设置 Pod 规约中的 `readinessGates` 列表，为 kubelet 提供一组额外的状况供其评估 Pod 就绪态时使用。

就绪态门控基于 Pod 的 `status.conditions` 字段的当前值来做决定。 如果 Kubernetes 无法在 `status.conditions` 字段中找到某状况， 则该状况的状态值默认为 "`False`"。

这里是一个例子：

```yaml
kind: Pod
...
spec:
  readinessGates:
    - conditionType: "www.example.com/feature-1"
status:
  conditions:
    - type: Ready                              # 内置的 Pod 状况
      status: "False"
      lastProbeTime: null
      lastTransitionTime: 2018-01-01T00:00:00Z
    - type: "www.example.com/feature-1"        # 额外的 Pod 状况
      status: "False"
      lastProbeTime: null
      lastTransitionTime: 2018-01-01T00:00:00Z
  containerStatuses:
    - containerID: docker://abcd...
      ready: true
...
```

你所添加的 Pod 状况名称必须满足 Kubernetes [标签键名格式](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set)。

##### Pod 就绪态的状态[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-readiness-status)

命令 `kubectl patch` 不支持修改对象的状态。 如果需要设置 Pod 的 `status.conditions`，应用或者 [Operators](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/operator/) 需要使用 `PATCH` 操作。你可以使用 [Kubernetes 客户端库](https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries/)之一来编写代码， 针对 Pod 就绪态设置定制的 Pod 状况。

对于使用定制状况的 Pod 而言，只有当下面的陈述都适用时，该 Pod 才会被评估为就绪：

- Pod 中所有容器都已就绪；
- `readinessGates` 中的所有状况都为 `True` 值。

当 Pod 的容器都已就绪，但至少一个定制状况没有取值或者取值为 `False`， `kubelet` 将 Pod 的[状况](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions)设置为 `ContainersReady`。

##### Pod 网络就绪[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-has-network)

**特性状态：** `Kubernetes v1.25 [alpha]`

在 Pod 被调度到某节点后，它需要被 Kubelet 接受并且挂载所需的卷。 一旦这些阶段完成，Kubelet 将与容器运行时（使用[容器运行时接口（Container Runtime Interface；CRI）](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#container-runtime)） 一起为 Pod 生成运行时沙箱并配置网络。 如果启用了 `PodHasNetworkCondition` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， kubelet 会通过 Pod 的 `status.conditions` 字段中的 `PodHasNetwork` 状况来报告 Pod 是否达到了初始化里程碑。

当 kubelet 检测到 Pod 不具备配置了网络的运行时沙箱时，`PodHasNetwork` 状况将被设置为 `False`。 以下场景中将会发生这种状况：

- 在 Pod 生命周期的早期阶段，kubelet 还没有开始使用容器运行时为 Pod 设置沙箱时。
- 在 Pod 生命周期的末期阶段，Pod 的沙箱由于以下原因被销毁时：
    - 节点重启时 Pod 没有被驱逐
    - 对于使用虚拟机进行隔离的容器运行时，Pod 沙箱虚拟机重启时，需要创建一个新的沙箱和全新的容器网络配置。

在运行时插件成功完成 Pod 的沙箱创建和网络配置后， kubelet 会将 `PodHasNetwork` 状况设置为 `True`。 当 `PodHasNetwork` 状况设置为 `True` 后， Kubelet 可以开始拉取容器镜像和创建容器。

对于带有 Init 容器的 Pod，kubelet 会在 Init 容器成功完成后将 `Initialized` 状况设置为 `True` （这发生在运行时成功创建沙箱和配置网络之后）， 对于没有 Init 容器的 Pod，kubelet 会在创建沙箱和网络配置开始之前将 `Initialized` 状况设置为 `True`。

##### Pod 调度就绪态[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-scheduling-readiness-gate)

**特性状态：** `Kubernetes v1.26 [alpha]`

有关详细信息，请参阅 [Pod 调度就绪态](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-scheduling-readiness/)。

#### 容器探针[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)

probe 是由 [kubelet](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/) 对容器执行的定期诊断。 要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。

##### 检查机制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#probe-check-methods)

使用探针来检查容器有四种不同的方法。 每个探针都必须准确定义为这四种机制中的一种：

`exec`

在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。

`grpc`

使用 [gRPC](https://grpc.io/) 执行一个远程过程调用。 目标应该实现 [gRPC 健康检查](https://grpc.io/grpc/core/md_doc_health-checking.html)。 如果响应的状态是 "SERVING"，则认为诊断成功。 gRPC 探针是一个 Alpha 特性，只有在你启用了 "GRPCContainerProbe" [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)时才能使用。

`httpGet`

对容器的 IP 地址上指定端口和路径执行 HTTP `GET` 请求。如果响应的状态码大于等于 200 且小于 400，则诊断被认为是成功的。

`tcpSocket`

对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。 如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。

##### 探测结果[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#probe-outcome)

每次探测都将获得以下三种结果之一：

`Success`（成功）

容器通过了诊断。

`Failure`（失败）

容器未通过诊断。

`Unknown`（未知）

诊断失败，因此不会采取任何行动。

##### 探测类型[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#types-of-probe)

针对运行中的容器，`kubelet` 可以选择是否执行以下三种探针，以及如何针对探测结果作出反应：

`livenessProbe`

指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器， 并且容器将根据其[重启策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy)决定未来。如果容器不提供存活探针， 则默认状态为 `Success`。

`readinessProbe`

指示容器是否准备好为请求提供服务。如果就绪态探测失败， 端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。 初始延迟之前的就绪态的状态值默认为 `Failure`。 如果容器不提供就绪态探针，则默认状态为 `Success`。

`startupProbe`

指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被 禁用，直到此探针成功为止。如果启动探测失败，`kubelet` 将杀死容器， 而容器依其[重启策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy)进行重启。 如果容器没有提供启动探测，则默认状态为 `Success`。

如欲了解如何设置存活态、就绪态和启动探针的进一步细节， 可以参阅[配置存活态、就绪态和启动探针](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)。

###### 何时该使用存活态探针?[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-liveness-probe)

**特性状态：** `Kubernetes v1.0 [stable]`

如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活态探针； `kubelet` 将根据 Pod 的 `restartPolicy` 自动执行修复操作。

如果你希望容器在探测失败时被杀死并重新启动，那么请指定一个存活态探针， 并指定 `restartPolicy` 为 "`Always`" 或 "`OnFailure`"。

###### 何时该使用就绪态探针?[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-readiness-probe)

**特性状态：** `Kubernetes v1.0 [stable]`

如果要仅在探测成功时才开始向 Pod 发送请求流量，请指定就绪态探针。 在这种情况下，就绪态探针可能与存活态探针相同，但是规约中的就绪态探针的存在意味着 Pod 将在启动阶段不接收任何数据，并且只有在探针探测成功后才开始接收数据。

如果你希望容器能够自行进入维护状态，也可以指定一个就绪态探针， 检查某个特定于就绪态的因此不同于存活态探测的端点。

如果你的应用程序对后端服务有严格的依赖性，你可以同时实现存活态和就绪态探针。 当应用程序本身是健康的，存活态探针检测通过后，就绪态探针会额外检查每个所需的后端服务是否可用。 这可以帮助你避免将流量导向只能返回错误信息的 Pod。

如果你的容器需要在启动期间加载大型数据、配置文件或执行迁移， 你可以使用[启动探针](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe)。 然而，如果你想区分已经失败的应用和仍在处理其启动数据的应用，你可能更倾向于使用就绪探针。

**说明：**

请注意，如果你只是想在 Pod 被删除时能够排空请求，则不一定需要使用就绪态探针； 在删除 Pod 时，Pod 会自动将自身置于未就绪状态，无论就绪态探针是否存在。 等待 Pod 中的容器停止期间，Pod 会一直处于未就绪状态。

###### 何时该使用启动探针？[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#when-should-you-use-a-startup-probe)

**特性状态：** `Kubernetes v1.20 [stable]`

对于所包含的容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。 你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选定， 对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。

如果你的容器启动时间通常超出 `initialDelaySeconds + failureThreshold × periodSeconds` 总值，你应该设置一个启动探测，对存活态探针所使用的同一端点执行检查。 `periodSeconds` 的默认值是 10 秒。你应该将其 `failureThreshold` 设置得足够高， 以便容器有充足的时间完成启动，并且避免更改存活态探针所使用的默认值。 这一设置有助于减少死锁状况的发生。

#### Pod 的终止[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)

由于 Pod 所代表的是在集群中节点上运行的进程，当不再需要这些进程时允许其体面地终止是很重要的。 一般不应武断地使用 `KILL` 信号终止它们，导致这些进程没有机会完成清理操作。

设计的目标是令你能够请求删除进程，并且知道进程何时被终止，同时也能够确保删除操作终将完成。 当你请求删除某个 Pod 时，集群会记录并跟踪 Pod 的体面终止周期， 而不是直接强制地杀死 Pod。在存在强制关闭设施的前提下， [kubelet](https://kubernetes.io/docs/reference/generated/kubelet) 会尝试体面地终止 Pod。

通常情况下，容器运行时会发送一个 TERM 信号到每个容器中的主进程。 很多容器运行时都能够注意到容器镜像中 `STOPSIGNAL` 的值，并发送该信号而不是 TERM。 一旦超出了体面终止限期，容器运行时会向所有剩余进程发送 KILL 信号，之后 Pod 就会被从 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)上移除。 如果 `kubelet` 或者容器运行时的管理服务在等待进程终止期间被重启， 集群会从头开始重试，赋予 Pod 完整的体面终止限期。

下面是一个例子：

1. 你使用 `kubectl` 工具手动删除某个特定的 Pod，而该 Pod 的体面终止限期是默认值（30 秒）。
    
2. API 服务器中的 Pod 对象被更新，记录涵盖体面终止限期在内 Pod 的最终死期，超出所计算时间点则认为 Pod 已死（dead）。 如果你使用 `kubectl describe` 来查验你正在删除的 Pod，该 Pod 会显示为 "Terminating" （正在终止）。 在 Pod 运行所在的节点上：`kubelet` 一旦看到 Pod 被标记为正在终止（已经设置了体面终止限期），`kubelet` 即开始本地的 Pod 关闭过程。
    
    1. 如果 Pod 中的容器之一定义了 `preStop` [回调](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks)， `kubelet` 开始在容器内运行该回调逻辑。如果超出体面终止限期时， `preStop` 回调逻辑仍在运行，`kubelet` 会请求给予该 Pod 的宽限期一次性增加 2 秒钟。
        
        **说明：**
        
        ```
          如果 `preStop` 回调所需要的时间长于默认的体面终止限期，你必须修改
          `terminationGracePeriodSeconds` 属性值来使其正常工作。
        ```
        
    
    2. `kubelet` 接下来触发容器运行时发送 TERM 信号给每个容器中的进程 1。
        
        **说明：**
        
        ```
          Pod 中的容器会在不同时刻收到 TERM 信号，接收顺序也是不确定的。
          如果关闭的顺序很重要，可以考虑使用 `preStop` 回调逻辑来协调。
        ```
        

3. 在 `kubelet` 启动体面关闭逻辑的同时，控制面会将关闭的 Pod 从对应的 EndpointSlice（和 Endpoints）对象中移除，过滤条件是 Pod 被对应的[服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)以某 [选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)选定。 [ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 和其他工作负载资源不再将关闭进程中的 Pod 视为合法的、能够提供服务的副本。 关闭动作很慢的 Pod 也无法继续处理请求数据， 因为负载均衡器（例如服务代理）已经在终止宽限期开始的时候将其从端点列表中移除。
    
    **说明：**
    
    如果你的集群中没有启用 EndpointSliceTerminatingCondition 特性门控 （该门控从 Kubernetes 1.22 开始默认开启，在 1.26 中锁定为默认）， 那么一旦 Pod 的终止宽限期开始，Kubernetes 控制平面就会从所有的相关 EndpointSlices 中移除 Pod。 上述行为是在 EndpointSliceTerminatingCondition 特性门控被启用时描述的。
    

1. 超出终止宽限期限时，`kubelet` 会触发强制关闭过程。容器运行时会向 Pod 中所有容器内仍在运行的进程发送 `SIGKILL` 信号。 `kubelet` 也会清理隐藏的 `pause` 容器，如果容器运行时使用了这种容器的话。
    
2. `kubelet` 触发强制从 API 服务器上删除 Pod 对象的逻辑，并将体面终止限期设置为 0 （这意味着马上删除）。
    
3. API 服务器删除 Pod 的 API 对象，从任何客户端都无法再看到该对象。
    

##### 强制终止 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced)

**注意：**

对于某些工作负载及其 Pod 而言，强制删除很可能会带来某种破坏。

默认情况下，所有的删除操作都会附有 30 秒钟的宽限期限。 `kubectl delete` 命令支持 `--grace-period=<seconds>` 选项，允许你重载默认值， 设定自己希望的期限值。

将宽限期限强制设置为 `0` 意味着立即从 API 服务器删除 Pod。 如果 Pod 仍然运行于某节点上，强制删除操作会触发 `kubelet` 立即执行清理操作。

**说明：**

你必须在设置 `--grace-period=0` 的同时额外设置 `--force` 参数才能发起强制删除请求。

执行强制删除操作时，API 服务器不再等待来自 `kubelet` 的、关于 Pod 已经在原来运行的节点上终止执行的确认消息。 API 服务器直接删除 Pod 对象，这样新的与之同名的 Pod 即可以被创建。 在节点侧，被设置为立即终止的 Pod 仍然会在被强行杀死之前获得一点点的宽限时间。

**注意：**

马上删除时不等待确认正在运行的资源已被终止。这些资源可能会无限期地继续在集群上运行。

如果你需要强制删除 StatefulSet 的 Pod， 请参阅[从 StatefulSet 中删除 Pod](https://kubernetes.io/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/) 的任务文档。

##### Pod 的垃圾收集[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)

对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上， 直到用户或者[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)进程显式地将其删除。

Pod 的垃圾收集器（PodGC）是控制平面的控制器，它会在 Pod 个数超出所配置的阈值 （根据 `kube-controller-manager` 的 `terminated-pod-gc-threshold` 设置）时删除已终止的 Pod（阶段值为 `Succeeded` 或 `Failed`）。 这一行为会避免随着时间演进不断创建和终止 Pod 而引起的资源泄露问题。

此外，PodGC 会清理满足以下任一条件的所有 Pod：

1. 孤儿 Pod - 绑定到不再存在的节点，
2. 计划外终止的 Pod
3. 终止过程中的 Pod，当启用 `NodeOutOfServiceVolumeDetach` 特性门控时， 绑定到有 [`node.kubernetes.io/out-of-service`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-out-of-service) 污点的未就绪节点。

若启用 `PodDisruptionConditions` 特性门控，在清理 Pod 的同时， 如果它们处于非终止状态阶段，PodGC 也会将它们标记为失败。 此外，PodGC 在清理孤儿 Pod 时会添加 Pod 干扰状况（另请参阅： [Pod 干扰状况](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions#pod-disruption-conditions)）。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 动手实践[为容器生命周期时间关联处理程序](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/)。
- 动手实践[配置存活态、就绪态和启动探针](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)。
- 进一步了解[容器生命周期回调](https://kubernetes.io/zh-cn/docs/concepts/containers/container-lifecycle-hooks/)。
- 关于 API 中定义的有关 Pod 和容器状态的详细规范信息， 可参阅 API 参考文档中 Pod 的 [`.status`](https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodStatus) 字段。

### Init 容器

本页提供了 Init 容器的概览。Init 容器是一种特殊容器，在 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。

你可以在 Pod 的规约中与用来描述应用容器的 `containers` 数组平行的位置指定 Init 容器。

#### 理解 Init 容器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#understanding-init-containers)

每个 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 中可以包含多个容器， 应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。

Init 容器与普通的容器非常像，除了如下两点：

- 它们总是运行到完成。
- 每个都必须在下一个启动之前成功完成。

如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 `restartPolicy` 值为 "Never"，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。

为 Pod 设置 Init 容器需要在 [Pod 规约](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec)中添加 `initContainers` 字段， 该字段以 [Container](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#container-v1-core) 类型对象数组的形式组织，和应用的 `containers` 数组同级相邻。 参阅 API 参考的[容器](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container)章节了解详情。

Init 容器的状态在 `status.initContainerStatuses` 字段中以容器状态数组的格式返回 （类似 `status.containerStatuses` 字段）。

##### 与普通容器的不同之处[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#differences-from-regular-containers)

Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。 然而，Init 容器对资源请求和限制的处理稍有不同，在下面[资源](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#resources)节有说明。

同时 Init 容器不支持 `lifecycle`、`livenessProbe`、`readinessProbe` 和 `startupProbe`， 因为它们必须在 Pod 就绪之前运行完成。

如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。 每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时， Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。

#### 使用 Init 容器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#using-init-containers)

因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：

- Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。 例如，没有必要仅为了在安装过程中使用类似 `sed`、`awk`、`python` 或 `dig` 这样的工具而去 `FROM` 一个镜像来生成一个新的镜像。
    
- 应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。
    

- 与同一 Pod 中的多个应用容器相比，Init 容器能以不同的文件系统视图运行。因此，Init 容器可以被赋予访问应用容器不能访问的 [Secret](https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/) 的权限。
    
- 由于 Init 容器必须在应用容器启动之前运行完成，因此 Init 容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。 一旦前置条件满足，Pod 内的所有的应用容器会并行启动。
    
- Init 容器可以安全地运行实用程序或自定义代码，而在其他方式下运行这些实用程序或自定义代码可能会降低应用容器镜像的安全性。 通过将不必要的工具分开，你可以限制应用容器镜像的被攻击范围。
    

##### 示例[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#examples)

下面是一些如何使用 Init 容器的想法：

- 等待一个 Service 完成创建，通过类似如下 Shell 命令：
    
    ```shell
    for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1
    ```
    

- 注册这个 Pod 到远程服务器，通过在命令中调用 API，类似如下：
    
    ```shell
    curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d 'instance=$(<POD_NAME>)&ip=$(<POD_IP>)'
    ```
    

- 在启动应用容器之前等一段时间，使用类似命令：
    
    ```shell
    sleep 60
    ```
    

- 克隆 Git 仓库到[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)中。
    
- 将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。 例如，在配置文件中存放 `POD_IP` 值，并使用 Jinja 生成主应用配置文件。
    

##### 使用 Init 容器的情况[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#init-containers-in-use)

下面的例子定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 `myservice` 启动， 第二个等待 `mydb` 启动。 一旦这两个 Init 容器都启动完成，Pod 将启动 `spec` 节中的应用容器。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app.kubernetes.io/name: MyApp
spec:
  containers:
  - name: myapp-container
    image: busybox:1.28
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: init-myservice
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done"]
  - name: init-mydb
    image: busybox:1.28
    command: ['sh', '-c', "until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done"]
```

你通过运行下面的命令启动 Pod：

```shell
kubectl apply -f myapp.yaml
```

输出类似于：

```
pod/myapp-pod created
```

使用下面的命令检查其状态：

```shell
kubectl get -f myapp.yaml
```

输出类似于：

```
NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
```

或者查看更多详细信息：

```shell
kubectl describe -f myapp.yaml
```

输出类似于：

```
Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image "busybox"
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image "busybox"
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container init-myservice
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container init-myservice
```

如需查看 Pod 内 Init 容器的日志，请执行：

```shell
kubectl logs myapp-pod -c init-myservice # 查看第一个 Init 容器
kubectl logs myapp-pod -c init-mydb      # 查看第二个 Init 容器
```

在这一刻，Init 容器将会等待至发现名称为 `mydb` 和 `myservice` 的 Service。

如下为创建这些 Service 的配置文件：

```yaml
---
apiVersion: v1
kind: Service
metadata:
  name: myservice
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
---
apiVersion: v1
kind: Service
metadata:
  name: mydb
spec:
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9377
```

创建 `mydb` 和 `myservice` 服务的命令：

```shell
kubectl apply -f services.yaml
```

输出类似于：

```
service/myservice created
service/mydb created
```

这样你将能看到这些 Init 容器执行完毕，随后 `my-app` 的 Pod 进入 `Running` 状态：

```shell
kubectl get -f myapp.yaml
```

输出类似于：

```
NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
```

这个简单例子应该能为你创建自己的 Init 容器提供一些启发。 [接下来](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#what-s-next)节提供了更详细例子的链接。

#### 具体行为[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#detailed-behavior)

在 Pod 启动过程中，每个 Init 容器会在网络和数据卷初始化之后按顺序启动。 kubelet 运行依据 Init 容器在 Pod 规约中的出现顺序依次运行之。

每个 Init 容器成功退出后才会启动下一个 Init 容器。 如果某容器因为容器运行时的原因无法启动，或以错误状态退出，kubelet 会根据 Pod 的 `restartPolicy` 策略进行重试。 然而，如果 Pod 的 `restartPolicy` 设置为 "Always"，Init 容器失败时会使用 `restartPolicy` 的 "OnFailure" 策略。

在所有的 Init 容器没有成功之前，Pod 将不会变成 `Ready` 状态。 Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 `Pending` 状态， 但会将状况 `Initializing` 设置为 false。

如果 Pod [重启](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#pod-restart-reasons)，所有 Init 容器必须重新执行。

对 Init 容器规约的修改仅限于容器的 `image` 字段。 更改 Init 容器的 `image` 字段，等同于重启该 Pod。

因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。 特别地，基于 `emptyDirs` 写文件的代码，应该对输出文件可能已经存在做好准备。

Init 容器具有应用容器的所有字段。然而 Kubernetes 禁止使用 `readinessProbe`， 因为 Init 容器不能定义不同于完成态（Completion）的就绪态（Readiness）。 Kubernetes 会在校验时强制执行此检查。

在 Pod 上使用 `activeDeadlineSeconds` 和在容器上使用 `livenessProbe` 可以避免 Init 容器一直重复失败。 `activeDeadlineSeconds` 时间包含了 Init 容器启动的时间。 但建议仅在团队将其应用程序部署为 Job 时才使用 `activeDeadlineSeconds`， 因为 `activeDeadlineSeconds` 在 Init 容器结束后仍有效果。 如果你设置了 `activeDeadlineSeconds`，已经在正常运行的 Pod 会被杀死。

在 Pod 中的每个应用容器和 Init 容器的名称必须唯一； 与任何其它容器共享同一个名称，会在校验时抛出错误。

##### 资源[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#resources)

在给定的 Init 容器执行顺序下，资源使用适用于如下规则：

- 所有 Init 容器上定义的任何特定资源的 limit 或 request 的最大值，作为 Pod **有效初始 request/limit**。 如果任何资源没有指定资源限制，这被视为最高限制。
- Pod 对资源的 **有效 limit/request** 是如下两者中的较大者：
    - 所有应用容器对某个资源的 limit/request 之和
    - 对某个资源的有效初始 limit/request
- 基于有效 limit/request 完成调度，这意味着 Init 容器能够为初始化过程预留资源， 这些资源在 Pod 生命周期过程中并没有被使用。
- Pod 的 **有效 QoS 层**，与 Init 容器和应用容器的一样。

配额和限制适用于有效 Pod 的请求和限制值。 Pod 级别的 cgroups 是基于有效 Pod 的请求和限制值，和调度器相同。

##### Pod 重启的原因[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#pod-restart-reasons)

Pod 重启会导致 Init 容器重新执行，主要有如下几个原因：

- Pod 的基础设施容器 (译者注：如 `pause` 容器) 被重启。这种情况不多见， 必须由具备 root 权限访问节点的人员来完成。
    
- 当 `restartPolicy` 设置为 `Always`，Pod 中所有容器会终止而强制重启。 由于垃圾收集机制的原因，Init 容器的完成记录将会丢失。
    

当 Init 容器的镜像发生改变或者 Init 容器的完成记录因为垃圾收集等原因被丢失时， Pod 不会被重启。这一行为适用于 Kubernetes v1.20 及更新版本。 如果你在使用较早版本的 Kubernetes，可查阅你所使用的版本对应的文档。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读[创建包含 Init 容器的 Pod](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-initialization/#create-a-pod-that-has-an-init-container)
- 学习如何[调试 Init 容器](https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-init-containers/)

### 干扰（Disruptions）

本指南针对的是希望构建高可用性应用的应用所有者，他们有必要了解可能发生在 Pod 上的干扰类型。

文档同样适用于想要执行自动化集群操作（例如升级和自动扩展集群）的集群管理员。

#### 自愿干扰和非自愿干扰[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#voluntary-and-involuntary-disruptions)

Pod 不会消失，除非有人（用户或控制器）将其销毁，或者出现了不可避免的硬件或软件系统错误。

我们把这些不可避免的情况称为应用的**非自愿干扰（Involuntary Disruptions）**。例如：

- 节点下层物理机的硬件故障
- 集群管理员错误地删除虚拟机（实例）
- 云提供商或虚拟机管理程序中的故障导致的虚拟机消失
- 内核错误
- 节点由于集群网络隔离从集群中消失
- 由于节点[资源不足](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/)导致 pod 被驱逐。

除了资源不足的情况，大多数用户应该都熟悉这些情况；它们不是特定于 Kubernetes 的。

我们称其他情况为**自愿干扰（Voluntary Disruptions）**。 包括由应用所有者发起的操作和由集群管理员发起的操作。 典型的应用所有者的操作包括：

- 删除 Deployment 或其他管理 Pod 的控制器
- 更新了 Deployment 的 Pod 模板导致 Pod 重启
- 直接删除 Pod（例如，因为误操作）

集群管理员操作包括：

- [排空（drain）节点](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/safely-drain-node/)进行修复或升级。
- 从集群中排空节点以缩小集群（了解[集群自动扩缩](https://github.com/kubernetes/autoscaler/#readme)）。
- 从节点中移除一个 Pod，以允许其他 Pod 使用该节点。

这些操作可能由集群管理员直接执行，也可能由集群管理员所使用的自动化工具执行，或者由集群托管提供商自动执行。

咨询集群管理员或联系云提供商，或者查询发布文档，以确定是否为集群启用了任何资源干扰源。 如果没有启用，可以不用创建 Pod Disruption Budgets（Pod 干扰预算）

**注意：**

并非所有的自愿干扰都会受到 Pod 干扰预算的限制。 例如，删除 Deployment 或 Pod 的删除操作就会跳过 Pod 干扰预算检查。

#### 处理干扰[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#%E5%A4%84%E7%90%86%E5%B9%B2%E6%89%B0)

以下是减轻非自愿干扰的一些方法：

- 确保 Pod 在请求中给出[所需资源](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/)。
- 如果需要更高的可用性，请复制应用。 （了解有关运行多副本的[无状态](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/) 和[有状态](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-replicated-stateful-application/)应用的信息。）
- 为了在运行复制应用时获得更高的可用性，请跨机架（使用 [反亲和性](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity)） 或跨区域（如果使用[多区域集群](https://kubernetes.io/zh-cn/docs/setup/best-practices/multiple-zones/)）扩展应用。

自愿干扰的频率各不相同。在一个基本的 Kubernetes 集群中，没有自愿干扰（只有用户触发的干扰）。 然而，集群管理员或托管提供商可能运行一些可能导致自愿干扰的额外服务。例如，节点软 更新可能导致自愿干扰。另外，集群（节点）自动缩放的某些 实现可能导致碎片整理和紧缩节点的自愿干扰。集群 管理员或托管提供商应该已经记录了各级别的自愿干扰（如果有的话）。 有些配置选项，例如在 pod spec 中 [使用 PriorityClasses](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/) 也会产生自愿（和非自愿）的干扰。

#### 干扰预算[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#pod-disruption-budgets)

**特性状态：** `Kubernetes v1.21 [stable]`

即使你会经常引入自愿性干扰，Kubernetes 提供的功能也能够支持你运行高度可用的应用。

作为一个应用的所有者，你可以为每个应用创建一个 `PodDisruptionBudget`（PDB）。 PDB 将限制在同一时间因自愿干扰导致的多副本应用中发生宕机的 Pod 数量。 例如，基于票选机制的应用希望确保运行中的副本数永远不会低于票选所需的数量。 Web 前端可能希望确保提供负载的副本数量永远不会低于总数的某个百分比。

集群管理员和托管提供商应该使用遵循 PodDisruptionBudgets 的接口 （通过调用[Eviction API](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api)）， 而不是直接删除 Pod 或 Deployment。

例如，`kubectl drain` 命令可以用来标记某个节点即将停止服务。 运行 `kubectl drain` 命令时，工具会尝试驱逐你所停服的节点上的所有 Pod。 `kubectl` 代表你所提交的驱逐请求可能会暂时被拒绝， 所以该工具会周期性地重试所有失败的请求， 直到目标节点上的所有的 Pod 都被终止，或者达到配置的超时时间。

PDB 指定应用可以容忍的副本数量（相当于应该有多少副本）。 例如，具有 `.spec.replicas: 5` 的 Deployment 在任何时间都应该有 5 个 Pod。 如果 PDB 允许其在某一时刻有 4 个副本，那么驱逐 API 将允许同一时刻仅有一个（而不是两个）Pod 自愿干扰。

使用标签选择器来指定构成应用的一组 Pod，这与应用的控制器（Deployment、StatefulSet 等） 选择 Pod 的逻辑一样。

Pod 的“预期”数量由管理这些 Pod 的工作负载资源的 `.spec.replicas` 参数计算出来的。 控制平面通过检查 Pod 的 `.metadata.ownerReferences` 来发现关联的工作负载资源。

PDB 无法防止[非自愿干扰](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#voluntary-and-involuntary-disruptions)； 但它们确实计入预算。

由于应用的滚动升级而被删除或不可用的 Pod 确实会计入干扰预算， 但是工作负载资源（如 Deployment 和 StatefulSet） 在进行滚动升级时不受 PDB 的限制。 应用更新期间的故障处理方式是在对应的工作负载资源的 `spec` 中配置的。

当使用驱逐 API 驱逐 Pod 时，Pod 会被体面地 [终止](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)，期间会 参考 [PodSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#podspec-v1-core) 中的 `terminationGracePeriodSeconds` 配置值。

#### PodDisruptionBudget 例子[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#pdb-example)

假设集群有 3 个节点，`node-1` 到 `node-3`。集群上运行了一些应用。 其中一个应用有 3 个副本，分别是 `pod-a`，`pod-b` 和 `pod-c`。 另外，还有一个不带 PDB 的无关 pod `pod-x` 也同样显示出来。 最初，所有的 Pod 分布如下：

| node-1 | node-2 | node-3 |
| --- | --- | --- |
| pod-a _available_ | pod-b _available_ | pod-c _available_ |
| pod-x _available_ |  |  |

3 个 Pod 都是 deployment 的一部分，并且共同拥有同一个 PDB，要求 3 个 Pod 中至少有 2 个 Pod 始终处于可用状态。

例如，假设集群管理员想要重启系统，升级内核版本来修复内核中的缺陷。 集群管理员首先使用 `kubectl drain` 命令尝试腾空 `node-1` 节点。 命令尝试驱逐 `pod-a` 和 `pod-x`。操作立即就成功了。 两个 Pod 同时进入 `terminating` 状态。这时的集群处于下面的状态：

| node-1 _draining_ | node-2 | node-3 |
| --- | --- | --- |
| pod-a _terminating_ | pod-b _available_ | pod-c _available_ |
| pod-x _terminating_ |  |  |

Deployment 控制器观察到其中一个 Pod 正在终止，因此它创建了一个替代 Pod `pod-d`。 由于 `node-1` 被封锁（cordon），`pod-d` 落在另一个节点上。 同样其他控制器也创建了 `pod-y` 作为 `pod-x` 的替代品。

（注意：对于 StatefulSet 来说，`pod-a`（也称为 `pod-0`）需要在替换 Pod 创建之前完全终止， 替代它的也称为 `pod-0`，但是具有不同的 UID。除此之外，此示例也适用于 StatefulSet。）

当前集群的状态如下：

| node-1 _draining_ | node-2 | node-3 |
| --- | --- | --- |
| pod-a _terminating_ | pod-b _available_ | pod-c _available_ |
| pod-x _terminating_ | pod-d _starting_ | pod-y |

在某一时刻，Pod 被终止，集群如下所示：

| node-1 _drained_ | node-2 | node-3 |
| --- | --- | --- |
|  | pod-b _available_ | pod-c _available_ |
|  | pod-d _starting_ | pod-y |

此时，如果一个急躁的集群管理员试图排空（drain）`node-2` 或 `node-3`，drain 命令将被阻塞， 因为对于 Deployment 来说只有 2 个可用的 Pod，并且它的 PDB 至少需要 2 个。 经过一段时间，`pod-d` 变得可用。

集群状态如下所示：

| node-1 _drained_ | node-2 | node-3 |
| --- | --- | --- |
|  | pod-b _available_ | pod-c _available_ |
|  | pod-d _available_ | pod-y |

现在，集群管理员试图排空（drain）`node-2`。 drain 命令将尝试按照某种顺序驱逐两个 Pod，假设先是 `pod-b`，然后是 `pod-d`。 命令成功驱逐 `pod-b`，但是当它尝试驱逐 `pod-d`时将被拒绝，因为对于 Deployment 来说只剩一个可用的 Pod 了。

Deployment 创建 `pod-b` 的替代 Pod `pod-e`。 因为集群中没有足够的资源来调度 `pod-e`，drain 命令再次阻塞。集群最终将是下面这种状态：

| node-1 _drained_ | node-2 | node-3 | _no node_ |
| --- | --- | --- | --- |
|  | pod-b _terminating_ | pod-c _available_ | pod-e _pending_ |
|  | pod-d _available_ | pod-y |  |

此时，集群管理员需要增加一个节点到集群中以继续升级操作。

可以看到 Kubernetes 如何改变干扰发生的速率，根据：

- 应用需要多少个副本
- 优雅关闭应用实例需要多长时间
- 启动应用新实例需要多长时间
- 控制器的类型
- 集群的资源能力

#### Pod 干扰状况[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#pod-disruption-conditions)

**特性状态：** `Kubernetes v1.26 [beta]`

**说明：**

如果你正使用的 Kubernetes 版本早于 1.26，请参阅对应版本的文档。

**说明：**

要使用此行为，你必须在集群中启用 `PodDisruptionConditions` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。

启用后，会给 Pod 添加一个 `DisruptionTarget` [状况](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions)， 用来表明该 Pod 因为发生[干扰](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/)而被删除。 状况中的 `reason` 字段进一步给出 Pod 终止的原因，如下：

`PreemptionByKubeScheduler`

Pod 将被调度器[抢占](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption)， 目的是接受优先级更高的新 Pod。 要了解更多的相关信息，请参阅 [Pod 优先级和抢占](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/)。

`DeletionByTaintManager`

由于 Pod 不能容忍 `NoExecute` 污点，Pod 将被 Taint Manager（`kube-controller-manager` 中节点生命周期控制器的一部分）删除； 请参阅基于[污点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)的驱逐。

`EvictionByEvictionAPI`

Pod 已被标记为[通过 Kubernetes API 驱逐](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/api-eviction/)。

`DeletionByPodGC`

绑定到一个不再存在的 Node 上的 Pod 将被 [Pod 垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)删除。

`TerminationByKubelet`

Pod 由于[节点压力驱逐](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/)或[节点体面关闭](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/#graceful-node-shutdown)而被 kubelet 终止。

**说明：**

Pod 的干扰可能会被中断。控制平面可能会重新尝试继续干扰同一个 Pod，但这没办法保证。 因此，`DisruptionTarget` 状况可能会被添加到 Pod 上， 但该 Pod 实际上可能不会被删除。 在这种情况下，一段时间后，Pod 干扰状况将被清除。

当 `PodDisruptionConditions` 特性门控被启用时，在清理 Pod 的同时，如果这些 Pod 处于非终止阶段， 则 Pod 垃圾回收器 (PodGC) 也会将这些 Pod 标记为失效 （另见 [Pod 垃圾回收](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)）。

使用 Job（或 CronJob）时，你可能希望将这些 Pod 干扰状况作为 Job [Pod 失效策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job#pod-failure-policy)的一部分。

#### 分离集群所有者和应用所有者角色[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#%E5%88%86%E7%A6%BB%E9%9B%86%E7%BE%A4%E6%89%80%E6%9C%89%E8%80%85%E5%92%8C%E5%BA%94%E7%94%A8%E6%89%80%E6%9C%89%E8%80%85%E8%A7%92%E8%89%B2)

通常，将集群管理者和应用所有者视为彼此了解有限的独立角色是很有用的。这种责任分离在下面这些场景下是有意义的：

- 当有许多应用团队共用一个 Kubernetes 集群，并且有自然的专业角色
- 当第三方工具或服务用于集群自动化管理

Pod 干扰预算通过在角色之间提供接口来支持这种分离。

如果你的组织中没有这样的责任分离，则可能不需要使用 Pod 干扰预算。

#### 如何在集群上执行干扰性操作[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E7%BE%A4%E4%B8%8A%E6%89%A7%E8%A1%8C%E5%B9%B2%E6%89%B0%E6%80%A7%E6%93%8D%E4%BD%9C)

如果你是集群管理员，并且需要对集群中的所有节点执行干扰操作，例如节点或系统软件升级，则可以使用以下选项

- 接受升级期间的停机时间。
- 故障转移到另一个完整的副本集群。
    - 没有停机时间，但是对于重复的节点和人工协调成本可能是昂贵的。
- 编写可容忍干扰的应用和使用 PDB。
    - 不停机。
    - 最小的资源重复。
    - 允许更多的集群管理自动化。
    - 编写可容忍干扰的应用是棘手的，但对于支持容忍自愿干扰所做的工作，和支持自动扩缩和容忍非 自愿干扰所做工作相比，有大量的重叠

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 参考[配置 Pod 干扰预算](https://kubernetes.io/zh-cn/docs/tasks/run-application/configure-pdb/)中的方法来保护你的应用。
    
- 进一步了解[排空节点](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/safely-drain-node/)的信息。
    
- 了解[更新 Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#updating-a-deployment) 的过程，包括如何在其进程中维持应用的可用性


### 临时容器

**特性状态：** `Kubernetes v1.25 [stable]`

本页面概述了临时容器：一种特殊的容器，该容器在现有 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 中临时运行，以便完成用户发起的操作，例如故障排查。 你会使用临时容器来检查服务，而不是用它来构建应用程序。

#### 了解临时容器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/#understanding-ephemeral-containers)

[Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 是 Kubernetes 应用程序的基本构建块。 由于 Pod 是一次性且可替换的，因此一旦 Pod 创建，就无法将容器加入到 Pod 中。 取而代之的是，通常使用 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 以受控的方式来删除并替换 Pod。

有时有必要检查现有 Pod 的状态。例如，对于难以复现的故障进行排查。 在这些场景中，可以在现有 Pod 中运行临时容器来检查其状态并运行任意命令。

##### 什么是临时容器？[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/#what-is-an-ephemeral-container)

临时容器与其他容器的不同之处在于，它们缺少对资源或执行的保证，并且永远不会自动重启， 因此不适用于构建应用程序。 临时容器使用与常规容器相同的 `ContainerSpec` 节来描述，但许多字段是不兼容和不允许的。

- 临时容器没有端口配置，因此像 `ports`、`livenessProbe`、`readinessProbe` 这样的字段是不允许的。
- Pod 资源分配是不可变的，因此 `resources` 配置是不允许的。
- 有关允许字段的完整列表，请参见 [EphemeralContainer 参考文档](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#ephemeralcontainer-v1-core)。

临时容器是使用 API 中的一种特殊的 `ephemeralcontainers` 处理器进行创建的， 而不是直接添加到 `pod.spec` 段，因此无法使用 `kubectl edit` 来添加一个临时容器。

与常规容器一样，将临时容器添加到 Pod 后，将不能更改或删除临时容器。

**说明：**

临时容器不被[静态 Pod](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/static-pod/) 支持。

#### 临时容器的用途[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/#uses-for-ephemeral-containers)

当由于容器崩溃或容器镜像不包含调试工具而导致 `kubectl exec` 无用时， 临时容器对于交互式故障排查很有用。

尤其是，[Distroless 镜像](https://github.com/GoogleContainerTools/distroless) 允许用户部署最小的容器镜像，从而减少攻击面并减少故障和漏洞的暴露。 由于 distroless 镜像不包含 Shell 或任何的调试工具，因此很难单独使用 `kubectl exec` 命令进行故障排查。

使用临时容器时， 启用[进程名字空间共享](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/)很有帮助， 可以查看其他容器中的进程。

接下来

- 了解如何[使用临时调试容器来进行调试](https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container)

### Pod 服务质量等级

本页介绍了Kubernetes 中的_服务质量 (QoS) 类_，并解释了 Kubernetes 如何根据您为该 Pod 中的容器指定的资源限制为每个 Pod 分配 QoS 类。当节点上没有足够的可用资源时，Kubernetes 依靠这种分类来决定驱逐哪些 Pod。

#### 服务质量等级[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes)

Kubernetes 对您运行的 Pod 进行分类，并将每个 Pod 分配到特定的 _服务质量 (QoS) 类别_。Kubernetes 使用该分类来影响不同 pod 的处理方式。Kubernetes 是根据资源请求来做这个 分类[的](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)[集装箱](https://kubernetes.io/docs/concepts/containers/)在该 Pod 中，以及这些请求与资源限制的关系。这被称为[服务质量](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/) (QoS) 类。Kubernetes 根据其组件容器的资源请求和限制为每个 Pod 分配一个 QoS 等级。Kubernetes 使用 QoS 类来决定从遇到 [节点压力的](https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/)节点中驱逐哪些 Pod 。可能的 QoS 类是`Guaranteed`、`Burstable`和`BestEffort`。当一个 Node 耗尽资源时，Kubernetes 将首先驱逐`BestEffort`在该 Node 上运行的 Pod，然后驱逐Pod `Burstable`，最后驱逐`Guaranteed`Pod。当这种驱逐是由于资源压力时，只有超出资源请求的 Pod 才是驱逐的候选对象。

##### 保证[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#guaranteed)

`Guaranteed`具有最严格的资源限制并且最不可能面临驱逐的Pod 。保证它们不会被杀死，直到它们超过它们的限制或者没有可以从节点抢占的低优先级 Pod。他们可能不会获得超出其指定限制的资源。这些 Pod 还可以使用 [`static`](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#static-policy)CPU 管理策略来使用独占 CPU。

###### 标准[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#criteria)

为 Pod 赋予 QoS 类`Guaranteed`：

- Pod 中的每个 Container 都必须有内存限制和内存请求。
- 对于 Pod 中的每个容器，内存限制必须等于内存请求。
- Pod 中的每个容器都必须有一个 CPU 限制和一个 CPU 请求。
- 对于 Pod 中的每个容器，CPU 限制必须等于 CPU 请求。

##### 可爆[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#burstable)

Pod 有`Burstable`一些基于请求的下限资源保证，但不需要特定的限制。如果未指定限制，则默认为与节点容量相当的限制，这允许 Pod 在资源可用时灵活地增加其资源。当由于Node资源压力导致Pod被驱逐时，只有在所有`BestEffort`Pod被驱逐后，这些Pod才会被驱逐。因为`Burstable`Pod 可以包含没有资源限制或请求的容器，所以 Pod`Burstable`可以尝试使用任意数量的节点资源。

###### 标准[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#criteria-1)

如果满足以下条件，Pod 将获得 QoS 等级`Burstable`：

- Pod 不符合 QoS 等级的标准`Guaranteed`。
- Pod 中至少有一个 Container 有内存或 CPU 请求或限制。

##### 最大努力[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#besteffort)

QoS 类中的 Pod`BestEffort`可以使用未专门分配给其他 QoS 类中的 Pod 的节点资源。例如，如果您有一个节点有 16 个 CPU 内核可供 kubelet 使用，并且您将 4 个 CPU 内核分配给一个 Pod `Guaranteed`，那么 QoS 类中的一个 Pod`BestEffort` 可以尝试使用剩余 12 个 CPU 内核中的任意数量。

`BestEffort`如果节点面临资源压力，kubelet 更愿意驱逐Pod。

###### 标准[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#criteria-2)

如果Pod`BestEffort`不满足 或 的条件，则它的`Guaranteed` QoS等级为`Burstable`。换句话说，`BestEffort`只有当 Pod 中的 Container 都没有内存限制或内存请求，并且 Pod 中的 Container 都没有 CPU 限制或 CPU 请求时，Pod 才存在。Pod 中的容器可以请求其他资源（不是 CPU 或内存）并且仍然被归类为 `BestEffort`.

#### 某些行为独立于 QoS 类[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#class-independent-behavior)

某些行为独立于 Kubernetes 分配的 QoS 类。例如：

- 任何超过资源限制的容器都将被 kubelet 杀死并重新启动，而不会影响该 Pod 中的其他容器。
    
- 如果一个 Container 超出了它的资源请求，它运行的节点面临资源压力，它所在的 Pod 就会成为驱逐的候选[者](https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/)。如果发生这种情况，Pod 中的所有 Container 都将被终止。Kubernetes 可能会创建一个替换 Pod，通常在不同的节点上。
    
- Pod的资源请求等于其组件Container的资源请求之和，Pod的资源限制等于其组件Container的资源限制之和。
    
- [kube-scheduler 在选择要抢占的](https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption)Pod 时不考虑 QoS 等级 。当集群没有足够的资源来运行您定义的所有 Pod 时，就会发生抢占。
    

#### 下一步是什么[](https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#what-s-next)

- 了解[Pod 和容器的资源管理](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/)。
- 了解[节点压力驱逐](https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/)。
- 了解[Pod 优先级和抢占](https://kubernetes.io/docs/concepts/scheduling-eviction/pod-priority-preemption/)。
- 了解[Pod 中断](https://kubernetes.io/docs/concepts/workload/pods/disruptions/)。
- 了解如何将[内存资源分配给容器和 Pod](https://kubernetes.io/docs/tasks/configure-pod-container/assign-memory-resource/)。
- 了解如何将[CPU 资源分配给容器和 Pod](https://kubernetes.io/docs/tasks/configure-pod-container/assign-cpu-resource/)。
- 了解如何[为 Pod 配置服务质量](https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/)。



### 用户命名空间

**特性状态：** `Kubernetes v1.25 [alpha]`

本页解释了在 Kubernetes Pod 中如何使用用户命名空间。 用户命名空间将容器内运行的用户与主机中的用户隔离开来。

在容器中以 root 身份运行的进程可以在主机中以不同的（非 root）用户身份运行； 换句话说，该进程在用户命名空间内的操作具有完全的权限， 但在命名空间外的操作是无特权的。

你可以使用这个功能来减少被破坏的容器对主机或同一节点中的其他 Pod 的破坏。 有[几个安全漏洞](https://github.com/kubernetes/enhancements/tree/217d790720c5aef09b8bd4d6ca96284a0affe6c2/keps/sig-node/127-user-namespaces#motivation)被评为 **高** 或 **重要**， 当用户命名空间处于激活状态时，这些漏洞是无法被利用的。 预计用户命名空间也会减轻一些未来的漏洞。

#### 准备开始[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/user-namespaces/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B)

🛇 本条目指向第三方项目或产品，而该项目（产品）不是 Kubernetes 的一部分。[更多信息](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/user-namespaces/#third-party-content-disclaimer)

这是一个只对 Linux 有效的功能特性。此外，需要在[容器运行时](https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes)提供支持， 才能在 Kubernetes 无状态 Pod 中使用这一功能：

- CRI-O：v1.25 版已经支持用户命名空间。
- containerd：计划在 1.7 版本中支持。更多细节请参见 containerd 问题 [#7063](https://github.com/containerd/containerd/issues/7063)。

目前 [cri-dockerd 没有计划](https://github.com/Mirantis/cri-dockerd/issues/74)支持此功能。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/user-namespaces/#introduction)

用户命名空间是一个 Linux 功能，允许将容器中的用户映射到主机中的不同用户。 此外，在某用户命名空间中授予 Pod 的权能只在该命名空间中有效，在该命名空间之外无效。

一个 Pod 可以通过将 `pod.spec.hostUsers` 字段设置为 `false` 来选择使用用户命名空间。

kubelet 将挑选 Pod 所映射的主机 UID/GID， 并将以保证同一节点上没有两个无状态 Pod 使用相同的映射的方式进行。

`pod.spec` 中的 `runAsUser`、`runAsGroup`、`fsGroup` 等字段总是指的是容器内的用户。 启用该功能时，有效的 UID/GID 在 0-65535 范围内。这以限制适用于文件和进程（`runAsUser`、`runAsGroup` 等）。

使用这个范围之外的 UID/GID 的文件将被视为属于溢出 ID， 通常是 65534（配置在 `/proc/sys/kernel/overflowuid和/proc/sys/kernel/overflowgid`）。 然而，即使以 65534 用户/组的身份运行，也不可能修改这些文件。

大多数需要以 root 身份运行但不访问其他主机命名空间或资源的应用程序， 在用户命名空间被启用时，应该可以继续正常运行，不需要做任何改变。

#### 了解无状态 Pod 的用户命名空间[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/user-namespaces/#understanding-user-namespaces-for-stateless-pods)

一些容器运行时的默认配置（如 Docker Engine、containerd、CRI-O）使用 Linux 命名空间进行隔离。 其他技术也存在，也可以与这些运行时（例如，Kata Containers 使用虚拟机而不是 Linux 命名空间）结合使用。 本页适用于使用 Linux 命名空间进行隔离的容器运行时。

在创建 Pod 时，默认情况下会使用几个新的命名空间进行隔离： 一个网络命名空间来隔离容器网络，一个 PID 命名空间来隔离进程视图等等。 如果使用了一个用户命名空间，这将把容器中的用户与节点中的用户隔离开来。

这意味着容器可以以 root 身份运行，并将该身份映射到主机上的一个非 root 用户。 在容器内，进程会认为它是以 root 身份运行的（因此像 `apt`、`yum` 等工具可以正常工作）， 而实际上该进程在主机上没有权限。 你可以验证这一点，例如，如果你从主机上执行 `ps aux` 来检查容器进程是以哪个用户运行的。 `ps` 显示的用户与你在容器内执行 `id` 命令时看到的用户是不一样的。

这种抽象限制了可能发生的情况，例如，容器设法逃逸到主机上时的后果。 鉴于容器是作为主机上的一个非特权用户运行的，它能对主机做的事情是有限的。

此外，由于每个 Pod 上的用户将被映射到主机中不同的非重叠用户， 他们对其他 Pod 可以执行的操作也是有限的。

授予一个 Pod 的权能也被限制在 Pod 的用户命名空间内， 并且在这一命名空间之外大多无效，有些甚至完全无效。这里有两个例子：

- `CAP_SYS_MODULE` 若被授予一个使用用户命名空间的 Pod 则没有任何效果，这个 Pod 不能加载内核模块。
- `CAP_SYS_ADMIN` 只限于 Pod 所在的用户命名空间，在该命名空间之外无效。

在不使用用户命名空间的情况下，以 root 账号运行的容器，在容器逃逸时，在节点上有 root 权限。 而且如果某些权能被授予了某容器，这些权能在宿主机上也是有效的。 当我们使用用户命名空间时，这些都不再成立。

如果你想知道关于使用用户命名空间时的更多变化细节，请参见 `man 7 user_namespaces`。

#### 设置一个节点以支持用户命名空间[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/user-namespaces/#set-up-a-node-to-support-user-namespaces)

建议主机的文件和主机的进程使用 0-65535 范围内的 UID/GID。

kubelet 会把高于这个范围的 UID/GID 分配给 Pod。 因此，为了保证尽可能多的隔离，主机的文件和主机的进程所使用的 UID/GID 应该在 0-65535 范围内。

请注意，这个建议对减轻 [CVE-2021-25741](https://github.com/kubernetes/kubernetes/issues/104980) 等 CVE 的影响很重要； 在这些 CVE 中，Pod 有可能读取主机中的任意文件。 如果 Pod 和主机的 UID/GID 不重叠，Pod 能够做的事情就会受到限制： Pod的 UID/GID 不会与主机的文件所有者/组相匹配。

#### 限制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/user-namespaces/#limitations)

当 Pod 使用用户命名空间时，不允许 Pod 使用其他主机命名空间。 特别是，如果你设置了 `hostUsers: false`，那么你就不可以设置如下属性：

- `hostNetwork: true`
- `hostIPC: true`
- `hostPID: true`

Pod 完全不使用卷是被允许的；如果使用卷，只允许使用以下卷类型：

- configmap
- secret
- projected
- downwardAPI
- emptyDir

为了保证 Pod 可以读取这些卷中的文件，卷的创建操作就像你为 Pod 指定了 `.spec.securityContext.fsGroup` 为 `0` 一样。 如果该属性被设定为不同值，那么这个不同值当然也会被使用。

作为一个副产品，这些卷的文件夹和文件将具有所给组的权限， 即使 `defaultMode` 或 volumes 的特定项目的 `mode` 被指定为没有组的权限。 例如，不可以在挂载这些卷时使其文件只允许所有者访问。

### Downward API

有两种方法可以将 Pod 和容器字段暴露给运行中的容器：环境变量和由特殊卷类型承载的文件。 这两种暴露 Pod 和容器字段的方法统称为 Downward API。

对于容器来说，在不与 Kubernetes 过度耦合的情况下，拥有关于自身的信息有时是很有用的。 **Downward API** 允许容器在不使用 Kubernetes 客户端或 API 服务器的情况下获得自己或集群的信息。

例如，现有应用程序假设某特定的周知的环境变量是存在的，其中包含唯一标识符。 一种方法是对应用程序进行封装，但这很繁琐且容易出错，并且违背了低耦合的目标。 更好的选择是使用 Pod 名称作为标识符，并将 Pod 名称注入到周知的环境变量中。

在 Kubernetes 中，有两种方法可以将 Pod 和容器字段暴露给运行中的容器：

- 作为[环境变量](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/environment-variable-expose-pod-information/)
- 作为 [`downwardAPI` 卷中的文件](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)

这两种暴露 Pod 和容器字段的方式统称为 **Downward API**。

#### 可用字段[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/#available-fields)

只有部分 Kubernetes API 字段可以通过 Downward API 使用。本节列出了你可以使用的字段。

你可以使用 `fieldRef` 传递来自可用的 Pod 级字段的信息。在 API 层面，一个 Pod 的 `spec` 总是定义了至少一个 [Container](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container)。 你可以使用 `resourceFieldRef` 传递来自可用的 Container 级字段的信息。

##### 可通过 `fieldRef` 获得的信息[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/#downwardapi-fieldRef)

对于大多数 Pod 级别的字段，你可以将它们作为环境变量或使用 `downwardAPI` 卷提供给容器。 通过这两种机制可用的字段有：

`metadata.name`

Pod 的名称

`metadata.namespace`

Pod 的[命名空间](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/)

`metadata.uid`

Pod 的唯一 ID

`metadata.annotations['<KEY>']`

Pod 的[注解](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/) `<KEY>` 的值（例如：`metadata.annotations['myannotation']`）

`metadata.labels['<KEY>']`

Pod 的[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/) `<KEY>` 的值（例如：`metadata.labels['mylabel']`）

以下信息可以通过环境变量获得，但**不能作为 `downwardAPI` 卷 `fieldRef`** 获得：

`spec.serviceAccountName`

Pod 的[服务账号](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/)名称

`spec.nodeName`

Pod 运行时所处的[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)名称

`status.hostIP`

Pod 所在节点的主 IP 地址

`status.podIP`

Pod 的主 IP 地址（通常是其 IPv4 地址）

以下信息可以通过 `downwardAPI` 卷 `fieldRef` 获得，但**不能作为环境变量**获得：

`metadata.labels`

Pod 的所有标签，格式为 `标签键名="转义后的标签值"`，每行一个标签

`metadata.annotations`

Pod 的全部注解，格式为 `注解键名="转义后的注解值"`，每行一个注解

##### 可通过 `resourceFieldRef` 获得的信息[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/#downwardapi-resourceFieldRef)

`resource: limits.cpu`

容器的 CPU 限制值

`resource: requests.cpu`

容器的 CPU 请求值

`resource: limits.memory`

容器的内存限制值

`resource: requests.memory`

容器的内存请求值

`resource: limits.hugepages-*`

容器的巨页限制值（前提是启用了 `DownwardAPIHugePages` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)）

`resource: requests.hugepages-*`

容器的巨页请求值（前提是启用了 `DownwardAPIHugePages` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)）

`resource: limits.ephemeral-storage`

容器的临时存储的限制值

`resource: requests.ephemeral-storage`

容器的临时存储的请求值

###### 资源限制的后备信息[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/#fallback-information-for-resource-limits)

如果没有为容器指定 CPU 和内存限制时尝试使用 Downward API 暴露该信息，那么 kubelet 默认会根据 [节点可分配资源](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable) 计算并暴露 CPU 和内存的最大可分配值。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/downward-api/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

你可以阅读有关 [`downwardAPI` 卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#downwardapi)的内容。

你可以尝试使用 Downward API 暴露容器或 Pod 级别的信息：

- 作为[环境变量](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/environment-variable-expose-pod-information/)
- 作为 [`downwardAPI` 卷中的文件](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)

### [工作负载资源](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/)


#### [Deployments](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)
一个 Deployment 为 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 和 [ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 提供声明式的更新能力。

你负责描述 Deployment 中的 **目标状态**，而 Deployment [控制器（Controller）](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 以受控速率更改实际状态， 使其变为期望状态。你可以定义 Deployment 以创建新的 ReplicaSet，或删除现有 Deployment， 并通过新的 Deployment 收养其资源。

**说明：**

不要管理 Deployment 所拥有的 ReplicaSet 。 如果存在下面未覆盖的使用场景，请考虑在 Kubernetes 仓库中提出 Issue。

##### 用例[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#%E7%94%A8%E4%BE%8B)

以下是 Deployments 的典型用例：

- [创建 Deployment 以将 ReplicaSet 上线](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#creating-a-deployment)。ReplicaSet 在后台创建 Pod。 检查 ReplicaSet 的上线状态，查看其是否成功。
- 通过更新 Deployment 的 PodTemplateSpec，[声明 Pod 的新状态](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#updating-a-deployment) 。 新的 ReplicaSet 会被创建，Deployment 以受控速率将 Pod 从旧 ReplicaSet 迁移到新 ReplicaSet。 每个新的 ReplicaSet 都会更新 Deployment 的修订版本。

- 如果 Deployment 的当前状态不稳定，[回滚到较早的 Deployment 版本](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment)。 每次回滚都会更新 Deployment 的修订版本。
- [扩大 Deployment 规模以承担更多负载](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment)。
- [暂停 Deployment 的上线](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment) 以应用对 PodTemplateSpec 所作的多项修改， 然后恢复其执行以启动新的上线版本。
- [使用 Deployment 状态](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#deployment-status)来判定上线过程是否出现停滞。
- [清理较旧的不再需要的 ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#clean-up-policy) 。

##### 创建 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#creating-a-deployment)

下面是一个 Deployment 示例。其中创建了一个 ReplicaSet，负责启动三个 `nginx` Pod：

[`controllers/nginx-deployment.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/nginx-deployment.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/nginx-deployment.yaml to clipboard")

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
```

在该例中：

- 创建名为 `nginx-deployment`（由 `.metadata.name` 字段标明）的 Deployment。 该名称将成为后续创建 ReplicaSet 和 Pod 的命名基础。 参阅[编写 Deployment 规约](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec)获取更多详细信息。
    
- 该 Deployment 创建一个 ReplicaSet，它创建三个（由 `.spec.replicas` 字段标明）Pod 副本。
    
- `.spec.selector` 字段定义所创建的 ReplicaSet 如何查找要管理的 Pod。 在这里，你选择在 Pod 模板中定义的标签（`app: nginx`）。 不过，更复杂的选择规则是也可能的，只要 Pod 模板本身满足所给规则即可。
    
    **说明：**
    
    `.spec.selector.matchLabels` 字段是 `{key,value}` 键值对映射。 在 `matchLabels` 映射中的每个 `{key,value}` 映射等效于 `matchExpressions` 中的一个元素， 即其 `key` 字段是 “key”，`operator` 为 “In”，`values` 数组仅包含 “value”。 在 `matchLabels` 和 `matchExpressions` 中给出的所有条件都必须满足才能匹配。
    

- `template` 字段包含以下子字段：
    - Pod 被使用 `.metadata.labels` 字段打上 `app: nginx` 标签。
    - Pod 模板规约（即 `.template.spec` 字段）指示 Pod 运行一个 `nginx` 容器， 该容器运行版本为 1.14.2 的 `nginx` [Docker Hub](https://hub.docker.com/) 镜像。
    - 创建一个容器并使用 `.spec.template.spec.containers[0].name` 字段将其命名为 `nginx`。

开始之前，请确保的 Kubernetes 集群已启动并运行。 按照以下步骤创建上述 Deployment ：

1. 通过运行以下命令创建 Deployment ：
    
    ```shell
    kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
    ```
    

2. 运行 `kubectl get deployments` 检查 Deployment 是否已创建。 如果仍在创建 Deployment，则输出类似于：
    
    ```
    NAME               READY   UP-TO-DATE   AVAILABLE   AGE
    nginx-deployment   0/3     0            0           1s
    ```
    
    在检查集群中的 Deployment 时，所显示的字段有：
    
    - `NAME` 列出了名字空间中 Deployment 的名称。
    - `READY` 显示应用程序的可用的“副本”数。显示的模式是“就绪个数/期望个数”。
    - `UP-TO-DATE` 显示为了达到期望状态已经更新的副本数。
    - `AVAILABLE` 显示应用可供用户使用的副本数。
    - `AGE` 显示应用程序运行的时间。
    
    请注意期望副本数是根据 `.spec.replicas` 字段设置 3。
    

3. 要查看 Deployment 上线状态，运行 `kubectl rollout status deployment/nginx-deployment`。
    
    输出类似于：
    
    ```
    Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
    deployment "nginx-deployment" successfully rolled out
    ```
    

4. 几秒钟后再次运行 `kubectl get deployments`。输出类似于：
    
    ```
    NAME               READY   UP-TO-DATE   AVAILABLE   AGE
    nginx-deployment   3/3     3            3           18s
    ```
    
    注意 Deployment 已创建全部三个副本，并且所有副本都是最新的（它们包含最新的 Pod 模板） 并且可用。
    

5. 要查看 Deployment 创建的 ReplicaSet（`rs`），运行 `kubectl get rs`。 输出类似于：
    
    ```
    NAME                          DESIRED   CURRENT   READY   AGE
    nginx-deployment-75675f5897   3         3         3       18s
    ```
    
    ReplicaSet 输出中包含以下字段：
    
    - `NAME` 列出名字空间中 ReplicaSet 的名称；
    - `DESIRED` 显示应用的期望副本个数，即在创建 Deployment 时所定义的值。 此为期望状态；
    - `CURRENT` 显示当前运行状态中的副本个数；
    - `READY` 显示应用中有多少副本可以为用户提供服务；
    - `AGE` 显示应用已经运行的时间长度。
    
    注意 ReplicaSet 的名称格式始终为 `[Deployment 名称]-[哈希]`。 该名称将成为所创建的 Pod 的命名基础。 其中的`哈希`字符串与 ReplicaSet 上的 `pod-template-hash` 标签一致。
    

6. 要查看每个 Pod 自动生成的标签，运行 `kubectl get pods --show-labels`。 输出类似于：
    
    ```
    NAME                                READY     STATUS    RESTARTS   AGE       LABELS
    nginx-deployment-75675f5897-7ci7o   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
    nginx-deployment-75675f5897-kzszj   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
    nginx-deployment-75675f5897-qqcnn   1/1       Running   0          18s       app=nginx,pod-template-hash=3123191453
    ```
    
    所创建的 ReplicaSet 确保总是存在三个 `nginx` Pod。
    

**说明：**

你必须在 Deployment 中指定适当的选择算符和 Pod 模板标签（在本例中为 `app: nginx`）。 标签或者选择算符不要与其他控制器（包括其他 Deployment 和 StatefulSet）重叠。 Kubernetes 不会阻止你这样做，但是如果多个控制器具有重叠的选择算符， 它们可能会发生冲突执行难以预料的操作。

###### Pod-template-hash 标签[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#pod-template-hash-%E6%A0%87%E7%AD%BE)

**注意：**

不要更改此标签。

Deployment 控制器将 `pod-template-hash` 标签添加到 Deployment 所创建或收留的每个 ReplicaSet 。

此标签可确保 Deployment 的子 ReplicaSets 不重叠。 标签是通过对 ReplicaSet 的 `PodTemplate` 进行哈希处理。 所生成的哈希值被添加到 ReplicaSet 选择算符、Pod 模板标签，并存在于在 ReplicaSet 可能拥有的任何现有 Pod 中。

##### 更新 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#updating-a-deployment)

**说明：**

仅当 Deployment Pod 模板（即 `.spec.template`）发生改变时，例如模板的标签或容器镜像被更新， 才会触发 Deployment 上线。其他更新（如对 Deployment 执行扩缩容的操作）不会触发上线动作。

按照以下步骤更新 Deployment：

1. 先来更新 nginx Pod 以使用 `nginx:1.16.1` 镜像，而不是 `nginx:1.14.2` 镜像。
    
    ```shell
    kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.16.1
    ```
    
    或者使用下面的命令：
    
    ```shell
    kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment image updated
    ```
    
    或者，可以对 Deployment 执行 `edit` 操作并将 `.spec.template.spec.containers[0].image` 从 `nginx:1.14.2` 更改至 `nginx:1.16.1`。
    
    ```shell
    kubectl edit deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment edited
    ```
    

2. 要查看上线状态，运行：
    
    ```shell
    kubectl rollout status deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
    ```
    
    或者
    
    ```
    deployment "nginx-deployment" successfully rolled out
    ```
    

获取关于已更新的 Deployment 的更多信息：

- 在上线成功后，可以通过运行 `kubectl get deployments` 来查看 Deployment： 输出类似于：
    
    ```ini
    NAME               READY   UP-TO-DATE   AVAILABLE   AGE
    nginx-deployment   3/3     3            3           36s
    ```
    

- 运行 `kubectl get rs` 以查看 Deployment 通过创建新的 ReplicaSet 并将其扩容到 3 个副本并将旧 ReplicaSet 缩容到 0 个副本完成了 Pod 的更新操作：
    
    ```shell
    kubectl get rs
    ```
    
    输出类似于：
    
    ```
    NAME                          DESIRED   CURRENT   READY   AGE
    nginx-deployment-1564180365   3         3         3       6s
    nginx-deployment-2035384211   0         0         0       36s
    ```
    

- 现在运行 `get pods` 应仅显示新的 Pod：
    
    ```shell
    kubectl get pods
    ```
    
    输出类似于：
    
    ```
    NAME                                READY     STATUS    RESTARTS   AGE
    nginx-deployment-1564180365-khku8   1/1       Running   0          14s
    nginx-deployment-1564180365-nacti   1/1       Running   0          14s
    nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
    ```
    
    下次要更新这些 Pod 时，只需再次更新 Deployment Pod 模板即可。
    
    Deployment 可确保在更新时仅关闭一定数量的 Pod。默认情况下，它确保至少所需 Pod 的 75% 处于运行状态（最大不可用比例为 25%）。
    
    Deployment 还确保仅所创建 Pod 数量只可能比期望 Pod 数高一点点。 默认情况下，它可确保启动的 Pod 个数比期望个数最多多出 125%（最大峰值 25%）。
    
    例如，如果仔细查看上述 Deployment ，将看到它首先创建了一个新的 Pod，然后删除旧的 Pod， 并创建了新的 Pod。它不会杀死旧 Pod，直到有足够数量的新 Pod 已经出现。 在足够数量的旧 Pod 被杀死前并没有创建新 Pod。它确保至少 3 个 Pod 可用， 同时最多总共 4 个 Pod 可用。 当 Deployment 设置为 4 个副本时，Pod 的个数会介于 3 和 5 之间。
    

- 获取 Deployment 的更多信息
    
    ```shell
    kubectl describe deployments
    ```
    
    输出类似于：
    
    ```
    Name:                   nginx-deployment
    Namespace:              default
    CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
    Labels:                 app=nginx
    Annotations:            deployment.kubernetes.io/revision=2
    Selector:               app=nginx
    Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
    StrategyType:           RollingUpdate
    MinReadySeconds:        0
    RollingUpdateStrategy:  25% max unavailable, 25% max surge
    Pod Template:
      Labels:  app=nginx
       Containers:
        nginx:
          Image:        nginx:1.16.1
          Port:         80/TCP
          Environment:  <none>
          Mounts:       <none>
        Volumes:        <none>
      Conditions:
        Type           Status  Reason
        ----           ------  ------
        Available      True    MinimumReplicasAvailable
        Progressing    True    NewReplicaSetAvailable
      OldReplicaSets:  <none>
      NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
      Events:
        Type    Reason             Age   From                   Message
        ----    ------             ----  ----                   -------
        Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
        Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
        Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
        Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
        Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
        Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
        Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
    ```
    
    可以看到，当第一次创建 Deployment 时，它创建了一个 ReplicaSet（`nginx-deployment-2035384211`） 并将其直接扩容至 3 个副本。更新 Deployment 时，它创建了一个新的 ReplicaSet （nginx-deployment-1564180365），并将其扩容为 1，等待其就绪；然后将旧 ReplicaSet 缩容到 2， 将新的 ReplicaSet 扩容到 2 以便至少有 3 个 Pod 可用且最多创建 4 个 Pod。 然后，它使用相同的滚动更新策略继续对新的 ReplicaSet 扩容并对旧的 ReplicaSet 缩容。 最后，你将有 3 个可用的副本在新的 ReplicaSet 中，旧 ReplicaSet 将缩容到 0。
    

**说明：**

Kubernetes 在计算 `availableReplicas` 数值时不考虑终止过程中的 Pod， `availableReplicas` 的值一定介于 `replicas - maxUnavailable` 和 `replicas + maxSurge` 之间。 因此，你可能在上线期间看到 Pod 个数比预期的多，Deployment 所消耗的总的资源也大于 `replicas + maxSurge` 个 Pod 所用的资源，直到被终止的 Pod 所设置的 `terminationGracePeriodSeconds` 到期为止。

###### 翻转（多 Deployment 动态更新）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#%E7%BF%BB%E8%BD%AC-%E5%A4%9A-deployment-%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0)

Deployment 控制器每次注意到新的 Deployment 时，都会创建一个 ReplicaSet 以启动所需的 Pod。 如果更新了 Deployment，则控制标签匹配 `.spec.selector` 但模板不匹配 `.spec.template` 的 Pod 的现有 ReplicaSet 被缩容。 最终，新的 ReplicaSet 缩放为 `.spec.replicas` 个副本， 所有旧 ReplicaSets 缩放为 0 个副本。

当 Deployment 正在上线时被更新，Deployment 会针对更新创建一个新的 ReplicaSet 并开始对其扩容，之前正在被扩容的 ReplicaSet 会被翻转，添加到旧 ReplicaSets 列表 并开始缩容。

例如，假定你在创建一个 Deployment 以生成 `nginx:1.14.2` 的 5 个副本，但接下来 更新 Deployment 以创建 5 个 `nginx:1.16.1` 的副本，而此时只有 3 个 `nginx:1.14.2` 副本已创建。在这种情况下，Deployment 会立即开始杀死 3 个 `nginx:1.14.2` Pod， 并开始创建 `nginx:1.16.1` Pod。它不会等待 `nginx:1.14.2` 的 5 个副本都创建完成后才开始执行变更动作。

###### 更改标签选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#label-selector-updates)

通常不鼓励更新标签选择算符。建议你提前规划选择算符。 在任何情况下，如果需要更新标签选择算符，请格外小心， 并确保自己了解这背后可能发生的所有事情。

**说明：**

在 API 版本 `apps/v1` 中，Deployment 标签选择算符在创建后是不可变的。

- 添加选择算符时要求使用新标签更新 Deployment 规约中的 Pod 模板标签，否则将返回验证错误。 此更改是非重叠的，也就是说新的选择算符不会选择使用旧选择算符所创建的 ReplicaSet 和 Pod， 这会导致创建新的 ReplicaSet 时所有旧 ReplicaSet 都会被孤立。
- 选择算符的更新如果更改了某个算符的键名，这会导致与添加算符时相同的行为。
- 删除选择算符的操作会删除从 Deployment 选择算符中删除现有算符。 此操作不需要更改 Pod 模板标签。现有 ReplicaSet 不会被孤立，也不会因此创建新的 ReplicaSet， 但请注意已删除的标签仍然存在于现有的 Pod 和 ReplicaSet 中。

##### 回滚 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment)

有时，你可能想要回滚 Deployment；例如，当 Deployment 不稳定时（例如进入反复崩溃状态）。 默认情况下，Deployment 的所有上线记录都保留在系统中，以便可以随时回滚 （你可以通过修改修订历史记录限制来更改这一约束）。

**说明：**

Deployment 被触发上线时，系统就会创建 Deployment 的新的修订版本。 这意味着仅当 Deployment 的 Pod 模板（`.spec.template`）发生更改时，才会创建新修订版本 -- 例如，模板的标签或容器镜像发生变化。 其他更新，如 Deployment 的扩缩容操作不会创建 Deployment 修订版本。 这是为了方便同时执行手动缩放或自动缩放。 换言之，当你回滚到较早的修订版本时，只有 Deployment 的 Pod 模板部分会被回滚。

- 假设你在更新 Deployment 时犯了一个拼写错误，将镜像名称命名设置为 `nginx:1.161` 而不是 `nginx:1.16.1`：
    
    ```shell
    kubectl set image deployment/nginx-deployment nginx=nginx:1.161
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment image updated
    ```
    

- 此上线进程会出现停滞。你可以通过检查上线状态来验证：
    
    ```shell
    kubectl rollout status deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
    ```
    

- 按 Ctrl-C 停止上述上线状态观测。有关上线停滞的详细信息，[参考这里](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#deployment-status)。

- 你可以看到旧的副本有两个（`nginx-deployment-1564180365` 和 `nginx-deployment-2035384211`）， 新的副本有 1 个（`nginx-deployment-3066724191`）：
    
    ```shell
    kubectl get rs
    ```
    
    输出类似于：
    
    ```
    NAME                          DESIRED   CURRENT   READY   AGE
    nginx-deployment-1564180365   3         3         3       25s
    nginx-deployment-2035384211   0         0         0       36s
    nginx-deployment-3066724191   1         1         0       6s
    ```
    

- 查看所创建的 Pod，你会注意到新 ReplicaSet 所创建的 1 个 Pod 卡顿在镜像拉取循环中。
    
    ```shell
    kubectl get pods
    ```
    
    输出类似于：
    
    ```
    NAME                                READY     STATUS             RESTARTS   AGE
    nginx-deployment-1564180365-70iae   1/1       Running            0          25s
    nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
    nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
    nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
    ```
    
    **说明：**
    
    Deployment 控制器自动停止有问题的上线过程，并停止对新的 ReplicaSet 扩容。 这行为取决于所指定的 rollingUpdate 参数（具体为 `maxUnavailable`）。 默认情况下，Kubernetes 将此值设置为 25%。
    

- 获取 Deployment 描述信息：
    
    ```shell
    kubectl describe deployment
    ```
    
    输出类似于：
    
    ```
    Name:           nginx-deployment
    Namespace:      default
    CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
    Labels:         app=nginx
    Selector:       app=nginx
    Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
    StrategyType:       RollingUpdate
    MinReadySeconds:    0
    RollingUpdateStrategy:  25% max unavailable, 25% max surge
    Pod Template:
      Labels:  app=nginx
      Containers:
       nginx:
        Image:        nginx:1.161
        Port:         80/TCP
        Host Port:    0/TCP
        Environment:  <none>
        Mounts:       <none>
      Volumes:        <none>
    Conditions:
      Type           Status  Reason
      ----           ------  ------
      Available      True    MinimumReplicasAvailable
      Progressing    True    ReplicaSetUpdated
    OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
    NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
    Events:
      FirstSeen LastSeen    Count   From                    SubObjectPath   Type        Reason              Message
      --------- --------    -----   ----                    -------------   --------    ------              -------
      1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
      22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
      22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
      22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
      21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
      21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
      13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
      13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
    ```
    
    要解决此问题，需要回滚到以前稳定的 Deployment 版本。
    

###### 检查 Deployment 上线历史[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#%E6%A3%80%E6%9F%A5-deployment-%E4%B8%8A%E7%BA%BF%E5%8E%86%E5%8F%B2)

按照如下步骤检查回滚历史：

1. 首先，检查 Deployment 修订历史：
    
    ```shell
    kubectl rollout history deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    deployments "nginx-deployment"
    REVISION    CHANGE-CAUSE
    1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml
    2           kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
    3           kubectl set image deployment/nginx-deployment nginx=nginx:1.161
    ```
    
    `CHANGE-CAUSE` 的内容是从 Deployment 的 `kubernetes.io/change-cause` 注解复制过来的。 复制动作发生在修订版本创建时。你可以通过以下方式设置 `CHANGE-CAUSE` 消息：
    
    - 使用 `kubectl annotate deployment/nginx-deployment kubernetes.io/change-cause="image updated to 1.16.1"` 为 Deployment 添加注解。
    - 手动编辑资源的清单。

2. 要查看修订历史的详细信息，运行：
    
    ```shell
    kubectl rollout history deployment/nginx-deployment --revision=2
    ```
    
    输出类似于：
    
    ```
    deployments "nginx-deployment" revision 2
      Labels:       app=nginx
              pod-template-hash=1159050644
      Annotations:  kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
      Containers:
       nginx:
        Image:      nginx:1.16.1
        Port:       80/TCP
         QoS Tier:
            cpu:      BestEffort
            memory:   BestEffort
        Environment Variables:      <none>
      No volumes.
    ```
    

###### 回滚到之前的修订版本[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#rolling-back-to-a-previous-revision)

按照下面给出的步骤将 Deployment 从当前版本回滚到以前的版本（即版本 2）。

1. 假定现在你已决定撤消当前上线并回滚到以前的修订版本：
    
    ```shell
    kubectl rollout undo deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment rolled back
    ```
    
    或者，你也可以通过使用 `--to-revision` 来回滚到特定修订版本：
    
    ```shell
    kubectl rollout undo deployment/nginx-deployment --to-revision=2
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment rolled back
    ```
    
    与回滚相关的指令的更详细信息，请参考 [`kubectl rollout`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#rollout)。
    
    现在，Deployment 正在回滚到以前的稳定版本。正如你所看到的，Deployment 控制器生成了回滚到修订版本 2 的 `DeploymentRollback` 事件。
    

2. 检查回滚是否成功以及 Deployment 是否正在运行，运行：
    
    ```shell
    kubectl get deployment nginx-deployment
    ```
    
    输出类似于：
    
    ```
    NAME               READY   UP-TO-DATE   AVAILABLE   AGE
    nginx-deployment   3/3     3            3           30m
    ```
    

3. 获取 Deployment 描述信息：
    
    ```shell
    kubectl describe deployment nginx-deployment
    ```
    
    输出类似于：
    
    ```
    Name:                   nginx-deployment
    Namespace:              default
    CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
    Labels:                 app=nginx
    Annotations:            deployment.kubernetes.io/revision=4
                            kubernetes.io/change-cause=kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
    Selector:               app=nginx
    Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
    StrategyType:           RollingUpdate
    MinReadySeconds:        0
    RollingUpdateStrategy:  25% max unavailable, 25% max surge
    Pod Template:
      Labels:  app=nginx
      Containers:
       nginx:
        Image:        nginx:1.16.1
        Port:         80/TCP
        Host Port:    0/TCP
        Environment:  <none>
        Mounts:       <none>
      Volumes:        <none>
    Conditions:
      Type           Status  Reason
      ----           ------  ------
      Available      True    MinimumReplicasAvailable
      Progressing    True    NewReplicaSetAvailable
    OldReplicaSets:  <none>
    NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
    Events:
      Type    Reason              Age   From                   Message
      ----    ------              ----  ----                   -------
      Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
      Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
      Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment "nginx-deployment" to revision 2
      Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
    ```
    

##### 缩放 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment)

你可以使用如下指令缩放 Deployment：

```shell
kubectl scale deployment/nginx-deployment --replicas=10
```

输出类似于：

```
deployment.apps/nginx-deployment scaled
```

假设集群启用了[Pod 的水平自动缩放](https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/)， 你可以为 Deployment 设置自动缩放器，并基于现有 Pod 的 CPU 利用率选择要运行的 Pod 个数下限和上限。

```shell
kubectl autoscale deployment/nginx-deployment --min=10 --max=15 --cpu-percent=80
```

输出类似于：

```
deployment.apps/nginx-deployment scaled
```

###### 比例缩放[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#proportional-scaling)

RollingUpdate 的 Deployment 支持同时运行应用程序的多个版本。 当自动缩放器缩放处于上线进程（仍在进行中或暂停）中的 RollingUpdate Deployment 时， Deployment 控制器会平衡现有的活跃状态的 ReplicaSets（含 Pod 的 ReplicaSets）中的额外副本， 以降低风险。这称为 _比例缩放（Proportional Scaling）_。

例如，你正在运行一个 10 个副本的 Deployment，其 [maxSurge](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#max-surge)\=3，[maxUnavailable](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#max-unavailable)\=2。

- 确保 Deployment 的这 10 个副本都在运行。
    
    ```shell
    kubectl get deploy
    ```
    
    输出类似于：
    
    ```
    NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
    nginx-deployment     10        10        10           10          50s
    ```
    

- 更新 Deployment 使用新镜像，碰巧该镜像无法从集群内部解析。
    
    ```shell
    kubectl set image deployment/nginx-deployment nginx=nginx:sometag
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment image updated
    ```
    

- 镜像更新使用 ReplicaSet `nginx-deployment-1989198191` 启动新的上线过程， 但由于上面提到的 `maxUnavailable` 要求，该进程被阻塞了。检查上线状态：
    
    ```shell
    kubectl get rs
    ```
    
    输出类似于：
    
    ```
    NAME                          DESIRED   CURRENT   READY     AGE
    nginx-deployment-1989198191   5         5         0         9s
    nginx-deployment-618515232    8         8         8         1m
    ```
    

- 然后，出现了新的 Deployment 扩缩请求。自动缩放器将 Deployment 副本增加到 15。 Deployment 控制器需要决定在何处添加 5 个新副本。如果未使用比例缩放，所有 5 个副本 都将添加到新的 ReplicaSet 中。使用比例缩放时，可以将额外的副本分布到所有 ReplicaSet。 较大比例的副本会被添加到拥有最多副本的 ReplicaSet，而较低比例的副本会进入到 副本较少的 ReplicaSet。所有剩下的副本都会添加到副本最多的 ReplicaSet。 具有零副本的 ReplicaSets 不会被扩容。

在上面的示例中，3 个副本被添加到旧 ReplicaSet 中，2 个副本被添加到新 ReplicaSet。 假定新的副本都很健康，上线过程最终应将所有副本迁移到新的 ReplicaSet 中。 要确认这一点，请运行：

```shell
kubectl get deploy
```

输出类似于：

```
NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     15        18        7            8           7m
```

上线状态确认了副本是如何被添加到每个 ReplicaSet 的。

```shell
kubectl get rs
```

输出类似于：

```
NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   7         7         0         7m
nginx-deployment-618515232    11        11        11        7m
```

##### 暂停、恢复 Deployment 的上线过程[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment)

在你更新一个 Deployment 的时候，或者计划更新它的时候， 你可以在触发一个或多个更新之前暂停 Deployment 的上线过程。 当你准备应用这些变更时，你可以重新恢复 Deployment 上线过程。 这样做使得你能够在暂停和恢复执行之间应用多个修补程序，而不会触发不必要的上线操作。

- 例如，对于一个刚刚创建的 Deployment：
    
    获取该 Deployment 信息：
    
    ```shell
    kubectl get deploy
    ```
    
    输出类似于：
    
    ```
    NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
    nginx     3         3         3            3           1m
    ```
    
    获取上线状态：
    
    ```shell
    kubectl get rs
    ```
    
    输出类似于：
    
    ```
    NAME               DESIRED   CURRENT   READY     AGE
    nginx-2142116321   3         3         3         1m
    ```
    

- 使用如下指令暂停上线：
    
    ```shell
    kubectl rollout pause deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment paused
    ```
    

- 接下来更新 Deployment 镜像：
    
    ```shell
    kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment image updated
    ```
    

- 注意没有新的上线被触发：
    
    ```shell
    kubectl rollout history deployment/nginx-deployment
    ```
    
    输出类似于：
    
    ```
    deployments "nginx"
    REVISION  CHANGE-CAUSE
    1   <none>
    ```
    

- 获取上线状态验证现有的 ReplicaSet 没有被更改：
    
    ```shell
    kubectl get rs
    ```
    
    输出类似于：
    
    ```
    NAME               DESIRED   CURRENT   READY     AGE
    nginx-2142116321   3         3         3         2m
    ```
    

- 你可以根据需要执行很多更新操作，例如，可以要使用的资源：
    
    ```shell
    kubectl set resources deployment/nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi
    ```
    
    输出类似于：
    
    ```
    deployment.apps/nginx-deployment resource requirements updated
    ```
    
    暂停 Deployment 上线之前的初始状态将继续发挥作用，但新的更新在 Deployment 上线被暂停期间不会产生任何效果。
    

- 最终，恢复 Deployment 上线并观察新的 ReplicaSet 的创建过程，其中包含了所应用的所有更新：
    
    ```shell
    kubectl rollout resume deployment/nginx-deployment
    ```
    
    输出类似于这样：
    
    ```
    deployment.apps/nginx-deployment resumed
    ```
    

- 观察上线的状态，直到完成。
    
    ```shell
    kubectl get rs -w
    ```
    
    输出类似于：
    
    ```
    NAME               DESIRED   CURRENT   READY     AGE
    nginx-2142116321   2         2         2         2m
    nginx-3926361531   2         2         0         6s
    nginx-3926361531   2         2         1         18s
    nginx-2142116321   1         2         2         2m
    nginx-2142116321   1         2         2         2m
    nginx-3926361531   3         2         1         18s
    nginx-3926361531   3         2         1         18s
    nginx-2142116321   1         1         1         2m
    nginx-3926361531   3         3         1         18s
    nginx-3926361531   3         3         2         19s
    nginx-2142116321   0         1         1         2m
    nginx-2142116321   0         1         1         2m
    nginx-2142116321   0         0         0         2m
    nginx-3926361531   3         3         3         20s
    ```
    

- 获取最近上线的状态：
    
    ```shell
    kubectl get rs
    ```
    
    输出类似于：
    
    ```
    NAME               DESIRED   CURRENT   READY     AGE
    nginx-2142116321   0         0         0         2m
    nginx-3926361531   3         3         3         28s
    ```
    

**说明：**

你不可以回滚处于暂停状态的 Deployment，除非先恢复其执行状态。

##### Deployment 状态[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#deployment-status)

Deployment 的生命周期中会有许多状态。上线新的 ReplicaSet 期间可能处于 [Progressing（进行中）](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#progressing-deployment)，可能是 [Complete（已完成）](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#complete-deployment)，也可能是 [Failed（失败）](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#failed-deployment)以至于无法继续进行。

###### 进行中的 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#progressing-deployment)

执行下面的任务期间，Kubernetes 标记 Deployment 为**进行中**（Progressing）\_：

- Deployment 创建新的 ReplicaSet
- Deployment 正在为其最新的 ReplicaSet 扩容
- Deployment 正在为其旧有的 ReplicaSet(s) 缩容
- 新的 Pod 已经就绪或者可用（就绪至少持续了 [MinReadySeconds](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#min-ready-seconds) 秒）。

当上线过程进入“Progressing”状态时，Deployment 控制器会向 Deployment 的 `.status.conditions` 中添加包含下面属性的状况条目：

- `type: Progressing`
- `status: "True"`
- `reason: NewReplicaSetCreated` | `reason: FoundNewReplicaSet` | `reason: ReplicaSetUpdated`

你可以使用 `kubectl rollout status` 监视 Deployment 的进度。

###### 完成的 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#complete-deployment)

当 Deployment 具有以下特征时，Kubernetes 将其标记为**完成（Complete）**;

- 与 Deployment 关联的所有副本都已更新到指定的最新版本，这意味着之前请求的所有更新都已完成。
- 与 Deployment 关联的所有副本都可用。
- 未运行 Deployment 的旧副本。

当上线过程进入“Complete”状态时，Deployment 控制器会向 Deployment 的 `.status.conditions` 中添加包含下面属性的状况条目：

- `type: Progressing`
- `status: "True"`
- `reason: NewReplicaSetAvailable`

这一 `Progressing` 状况的状态值会持续为 `"True"`，直至新的上线动作被触发。 即使副本的可用状态发生变化（进而影响 `Available` 状况），`Progressing` 状况的值也不会变化。

你可以使用 `kubectl rollout status` 检查 Deployment 是否已完成。 如果上线成功完成，`kubectl rollout status` 返回退出代码 0。

```shell
kubectl rollout status deployment/nginx-deployment
```

输出类似于：

```
Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment "nginx-deployment" successfully rolled out
```

从 `kubectl rollout` 命令获得的返回状态为 0（成功）：

```shell
echo $?
```

```
0
```

###### 失败的 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#failed-deployment)

你的 Deployment 可能会在尝试部署其最新的 ReplicaSet 受挫，一直处于未完成状态。 造成此情况一些可能因素如下：

- 配额（Quota）不足
- 就绪探测（Readiness Probe）失败
- 镜像拉取错误
- 权限不足
- 限制范围（Limit Ranges）问题
- 应用程序运行时的配置错误

检测此状况的一种方法是在 Deployment 规约中指定截止时间参数： （[`.spec.progressDeadlineSeconds`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds)）。 `.spec.progressDeadlineSeconds` 给出的是一个秒数值，Deployment 控制器在（通过 Deployment 状态） 标示 Deployment 进展停滞之前，需要等待所给的时长。

以下 `kubectl` 命令设置规约中的 `progressDeadlineSeconds`，从而告知控制器 在 10 分钟后报告 Deployment 的上线没有进展：

```shell
kubectl patch deployment/nginx-deployment -p '{"spec":{"progressDeadlineSeconds":600}}'
```

输出类似于：

```
deployment.apps/nginx-deployment patched
```

超过截止时间后，Deployment 控制器将添加具有以下属性的 Deployment 状况到 Deployment 的 `.status.conditions` 中：

- `type: Progressing`
- `status: "False"`
- `reason: ProgressDeadlineExceeded`

这一状况也可能会比较早地失败，因而其状态值被设置为 `"False"`， 其原因为 `ReplicaSetCreateError`。 一旦 Deployment 上线完成，就不再考虑其期限。

参考 [Kubernetes API Conventions](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties) 获取更多状态状况相关的信息。

**说明：**

除了报告 `Reason=ProgressDeadlineExceeded` 状态之外，Kubernetes 对已停止的 Deployment 不执行任何操作。更高级别的编排器可以利用这一设计并相应地采取行动。 例如，将 Deployment 回滚到其以前的版本。

**说明：**

如果你暂停了某个 Deployment 上线，Kubernetes 不再根据指定的截止时间检查 Deployment 上线的进展。 你可以在上线过程中间安全地暂停 Deployment 再恢复其执行，这样做不会导致超出最后时限的问题。

Deployment 可能会出现瞬时性的错误，可能因为设置的超时时间过短， 也可能因为其他可认为是临时性的问题。例如，假定所遇到的问题是配额不足。 如果描述 Deployment，你将会注意到以下部分：

```shell
kubectl describe deployment nginx-deployment
```

输出类似于：

```
<...>
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
<...>
```

如果运行 `kubectl get deployment nginx-deployment -o yaml`，Deployment 状态输出 将类似于这样：

```
status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set "nginx-deployment-4262182780" is progressing.
    reason: ReplicaSetUpdated
    status: "True"
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: "True"
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: 'Error creating: pods "nginx-deployment-4262182780-" is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2'
    reason: FailedCreate
    status: "True"
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
```

最终，一旦超过 Deployment 进度限期，Kubernetes 将更新状态和进度状况的原因：

```
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
```

可以通过缩容 Deployment 或者缩容其他运行状态的控制器，或者直接在命名空间中增加配额 来解决配额不足的问题。如果配额条件满足，Deployment 控制器完成了 Deployment 上线操作， Deployment 状态会更新为成功状况（`Status=True` 和 `Reason=NewReplicaSetAvailable`）。

```
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
```

`type: Available` 加上 `status: True` 意味着 Deployment 具有最低可用性。 最低可用性由 Deployment 策略中的参数指定。 `type: Progressing` 加上 `status: True` 表示 Deployment 处于上线过程中，并且正在运行， 或者已成功完成进度，最小所需新副本处于可用。 请参阅对应状况的 Reason 了解相关细节。 在我们的案例中 `reason: NewReplicaSetAvailable` 表示 Deployment 已完成。

你可以使用 `kubectl rollout status` 检查 Deployment 是否未能取得进展。 如果 Deployment 已超过进度限期，`kubectl rollout status` 返回非零退出代码。

```shell
kubectl rollout status deployment/nginx-deployment
```

输出类似于：

```
Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment "nginx" exceeded its progress deadline
```

`kubectl rollout` 命令的退出状态为 1（表明发生了错误）：

```shell
echo $?
```

```
1
```

###### 对失败 Deployment 的操作[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#operating-on-a-failed-deployment)

可应用于已完成的 Deployment 的所有操作也适用于失败的 Deployment。 你可以对其执行扩缩容、回滚到以前的修订版本等操作，或者在需要对 Deployment 的 Pod 模板应用多项调整时，将 Deployment 暂停。

##### 清理策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#clean-up-policy)

你可以在 Deployment 中设置 `.spec.revisionHistoryLimit` 字段以指定保留此 Deployment 的多少个旧有 ReplicaSet。其余的 ReplicaSet 将在后台被垃圾回收。 默认情况下，此值为 10。

**说明：**

显式将此字段设置为 0 将导致 Deployment 的所有历史记录被清空，因此 Deployment 将无法回滚。

##### 金丝雀部署[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#canary-deployment)

如果要使用 Deployment 向用户子集或服务器子集上线版本， 则可以遵循[资源管理](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/manage-deployment/#canary-deployments)所描述的金丝雀模式， 创建多个 Deployment，每个版本一个。

##### 编写 Deployment 规约[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#writing-a-deployment-spec)

同其他 Kubernetes 配置一样， Deployment 需要 `.apiVersion`，`.kind` 和 `.metadata` 字段。 有关配置文件的其他信息，请参考[部署 Deployment](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/)、 配置容器和[使用 kubectl 管理资源](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/)等相关文档。

当控制面为 Deployment 创建新的 Pod 时，Deployment 的 `.metadata.name` 是命名这些 Pod 的部分基础。 Deployment 的名称必须是一个合法的 [DNS 子域](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names)值， 但这会对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规则。

Deployment 还需要 [`.spec` 部分](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status)。

###### Pod 模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#pod-template)

`.spec` 中只有 `.spec.template` 和 `.spec.selector` 是必需的字段。

`.spec.template` 是一个 [Pod 模板](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)。 它和 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 的语法规则完全相同。 只是这里它是嵌套的，因此不需要 `apiVersion` 或 `kind`。

除了 Pod 的必填字段外，Deployment 中的 Pod 模板必须指定适当的标签和适当的重新启动策略。 对于标签，请确保不要与其他控制器重叠。请参考[选择算符](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#selector)。

只有 [`.spec.template.spec.restartPolicy`](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy) 等于 `Always` 才是被允许的，这也是在没有指定时的默认设置。

###### 副本[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#replicas)

`.spec.replicas` 是指定所需 Pod 的可选字段。它的默认值是1。

如果你对某个 Deployment 执行了手动扩缩操作（例如，通过 `kubectl scale deployment deployment --replicas=X`）， 之后基于清单对 Deployment 执行了更新操作（例如通过运行 `kubectl apply -f deployment.yaml`），那么通过应用清单而完成的更新会覆盖之前手动扩缩所作的变更。

如果一个 [HorizontalPodAutoscaler](https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/) （或者其他执行水平扩缩操作的类似 API）在管理 Deployment 的扩缩， 则不要设置 `.spec.replicas`。

恰恰相反，应该允许 Kubernetes [控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)来自动管理 `.spec.replicas` 字段。

###### 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#selector)

`.spec.selector` 是指定本 Deployment 的 Pod [标签选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)的必需字段。

`.spec.selector` 必须匹配 `.spec.template.metadata.labels`，否则请求会被 API 拒绝。

在 API `apps/v1`版本中，`.spec.selector` 和 `.metadata.labels` 如果没有设置的话， 不会被默认设置为 `.spec.template.metadata.labels`，所以需要明确进行设置。 同时在 `apps/v1`版本中，Deployment 创建后 `.spec.selector` 是不可变的。

当 Pod 的标签和选择算符匹配，但其模板和 `.spec.template` 不同时，或者此类 Pod 的总数超过 `.spec.replicas` 的设置时，Deployment 会终结之。 如果 Pod 总数未达到期望值，Deployment 会基于 `.spec.template` 创建新的 Pod。

**说明：**

你不应直接创建与此选择算符匹配的 Pod，也不应通过创建另一个 Deployment 或者类似于 ReplicaSet 或 ReplicationController 这类控制器来创建标签与此选择算符匹配的 Pod。 如果这样做，第一个 Deployment 会认为它创建了这些 Pod。 Kubernetes 不会阻止你这么做。

如果有多个控制器的选择算符发生重叠，则控制器之间会因冲突而无法正常工作。

###### 策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#strategy)

`.spec.strategy` 策略指定用于用新 Pod 替换旧 Pod 的策略。 `.spec.strategy.type` 可以是 “Recreate” 或 “RollingUpdate”。“RollingUpdate” 是默认值。

####### 重新创建 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#recreate-deployment)

如果 `.spec.strategy.type==Recreate`，在创建新 Pod 之前，所有现有的 Pod 会被杀死。

**说明：**

这只会确保为了升级而创建新 Pod 之前其他 Pod 都已终止。如果你升级一个 Deployment， 所有旧版本的 Pod 都会立即被终止。控制器等待这些 Pod 被成功移除之后， 才会创建新版本的 Pod。如果你手动删除一个 Pod，其生命周期是由 ReplicaSet 来控制的， 后者会立即创建一个替换 Pod（即使旧的 Pod 仍然处于 Terminating 状态）。 如果你需要一种“最多 n 个”的 Pod 个数保证，你需要考虑使用 [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/)。

####### 滚动更新 Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment)

Deployment 会在 `.spec.strategy.type==RollingUpdate`时，采取 滚动更新的方式更新 Pod。你可以指定 `maxUnavailable` 和 `maxSurge` 来控制滚动更新 过程。

######## 最大不可用[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#max-unavailable)

`.spec.strategy.rollingUpdate.maxUnavailable` 是一个可选字段，用来指定 更新过程中不可用的 Pod 的个数上限。该值可以是绝对数字（例如，5），也可以是所需 Pod 的百分比（例如，10%）。百分比值会转换成绝对数并去除小数部分。 如果 `.spec.strategy.rollingUpdate.maxSurge` 为 0，则此值不能为 0。 默认值为 25%。

例如，当此值设置为 30% 时，滚动更新开始时会立即将旧 ReplicaSet 缩容到期望 Pod 个数的70%。 新 Pod 准备就绪后，可以继续缩容旧有的 ReplicaSet，然后对新的 ReplicaSet 扩容， 确保在更新期间可用的 Pod 总数在任何时候都至少为所需的 Pod 个数的 70%。

######## 最大峰值[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#max-surge)

`.spec.strategy.rollingUpdate.maxSurge` 是一个可选字段，用来指定可以创建的超出期望 Pod 个数的 Pod 数量。此值可以是绝对数（例如，5）或所需 Pod 的百分比（例如，10%）。 如果 `MaxUnavailable` 为 0，则此值不能为 0。百分比值会通过向上取整转换为绝对数。 此字段的默认值为 25%。

例如，当此值为 30% 时，启动滚动更新后，会立即对新的 ReplicaSet 扩容，同时保证新旧 Pod 的总数不超过所需 Pod 总数的 130%。一旦旧 Pod 被杀死，新的 ReplicaSet 可以进一步扩容， 同时确保更新期间的任何时候运行中的 Pod 总数最多为所需 Pod 总数的 130%。

###### 进度期限秒数[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#progress-deadline-seconds)

`.spec.progressDeadlineSeconds` 是一个可选字段，用于指定系统在报告 Deployment [进展失败](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#failed-deployment) 之前等待 Deployment 取得进展的秒数。 这类报告会在资源状态中体现为 `type: Progressing`、`status: False`、 `reason: ProgressDeadlineExceeded`。Deployment 控制器将在默认 600 毫秒内持续重试 Deployment。 将来，一旦实现了自动回滚，Deployment 控制器将在探测到这样的条件时立即回滚 Deployment。

如果指定，则此字段值需要大于 `.spec.minReadySeconds` 取值。

###### 最短就绪时间[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#min-ready-seconds)

`.spec.minReadySeconds` 是一个可选字段，用于指定新创建的 Pod 在没有任意容器崩溃情况下的最小就绪时间， 只有超出这个时间 Pod 才被视为可用。默认值为 0（Pod 在准备就绪后立即将被视为可用）。 要了解何时 Pod 被视为就绪， 可参考[容器探针](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)。

###### 修订历史限制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#%E4%BF%AE%E8%AE%A2%E5%8E%86%E5%8F%B2%E9%99%90%E5%88%B6)

Deployment 的修订历史记录存储在它所控制的 ReplicaSets 中。

`.spec.revisionHistoryLimit` 是一个可选字段，用来设定出于回滚目的所要保留的旧 ReplicaSet 数量。 这些旧 ReplicaSet 会消耗 etcd 中的资源，并占用 `kubectl get rs` 的输出。 每个 Deployment 修订版本的配置都存储在其 ReplicaSets 中；因此，一旦删除了旧的 ReplicaSet， 将失去回滚到 Deployment 的对应修订版本的能力。 默认情况下，系统保留 10 个旧 ReplicaSet，但其理想值取决于新 Deployment 的频率和稳定性。

更具体地说，将此字段设置为 0 意味着将清理所有具有 0 个副本的旧 ReplicaSet。 在这种情况下，无法撤消新的 Deployment 上线，因为它的修订历史被清除了。

###### paused（暂停的）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#paused)

`.spec.paused` 是用于暂停和恢复 Deployment 的可选布尔字段。 暂停的 Deployment 和未暂停的 Deployment 的唯一区别是，Deployment 处于暂停状态时， PodTemplateSpec 的任何修改都不会触发新的上线。 Deployment 在创建时是默认不会处于暂停状态。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。
- [使用 Deployment 运行一个无状态应用](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/)。
- `Deployment` 是 Kubernetes REST API 中的一个顶层资源。 阅读 [Deployment](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/deployment-v1/) 对象定义，以了解 Deployment 的 API 细节。
- 阅读 [PodDisruptionBudget](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/) 了解如何使用它来在可能出现干扰的情况下管理应用的可用性。

#### [ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/)
ReplicaSet 的目的是维护一组在任何时候都处于运行状态的 Pod 副本的稳定集合。 因此，它通常用来保证给定数量的、完全相同的 Pod 的可用性。

##### ReplicaSet 的工作原理[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#how-a-replicaset-works)

ReplicaSet 是通过一组字段来定义的，包括一个用来识别可获得的 Pod 的集合的选择算符、一个用来标明应该维护的副本个数的数值、一个用来指定应该创建新 Pod 以满足副本个数条件时要使用的 Pod 模板等等。 每个 ReplicaSet 都通过根据需要创建和删除 Pod 以使得副本个数达到期望值， 进而实现其存在价值。当 ReplicaSet 需要创建新的 Pod 时，会使用所提供的 Pod 模板。

ReplicaSet 通过 Pod 上的 [metadata.ownerReferences](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#owners-and-dependents) 字段连接到附属 Pod，该字段给出当前对象的属主资源。 ReplicaSet 所获得的 Pod 都在其 ownerReferences 字段中包含了属主 ReplicaSet 的标识信息。正是通过这一连接，ReplicaSet 知道它所维护的 Pod 集合的状态， 并据此计划其操作行为。

ReplicaSet 使用其选择算符来辨识要获得的 Pod 集合。如果某个 Pod 没有 OwnerReference 或者其 OwnerReference 不是一个[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)， 且其匹配到某 ReplicaSet 的选择算符，则该 Pod 立即被此 ReplicaSet 获得。

##### 何时使用 ReplicaSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#when-to-use-a-replicaset)

ReplicaSet 确保任何时间都有指定数量的 Pod 副本在运行。 然而，Deployment 是一个更高级的概念，它管理 ReplicaSet，并向 Pod 提供声明式的更新以及许多其他有用的功能。 因此，我们建议使用 Deployment 而不是直接使用 ReplicaSet， 除非你需要自定义更新业务流程或根本不需要更新。

这实际上意味着，你可能永远不需要操作 ReplicaSet 对象：而是使用 Deployment，并在 spec 部分定义你的应用。

##### 示例[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#example)

[`controllers/frontend.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/frontend.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/frontend.yaml to clipboard")

```yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: frontend
  labels:
    app: guestbook
    tier: frontend
spec:
  # 按你的实际情况修改副本数
  replicas: 3
  selector:
    matchLabels:
      tier: frontend
  template:
    metadata:
      labels:
        tier: frontend
    spec:
      containers:
      - name: php-redis
        image: gcr.io/google_samples/gb-frontend:v3
```

将此清单保存到 `frontend.yaml` 中，并将其提交到 Kubernetes 集群， 就能创建 yaml 文件所定义的 ReplicaSet 及其管理的 Pod。

```shell
kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
```

你可以看到当前被部署的 ReplicaSet：

```shell
kubectl get rs
```

并看到你所创建的前端：

```
NAME       DESIRED   CURRENT   READY   AGE
frontend   3         3         3       6s
```

你也可以查看 ReplicaSet 的状态：

```shell
kubectl describe rs/frontend
```

你会看到类似如下的输出：

```
Name:         frontend
Namespace:    default
Selector:     tier=frontend
Labels:       app=guestbook
              tier=frontend
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {"apiVersion":"apps/v1","kind":"ReplicaSet","metadata":{"annotations":{},"labels":{"app":"guestbook","tier":"frontend"},"name":"frontend",...
Replicas:     3 current / 3 desired
Pods Status:  3 Running / 0 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:  tier=frontend
  Containers:
   php-redis:
    Image:        gcr.io/google_samples/gb-frontend:v3
    Port:         <none>
    Host Port:    <none>
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Events:
  Type    Reason            Age   From                   Message
  ----    ------            ----  ----                   -------
  Normal  SuccessfulCreate  117s  replicaset-controller  Created pod: frontend-wtsmm
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-b2zdv
  Normal  SuccessfulCreate  116s  replicaset-controller  Created pod: frontend-vcmts
```

最后可以查看启动了的 Pod 集合：

```shell
kubectl get pods
```

你会看到类似如下的 Pod 信息：

```
NAME             READY   STATUS    RESTARTS   AGE
frontend-b2zdv   1/1     Running   0          6m36s
frontend-vcmts   1/1     Running   0          6m36s
frontend-wtsmm   1/1     Running   0          6m36s
```

你也可以查看 Pod 的属主引用被设置为前端的 ReplicaSet。 要实现这点，可取回运行中的某个 Pod 的 YAML：

```shell
kubectl get pods frontend-b2zdv -o yaml
```

输出将类似这样，frontend ReplicaSet 的信息被设置在 metadata 的 `ownerReferences` 字段中：

```yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: "2020-02-12T07:06:16Z"
  generateName: frontend-
  labels:
    tier: frontend
  name: frontend-b2zdv
  namespace: default
  ownerReferences:
  - apiVersion: apps/v1
    blockOwnerDeletion: true
    controller: true
    kind: ReplicaSet
    name: frontend
    uid: f391f6db-bb9b-4c09-ae74-6a1f77f3d5cf
...
```

##### 非模板 Pod 的获得[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#non-template-pod-acquisitions)

尽管你完全可以直接创建裸的 Pod，强烈建议你确保这些裸的 Pod 并不包含可能与你的某个 ReplicaSet 的选择算符相匹配的标签。原因在于 ReplicaSet 并不仅限于拥有在其模板中设置的 Pod，它还可以像前面小节中所描述的那样获得其他 Pod。

以前面的 frontend ReplicaSet 为例，并在以下清单中指定这些 Pod：

[`pods/pod-rs.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-rs.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy pods/pod-rs.yaml to clipboard")

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod1
  labels:
    tier: frontend
spec:
  containers:
  - name: hello1
    image: gcr.io/google-samples/hello-app:2.0

---

apiVersion: v1
kind: Pod
metadata:
  name: pod2
  labels:
    tier: frontend
spec:
  containers:
  - name: hello2
    image: gcr.io/google-samples/hello-app:1.0
```

由于这些 Pod 没有控制器（Controller，或其他对象）作为其属主引用， 并且其标签与 frontend ReplicaSet 的选择算符匹配，它们会立即被该 ReplicaSet 获取。

假定你在 frontend ReplicaSet 已经被部署之后创建 Pod，并且你已经在 ReplicaSet 中设置了其初始的 Pod 副本数以满足其副本计数需要：

```shell
kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
```

新的 Pod 会被该 ReplicaSet 获取，并立即被 ReplicaSet 终止， 因为它们的存在会使得 ReplicaSet 中 Pod 个数超出其期望值。

取回 Pod：

```shell
kubectl get pods
```

输出显示新的 Pod 或者已经被终止，或者处于终止过程中：

```
NAME             READY   STATUS        RESTARTS   AGE
frontend-b2zdv   1/1     Running       0          10m
frontend-vcmts   1/1     Running       0          10m
frontend-wtsmm   1/1     Running       0          10m
pod1             0/1     Terminating   0          1s
pod2             0/1     Terminating   0          1s
```

如果你先行创建 Pod：

```shell
kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
```

之后再创建 ReplicaSet：

```shell
kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
```

你会看到 ReplicaSet 已经获得了该 Pod，并仅根据其规约创建新的 Pod， 直到新的 Pod 和原来的 Pod 的总数达到其预期个数。 这时取回 Pod 列表：

```shell
kubectl get pods
```

将会生成下面的输出：

```
NAME             READY   STATUS    RESTARTS   AGE
frontend-hmmj2   1/1     Running   0          9s
pod1             1/1     Running   0          36s
pod2             1/1     Running   0          36s
```

采用这种方式，一个 ReplicaSet 中可以包含异质的 Pod 集合。

##### 编写 ReplicaSet 的清单[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#writing-a-replicaset-manifest)

与所有其他 Kubernetes API 对象一样，ReplicaSet 也需要 `apiVersion`、`kind`、和 `metadata` 字段。 对于 ReplicaSet 而言，其 `kind` 始终是 ReplicaSet。

当控制平面为 ReplicaSet 创建新的 Pod 时，ReplicaSet 的 `.metadata.name` 是命名这些 Pod 的部分基础。ReplicaSet 的名称必须是一个合法的 [DNS 子域](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names)值， 但这可能对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规则。

ReplicaSet 也需要 [`.spec`](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status) 部分。

###### Pod 模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#pod-template)

`.spec.template` 是一个 [Pod 模板](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)， 要求设置标签。在 `frontend.yaml` 示例中，我们指定了标签 `tier: frontend`。 注意不要将标签与其他控制器的选择算符重叠，否则那些控制器会尝试收养此 Pod。

对于模板的[重启策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy) 字段，`.spec.template.spec.restartPolicy`，唯一允许的取值是 `Always`，这也是默认值.

###### Pod 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#pod-selector)

`.spec.selector` 字段是一个[标签选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)。 如前文中[所讨论的](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#how-a-replicaset-works)，这些是用来标识要被获取的 Pod 的标签。在签名的 `frontend.yaml` 示例中，选择算符为：

```yaml
matchLabels:
  tier: frontend
```

在 ReplicaSet 中，`.spec.template.metadata.labels` 的值必须与 `spec.selector` 值相匹配，否则该配置会被 API 拒绝。

**说明：**

对于设置了相同的 `.spec.selector`，但 `.spec.template.metadata.labels` 和 `.spec.template.spec` 字段不同的两个 ReplicaSet 而言，每个 ReplicaSet 都会忽略被另一个 ReplicaSet 所创建的 Pod。

###### Replicas[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#replicas)

你可以通过设置 `.spec.replicas` 来指定要同时运行的 Pod 个数。 ReplicaSet 创建、删除 Pod 以与此值匹配。

如果你没有指定 `.spec.replicas`，那么默认值为 1。

##### 使用 ReplicaSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#working-with-replicasets)

###### 删除 ReplicaSet 和它的 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#deleting-a-replicaset-and-its-pods)

要删除 ReplicaSet 和它的所有 Pod，使用 [`kubectl delete`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete) 命令。 默认情况下，[垃圾收集器](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/) 自动删除所有依赖的 Pod。

当使用 REST API 或 `client-go` 库时，你必须在 `-d` 选项中将 `propagationPolicy` 设置为 `Background` 或 `Foreground`。例如：

```shell
kubectl proxy --port=8080
curl -X DELETE  'localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend' \
  -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Foreground"}' \
  -H "Content-Type: application/json"
```

###### 只删除 ReplicaSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#deleting-just-a-replicaset)

你可以只删除 ReplicaSet 而不影响它的各个 Pod，方法是使用 [`kubectl delete`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete) 命令并设置 `--cascade=orphan` 选项。

当使用 REST API 或 `client-go` 库时，你必须将 `propagationPolicy` 设置为 `Orphan`。 例如：

```shell
kubectl proxy --port=8080
curl -X DELETE  'localhost:8080/apis/apps/v1/namespaces/default/replicasets/frontend' \
  -d '{"kind":"DeleteOptions","apiVersion":"v1","propagationPolicy":"Orphan"}' \
  -H "Content-Type: application/json"
```

一旦删除了原来的 ReplicaSet，就可以创建一个新的来替换它。 由于新旧 ReplicaSet 的 `.spec.selector` 是相同的，新的 ReplicaSet 将接管老的 Pod。 但是，它不会努力使现有的 Pod 与新的、不同的 Pod 模板匹配。 若想要以可控的方式更新 Pod 的规约，可以使用 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/#creating-a-deployment) 资源，因为 ReplicaSet 并不直接支持滚动更新。

###### 将 Pod 从 ReplicaSet 中隔离[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#isolating-pods-from-a-replicaset)

可以通过改变标签来从 ReplicaSet 中移除 Pod。 这种技术可以用来从服务中去除 Pod，以便进行排错、数据恢复等。 以这种方式移除的 Pod 将被自动替换（假设副本的数量没有改变）。

###### 扩缩 ReplicaSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#scaling-a-replicaset)

通过更新 `.spec.replicas` 字段，ReplicaSet 可以被轻松地进行扩缩。ReplicaSet 控制器能确保匹配标签选择器的数量的 Pod 是可用的和可操作的。

在降低集合规模时，ReplicaSet 控制器通过对可用的所有 Pod 进行排序来优先选择要被删除的那些 Pod。 其一般性算法如下：

1. 首先选择剔除悬决（Pending，且不可调度）的各个 Pod
2. 如果设置了 `controller.kubernetes.io/pod-deletion-cost` 注解，则注解值较小的优先被裁减掉
3. 所处节点上副本个数较多的 Pod 优先于所处节点上副本较少者
4. 如果 Pod 的创建时间不同，最近创建的 Pod 优先于早前创建的 Pod 被裁减。 （当 `LogarithmicScaleDown` 这一[特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/) 被启用时，创建时间是按整数幂级来分组的）。

如果以上比较结果都相同，则随机选择。

###### Pod 删除开销[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#pod-deletion-cost)

**特性状态：** `Kubernetes v1.22 [beta]`

通过使用 [`controller.kubernetes.io/pod-deletion-cost`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#pod-deletion-cost) 注解，用户可以对 ReplicaSet 缩容时要先删除哪些 Pod 设置偏好。

此注解要设置到 Pod 上，取值范围为 \[-2147483647, 2147483647\]。 所代表的是删除同一 ReplicaSet 中其他 Pod 相比较而言的开销。 删除开销较小的 Pod 比删除开销较高的 Pod 更容易被删除。

Pod 如果未设置此注解，则隐含的设置值为 0。负值也是可接受的。 如果注解值非法，API 服务器会拒绝对应的 Pod。

此功能特性处于 Beta 阶段，默认被启用。你可以通过为 kube-apiserver 和 kube-controller-manager 设置[特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/) `PodDeletionCost` 来禁用此功能。

**说明：**

- 此机制实施时仅是尽力而为，并不能对 Pod 的删除顺序作出任何保证；
- 用户应避免频繁更新注解值，例如根据某观测度量值来更新此注解值是应该避免的。 这样做会在 API 服务器上产生大量的 Pod 更新操作。

####### 使用场景示例[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#example-use-case)

同一应用的不同 Pod 可能其利用率是不同的。在对应用执行缩容操作时， 可能希望移除利用率较低的 Pod。为了避免频繁更新 Pod，应用应该在执行缩容操作之前更新一次 `controller.kubernetes.io/pod-deletion-cost` 注解值 （将注解值设置为一个与其 Pod 利用率对应的值）。 如果应用自身控制器缩容操作时（例如 Spark 部署的驱动 Pod），这种机制是可以起作用的。

###### ReplicaSet 作为水平的 Pod 自动扩缩器目标[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#replicaset-as-a-horizontal-pod-autoscaler-target)

ReplicaSet 也可以作为[水平的 Pod 扩缩器 (HPA)](https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/) 的目标。也就是说，ReplicaSet 可以被 HPA 自动扩缩。 以下是 HPA 以我们在前一个示例中创建的副本集为目标的示例。

[`controllers/hpa-rs.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/hpa-rs.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/hpa-rs.yaml to clipboard")

```yaml
apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
  name: frontend-scaler
spec:
  scaleTargetRef:
    kind: ReplicaSet
    name: frontend
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 50
```

将这个列表保存到 `hpa-rs.yaml` 并提交到 Kubernetes 集群，就能创建它所定义的 HPA，进而就能根据复制的 Pod 的 CPU 利用率对目标 ReplicaSet 进行自动扩缩。

```shell
kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
```

或者，可以使用 `kubectl autoscale` 命令完成相同的操作（而且它更简单！）

```shell
kubectl autoscale rs frontend --max=10 --min=3 --cpu-percent=50
```

##### ReplicaSet 的替代方案[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#alternatives-to-replicaset)

###### Deployment（推荐）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#deployment-recommended)

[`Deployment`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 是一个可以拥有 ReplicaSet 并使用声明式方式在服务器端完成对 Pod 滚动更新的对象。 尽管 ReplicaSet 可以独立使用，目前它们的主要用途是提供给 Deployment 作为编排 Pod 创建、删除和更新的一种机制。当使用 Deployment 时，你不必关心如何管理它所创建的 ReplicaSet，Deployment 拥有并管理其 ReplicaSet。 因此，建议你在需要 ReplicaSet 时使用 Deployment。

###### 裸 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#bare-pods)

与用户直接创建 Pod 的情况不同，ReplicaSet 会替换那些由于某些原因被删除或被终止的 Pod，例如在节点故障或破坏性的节点维护（如内核升级）的情况下。 因为这个原因，我们建议你使用 ReplicaSet，即使应用程序只需要一个 Pod。 想像一下，ReplicaSet 类似于进程监视器，只不过它在多个节点上监视多个 Pod， 而不是在单个节点上监视单个进程。 ReplicaSet 将本地容器重启的任务委托给了节点上的某个代理（例如，Kubelet）去完成。

###### Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#job)

使用[`Job`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 代替 ReplicaSet， 可以用于那些期望自行终止的 Pod。

###### DaemonSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#daemonset)

对于管理那些提供主机级别功能（如主机监控和主机日志）的容器， 就要用 [`DaemonSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/) 而不用 ReplicaSet。 这些 Pod 的寿命与主机寿命有关：这些 Pod 需要先于主机上的其他 Pod 运行， 并且在机器准备重新启动/关闭时安全地终止。

###### ReplicationController[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#replicationcontroller)

ReplicaSet 是 [ReplicationController](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/) 的后继者。二者目的相同且行为类似，只是 ReplicationController 不支持 [标签用户指南](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors) 中讨论的基于集合的选择算符需求。 因此，相比于 ReplicationController，应优先考虑 ReplicaSet。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。
- 了解 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)。
- [使用 Deployment 运行一个无状态应用](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/)， 它依赖于 ReplicaSet。
- `ReplicaSet` 是 Kubernetes REST API 中的顶级资源。阅读 [ReplicaSet](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/replica-set-v1/) 对象定义理解关于该资源的 API。
- 阅读 [Pod 干扰预算（Disruption Budget）](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/)， 了解如何在干扰下运行高度可用的应用。
#### [StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/)
StatefulSet 是用来管理有状态应用的工作负载 API 对象。

StatefulSet 用来管理某 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 集合的部署和扩缩， 并为这些 Pod 提供持久存储和持久标识符。

和 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 类似， StatefulSet 管理基于相同容器规约的一组 Pod。但和 Deployment 不同的是， StatefulSet 为它们的每个 Pod 维护了一个有粘性的 ID。这些 Pod 是基于相同的规约来创建的， 但是不能相互替换：无论怎么调度，每个 Pod 都有一个永久不变的 ID。

如果希望使用存储卷为工作负载提供持久存储，可以使用 StatefulSet 作为解决方案的一部分。 尽管 StatefulSet 中的单个 Pod 仍可能出现故障， 但持久的 Pod 标识符使得将现有卷与替换已失败 Pod 的新 Pod 相匹配变得更加容易。

##### 使用 StatefulSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#using-statefulsets)

StatefulSet 对于需要满足以下一个或多个需求的应用程序很有价值：

- 稳定的、唯一的网络标识符。
- 稳定的、持久的存储。
- 有序的、优雅的部署和扩缩。
- 有序的、自动的滚动更新。

在上面描述中，“稳定的”意味着 Pod 调度或重调度的整个过程是有持久性的。 如果应用程序不需要任何稳定的标识符或有序的部署、删除或扩缩， 则应该使用由一组无状态的副本控制器提供的工作负载来部署应用程序，比如 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 或者 [ReplicaSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 可能更适用于你的无状态应用部署需要。

##### 限制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#limitations)

- 给定 Pod 的存储必须由 [PersistentVolume Provisioner](https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/README.md) 基于所请求的 `storage class` 来制备，或者由管理员预先制备。
- 删除或者扩缩 StatefulSet 并**不会**删除它关联的存储卷。 这样做是为了保证数据安全，它通常比自动清除 StatefulSet 所有相关的资源更有价值。
- StatefulSet 当前需要[无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)来负责 Pod 的网络标识。你需要负责创建此服务。
- 当删除一个 StatefulSet 时，该 StatefulSet 不提供任何终止 Pod 的保证。 为了实现 StatefulSet 中的 Pod 可以有序且体面地终止，可以在删除之前将 StatefulSet 缩容到 0。
- 在默认 [Pod 管理策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-management-policies)(`OrderedReady`) 时使用[滚动更新](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#rolling-updates)， 可能进入需要[人工干预](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#forced-rollback)才能修复的损坏状态。

##### 组件[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#components)

下面的示例演示了 StatefulSet 的组件。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  ports:
  - port: 80
    name: web
  clusterIP: None
  selector:
    app: nginx
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:
  selector:
    matchLabels:
      app: nginx # 必须匹配 .spec.template.metadata.labels
  serviceName: "nginx"
  replicas: 3 # 默认值是 1
  minReadySeconds: 10 # 默认值是 0
  template:
    metadata:
      labels:
        app: nginx # 必须匹配 .spec.selector.matchLabels
    spec:
      terminationGracePeriodSeconds: 10
      containers:
      - name: nginx
        image: registry.k8s.io/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "my-storage-class"
      resources:
        requests:
          storage: 1Gi
```

上述例子中：

- 名为 `nginx` 的 Headless Service 用来控制网络域名。
- 名为 `web` 的 StatefulSet 有一个 Spec，它表明将在独立的 3 个 Pod 副本中启动 nginx 容器。
- `volumeClaimTemplates` 将通过 PersistentVolume 制备程序所准备的 [PersistentVolumes](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/) 来提供稳定的存储。

StatefulSet 的命名需要遵循 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规范。

###### Pod 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-selector)

你必须设置 StatefulSet 的 `.spec.selector` 字段，使之匹配其在 `.spec.template.metadata.labels` 中设置的标签。 未指定匹配的 Pod 选择算符将在创建 StatefulSet 期间导致验证错误。

###### 卷申领模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#volume-claim-templates)

你可以设置 `.spec.volumeClaimTemplates`， 它可以使用 PersistentVolume 制备程序所准备的 [PersistentVolumes](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/) 来提供稳定的存储。

###### 最短就绪秒数[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#minimum-ready-seconds)

**特性状态：** `Kubernetes v1.25 [stable]`

`.spec.minReadySeconds` 是一个可选字段。 它指定新创建的 Pod 应该在没有任何容器崩溃的情况下运行并准备就绪，才能被认为是可用的。 这用于在使用[滚动更新](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#rolling-updates)策略时检查滚动的进度。 该字段默认为 0（Pod 准备就绪后将被视为可用）。 要了解有关何时认为 Pod 准备就绪的更多信息， 请参阅[容器探针](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes)。

##### Pod 标识[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-identity)

StatefulSet Pod 具有唯一的标识，该标识包括顺序标识、稳定的网络标识和稳定的存储。 该标识和 Pod 是绑定的，与该 Pod 调度到哪个节点上无关。

###### 有序索引[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#ordinal-index)

对于具有 N 个[副本](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#replicas)的 StatefulSet，该 StatefulSet 中的每个 Pod 将被分配一个整数序号， 该序号在此 StatefulSet 上是唯一的。默认情况下，这些 Pod 将被从 0 到 N-1 的序号。

###### 起始序号[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#start-ordinal)

**特性状态：** `Kubernetes v1.26 [alpha]`

`.spec.ordinals` 是一个可选的字段，允许你配置分配给每个 Pod 的整数序号。 该字段默认为 nil 值。你必须启用 `StatefulSetStartOrdinal` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)才能使用此字段。 一旦启用，你就可以配置以下选项：

- `.spec.ordinals.start`：如果 `.spec.ordinals.start` 字段被设置，则 Pod 将被分配从 `.spec.ordinals.start` 到 `.spec.ordinals.start + .spec.replicas - 1` 的序号。

###### 稳定的网络 ID[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#stable-network-id)

StatefulSet 中的每个 Pod 根据 StatefulSet 的名称和 Pod 的序号派生出它的主机名。 组合主机名的格式为`$(StatefulSet 名称)-$(序号)`。 上例将会创建三个名称分别为 `web-0、web-1、web-2` 的 Pod。 StatefulSet 可以使用[无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)控制它的 Pod 的网络域。管理域的这个服务的格式为： `$(服务名称).$(名字空间).svc.cluster.local`，其中 `cluster.local` 是集群域。 一旦每个 Pod 创建成功，就会得到一个匹配的 DNS 子域，格式为： `$(pod 名称).$(所属服务的 DNS 域名)`，其中所属服务由 StatefulSet 的 `serviceName` 域来设定。

取决于集群域内部 DNS 的配置，有可能无法查询一个刚刚启动的 Pod 的 DNS 命名。 当集群内其他客户端在 Pod 创建完成前发出 Pod 主机名查询时，就会发生这种情况。 负缓存 (在 DNS 中较为常见) 意味着之前失败的查询结果会被记录和重用至少若干秒钟， 即使 Pod 已经正常运行了也是如此。

如果需要在 Pod 被创建之后及时发现它们，可使用以下选项：

- 直接查询 Kubernetes API（比如，利用 watch 机制）而不是依赖于 DNS 查询
- 缩短 Kubernetes DNS 驱动的缓存时长（通常这意味着修改 CoreDNS 的 ConfigMap，目前缓存时长为 30 秒）

正如[限制](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#limitations)中所述， 你需要负责创建[无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)以便为 Pod 提供网络标识。

下面给出一些选择集群域、服务名、StatefulSet 名、及其怎样影响 StatefulSet 的 Pod 上的 DNS 名称的示例：

| 集群域名 | 服务（名字空间/名字） | StatefulSet（名字空间/名字） | StatefulSet 域名 | Pod DNS | Pod 主机名 |
| --- | --- | --- | --- | --- | --- |
| cluster.local | default/nginx | default/web | nginx.default.svc.cluster.local | web-{0..N-1}.nginx.default.svc.cluster.local | web-{0..N-1} |
| cluster.local | foo/nginx | foo/web | nginx.foo.svc.cluster.local | web-{0..N-1}.nginx.foo.svc.cluster.local | web-{0..N-1} |
| kube.local | foo/nginx | foo/web | nginx.foo.svc.kube.local | web-{0..N-1}.nginx.foo.svc.kube.local | web-{0..N-1} |

**说明：**

集群域会被设置为 `cluster.local`，除非有[其他配置](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/)。

###### 稳定的存储[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#stable-storage)

对于 StatefulSet 中定义的每个 VolumeClaimTemplate，每个 Pod 接收到一个 PersistentVolumeClaim。 在上面的 nginx 示例中，每个 Pod 将会得到基于 StorageClass `my-storage-class` 制备的 1 Gib 的 PersistentVolume。 如果没有声明 StorageClass，就会使用默认的 StorageClass。 当一个 Pod 被调度（重新调度）到节点上时，它的 `volumeMounts` 会挂载与其 PersistentVolumeClaims 相关联的 PersistentVolume。 请注意，当 Pod 或者 StatefulSet 被删除时，与 PersistentVolumeClaims 相关联的 PersistentVolume 并不会被删除。要删除它必须通过手动方式来完成。

###### Pod 名称标签[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-name-label)

当 StatefulSet [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)创建 Pod 时， 它会添加一个标签 `statefulset.kubernetes.io/pod-name`，该标签值设置为 Pod 名称。 这个标签允许你给 StatefulSet 中的特定 Pod 绑定一个 Service。

##### 部署和扩缩保证[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees)

- 对于包含 N 个 副本的 StatefulSet，当部署 Pod 时，它们是依次创建的，顺序为 `0..N-1`。
- 当删除 Pod 时，它们是逆序终止的，顺序为 `N-1..0`。
- 在将扩缩操作应用到 Pod 之前，它前面的所有 Pod 必须是 Running 和 Ready 状态。
- 在一个 Pod 终止之前，所有的继任者必须完全关闭。

StatefulSet 不应将 `pod.Spec.TerminationGracePeriodSeconds` 设置为 0。 这种做法是不安全的，要强烈阻止。 更多的解释请参考[强制删除 StatefulSet Pod](https://kubernetes.io/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/)。

在上面的 nginx 示例被创建后，会按照 web-0、web-1、web-2 的顺序部署三个 Pod。 在 web-0 进入 [Running 和 Ready](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/) 状态前不会部署 web-1。在 web-1 进入 Running 和 Ready 状态前不会部署 web-2。 如果 web-1 已经处于 Running 和 Ready 状态，而 web-2 尚未部署，在此期间发生了 web-0 运行失败，那么 web-2 将不会被部署，要等到 web-0 部署完成并进入 Running 和 Ready 状态后，才会部署 web-2。

如果用户想将示例中的 StatefulSet 扩缩为 `replicas=1`，首先被终止的是 web-2。 在 web-2 没有被完全停止和删除前，web-1 不会被终止。 当 web-2 已被终止和删除、web-1 尚未被终止，如果在此期间发生 web-0 运行失败， 那么就不会终止 web-1，必须等到 web-0 进入 Running 和 Ready 状态后才会终止 web-1。

###### Pod 管理策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-management-policies)

StatefulSet 允许你放宽其排序保证， 同时通过它的 `.spec.podManagementPolicy` 域保持其唯一性和身份保证。

####### OrderedReady Pod 管理[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#orderedready-pod-management)

`OrderedReady` Pod 管理是 StatefulSet 的默认设置。 它实现了[上面](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees)描述的功能。

####### 并行 Pod 管理[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#parallel-pod-management)

`Parallel` Pod 管理让 StatefulSet 控制器并行的启动或终止所有的 Pod， 启动或者终止其他 Pod 前，无需等待 Pod 进入 Running 和 Ready 或者完全停止状态。 这个选项只会影响扩缩操作的行为，更新则不会被影响。

##### 更新策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#update-strategies)

StatefulSet 的 `.spec.updateStrategy` 字段让你可以配置和禁用掉自动滚动更新 Pod 的容器、标签、资源请求或限制、以及注解。有两个允许的值：

`OnDelete`

当 StatefulSet 的 `.spec.updateStrategy.type` 设置为 `OnDelete` 时， 它的控制器将不会自动更新 StatefulSet 中的 Pod。 用户必须手动删除 Pod 以便让控制器创建新的 Pod，以此来对 StatefulSet 的 `.spec.template` 的变动作出反应。

`RollingUpdate`

`RollingUpdate` 更新策略对 StatefulSet 中的 Pod 执行自动的滚动更新。这是默认的更新策略。

##### 滚动更新[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#rolling-updates)

当 StatefulSet 的 `.spec.updateStrategy.type` 被设置为 `RollingUpdate` 时， StatefulSet 控制器会删除和重建 StatefulSet 中的每个 Pod。 它将按照与 Pod 终止相同的顺序（从最大序号到最小序号）进行，每次更新一个 Pod。

Kubernetes 控制平面会等到被更新的 Pod 进入 Running 和 Ready 状态，然后再更新其前身。 如果你设置了 `.spec.minReadySeconds`（查看[最短就绪秒数](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#minimum-ready-seconds)）， 控制平面在 Pod 就绪后会额外等待一定的时间再执行下一步。

###### 分区滚动更新[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#partitions)

通过声明 `.spec.updateStrategy.rollingUpdate.partition` 的方式，`RollingUpdate` 更新策略可以实现分区。 如果声明了一个分区，当 StatefulSet 的 `.spec.template` 被更新时， 所有序号大于等于该分区序号的 Pod 都会被更新。 所有序号小于该分区序号的 Pod 都不会被更新，并且，即使它们被删除也会依据之前的版本进行重建。 如果 StatefulSet 的 `.spec.updateStrategy.rollingUpdate.partition` 大于它的 `.spec.replicas`，则对它的 `.spec.template` 的更新将不会传递到它的 Pod。 在大多数情况下，你不需要使用分区，但如果你希望进行阶段更新、执行金丝雀或执行分阶段上线，则这些分区会非常有用。

###### 最大不可用 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#maximum-unavailable-pods)

**特性状态：** `Kubernetes v1.24 [alpha]`

你可以通过指定 `.spec.updateStrategy.rollingUpdate.maxUnavailable` 字段来控制更新期间不可用的 Pod 的最大数量。 该值可以是绝对值（例如，“5”）或者是期望 Pod 个数的百分比（例如，`10%`）。 绝对值是根据百分比值四舍五入计算的。 该字段不能为 0。默认设置为 1。

该字段适用于 `0` 到 `replicas - 1` 范围内的所有 Pod。 如果在 `0` 到 `replicas - 1` 范围内存在不可用 Pod，这类 Pod 将被计入 `maxUnavailable` 值。

**说明：**

`maxUnavailable` 字段处于 Alpha 阶段，仅当 API 服务器启用了 `MaxUnavailableStatefulSet` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)时才起作用。

###### 强制回滚[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#forced-rollback)

在默认 [Pod 管理策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#pod-management-policies)(`OrderedReady`) 下使用[滚动更新](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#rolling-updates)， 可能进入需要人工干预才能修复的损坏状态。

如果更新后 Pod 模板配置进入无法运行或就绪的状态（例如， 由于错误的二进制文件或应用程序级配置错误），StatefulSet 将停止回滚并等待。

在这种状态下，仅将 Pod 模板还原为正确的配置是不够的。 由于[已知问题](https://github.com/kubernetes/kubernetes/issues/67250)，StatefulSet 将继续等待损坏状态的 Pod 准备就绪（永远不会发生），然后再尝试将其恢复为正常工作配置。

恢复模板后，还必须删除 StatefulSet 尝试使用错误的配置来运行的 Pod。这样， StatefulSet 才会开始使用被还原的模板来重新创建 Pod。

##### PersistentVolumeClaim 保留[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#persistentvolumeclaim-retention)

**特性状态：** `Kubernetes v1.23 [alpha]`

在 StatefulSet 的生命周期中，可选字段 `.spec.persistentVolumeClaimRetentionPolicy` 控制是否删除以及如何删除 PVC。 使用该字段，你必须在 API 服务器和控制器管理器启用 `StatefulSetAutoDeletePVC` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。 启用后，你可以为每个 StatefulSet 配置两个策略：

`whenDeleted`

配置删除 StatefulSet 时应用的卷保留行为。

`whenScaled`

配置当 StatefulSet 的副本数减少时应用的卷保留行为；例如，缩小集合时。

对于你可以配置的每个策略，你可以将值设置为 `Delete` 或 `Retain`。

`Delete`

对于受策略影响的每个 Pod，基于 StatefulSet 的 `volumeClaimTemplate` 字段创建的 PVC 都会被删除。 使用 `whenDeleted` 策略，所有来自 `volumeClaimTemplate` 的 PVC 在其 Pod 被删除后都会被删除。 使用 `whenScaled` 策略，只有与被缩减的 Pod 副本对应的 PVC 在其 Pod 被删除后才会被删除。

`Retain`（默认）

来自 `volumeClaimTemplate` 的 PVC 在 Pod 被删除时不受影响。这是此新功能之前的行为。

请记住，这些策略**仅**适用于由于 StatefulSet 被删除或被缩小而被删除的 Pod。 例如，如果与 StatefulSet 关联的 Pod 由于节点故障而失败， 并且控制平面创建了替换 Pod，则 StatefulSet 保留现有的 PVC。 现有卷不受影响，集群会将其附加到新 Pod 即将启动的节点上。

策略的默认值为 `Retain`，与此新功能之前的 StatefulSet 行为相匹配。

这是一个示例策略。

```yaml
apiVersion: apps/v1
kind: StatefulSet
...
spec:
  persistentVolumeClaimRetentionPolicy:
    whenDeleted: Retain
    whenScaled: Delete
...
```

StatefulSet [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)为其 PVC 添加了[属主引用](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/owners-dependents/#owner-references-in-object-specifications)， 这些 PVC 在 Pod 终止后被[垃圾回收器](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/)删除。 这使 Pod 能够在删除 PVC 之前（以及在删除后备 PV 和卷之前，取决于保留策略）干净地卸载所有卷。 当你设置 `whenDeleted` 删除策略，对 StatefulSet 实例的属主引用放置在与该 StatefulSet 关联的所有 PVC 上。

`whenScaled` 策略必须仅在 Pod 缩减时删除 PVC，而不是在 Pod 因其他原因被删除时删除。 执行协调操作时，StatefulSet 控制器将其所需的副本数与集群上实际存在的 Pod 进行比较。 对于 StatefulSet 中的所有 Pod 而言，如果其 ID 大于副本数，则将被废弃并标记为需要删除。 如果 `whenScaled` 策略是 `Delete`，则在删除 Pod 之前， 首先将已销毁的 Pod 设置为与 StatefulSet 模板对应的 PVC 的属主。 这会导致 PVC 仅在已废弃的 Pod 终止后被垃圾收集。

这意味着如果控制器崩溃并重新启动，在其属主引用更新到适合策略的 Pod 之前，不会删除任何 Pod。 如果在控制器关闭时强制删除了已废弃的 Pod，则属主引用可能已被设置，也可能未被设置，具体取决于控制器何时崩溃。 更新属主引用可能需要几个协调循环，因此一些已废弃的 Pod 可能已经被设置了属主引用，而其他可能没有。 出于这个原因，我们建议等待控制器恢复，控制器将在终止 Pod 之前验证属主引用。 如果这不可行，则操作员应验证 PVC 上的属主引用，以确保在强制删除 Pod 时删除预期的对象。

###### 副本数[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#replicas)

`.spec.replicas` 是一个可选字段，用于指定所需 Pod 的数量。它的默认值为 1。

如果你手动扩缩已部署的负载，例如通过 `kubectl scale statefulset statefulset --replicas=X`， 然后根据清单更新 StatefulSet（例如：通过运行 `kubectl apply -f statefulset.yaml`）， 那么应用该清单的操作会覆盖你之前所做的手动扩缩。

如果 [HorizontalPodAutoscaler](https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/) （或任何类似的水平扩缩 API）正在管理 StatefulSet 的扩缩， 请不要设置 `.spec.replicas`。 相反，允许 Kubernetes 控制平面自动管理 `.spec.replicas` 字段。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。
- 了解如何使用 StatefulSet
    - 跟随示例[部署有状态应用](https://kubernetes.io/zh-cn/docs/tutorials/stateful-application/basic-stateful-set/)。
    - 跟随示例[使用 StatefulSet 部署 Cassandra](https://kubernetes.io/zh-cn/docs/tutorials/stateful-application/cassandra/)。
    - 跟随示例[运行多副本的有状态应用程序](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-replicated-stateful-application/)。
    - 了解如何[扩缩 StatefulSet](https://kubernetes.io/zh-cn/docs/tasks/run-application/scale-stateful-set/)。
    - 了解[删除 StatefulSet](https://kubernetes.io/zh-cn/docs/tasks/run-application/delete-stateful-set/)涉及到的操作。
    - 了解如何[配置 Pod 以使用卷进行存储](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-volume-storage/)。
    - 了解如何[配置 Pod 以使用 PersistentVolume 作为存储](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/)。
- `StatefulSet` 是 Kubernetes REST API 中的顶级资源。阅读 [StatefulSet](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/) 对象定义理解关于该资源的 API。
- 阅读 [Pod 干扰预算（Disruption Budget）](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions/)，了解如何在干扰下运行高度可用的应用。
#### [DaemonSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/)
**DaemonSet** 确保全部（或者某些）节点上运行一个 Pod 的副本。 当有节点加入集群时， 也会为他们新增一个 Pod 。 当有节点从集群移除时，这些 Pod 也会被回收。删除 DaemonSet 将会删除它创建的所有 Pod。

DaemonSet 的一些典型用法：

- 在每个节点上运行集群守护进程
- 在每个节点上运行日志收集守护进程
- 在每个节点上运行监控守护进程

一种简单的用法是为每种类型的守护进程在所有的节点上都启动一个 DaemonSet。 一个稍微复杂的用法是为同一种守护进程部署多个 DaemonSet；每个具有不同的标志， 并且对不同硬件类型具有不同的内存、CPU 要求。

##### 编写 DaemonSet Spec[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#writing-a-daemon-set-spec)

###### 创建 DaemonSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#create-a-daemon-set)

你可以在 YAML 文件中描述 DaemonSet。 例如，下面的 daemonset.yaml 文件描述了一个运行 fluentd-elasticsearch Docker 镜像的 DaemonSet：

[`controllers/daemonset.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/daemonset.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/daemonset.yaml to clipboard")

```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluentd-elasticsearch
  namespace: kube-system
  labels:
    k8s-app: fluentd-logging
spec:
  selector:
    matchLabels:
      name: fluentd-elasticsearch
  template:
    metadata:
      labels:
        name: fluentd-elasticsearch
    spec:
      tolerations:
      # 这些容忍度设置是为了让该守护进程集在控制平面节点上运行
      # 如果你不希望自己的控制平面节点运行 Pod，可以删除它们
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule
      containers:
      - name: fluentd-elasticsearch
        image: quay.io/fluentd_elasticsearch/fluentd:v2.5.2
        resources:
          limits:
            memory: 200Mi
          requests:
            cpu: 100m
            memory: 200Mi
        volumeMounts:
        - name: varlog
          mountPath: /var/log
      terminationGracePeriodSeconds: 30
      volumes:
      - name: varlog
        hostPath:
          path: /var/log
```

基于 YAML 文件创建 DaemonSet：

```
kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
```

###### 必需字段[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#required-fields)

与所有其他 Kubernetes 配置一样，DaemonSet 也需要 `apiVersion`、`kind` 和 `metadata` 字段。 有关使用这些配置文件的通用信息， 参见[运行无状态应用](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/)和[使用 kubectl 管理对象](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/)。

DaemonSet 对象的名称必须是一个合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)。

DaemonSet 也需要 [`.spec`](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status) 节区。

###### Pod 模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#pod-template)

`.spec` 中唯一必需的字段是 `.spec.template`。

`.spec.template` 是一个 [Pod 模板](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)。 除了它是嵌套的，因而不具有 `apiVersion` 或 `kind` 字段之外，它与 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 具有相同的 schema。

除了 Pod 必需字段外，在 DaemonSet 中的 Pod 模板必须指定合理的标签（查看 [Pod 选择算符](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#pod-selector)）。

在 DaemonSet 中的 Pod 模板必须具有一个值为 `Always` 的 [`RestartPolicy`](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy)。 当该值未指定时，默认是 `Always`。

###### Pod 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#pod-selector)

`.spec.selector` 字段表示 Pod 选择算符，它与 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 的 `.spec.selector` 的作用是相同的。

你必须指定与 `.spec.template` 的标签匹配的 Pod 选择算符。 此外，一旦创建了 DaemonSet，它的 `.spec.selector` 就不能修改。 修改 Pod 选择算符可能导致 Pod 意外悬浮，并且这对用户来说是费解的。

`spec.selector` 是一个对象，如下两个字段组成：

- `matchLabels` - 与 [ReplicationController](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/) 的 `.spec.selector` 的作用相同。
- `matchExpressions` - 允许构建更加复杂的选择器，可以通过指定 key、value 列表以及将 key 和 value 列表关联起来的 Operator。

当上述两个字段都指定时，结果会按逻辑与（AND）操作处理。

`.spec.selector` 必须与 `.spec.template.metadata.labels` 相匹配。 如果配置中这两个字段不匹配，则会被 API 拒绝。

###### 在选定的节点上运行 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#running-pods-on-select-nodes)

如果指定了 `.spec.template.spec.nodeSelector`，DaemonSet 控制器将在能够与 [Node 选择算符](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/)匹配的节点上创建 Pod。 类似这种情况，可以指定 `.spec.template.spec.affinity`，之后 DaemonSet 控制器将在能够与[节点亲和性](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/)匹配的节点上创建 Pod。 如果根本就没有指定，则 DaemonSet Controller 将在所有节点上创建 Pod。

##### Daemon Pods 是如何被调度的[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#how-daemon-pods-are-scheduled)

DaemonSet 确保所有符合条件的节点都运行该 Pod 的一个副本。 DaemonSet 控制器为每个符合条件的节点创建一个 Pod，并添加 Pod 的 `spec.affinity.nodeAffinity` 字段以匹配目标主机。Pod 被创建之后，默认的调度程序通常通过设置 `.spec.nodeName` 字段来接管 Pod 并将 Pod 绑定到目标主机。如果新的 Pod 无法放在节点上，则默认的调度程序可能会根据新 Pod 的[优先级](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority)抢占 （驱逐）某些现存的 Pod。

用户通过设置 DaemonSet 的 `.spec.template.spec.schedulerName` 字段，可以为 DamonSet 的 Pod 指定不同的调度程序。

当评估符合条件的节点时，原本在 `.spec.template.spec.affinity.nodeAffinity` 字段上指定的节点亲和性将由 DaemonSet 控制器进行考量，但在创建的 Pod 上会被替换为与符合条件的节点名称匹配的节点亲和性。

`ScheduleDaemonSetPods` 允许你使用默认调度器而不是 DaemonSet 控制器来调度这些 DaemonSet， 方法是将 `NodeAffinity` 条件而不是 `.spec.nodeName` 条件添加到这些 DaemonSet Pod。 默认调度器接下来将 Pod 绑定到目标主机。 如果 DaemonSet Pod 的节点亲和性配置已存在，则被替换 （原始的节点亲和性配置在选择目标主机之前被考虑）。 DaemonSet 控制器仅在创建或修改 DaemonSet Pod 时执行这些操作， 并且不会更改 DaemonSet 的 `spec.template`。

```yaml
nodeAffinity:
  requiredDuringSchedulingIgnoredDuringExecution:
    nodeSelectorTerms:
    - matchFields:
      - key: metadata.name
        operator: In
        values:
        - target-host-name
```

###### 污点和容忍度[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#taint-and-toleration)

DaemonSet 控制器会自动将一组容忍度添加到 DaemonSet Pod：

| 容忍度键名 | 效果 | 描述 |
| --- | --- | --- |
| [`node.kubernetes.io/not-ready`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-not-ready) | `NoExecute` | DaemonSet Pod 可以被调度到不健康或还不准备接受 Pod 的节点上。在这些节点上运行的所有 DaemonSet Pod 将不会被驱逐。 |
| [`node.kubernetes.io/unreachable`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-unreachable) | `NoExecute` | DaemonSet Pod 可以被调度到从节点控制器不可达的节点上。在这些节点上运行的所有 DaemonSet Pod 将不会被驱逐。 |
| [`node.kubernetes.io/disk-pressure`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-disk-pressure) | `NoSchedule` | DaemonSet Pod 可以被调度到具有磁盘压力问题的节点上。 |
| [`node.kubernetes.io/memory-pressure`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-memory-pressure) | `NoSchedule` | DaemonSet Pod 可以被调度到具有内存压力问题的节点上。 |
| [`node.kubernetes.io/pid-pressure`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-pid-pressure) | `NoSchedule` | DaemonSet Pod 可以被调度到具有进程压力问题的节点上。 |
| [`node.kubernetes.io/unschedulable`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-unschedulable) | `NoSchedule` | DaemonSet Pod 可以被调度到不可调度的节点上。 |
| [`node.kubernetes.io/network-unavailable`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#node-kubernetes-io-network-unavailable) | `NoSchedule` | **仅针对请求主机联网的 DaemonSet Pod 添加此容忍度**，即 Pod 具有 `spec.hostNetwork: true`。这些 DaemonSet Pod 可以被调度到网络不可用的节点上。 |

你也可以在 DaemonSet 的 Pod 模板中定义自己的容忍度并将其添加到 DaemonSet Pod。

因为 DaemonSet 控制器自动设置 `node.kubernetes.io/unschedulable:NoSchedule` 容忍度， 所以 Kubernetes 可以在标记为**不可调度**的节点上运行 DaemonSet Pod。

如果你使用 DaemonSet 提供重要的节点级别功能， 例如[集群联网](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/)， Kubernetes 在节点就绪之前将 DaemonSet Pod 放到节点上会很有帮助。 例如，如果没有这种特殊的容忍度，因为网络插件未在节点上运行，所以你可能会在未标记为就绪的节点上陷入死锁状态， 同时因为该节点还未就绪，所以网络插件不会在该节点上运行。

##### 与 Daemon Pod 通信[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#communicating-with-daemon-pods)

与 DaemonSet 中的 Pod 进行通信的几种可能模式如下：

- **推送（Push）**：配置 DaemonSet 中的 Pod，将更新发送到另一个服务，例如统计数据库。 这些服务没有客户端。
    
- **NodeIP 和已知端口**：DaemonSet 中的 Pod 可以使用 `hostPort`，从而可以通过节点 IP 访问到 Pod。客户端能通过某种方法获取节点 IP 列表，并且基于此也可以获取到相应的端口。
    
- **DNS**：创建具有相同 Pod 选择算符的[无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)， 通过使用 `endpoints` 资源或从 DNS 中检索到多个 A 记录来发现 DaemonSet。
    
- **Service**：创建具有相同 Pod 选择算符的服务，并使用该服务随机访问到某个节点上的守护进程（没有办法访问到特定节点）。
    

##### 更新 DaemonSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#updating-a-daemon-set)

如果节点的标签被修改，DaemonSet 将立刻向新匹配上的节点添加 Pod， 同时删除不匹配的节点上的 Pod。

你可以修改 DaemonSet 创建的 Pod。不过并非 Pod 的所有字段都可更新。 下次当某节点（即使具有相同的名称）被创建时，DaemonSet 控制器还会使用最初的模板。

你可以删除一个 DaemonSet。如果使用 `kubectl` 并指定 `--cascade=orphan` 选项， 则 Pod 将被保留在节点上。接下来如果创建使用相同选择算符的新 DaemonSet， 新的 DaemonSet 会收养已有的 Pod。 如果有 Pod 需要被替换，DaemonSet 会根据其 `updateStrategy` 来替换。

你可以对 DaemonSet [执行滚动更新](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/)操作。

##### DaemonSet 的替代方案[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#alternatives-to-daemon-set)

###### init 脚本[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#init-scripts)

直接在节点上启动守护进程（例如使用 `init`、`upstartd` 或 `systemd`）的做法当然是可行的。 不过，基于 DaemonSet 来运行这些进程有如下一些好处：

- 像所运行的其他应用一样，DaemonSet 具备为守护进程提供监控和日志管理的能力。
    
- 为守护进程和应用所使用的配置语言和工具（如 Pod 模板、`kubectl`）是相同的。
    
- 在资源受限的容器中运行守护进程能够增加守护进程和应用容器的隔离性。 然而，这一点也可以通过在容器中运行守护进程但却不在 Pod 中运行之来实现。
    

###### 裸 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#bare-pods)

直接创建 Pod并指定其运行在特定的节点上也是可以的。 然而，DaemonSet 能够替换由于任何原因（例如节点失败、例行节点维护、内核升级） 而被删除或终止的 Pod。 由于这个原因，你应该使用 DaemonSet 而不是单独创建 Pod。

###### 静态 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#static-pods)

通过在一个指定的、受 `kubelet` 监视的目录下编写文件来创建 Pod 也是可行的。 这类 Pod 被称为[静态 Pod](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/static-pod/)。 不像 DaemonSet，静态 Pod 不受 `kubectl` 和其它 Kubernetes API 客户端管理。 静态 Pod 不依赖于 API 服务器，这使得它们在启动引导新集群的情况下非常有用。 此外，静态 Pod 在将来可能会被废弃。

###### Deployment[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#deployment)

DaemonSet 与 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 非常类似， 它们都能创建 Pod，并且 Pod 中的进程都不希望被终止（例如，Web 服务器、存储服务器）。

建议为无状态的服务使用 Deployment，比如前端服务。 对这些服务而言，对副本的数量进行扩缩容、平滑升级，比精确控制 Pod 运行在某个主机上要重要得多。 当需要 Pod 副本总是运行在全部或特定主机上，并且当该 DaemonSet 提供了节点级别的功能（允许其他 Pod 在该特定节点上正确运行）时， 应该使用 DaemonSet。

例如，[网络插件](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)通常包含一个以 DaemonSet 运行的组件。 这个 DaemonSet 组件确保它所在的节点的集群网络正常工作。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。
    - 了解[静态 Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/#static-pods)，这对运行 Kubernetes [控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)组件有帮助。
- 了解如何使用 DaemonSet
    - [对 DaemonSet 执行滚动更新](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/)
    - [对 DaemonSet 执行回滚](https://kubernetes.io/zh-cn/docs/tasks/manage-daemon/rollback-daemon-set/)（例如：新的版本没有达到你的预期）
- 理解[Kubernetes 如何将 Pod 分配给节点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/)。
- 了解[设备插件](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/)和 [扩展（Addons）](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/)，它们常以 DaemonSet 运行。
- `DaemonSet` 是 Kubernetes REST API 中的顶级资源。阅读 [DaemonSet](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/daemon-set-v1/) 对象定义理解关于该资源的 API。
#### [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/)
    Job 会创建一个或者多个 Pod，并将继续重试 Pod 的执行，直到指定数量的 Pod 成功终止。 随着 Pod 成功结束，Job 跟踪记录成功完成的 Pod 个数。 当数量达到指定的成功个数阈值时，任务（即 Job）结束。 删除 Job 的操作会清除所创建的全部 Pod。 挂起 Job 的操作会删除 Job 的所有活跃 Pod，直到 Job 被再次恢复执行。

一种简单的使用场景下，你会创建一个 Job 对象以便以一种可靠的方式运行某 Pod 直到完成。 当第一个 Pod 失败或者被删除（比如因为节点硬件失效或者重启）时，Job 对象会启动一个新的 Pod。

你也可以使用 Job 以并行的方式运行多个 Pod。

如果你想按某种排期表（Schedule）运行 Job（单个任务或多个并行任务），请参阅 [CronJob](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/)。

##### 运行示例 Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#running-an-example-job)

下面是一个 Job 配置示例。它负责计算 π 到小数点后 2000 位，并将结果打印出来。 此计算大约需要 10 秒钟完成。

[`controllers/job.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/job.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/job.yaml to clipboard")

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34.0
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
  backoffLimit: 4

```

你可以使用下面的命令来运行此示例：

```shell
kubectl apply -f https://kubernetes.io/examples/controllers/job.yaml
```

输出类似于：

```
job.batch/pi created
```

使用 `kubectl` 来检查 Job 的状态：

- [kubectl describe job pi](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#check-status-of-job-0)
- [kubectl get job pi -o yaml](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#check-status-of-job-1)

```bash

Name:             pi
Namespace:        default
Selector:         controller-uid=0cd26dd5-88a2-4a5f-a203-ea19a1d5d578
Labels:           controller-uid=0cd26dd5-88a2-4a5f-a203-ea19a1d5d578
                  job-name=pi
Annotations:      batch.kubernetes.io/job-tracking: 
Parallelism:      1
Completions:      1
Completion Mode:  NonIndexed
Start Time:       Fri, 28 Oct 2022 13:05:18 +0530
Completed At:     Fri, 28 Oct 2022 13:05:21 +0530
Duration:         3s
Pods Statuses:    0 Active / 1 Succeeded / 0 Failed
Pod Template:
  Labels:  controller-uid=0cd26dd5-88a2-4a5f-a203-ea19a1d5d578
           job-name=pi
  Containers:
   pi:
    Image:      perl:5.34.0
    Port:       <none>
    Host Port:  <none>
    Command:
      perl
      -Mbignum=bpi
      -wle
      print bpi(2000)
    Environment:  <none>
    Mounts:       <none>
  Volumes:        <none>
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  21s   job-controller  Created pod: pi-xf9p4
  Normal  Completed         18s   job-controller  Job completed
```

```bash

apiVersion: batch/v1
kind: Job
metadata:
  annotations:
    batch.kubernetes.io/job-tracking: ""
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"batch/v1","kind":"Job","metadata":{"annotations":{},"name":"pi","namespace":"default"},"spec":{"backoffLimit":4,"template":{"spec":{"containers":[{"command":["perl","-Mbignum=bpi","-wle","print bpi(2000)"],"image":"perl:5.34.0","name":"pi"}],"restartPolicy":"Never"}}}}
  creationTimestamp: "2022-11-10T17:53:53Z"
  generation: 1
  labels:
    controller-uid: 204fb678-040b-497f-9266-35ffa8716d14
    job-name: pi
  name: pi
  namespace: default
  resourceVersion: "4751"
  uid: 204fb678-040b-497f-9266-35ffa8716d14
spec:
  backoffLimit: 4
  completionMode: NonIndexed
  completions: 1
  parallelism: 1
  selector:
    matchLabels:
      controller-uid: 204fb678-040b-497f-9266-35ffa8716d14
  suspend: false
  template:
    metadata:
      creationTimestamp: null
      labels:
        controller-uid: 204fb678-040b-497f-9266-35ffa8716d14
        job-name: pi
    spec:
      containers:
      - command:
        - perl
        - -Mbignum=bpi
        - -wle
        - print bpi(2000)
        image: perl:5.34.0
        imagePullPolicy: IfNotPresent
        name: pi
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Never
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
status:
  active: 1
  ready: 0
  startTime: "2022-11-10T17:53:57Z"
  uncountedTerminatedPods: {}
```

要查看 Job 对应的已完成的 Pod，可以执行 `kubectl get pods`。

要以机器可读的方式列举隶属于某 Job 的全部 Pod，你可以使用类似下面这条命令：

```shell
pods=$(kubectl get pods --selector=job-name=pi --output=jsonpath='{.items[*].metadata.name}')
echo $pods
```

输出类似于：

```
pi-5rwd7
```

这里，选择算符与 Job 的选择算符相同。`--output=jsonpath` 选项给出了一个表达式， 用来从返回的列表中提取每个 Pod 的 name 字段。

查看其中一个 Pod 的标准输出：

```shell
kubectl logs $pods
```

输出类似于：

```
3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
```

##### 编写 Job 规约[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#writing-a-job-spec)

与 Kubernetes 中其他资源的配置类似，Job 也需要 `apiVersion`、`kind` 和 `metadata` 字段。

当控制面为 Job 创建新的 Pod 时，Job 的 `.metadata.name` 是命名这些 Pod 的基础组成部分。 Job 的名字必须是合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)值， 但这可能对 Pod 主机名产生意料之外的结果。为了获得最佳兼容性，此名字应遵循更严格的 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规则。 即使该名字被要求遵循 DNS 子域名规则，也不得超过 63 个字符。

Job 配置还需要一个 [`.spec` 节](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status)。

###### Pod 模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-template)

Job 的 `.spec` 中只有 `.spec.template` 是必需的字段。

字段 `.spec.template` 的值是一个 [Pod 模板](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)。 其定义规范与 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 完全相同，只是其中不再需要 `apiVersion` 或 `kind` 字段。

除了作为 Pod 所必需的字段之外，Job 中的 Pod 模板必须设置合适的标签 （参见 [Pod 选择算符](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-selector)）和合适的重启策略。

Job 中 Pod 的 [`RestartPolicy`](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy) 只能设置为 `Never` 或 `OnFailure` 之一。

###### Pod 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-selector)

字段 `.spec.selector` 是可选的。在绝大多数场合，你都不需要为其赋值。 参阅[设置自己的 Pod 选择算符](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#specifying-your-own-pod-selector).

###### Job 的并行执行[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#parallel-jobs)

适合以 Job 形式来运行的任务主要有三种：

1. 非并行 Job：
    - 通常只启动一个 Pod，除非该 Pod 失败。
    - 当 Pod 成功终止时，立即视 Job 为完成状态。
2. 具有**确定完成计数**的并行 Job：
    - `.spec.completions` 字段设置为非 0 的正数值。
    - Job 用来代表整个任务，当成功的 Pod 个数达到 `.spec.completions` 时，Job 被视为完成。
    - 当使用 `.spec.completionMode="Indexed"` 时，每个 Pod 都会获得一个不同的 索引值，介于 0 和 `.spec.completions-1` 之间。
3. 带**工作队列**的并行 Job：
    - 不设置 `spec.completions`，默认值为 `.spec.parallelism`。
    - 多个 Pod 之间必须相互协调，或者借助外部服务确定每个 Pod 要处理哪个工作条目。 例如，任一 Pod 都可以从工作队列中取走最多 N 个工作条目。
    - 每个 Pod 都可以独立确定是否其它 Pod 都已完成，进而确定 Job 是否完成。
    - 当 Job 中**任何** Pod 成功终止，不再创建新 Pod。
    - 一旦至少 1 个 Pod 成功完成，并且所有 Pod 都已终止，即可宣告 Job 成功完成。
    - 一旦任何 Pod 成功退出，任何其它 Pod 都不应再对此任务执行任何操作或生成任何输出。 所有 Pod 都应启动退出过程。

对于**非并行**的 Job，你可以不设置 `spec.completions` 和 `spec.parallelism`。 这两个属性都不设置时，均取默认值 1。

对于**确定完成计数**类型的 Job，你应该设置 `.spec.completions` 为所需要的完成个数。 你可以设置 `.spec.parallelism`，也可以不设置。其默认值为 1。

对于一个**工作队列** Job，你不可以设置 `.spec.completions`，但要将`.spec.parallelism` 设置为一个非负整数。

关于如何利用不同类型的 Job 的更多信息，请参见 [Job 模式](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#job-patterns)一节。

####### 控制并行性[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#controlling-parallelism)

并行性请求（`.spec.parallelism`）可以设置为任何非负整数。 如果未设置，则默认为 1。 如果设置为 0，则 Job 相当于启动之后便被暂停，直到此值被增加。

实际并行性（在任意时刻运行状态的 Pod 个数）可能比并行性请求略大或略小， 原因如下：

- 对于**确定完成计数** Job，实际上并行执行的 Pod 个数不会超出剩余的完成数。 如果 `.spec.parallelism` 值较高，会被忽略。
- 对于**工作队列** Job，有任何 Job 成功结束之后，不会有新的 Pod 启动。 不过，剩下的 Pod 允许执行完毕。
- 如果 Job [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 没有来得及作出响应，或者
- 如果 Job 控制器因为任何原因（例如，缺少 `ResourceQuota` 或者没有权限）无法创建 Pod。 Pod 个数可能比请求的数目小。
- Job 控制器可能会因为之前同一 Job 中 Pod 失效次数过多而压制新 Pod 的创建。
- 当 Pod 处于体面终止进程中，需要一定时间才能停止。

###### 完成模式[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#completion-mode)

**特性状态：** `Kubernetes v1.24 [stable]`

带有**确定完成计数**的 Job，即 `.spec.completions` 不为 null 的 Job， 都可以在其 `.spec.completionMode` 中设置完成模式：

- `NonIndexed`（默认值）：当成功完成的 Pod 个数达到 `.spec.completions` 所 设值时认为 Job 已经完成。换言之，每个 Job 完成事件都是独立无关且同质的。 要注意的是，当 `.spec.completions` 取值为 null 时，Job 被隐式处理为 `NonIndexed`。
    
- `Indexed`：Job 的 Pod 会获得对应的完成索引，取值为 0 到 `.spec.completions-1`。 该索引可以通过三种方式获取：
    
    - Pod 注解 `batch.kubernetes.io/job-completion-index`。
    - 作为 Pod 主机名的一部分，遵循模式 `$(job-name)-$(index)`。 当你同时使用带索引的 Job（Indexed Job）与 [服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)， Job 中的 Pod 可以通过 DNS 使用确切的主机名互相寻址。 有关如何配置的更多信息，请参阅[带 Pod 间通信的 Job](https://kubernetes.io/zh-cn/docs/tasks/job/job-with-pod-to-pod-communication/)。
    - 对于容器化的任务，在环境变量 `JOB_COMPLETION_INDEX` 中。
    
    当每个索引都对应一个成功完成的 Pod 时，Job 被认为是已完成的。 关于如何使用这种模式的更多信息，可参阅 [用带索引的 Job 执行基于静态任务分配的并行处理](https://kubernetes.io/zh-cn/docs/tasks/job/indexed-parallel-processing-static/)。 需要注意的是，对同一索引值可能被启动的 Pod 不止一个，尽管这种情况很少发生。 这时，只有一个会被记入完成计数中。
    

##### 处理 Pod 和容器失效[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#handling-pod-and-container-failures)

Pod 中的容器可能因为多种不同原因失效，例如因为其中的进程退出时返回值非零， 或者容器因为超出内存约束而被杀死等等。 如果发生这类事件，并且 `.spec.template.spec.restartPolicy = "OnFailure"`， Pod 则继续留在当前节点，但容器会被重新运行。 因此，你的程序需要能够处理在本地被重启的情况，或者要设置 `.spec.template.spec.restartPolicy = "Never"`。 关于 `restartPolicy` 的更多信息，可参阅 [Pod 生命周期](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#example-states)。

整个 Pod 也可能会失败，且原因各不相同。 例如，当 Pod 启动时，节点失效（被升级、被重启、被删除等）或者其中的容器失败而 `.spec.template.spec.restartPolicy = "Never"`。 当 Pod 失败时，Job 控制器会启动一个新的 Pod。 这意味着，你的应用需要处理在一个新 Pod 中被重启的情况。 尤其是应用需要处理之前运行所产生的临时文件、锁、不完整的输出等问题。

默认情况下，每个 Pod 失效都被计入 `.spec.backoffLimit` 限制， 请参阅 [Pod 回退失效策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy)。 但你可以通过设置 Job 的 [Pod 失效策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-failure-policy)自定义对 Pod 失效的处理方式。

注意，即使你将 `.spec.parallelism` 设置为 1，且将 `.spec.completions` 设置为 1，并且 `.spec.template.spec.restartPolicy` 设置为 "Never"，同一程序仍然有可能被启动两次。

如果你确实将 `.spec.parallelism` 和 `.spec.completions` 都设置为比 1 大的值， 那就有可能同时出现多个 Pod 运行的情况。 为此，你的 Pod 也必须能够处理并发性问题。

当[特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/) `PodDisruptionConditions` 和 `JobPodFailurePolicy` 都被启用且 `.spec.podFailurePolicy` 字段被设置时， Job 控制器不会将终止过程中的 Pod（已设置 `.metadata.deletionTimestamp` 字段的 Pod）视为失效 Pod， 直到该 Pod 完全终止（其 `.status.phase` 为 `Failed` 或 `Succeeded`）。 但只要终止变得显而易见，Job 控制器就会创建一个替代的 Pod。一旦 Pod 终止，Job 控制器将把这个刚终止的 Pod 考虑在内，评估相关 Job 的 `.backoffLimit` 和 `.podFailurePolicy`。

如果不满足任一要求，即使 Pod 稍后以 `phase: "Succeeded"` 终止，Job 控制器也会将此即将终止的 Pod 计为立即失效。

###### Pod 回退失效策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy)

在有些情形下，你可能希望 Job 在经历若干次重试之后直接进入失败状态， 因为这很可能意味着遇到了配置错误。 为了实现这点，可以将 `.spec.backoffLimit` 设置为视 Job 为失败之前的重试次数。 失效回退的限制值默认为 6。 与 Job 相关的失效的 Pod 会被 Job 控制器重建，回退重试时间将会按指数增长 （从 10 秒、20 秒到 40 秒）最多至 6 分钟。

计算重试次数有以下两种方法：

- 计算 `.status.phase = "Failed"` 的 Pod 数量。
- 当 Pod 的 `restartPolicy = "OnFailure"` 时，针对 `.status.phase` 等于 `Pending` 或 `Running` 的 Pod，计算其中所有容器的重试次数。

如果两种方式其中一个的值达到 `.spec.backoffLimit`，则 Job 被判定为失败。

**说明：**

如果你的 Job 的 `restartPolicy` 被设置为 "OnFailure"，就要注意运行该 Job 的 Pod 会在 Job 到达失效回退次数上限时自动被终止。 这会使得调试 Job 中可执行文件的工作变得非常棘手。 我们建议在调试 Job 时将 `restartPolicy` 设置为 "Never"， 或者使用日志系统来确保失效 Job 的输出不会意外遗失。

##### Job 终止与清理[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#job-termination-and-cleanup)

Job 完成时不会再创建新的 Pod，不过已有的 Pod [通常](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy)也不会被删除。 保留这些 Pod 使得你可以查看已完成的 Pod 的日志输出，以便检查错误、警告或者其它诊断性输出。 Job 完成时 Job 对象也一样被保留下来，这样你就可以查看它的状态。 在查看了 Job 状态之后删除老的 Job 的操作留给了用户自己。 你可以使用 `kubectl` 来删除 Job（例如，`kubectl delete jobs/pi` 或者 `kubectl delete -f ./job.yaml`）。 当使用 `kubectl` 来删除 Job 时，该 Job 所创建的 Pod 也会被删除。

默认情况下，Job 会持续运行，除非某个 Pod 失败（`restartPolicy=Never`） 或者某个容器出错退出（`restartPolicy=OnFailure`）。 这时，Job 基于前述的 `spec.backoffLimit` 来决定是否以及如何重试。 一旦重试次数到达 `.spec.backoffLimit` 所设的上限，Job 会被标记为失败， 其中运行的 Pod 都会被终止。

终止 Job 的另一种方式是设置一个活跃期限。 你可以为 Job 的 `.spec.activeDeadlineSeconds` 设置一个秒数值。 该值适用于 Job 的整个生命期，无论 Job 创建了多少个 Pod。 一旦 Job 运行时间达到 `activeDeadlineSeconds` 秒，其所有运行中的 Pod 都会被终止， 并且 Job 的状态更新为 `type: Failed` 及 `reason: DeadlineExceeded`。

注意 Job 的 `.spec.activeDeadlineSeconds` 优先级高于其 `.spec.backoffLimit` 设置。 因此，如果一个 Job 正在重试一个或多个失效的 Pod，该 Job 一旦到达 `activeDeadlineSeconds` 所设的时限即不再部署额外的 Pod， 即使其重试次数还未达到 `backoffLimit` 所设的限制。

例如：

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi-with-timeout
spec:
  backoffLimit: 5
  activeDeadlineSeconds: 100
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34.0
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
```

注意 Job 规约和 Job 中的 [Pod 模板规约](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/init-containers/#detailed-behavior) 都有 `activeDeadlineSeconds` 字段。 请确保你在合适的层次设置正确的字段。

还要注意的是，`restartPolicy` 对应的是 Pod，而不是 Job 本身： 一旦 Job 状态变为 `type: Failed`，就不会再发生 Job 重启的动作。 换言之，由 `.spec.activeDeadlineSeconds` 和 `.spec.backoffLimit` 所触发的 Job 终结机制都会导致 Job 永久性的失败，而这类状态都需要手工干预才能解决。

##### 自动清理完成的 Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically)

完成的 Job 通常不需要留存在系统中。在系统中一直保留它们会给 API 服务器带来额外的压力。 如果 Job 由某种更高级别的控制器来管理，例如 [CronJob](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/)， 则 Job 可以被 CronJob 基于特定的根据容量裁定的清理策略清理掉。

###### 已完成 Job 的 TTL 机制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#ttl-mechanisms-for-finished-jobs)

**特性状态：** `Kubernetes v1.23 [stable]`

自动清理已完成 Job （状态为 `Complete` 或 `Failed`）的另一种方式是使用由 [TTL 控制器](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/)所提供的 TTL 机制。 通过设置 Job 的 `.spec.ttlSecondsAfterFinished` 字段，可以让该控制器清理掉已结束的资源。

TTL 控制器清理 Job 时，会级联式地删除 Job 对象。 换言之，它会删除所有依赖的对象，包括 Pod 及 Job 本身。 注意，当 Job 被删除时，系统会考虑其生命周期保障，例如其 Finalizers。

例如：

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: pi-with-ttl
spec:
  ttlSecondsAfterFinished: 100
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34.0
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never
```

Job `pi-with-ttl` 在结束 100 秒之后，可以成为被自动删除的对象。

如果该字段设置为 `0`，Job 在结束之后立即成为可被自动删除的对象。 如果该字段没有设置，Job 不会在结束之后被 TTL 控制器自动清除。

**说明：**

建议设置 `ttlSecondsAfterFinished` 字段，因为非托管任务 （是你直接创建的 Job，而不是通过其他工作负载 API（如 CronJob）间接创建的 Job） 的默认删除策略是 `orphanDependents`，这会导致非托管 Job 创建的 Pod 在该 Job 被完全删除后被保留。 即使[控制面](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-control-plane)最终在 Pod 失效或完成后 对已删除 Job 中的这些 Pod 执行[垃圾收集](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)操作， 这些残留的 Pod 有时可能会导致集群性能下降，或者在最坏的情况下会导致集群因这种性能下降而离线。

你可以使用 [LimitRange](https://kubernetes.io/zh-cn/docs/concepts/policy/limit-range/) 和 [ResourceQuota](https://kubernetes.io/zh-cn/docs/concepts/policy/resource-quotas/)， 设定一个特定名字空间可以消耗的资源上限。

##### Job 模式[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#job-patterns)

Job 对象可以用来支持多个 Pod 的可靠的并发执行。 Job 对象不是设计用来支持相互通信的并行进程的，后者一般在科学计算中应用较多。 Job 的确能够支持对一组相互独立而又有所关联的**工作条目**的并行处理。 这类工作条目可能是要发送的电子邮件、要渲染的视频帧、要编解码的文件、NoSQL 数据库中要扫描的主键范围等等。

在一个复杂系统中，可能存在多个不同的工作条目集合。 这里我们仅考虑用户希望一起管理的工作条目集合之一：**批处理作业**。

并行计算的模式有好多种，每种都有自己的强项和弱点。这里要权衡的因素有：

- 每个工作条目对应一个 Job 或者所有工作条目对应同一 Job 对象。 后者更适合处理大量工作条目的场景； 前者会给用户带来一些额外的负担，而且需要系统管理大量的 Job 对象。
- 创建与工作条目相等的 Pod 或者令每个 Pod 可以处理多个工作条目。 前者通常不需要对现有代码和容器做较大改动； 后者则更适合工作条目数量较大的场合，原因同上。
- 有几种技术都会用到工作队列。这意味着需要运行一个队列服务， 并修改现有程序或容器使之能够利用该工作队列。 与之比较，其他方案在修改现有容器化应用以适应需求方面可能更容易一些。

下面是对这些权衡的汇总，第 2 到 4 列对应上面的权衡比较。 模式的名称对应了相关示例和更详细描述的链接。

| 模式 | 单个 Job 对象 | Pod 数少于工作条目数？ | 直接使用应用无需修改? |
| --- | --- | --- | --- |
| [每工作条目一 Pod 的队列](https://kubernetes.io/zh-cn/docs/tasks/job/coarse-parallel-processing-work-queue/) | ✓ |  | 有时 |
| [Pod 数量可变的队列](https://kubernetes.io/zh-cn/docs/tasks/job/fine-parallel-processing-work-queue/) | ✓ | ✓ |  |
| [静态任务分派的带索引的 Job](https://kubernetes.io/zh-cn/docs/tasks/job/indexed-parallel-processing-static) | ✓ |  | ✓ |
| [Job 模板扩展](https://kubernetes.io/zh-cn/docs/tasks/job/parallel-processing-expansion/) |  |  | ✓ |
| [带 Pod 间通信的 Job](https://kubernetes.io/zh-cn/docs/tasks/job/job-with-pod-to-pod-communication/) | ✓ | 有时 | 有时 |

当你使用 `.spec.completions` 来设置完成数时，Job 控制器所创建的每个 Pod 使用完全相同的 [`spec`](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status)。 这意味着任务的所有 Pod 都有相同的命令行，都使用相同的镜像和数据卷， 甚至连环境变量都（几乎）相同。 这些模式是让每个 Pod 执行不同工作的几种不同形式。

下表显示的是每种模式下 `.spec.parallelism` 和 `.spec.completions` 所需要的设置。 其中，`W` 表示的是工作条目的个数。

| 模式 | `.spec.completions` | `.spec.parallelism` |
| --- | --- | --- |
| [每工作条目一 Pod 的队列](https://kubernetes.io/zh-cn/docs/tasks/job/coarse-parallel-processing-work-queue/) | W | 任意值 |
| [Pod 个数可变的队列](https://kubernetes.io/zh-cn/docs/tasks/job/fine-parallel-processing-work-queue/) | 1 | 任意值 |
| [静态任务分派的带索引的 Job](https://kubernetes.io/zh-cn/docs/tasks/job/indexed-parallel-processing-static) | W |  |
| [Job 模板扩展](https://kubernetes.io/zh-cn/docs/tasks/job/parallel-processing-expansion/) | 1 | 应该为 1 |
| [带 Pod 间通信的 Job](https://kubernetes.io/zh-cn/docs/tasks/job/job-with-pod-to-pod-communication/) | W | W |

##### 高级用法[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#advanced-usage)

###### 挂起 Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#suspending-a-job)

**特性状态：** `Kubernetes v1.24 [stable]`

Job 被创建时，Job 控制器会马上开始执行 Pod 创建操作以满足 Job 的需求， 并持续执行此操作直到 Job 完成为止。 不过你可能想要暂时挂起 Job 执行，或启动处于挂起状态的 Job， 并拥有一个自定义控制器以后再决定什么时候开始。

要挂起一个 Job，你可以更新 `.spec.suspend` 字段为 true， 之后，当你希望恢复其执行时，将其更新为 false。 创建一个 `.spec.suspend` 被设置为 true 的 Job 本质上会将其创建为被挂起状态。

当 Job 被从挂起状态恢复执行时，其 `.status.startTime` 字段会被重置为当前的时间。 这意味着 `.spec.activeDeadlineSeconds` 计时器会在 Job 挂起时被停止， 并在 Job 恢复执行时复位。

当你挂起一个 Job 时，所有正在运行且状态不是 `Completed` 的 Pod 将被[终止](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination)。 Pod 的体面终止期限会被考虑，不过 Pod 自身也必须在此期限之内处理完信号。 处理逻辑可能包括保存进度以便将来恢复，或者取消已经做出的变更等等。 Pod 以这种形式终止时，不会被记入 Job 的 `completions` 计数。

处于被挂起状态的 Job 的定义示例可能是这样子：

```shell
kubectl get job myjob -o yaml
```

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: myjob
spec:
  suspend: true
  parallelism: 1
  completions: 5
  template:
    spec:
      ...
```

你也可以使用命令行为 Job 打补丁来切换 Job 的挂起状态。

挂起一个活跃的 Job：

```shell
kubectl patch job/myjob --type=strategic --patch '{"spec":{"suspend":true}}'
```

恢复一个挂起的 Job：

```shell
kubectl patch job/myjob --type=strategic --patch '{"spec":{"suspend":false}}'
```

Job 的 `status` 可以用来确定 Job 是否被挂起，或者曾经被挂起。

```shell
kubectl get jobs/myjob -o yaml
```

```yaml
apiVersion: batch/v1
kind: Job
# .metadata 和 .spec 已省略
status:
  conditions:
  - lastProbeTime: "2021-02-05T13:14:33Z"
    lastTransitionTime: "2021-02-05T13:14:33Z"
    status: "True"
    type: Suspended
  startTime: "2021-02-05T13:13:48Z"
```

Job 的 "Suspended" 类型的状况在状态值为 "True" 时意味着 Job 正被挂起； `lastTransitionTime` 字段可被用来确定 Job 被挂起的时长。 如果此状况字段的取值为 "False"，则 Job 之前被挂起且现在在运行。 如果 "Suspended" 状况在 `status` 字段中不存在，则意味着 Job 从未被停止执行。

当 Job 被挂起和恢复执行时，也会生成事件：

```shell
kubectl describe jobs/myjob
```

```
Name:           myjob
...
Events:
  Type    Reason            Age   From            Message
  ----    ------            ----  ----            -------
  Normal  SuccessfulCreate  12m   job-controller  Created pod: myjob-hlrpl
  Normal  SuccessfulDelete  11m   job-controller  Deleted pod: myjob-hlrpl
  Normal  Suspended         11m   job-controller  Job suspended
  Normal  SuccessfulCreate  3s    job-controller  Created pod: myjob-jvb44
  Normal  Resumed           3s    job-controller  Job resumed
```

最后四个事件，特别是 "Suspended" 和 "Resumed" 事件，都是因为 `.spec.suspend` 字段值被改来改去造成的。在这两个事件之间，我们看到没有 Pod 被创建，不过当 Job 被恢复执行时，Pod 创建操作立即被重启执行。

###### 可变调度指令[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#mutable-scheduling-directives)

**特性状态：** `Kubernetes v1.23 [beta]`

**说明：**

为了使用此功能，你必须在 [API 服务器](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/)上启用 `JobMutableNodeSchedulingDirectives` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。 默认情况下启用。

在大多数情况下，并行作业会希望 Pod 在一定约束条件下运行， 比如所有的 Pod 都在同一个区域，或者所有的 Pod 都在 GPU 型号 x 或 y 上，而不是两者的混合。

[suspend](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#suspending-a-job) 字段是实现这些语义的第一步。 suspend 允许自定义队列控制器，以决定工作何时开始；然而，一旦工作被取消暂停， 自定义队列控制器对 Job 中 Pod 的实际放置位置没有影响。

此特性允许在 Job 开始之前更新调度指令，从而为定制队列提供影响 Pod 放置的能力，同时将 Pod 与节点间的分配关系留给 kube-scheduler 决定。 这一特性仅适用于之前从未被暂停过的、已暂停的 Job。 控制器能够影响 Pod 放置，同时参考实际 pod-to-node 分配给 kube-scheduler。 这仅适用于从未暂停的 Job。

Job 的 Pod 模板中可以更新的字段是节点亲和性、节点选择器、容忍、标签和注解。

###### 指定你自己的 Pod 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#specifying-your-own-pod-selector)

通常，当你创建一个 Job 对象时，你不会设置 `.spec.selector`。 系统的默认值填充逻辑会在创建 Job 时添加此字段。 它会选择一个不会与任何其他 Job 重叠的选择算符设置。

不过，有些场合下，你可能需要重载这个自动设置的选择算符。 为了实现这点，你可以手动设置 Job 的 `spec.selector` 字段。

做这个操作时请务必小心。 如果你所设定的标签选择算符并不唯一针对 Job 对应的 Pod 集合， 甚或该算符还能匹配其他无关的 Pod，这些无关的 Job 的 Pod 可能会被删除。 或者当前 Job 会将另外一些 Pod 当作是完成自身工作的 Pod， 又或者两个 Job 之一或者二者同时都拒绝创建 Pod，无法运行至完成状态。 如果所设置的算符不具有唯一性，其他控制器（如 RC 副本控制器）及其所管理的 Pod 集合可能会变得行为不可预测。 Kubernetes 不会在你设置 `.spec.selector` 时尝试阻止你犯这类错误。

下面是一个示例场景，在这种场景下你可能会使用刚刚讲述的特性。

假定名为 `old` 的 Job 已经处于运行状态。 你希望已有的 Pod 继续运行，但你希望 Job 接下来要创建的其他 Pod 使用一个不同的 Pod 模板，甚至希望 Job 的名字也发生变化。 你无法更新现有的 Job，因为这些字段都是不可更新的。 因此，你会删除 `old` Job，但**允许该 Job 的 Pod 集合继续运行**。 这是通过 `kubectl delete jobs/old --cascade=orphan` 实现的。 在删除之前，我们先记下该 Job 所使用的选择算符。

```shell
kubectl get job old -o yaml
```

输出类似于：

```yaml
kind: Job
metadata:
  name: old
  ...
spec:
  selector:
    matchLabels:
      controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
```

接下来你会创建名为 `new` 的新 Job，并显式地为其设置相同的选择算符。 由于现有 Pod 都具有标签 `controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002`， 它们也会被名为 `new` 的 Job 所控制。

你需要在新 Job 中设置 `manualSelector: true`， 因为你并未使用系统通常自动为你生成的选择算符。

```yaml
kind: Job
metadata:
  name: new
  ...
spec:
  manualSelector: true
  selector:
    matchLabels:
      controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
```

新的 Job 自身会有一个不同于 `a8f3d00d-c6d2-11e5-9f87-42010af00002` 的唯一 ID。 设置 `manualSelector: true` 是在告诉系统你知道自己在干什么并要求系统允许这种不匹配的存在。

###### Pod 失效策略[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-failure-policy)

**特性状态：** `Kubernetes v1.26 [beta]`

**说明：**

只有你在集群中启用了 `JobPodFailurePolicy` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， 你才能为某个 Job 配置 Pod 失效策略。 此外，建议启用 `PodDisruptionConditions` 特性门控以便在 Pod 失效策略中检测和处理 Pod 干扰状况 （参考：[Pod 干扰状况](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/disruptions#pod-disruption-conditions)）。 这两个特性门控都是在 Kubernetes 1.26 中提供的。

Pod 失效策略使用 `.spec.podFailurePolicy` 字段来定义， 它能让你的集群根据容器的退出码和 Pod 状况来处理 Pod 失效事件。

在某些情况下，你可能希望更好地控制 Pod 失效的处理方式， 而不是仅限于 [Pod 回退失效策略](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#pod-backoff-failure-policy)所提供的控制能力， 后者是基于 Job 的 `.spec.backoffLimit` 实现的。以下是一些使用场景：

- 通过避免不必要的 Pod 重启来优化工作负载的运行成本， 你可以在某 Job 中一个 Pod 失效且其退出码表明存在软件错误时立即终止该 Job。
- 为了保证即使有干扰也能完成 Job，你可以忽略由干扰导致的 Pod 失效 （例如[抢占](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption)、 [通过 API 发起的驱逐](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/api-eviction/) 或基于[污点](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)的驱逐）， 这样这些失效就不会被计入 `.spec.backoffLimit` 的重试限制中。

你可以在 `.spec.podFailurePolicy` 字段中配置 Pod 失效策略，以满足上述使用场景。 该策略可以根据容器退出码和 Pod 状况来处理 Pod 失效。

下面是一个定义了 `podFailurePolicy` 的 Job 的清单：

[`controllers/job-pod-failure-policy-example.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/job-pod-failure-policy-example.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/job-pod-failure-policy-example.yaml to clipboard")

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: job-pod-failure-policy-example
spec:
  completions: 12
  parallelism: 3
  template:
    spec:
      restartPolicy: Never
      containers:
      - name: main
        image: docker.io/library/bash:5
        command: ["bash"]        # 模拟一个触发 FailJob 动作的错误的示例命令
        args:
        - -c
        - echo "Hello world!" && sleep 5 && exit 42
  backoffLimit: 6
  podFailurePolicy:
    rules:
    - action: FailJob
      onExitCodes:
        containerName: main      # 可选
        operator: In             # In 和 NotIn 二选一
        values: [42]
    - action: Ignore             # Ignore、FailJob、Count 其中之一
      onPodConditions:
      - type: DisruptionTarget   # 表示 Pod 失效
```

在上面的示例中，Pod 失效策略的第一条规则规定如果 `main` 容器失败并且退出码为 42， Job 将被标记为失败。以下是 `main` 容器的具体规则：

- 退出码 0 代表容器成功
- 退出码 42 代表 **整个 Job** 失败
- 所有其他退出码都代表容器失败，同时也代表着整个 Pod 失效。 如果重启总次数低于 `backoffLimit` 定义的次数，则会重新启动 Pod， 如果等于 `backoffLimit` 所设置的次数，则代表 **整个 Job** 失效。

**说明：**

因为 Pod 模板中指定了 `restartPolicy: Never`， 所以 kubelet 将不会重启 Pod 中的 `main` 容器。

Pod 失效策略的第二条规则， 指定对于状况为 `DisruptionTarget` 的失效 Pod 采取 `Ignore` 操作， 统计 `.spec.backoffLimit` 重试次数限制时不考虑 Pod 因干扰而发生的异常。

**说明：**

如果根据 Pod 失效策略或 Pod 回退失效策略判定 Pod 已经失效， 并且 Job 正在运行多个 Pod，Kubernetes 将终止该 Job 中仍处于 Pending 或 Running 的所有 Pod。

下面是此 API 的一些要求和语义：

- 如果你想在 Job 中使用 `.spec.podFailurePolicy` 字段， 你必须将 Job 的 Pod 模板中的 `.spec.restartPolicy` 设置为 `Never`。
- 在 `spec.podFailurePolicy.rules` 中设定的 Pod 失效策略规则将按序评估。 一旦某个规则与 Pod 失效策略匹配，其余规则将被忽略。 当没有规则匹配 Pod 失效策略时，将会采用默认的处理方式。
- 你可能希望在 `spec.podFailurePolicy.rules[*].containerName` 中通过指定的名称将规则限制到特定容器。 如果不设置，规则将适用于所有容器。 如果指定了容器名称，它应该匹配 Pod 模板中的一个普通容器或一个初始容器（Init Container）。
- 你可以在 `spec.podFailurePolicy.rules[*].action` 指定当 Pod 失效策略发生匹配时要采取的操作。 可能的值为：
    - `FailJob`：表示 Pod 的任务应标记为 Failed，并且所有正在运行的 Pod 应被终止。
    - `Ignore`：表示 `.spec.backoffLimit` 的计数器不应该增加，应该创建一个替换的 Pod。
    - `Count`：表示 Pod 应该以默认方式处理。`.spec.backoffLimit` 的计数器应该增加。

###### 使用 Finalizer 追踪 Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#job-tracking-with-finalizers)

**特性状态：** `Kubernetes v1.26 [stable]`

**说明：**

如果 Job 是在特性门控 `JobTrackingWithFinalizers` 被禁用时创建的，即使你将控制面升级到 1.26， 控制面也不会使用 Finalizer 跟踪 Job。

控制面会跟踪属于任何 Job 的 Pod，并通知是否有任何这样的 Pod 被从 API 服务器中移除。 为了实现这一点，Job 控制器创建的 Pod 带有 Finalizer `batch.kubernetes.io/job-tracking`。 控制器只有在 Pod 被记入 Job 状态后才会移除 Finalizer，允许 Pod 可以被其他控制器或用户移除。

在升级到 Kubernetes 1.26 之前或在启用特性门控 `JobTrackingWithFinalizers` 之前创建的 Job 被跟踪时不使用 Pod Finalizer。 Job [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)仅根据集群中存在的 Pod 更新 `succeeded` 和 `failed` Pod 的状态计数器。如果 Pod 被从集群中删除，控制面可能无法跟踪 Job 的进度。

你可以根据检查 Job 是否含有 `batch.kubernetes.io/job-tracking` 注解， 来确定控制面是否正在使用 Pod Finalizer 追踪 Job。 你**不**应该给 Job 手动添加或删除该注解。 取而代之的是你可以重新创建 Job 以确保使用 Pod Finalizer 跟踪这些 Job。

##### 替代方案[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#alternatives)

###### 裸 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#bare-pods)

当 Pod 运行所在的节点重启或者失败，Pod 会被终止并且不会被重启。 Job 会重新创建新的 Pod 来替代已终止的 Pod。 因为这个原因，我们建议你使用 Job 而不是独立的裸 Pod， 即使你的应用仅需要一个 Pod。

###### 副本控制器[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#replication-controller)

Job 与[副本控制器](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/)是彼此互补的。 副本控制器管理的是那些不希望被终止的 Pod （例如，Web 服务器）， Job 管理的是那些希望被终止的 Pod（例如，批处理作业）。

正如在 [Pod 生命期](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/) 中讨论的， `Job` 仅适合于 `restartPolicy` 设置为 `OnFailure` 或 `Never` 的 Pod。 注意：如果 `restartPolicy` 未设置，其默认值是 `Always`。

###### 单个 Job 启动控制器 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#single-job-starts-controller-pod)

另一种模式是用唯一的 Job 来创建 Pod，而该 Pod 负责启动其他 Pod， 因此扮演了一种后启动 Pod 的控制器的角色。 这种模式的灵活性更高，但是有时候可能会把事情搞得很复杂，很难入门， 并且与 Kubernetes 的集成度很低。

这种模式的实例之一是用 Job 来启动一个运行脚本的 Pod，脚本负责启动 Spark 主控制器（参见 [Spark 示例](https://github.com/kubernetes/examples/tree/master/staging/spark/README.md)）， 运行 Spark 驱动，之后完成清理工作。

这种方法的优点之一是整个过程得到了 Job 对象的完成保障， 同时维持了对创建哪些 Pod、如何向其分派工作的完全控制能力，

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。
- 了解运行 Job 的不同的方式：
    - [使用工作队列进行粗粒度并行处理](https://kubernetes.io/zh-cn/docs/tasks/job/coarse-parallel-processing-work-queue/)
    - [使用工作队列进行精细的并行处理](https://kubernetes.io/zh-cn/docs/tasks/job/fine-parallel-processing-work-queue/)
    - [使用索引作业完成静态工作分配下的并行处理](https://kubernetes.io/zh-cn/docs/tasks/job/indexed-parallel-processing-static/)
    - 基于一个模板运行多个 Job：[使用展开的方式进行并行处理](https://kubernetes.io/zh-cn/docs/tasks/job/parallel-processing-expansion/)
- 跟随[自动清理完成的 Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically) 文中的链接，了解你的集群如何清理完成和失败的任务。
- `Job` 是 Kubernetes REST API 的一部分。阅读 [](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/job-v1/)对象定义理解关于该资源的 API。
- 阅读 [`CronJob`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/)， 它允许你定义一系列定期运行的 Job，类似于 UNIX 工具 `cron`。
- 根据循序渐进的[示例](https://kubernetes.io/zh-cn/docs/tasks/job/pod-failure-policy/)， 练习如何使用 `podFailurePolicy` 配置处理可重试和不可重试的 Pod 失效。
#### [已完成 Job 的自动清理](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/)

一种用于清理已完成执行的旧 Job 的 TTL 机制。
**特性状态：** `Kubernetes v1.23 [stable]`

当你的 Job 已结束时，将 Job 保留在 API 中（而不是立即删除 Job）很有用， 这样你就可以判断 Job 是成功还是失败。

Kubernetes TTL-after-finished [控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)提供了一种 TTL 机制来限制已完成执行的 Job 对象的生命期。

##### 清理已完成的 Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/#cleanup-for-finished-jobs)

TTL-after-finished 控制器只支持 Job。你可以通过指定 Job 的 `.spec.ttlSecondsAfterFinished` 字段来自动清理已结束的 Job（`Complete` 或 `Failed`）， 如[示例](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically)所示。

TTL-after-finished 控制器假设 Job 能在执行完成后的 TTL 秒内被清理。一旦 Job 的状态条件发生变化表明该 Job 是 `Complete` 或 `Failed`，计时器就会启动；一旦 TTL 已过期，该 Job 就能被[级联删除](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#cascading-deletion)。 当 TTL 控制器清理作业时，它将做级联删除操作，即删除 Job 的同时也删除其依赖对象。

Kubernetes 尊重 Job 对象的生命周期保证，例如等待 [Finalizer](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/finalizers/)。

你可以随时设置 TTL 秒。以下是设置 Job 的 `.spec.ttlSecondsAfterFinished` 字段的一些示例：

- 在 Job 清单（manifest）中指定此字段，以便 Job 在完成后的某个时间被自动清理。
- 手动设置现有的、已完成的 Job 的此字段，以便这些 Job 可被清理。
- 在创建 Job 时使用[修改性质的准入 Webhook](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook) 动态设置该字段。集群管理员可以使用它对已完成的作业强制执行 TTL 策略。

- 使用[修改性质的准入 Webhook](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook) 在 Job 完成后动态设置该字段，并根据 Job 状态、标签等选择不同的 TTL 值。 对于这种情况，Webhook 需要检测 Job 的 `.status` 变化，并且仅在 Job 被标记为已完成时设置 TTL。
- 编写你自己的控制器来管理与特定[选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)匹配的 Job 的清理 TTL。

##### 警告[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/#caveats)

###### 更新已完成 Job 的 TTL[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/#updating-ttl-for-finished-jobs)

在创建 Job 或已经执行结束后，你仍可以修改其 TTL 周期，例如 Job 的 `.spec.ttlSecondsAfterFinished` 字段。 如果你在当前 `ttlSecondsAfterFinished` 时长已过期后延长 TTL 周期， 即使延长 TTL 的更新得到了成功的 API 响应，Kubernetes 也不保证保留此 Job，

###### 时间偏差[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/#time-skew)

由于 TTL-after-finished 控制器使用存储在 Kubernetes Job 中的时间戳来确定 TTL 是否已过期， 因此该功能对集群中的时间偏差很敏感，这可能导致控制平面在错误的时间清理 Job 对象。

时钟并不总是如此正确，但差异应该很小。 设置非零 TTL 时请注意避免这种风险。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/ttlafterfinished/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读[自动清理 Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically)
    
- 参阅 [Kubernetes 增强提案](https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md) (KEP) 了解此机制的演进过程。
#### [CronJob](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/)
**特性状态：** `Kubernetes v1.21 [stable]`

**CronJob** 创建基于时隔重复调度的 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/)。

CronJob 用于执行排期操作，例如备份、生成报告等。 一个 CronJob 对象就像 Unix 系统上的 **crontab**（cron table）文件中的一行。 它用 [Cron](https://zh.wikipedia.org/wiki/Cron) 格式进行编写， 并周期性地在给定的调度时间执行 Job。

CronJob 有所限制，也比较特殊。 例如在某些情况下，单个 CronJob 可以创建多个并发任务。 请参阅下面的[限制](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#cron-job-limitations)。

当控制平面为 CronJob 创建新的 Job 和（间接）Pod 时，CronJob 的 `.metadata.name` 是命名这些 Pod 的部分基础。 CronJob 的名称必须是一个合法的 [DNS 子域](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names)值， 但这会对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规则。 即使名称是一个 DNS 子域，它也不能超过 52 个字符。这是因为 CronJob 控制器将自动在你所提供的 Job 名称后附加 11 个字符，并且存在 Job 名称的最大长度不能超过 63 个字符的限制。

##### 示例[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#example)

下面的 CronJob 示例清单会在每分钟打印出当前时间和问候消息：

[`application/job/cronjob.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/job/cronjob.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy application/job/cronjob.yaml to clipboard")

```yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: "* * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox:1.28
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure
```

[使用 CronJob 运行自动化任务](https://kubernetes.io/zh-cn/docs/tasks/job/automated-tasks-with-cron-jobs/)一文会为你详细讲解此例。

##### 编写 CronJob 声明信息[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#writing-a-cronjob-spec)

###### Cron 时间表语法[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#cron-schedule-syntax)

`.spec.schedule` 字段是必需的。该字段的值遵循 [Cron](https://zh.wikipedia.org/wiki/Cron) 语法：

```
# ┌───────────── 分钟 (0 - 59)
# │ ┌───────────── 小时 (0 - 23)
# │ │ ┌───────────── 月的某天 (1 - 31)
# │ │ │ ┌───────────── 月份 (1 - 12)
# │ │ │ │ ┌───────────── 周的某天 (0 - 6)（周日到周一；在某些系统上，7 也是星期日）
# │ │ │ │ │                          或者是 sun，mon，tue，web，thu，fri，sat
# │ │ │ │ │
# │ │ │ │ │
# * * * * *
```

例如 `0 0 13 * 5` 表示此任务必须在每个星期五的午夜以及每个月的 13 日的午夜开始。

该格式也包含了扩展的 “Vixie cron” 步长值。 [FreeBSD 手册](https://www.freebsd.org/cgi/man.cgi?crontab%285%29)中解释如下:

> 步长可被用于范围组合。范围后面带有 `/<数字>` 可以声明范围内的步幅数值。 例如，`0-23/2` 可被用在小时字段来声明命令在其他数值的小时数执行 （V7 标准中对应的方法是 `0,2,4,6,8,10,12,14,16,18,20,22`）。 步长也可以放在通配符后面，因此如果你想表达 “每两小时”，就用 `*/2` 。

**说明：**

时间表中的问号 (`?`) 和星号 `*` 含义相同，它们用来表示给定字段的任何可用值。

除了标准语法，还可以使用一些类似 `@monthly` 的宏：

| 输入 | 描述 | 相当于 |
| --- | --- | --- |
| @yearly (或 @annually) | 每年 1 月 1 日的午夜运行一次 | 0 0 1 1 \* |
| @monthly | 每月第一天的午夜运行一次 | 0 0 1 \* \* |
| @weekly | 每周的周日午夜运行一次 | 0 0 \* \* 0 |
| @daily (或 @midnight) | 每天午夜运行一次 | 0 0 \* \* \* |
| @hourly | 每小时的开始一次 | 0 \* \* \* \* |

为了生成 CronJob 时间表的表达式，你还可以使用 [crontab.guru](https://crontab.guru/) 这类 Web 工具。

###### 任务模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#job-template)

`.spec.jobTemplate`为 CronJob 创建的 Job 定义模板，它是必需的。它和 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 的语法完全一样， 只不过它是嵌套的，没有 `apiVersion` 和 `kind`。 你可以为模板化的 Job 指定通用的元数据， 例如[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)或[注解](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/)。 有关如何编写一个任务的 `.spec`， 请参考[编写 Job 规约](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#writing-a-job-spec)。

###### 任务延迟开始的最后期限[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#starting-deadline)

`.spec.startingDeadlineSeconds` 字段是可选的。 它表示任务如果由于某种原因错过了调度时间，开始该任务的截止时间的秒数。

过了截止时间，CronJob 就不会开始该任务的实例（未来的任务仍在调度之中）。 例如，如果你有一个每天运行两次的备份任务，你可能会允许它最多延迟 8 小时开始，但不能更晚， 因为更晚进行的备份将变得没有意义：你宁愿等待下一次计划的运行。

对于错过已配置的最后期限的 Job，Kubernetes 将其视为失败的任务。 如果你没有为 CronJob 指定 `startingDeadlineSeconds`，那 Job 就没有最后期限。

如果 `.spec.startingDeadlineSeconds` 字段被设置（非空）， CronJob 控制器将会计算从预期创建 Job 到当前时间的时间差。 如果时间差大于该限制，则跳过此次执行。

例如，如果将其设置为 `200`，则 Job 控制器允许在实际调度之后最多 200 秒内创建 Job。

###### 并发性规则[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#concurrency-policy)

`.spec.concurrencyPolicy` 也是可选的。它声明了 CronJob 创建的任务执行时发生重叠如何处理。 spec 仅能声明下列规则中的一种：

- `Allow`（默认）：CronJob 允许并发任务执行。
- `Forbid`： CronJob 不允许并发任务执行；如果新任务的执行时间到了而老任务没有执行完，CronJob 会忽略新任务的执行。
- `Replace`：如果新任务的执行时间到了而老任务没有执行完，CronJob 会用新任务替换当前正在运行的任务。

请注意，并发性规则仅适用于相同 CronJob 创建的任务。如果有多个 CronJob，它们相应的任务总是允许并发执行的。

###### 调度挂起[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#schedule-suspension)

通过将可选的 `.spec.suspend` 字段设置为 `true`，可以挂起针对 CronJob 执行的任务。

这个设置**不**会影响 CronJob 已经开始的任务。

如果你将此字段设置为 `true`，后续发生的执行都会被挂起 （这些任务仍然在调度中，但 CronJob 控制器不会启动这些 Job 来运行任务），直到你取消挂起 CronJob 为止。

**注意：**

在调度时间内挂起的执行都会被统计为错过的任务。当现有的 CronJob 将 `.spec.suspend` 从 `true` 改为 `false` 时， 且没有[开始的最后期限](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#starting-deadline)，错过的任务会被立即调度。

###### 任务历史限制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#jobs-history-limits)

`.spec.successfulJobsHistoryLimit` 和 `.spec.failedJobsHistoryLimit` 字段是可选的。 这两个字段指定应保留多少已完成和失败的任务。 默认设置分别为 3 和 1。将限制设置为 `0` 代表相应类型的任务完成后不会保留。

有关自动清理任务的其他方式， 请参见[自动清理完成的 Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically)。

##### 时区[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#time-zones)

对于没有指定时区的 CronJob， [kube-controller-manager](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/) 基于本地时区解释排期表（Schedule）。

**特性状态：** `Kubernetes v1.25 [beta]`

如果启用了 `CronJobTimeZone` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， 你可以为 CronJob 指定一个时区（如果你没有启用该特性门控，或者你使用的是不支持试验性时区功能的 Kubernetes 版本，集群中所有 CronJob 的时区都是未指定的）。

启用该特性后，你可以将 `spec.timeZone` 设置为有效[时区](https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E5%BA%93)名称。 例如，设置 `spec.timeZone: "Etc/UTC"` 指示 Kubernetes 采用 UTC 来解释排期表。

**注意：**

Kubernetes 1.26 中 CronJob API 的实现允许你设置 `.spec.schedule` 字段以包含时区；例如：`CRON_TZ=UTC * * * * *` 或 `TZ=UTC * * * * *`。

以这种方式指定时区是**未正式支持**（而且从来没有）。

如果你尝试设置包含 `TZ` 或 `CRON_TZ` 时区规范的排期表， Kubernetes 会向客户端报告[警告](https://kubernetes.io/zh-cn/blog/2020/09/03/warnings/)。 Kubernetes 的未来版本可能根本不会实现这种非正式的时区机制。

Go 标准库中的时区数据库包含在二进制文件中，并用作备用数据库，以防系统上没有可用的外部数据库。

##### CronJob 限制[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#cronjob-limitations)

###### 修改 CronJob[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#modifying-a-cronjob)

按照设计，CronJob 包含一个用于**新** Job 的模板。 如果你修改现有的 CronJob，你所做的更改将应用于修改完成后开始运行的新任务。 已经开始的任务（及其 Pod）将继续运行而不会发生任何变化。 也就是说，CronJob **不** 会更新现有任务，即使这些任务仍在运行。

###### Job 创建[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#job-creation)

CronJob 根据其计划编排，在每次该执行任务的时候大约会创建一个 Job。 我们之所以说 "大约"，是因为在某些情况下，可能会创建两个 Job，或者不会创建任何 Job。 我们试图使这些情况尽量少发生，但不能完全杜绝。因此，Job 应该是 **幂等的**。

如果 `startingDeadlineSeconds` 设置为很大的数值或未设置（默认），并且 `concurrencyPolicy` 设置为 `Allow`，则作业将始终至少运行一次。

**注意：**

如果 `startingDeadlineSeconds` 的设置值低于 10 秒钟，CronJob 可能无法被调度。 这是因为 CronJob 控制器每 10 秒钟执行一次检查。

对于每个 CronJob，CronJob [控制器（Controller）](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/) 检查从上一次调度的时间点到现在所错过了调度次数。如果错过的调度次数超过 100 次， 那么它就不会启动这个任务，并记录这个错误:

```
Cannot determine if job needs to be started. Too many missed start time (> 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
```

需要注意的是，如果 `startingDeadlineSeconds` 字段非空，则控制器会统计从 `startingDeadlineSeconds` 设置的值到现在而不是从上一个计划时间到现在错过了多少次 Job。 例如，如果 `startingDeadlineSeconds` 是 `200`，则控制器会统计在过去 200 秒中错过了多少次 Job。

如果未能在调度时间内创建 CronJob，则计为错过。 例如，如果 `concurrencyPolicy` 被设置为 `Forbid`，并且当前有一个调度仍在运行的情况下， 试图调度的 CronJob 将被计算为错过。

例如，假设一个 CronJob 被设置为从 `08:30:00` 开始每隔一分钟创建一个新的 Job， 并且它的 `startingDeadlineSeconds` 字段未被设置。如果 CronJob 控制器从 `08:29:00` 到 `10:21:00` 终止运行，则该 Job 将不会启动， 因为其错过的调度次数超过了 100。

为了进一步阐述这个概念，假设将 CronJob 设置为从 `08:30:00` 开始每隔一分钟创建一个新的 Job， 并将其 `startingDeadlineSeconds` 字段设置为 200 秒。 如果 CronJob 控制器恰好在与上一个示例相同的时间段（`08:29:00` 到 `10:21:00`）终止运行， 则 Job 仍将从 `10:22:00` 开始。 造成这种情况的原因是控制器现在检查在最近 200 秒（即 3 个错过的调度）中发生了多少次错过的 Job 调度，而不是从现在为止的最后一个调度时间开始。

CronJob 仅负责创建与其调度时间相匹配的 Job，而 Job 又负责管理其代表的 Pod。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/cron-jobs/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 CronJob 所依赖的 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 与 [Job](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 的概念。
- 阅读 CronJob `.spec.schedule` 字段的详细[格式](https://pkg.go.dev/github.com/robfig/cron/v3#hdr-CRON_Expression_Format)。
- 有关创建和使用 CronJob 的说明及 CronJob 清单的示例， 请参见[使用 CronJob 运行自动化任务](https://kubernetes.io/zh-cn/docs/tasks/job/automated-tasks-with-cron-jobs/)。
- `CronJob` 是 Kubernetes REST API 的一部分， 阅读 [CronJob](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/cron-job-v1/) API 参考了解更多细节。
#### [ReplicationController](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/)

**说明：**

现在推荐使用配置 [`ReplicaSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 的 [`Deployment`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 来建立副本管理机制。

**ReplicationController** 确保在任何时候都有特定数量的 Pod 副本处于运行状态。 换句话说，ReplicationController 确保一个 Pod 或一组同类的 Pod 总是可用的。

##### ReplicationController 如何工作[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#how-a-replicationcontroller-works)

当 Pod 数量过多时，ReplicationController 会终止多余的 Pod。当 Pod 数量太少时，ReplicationController 将会启动新的 Pod。 与手动创建的 Pod 不同，由 ReplicationController 创建的 Pod 在失败、被删除或被终止时会被自动替换。 例如，在中断性维护（如内核升级）之后，你的 Pod 会在节点上重新创建。 因此，即使你的应用程序只需要一个 Pod，你也应该使用 ReplicationController 创建 Pod。 ReplicationController 类似于进程管理器，但是 ReplicationController 不是监控单个节点上的单个进程，而是监控跨多个节点的多个 Pod。

在讨论中，ReplicationController 通常缩写为 "rc"，并作为 kubectl 命令的快捷方式。

一个简单的示例是创建一个 ReplicationController 对象来可靠地无限期地运行 Pod 的一个实例。 更复杂的用例是运行一个多副本服务（如 web 服务器）的若干相同副本。

##### 运行一个示例 ReplicationController[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#running-an-example-replicationcontroller)

这个示例 ReplicationController 配置运行 nginx Web 服务器的三个副本。

[`controllers/replication.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/controllers/replication.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy controllers/replication.yaml to clipboard")

```yaml
apiVersion: v1
kind: ReplicationController
metadata:
  name: nginx
spec:
  replicas: 3
  selector:
    app: nginx
  template:
    metadata:
      name: nginx
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

通过下载示例文件并运行以下命令来运行示例任务:

```shell
kubectl apply -f https://k8s.io/examples/controllers/replication.yaml
```

输出类似于：

```
replicationcontroller/nginx created
```

使用以下命令检查 ReplicationController 的状态:

```shell
kubectl describe replicationcontrollers/nginx
```

输出类似于：

```
Name:        nginx
Namespace:   default
Selector:    app=nginx
Labels:      app=nginx
Annotations:    <none>
Replicas:    3 current / 3 desired
Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       app=nginx
  Containers:
   nginx:
    Image:              nginx
    Port:               80/TCP
    Environment:        <none>
    Mounts:             <none>
  Volumes:              <none>
Events:
  FirstSeen       LastSeen     Count    From                        SubobjectPath    Type      Reason              Message
  ---------       --------     -----    ----                        -------------    ----      ------              -------
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v
```

在这里，创建了三个 Pod，但没有一个 Pod 正在运行，这可能是因为正在拉取镜像。 稍后，相同的命令可能会显示：

```
Pods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed
```

要以机器可读的形式列出属于 ReplicationController 的所有 Pod，可以使用如下命令：

```shell
pods=$(kubectl get pods --selector=app=nginx --output=jsonpath={.items..metadata.name})
echo $pods
```

输出类似于：

```
nginx-3ntk0 nginx-4ok8v nginx-qrm3m
```

这里，选择算符与 ReplicationController 的选择算符相同（参见 `kubectl describe` 输出），并以不同的形式出现在 `replication.yaml` 中。 `--output=jsonpath` 选项指定了一个表达式，仅从返回列表中的每个 Pod 中获取名称。

##### 编写一个 ReplicationController 清单[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#writing-a-replicationcontroller-manifest)

与所有其它 Kubernetes 配置一样，ReplicationController 需要 `apiVersion`、`kind` 和 `metadata` 字段。

当控制平面为 ReplicationController 创建新的 Pod 时，ReplicationController 的 `.metadata.name` 是命名这些 Pod 的部分基础。ReplicationController 的名称必须是一个合法的 [DNS 子域](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names)值， 但这可能对 Pod 的主机名产生意外的结果。为获得最佳兼容性，名称应遵循更严格的 [DNS 标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-label-names)规则。

有关使用配置文件的常规信息， 参考[对象管理](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management/)。

ReplicationController 也需要一个 [`.spec` 部分](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status)。

###### Pod 模板[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#pod-template)

`.spec.template` 是 `.spec` 的唯一必需字段。

`.spec.template` 是一个 [Pod 模板](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/#pod-templates)。 它的模式与 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 完全相同，只是它是嵌套的，没有 `apiVersion` 或 `kind` 属性。

除了 Pod 所需的字段外，ReplicationController 中的 Pod 模板必须指定适当的标签和适当的重新启动策略。 对于标签，请确保不与其他控制器重叠。参考 [Pod 选择算符](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#pod-selector)。

只允许 [`.spec.template.spec.restartPolicy`](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy) 等于 `Always`，如果没有指定，这是默认值。

对于本地容器重启，ReplicationController 委托给节点上的代理， 例如 [Kubelet](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kubelet/)。

###### ReplicationController 上的标签[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#labels-on-the-replicacontroller)

ReplicationController 本身可以有标签 （`.metadata.labels`）。 通常，你可以将这些设置为 `.spec.template.metadata.labels`； 如果没有指定 `.metadata.labels` 那么它默认为 `.spec.template.metadata.labels`。 但是，Kubernetes 允许它们是不同的，`.metadata.labels` 不会影响 ReplicationController 的行为。

###### Pod 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#pod-selector)

`.spec.selector` 字段是一个[标签选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors)。 ReplicationController 管理标签与选择算符匹配的所有 Pod。 它不区分它创建或删除的 Pod 和其他人或进程创建或删除的 Pod。 这允许在不影响正在运行的 Pod 的情况下替换 ReplicationController。

如果指定了 `.spec.template.metadata.labels`，它必须和 `.spec.selector` 相同，否则它将被 API 拒绝。 如果没有指定 `.spec.selector`，它将默认为 `.spec.template.metadata.labels`。

另外，通常不应直接使用另一个 ReplicationController 或另一个控制器（例如 Job） 来创建其标签与该选择算符匹配的任何 Pod。如果这样做，ReplicationController 会认为它创建了这些 Pod。 Kubernetes 并没有阻止你这样做。

如果你的确创建了多个控制器并且其选择算符之间存在重叠，那么你将不得不自己管理删除操作（参考[后文](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#working-with-replicationcontrollers)）。

###### 多个副本[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#multiple-replicas)

你可以通过设置 `.spec.replicas` 来指定应该同时运行多少个 Pod。 在任何时候，处于运行状态的 Pod 个数都可能高于或者低于设定值。例如，副本个数刚刚被增加或减少时， 或者一个 Pod 处于优雅终止过程中而其替代副本已经提前开始创建时。

如果你没有指定 `.spec.replicas`，那么它默认是 1。

##### 使用 ReplicationController[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#working-with-replicationcontrollers)

###### 删除一个 ReplicationController 以及它的 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#deleteing-a-replicationcontroller-and-its-pods)

要删除一个 ReplicationController 以及它的 Pod，使用 [`kubectl delete`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete)。 kubectl 将 ReplicationController 缩容为 0 并等待以便在删除 ReplicationController 本身之前删除每个 Pod。 如果这个 kubectl 命令被中断，可以重新启动它。

当使用 REST API 或[客户端库](https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries)时，你需要明确地执行这些步骤（缩容副本为 0、 等待 Pod 删除，之后删除 ReplicationController 资源）。

###### 只删除 ReplicationController[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#deleting-only-a-replicationcontroller)

你可以删除一个 ReplicationController 而不影响它的任何 Pod。

使用 kubectl，为 [`kubectl delete`](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#delete) 指定 `--cascade=orphan` 选项。

当使用 REST API 或[客户端库](https://kubernetes.io/zh-cn/docs/reference/using-api/client-libraries)时，只需删除 ReplicationController 对象。

一旦原始对象被删除，你可以创建一个新的 ReplicationController 来替换它。 只要新的和旧的 `.spec.selector` 相同，那么新的控制器将领养旧的 Pod。 但是，它不会做出任何努力使现有的 Pod 匹配新的、不同的 Pod 模板。 如果希望以受控方式更新 Pod 以使用新的 spec，请执行[滚动更新](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#rolling-updates)操作。

###### 从 ReplicationController 中隔离 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#isolating-pods-from-a-replicationcontroller)

通过更改 Pod 的标签，可以从 ReplicationController 的目标中删除 Pod。 此技术可用于从服务中删除 Pod 以进行调试、数据恢复等。以这种方式删除的 Pod 将被自动替换（假设复制副本的数量也没有更改）。

##### 常见的使用模式[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#common-usage-patterns)

###### 重新调度[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#rescheduling)

如上所述，无论你想要继续运行 1 个 Pod 还是 1000 个 Pod，一个 ReplicationController 都将确保存在指定数量的 Pod，即使在节点故障或 Pod 终止(例如，由于另一个控制代理的操作)的情况下也是如此。

###### 扩缩容[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#scaling)

通过设置 `replicas` 字段，ReplicationController 可以允许扩容或缩容副本的数量。 你可以手动或通过自动扩缩控制代理来控制 ReplicationController 执行此操作。

###### 滚动更新[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#rolling-updates)

ReplicationController 的设计目的是通过逐个替换 Pod 以方便滚动更新服务。

如 [#1353](https://issue.k8s.io/1353) PR 中所述，建议的方法是使用 1 个副本创建一个新的 ReplicationController， 逐个扩容新的（+1）和缩容旧的（-1）控制器，然后在旧的控制器达到 0 个副本后将其删除。 这一方法能够实现可控的 Pod 集合更新，即使存在意外失效的状况。

理想情况下，滚动更新控制器将考虑应用程序的就绪情况，并确保在任何给定时间都有足够数量的 Pod 有效地提供服务。

这两个 ReplicationController 将需要创建至少具有一个不同标签的 Pod，比如 Pod 主要容器的镜像标签，因为通常是镜像更新触发滚动更新。

###### 多个版本跟踪[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#multiple-release-tracks)

除了在滚动更新过程中运行应用程序的多个版本之外，通常还会使用多个版本跟踪来长时间， 甚至持续运行多个版本。这些跟踪将根据标签加以区分。

例如，一个服务可能把具有 `tier in (frontend), environment in (prod)` 的所有 Pod 作为目标。 现在假设你有 10 个副本的 Pod 组成了这个层。但是你希望能够 `canary` （`金丝雀`）发布这个组件的新版本。 你可以为大部分副本设置一个 ReplicationController，其中 `replicas` 设置为 9， 标签为 `tier=frontend, environment=prod, track=stable` 而为 `canary` 设置另一个 ReplicationController，其中 `replicas` 设置为 1， 标签为 `tier=frontend, environment=prod, track=canary`。 现在这个服务覆盖了 `canary` 和非 `canary` Pod。但你可以单独处理 ReplicationController，以测试、监控结果等。

###### 和服务一起使用 ReplicationController[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#using-replicationcontrollers-with-services)

多个 ReplicationController 可以位于一个服务的后面，例如，一部分流量流向旧版本， 一部分流量流向新版本。

一个 ReplicationController 永远不会自行终止，但它不会像服务那样长时间存活。 服务可以由多个 ReplicationController 控制的 Pod 组成，并且在服务的生命周期内 （例如，为了执行 Pod 更新而运行服务），可以创建和销毁许多 ReplicationController。 服务本身和它们的客户端都应该忽略负责维护服务 Pod 的 ReplicationController 的存在。

##### 编写多副本的应用[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#writing-programs-for-replication)

由 ReplicationController 创建的 Pod 是可替换的，语义上是相同的， 尽管随着时间的推移，它们的配置可能会变得异构。 这显然适合于多副本的无状态服务器，但是 ReplicationController 也可以用于维护主选、 分片和工作池应用程序的可用性。 这样的应用程序应该使用动态的工作分配机制，例如 [RabbitMQ 工作队列](https://www.rabbitmq.com/tutorials/tutorial-two-python.html)， 而不是静态的或者一次性定制每个 Pod 的配置，这被认为是一种反模式。 执行的任何 Pod 定制，例如资源的垂直自动调整大小（例如，CPU 或内存）， 都应该由另一个在线控制器进程执行，这与 ReplicationController 本身没什么不同。

##### ReplicationController 的职责[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#responsibilities-of-the-replicationcontroller)

ReplicationController 仅确保所需的 Pod 数量与其标签选择算符匹配，并且是可操作的。 目前，它的计数中只排除终止的 Pod。 未来，可能会考虑系统提供的[就绪状态](https://issue.k8s.io/620)和其他信息， 我们可能会对替换策略添加更多控制， 我们计划发出事件，这些事件可以被外部客户端用来实现任意复杂的替换和/或缩减策略。

ReplicationController 永远被限制在这个狭隘的职责范围内。 它本身既不执行就绪态探测，也不执行活跃性探测。 它不负责执行自动扩缩，而是由外部自动扩缩器控制（如 [#492](https://issue.k8s.io/492) 中所述），后者负责更改其 `replicas` 字段值。 我们不会向 ReplicationController 添加调度策略（例如， [spreading](https://issue.k8s.io/367#issuecomment-48428019)）。 它也不应该验证所控制的 Pod 是否与当前指定的模板匹配，因为这会阻碍自动调整大小和其他自动化过程。 类似地，完成期限、整理依赖关系、配置扩展和其他特性也属于其他地方。 我们甚至计划考虑批量创建 Pod 的机制（查阅 [#170](https://issue.k8s.io/170)）。

ReplicationController 旨在成为可组合的构建基元。 我们希望在它和其他补充原语的基础上构建更高级别的 API 或者工具，以便于将来的用户使用。 kubectl 目前支持的 "macro" 操作（运行、扩缩、滚动更新）就是这方面的概念示例。 例如，我们可以想象类似于 [Asgard](https://netflixtechblog.com/asgard-web-based-cloud-management-and-deployment-2c9fc4e4d3a1) 的东西管理 ReplicationController、自动定标器、服务、调度策略、金丝雀发布等。

##### API 对象[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#api-object)

在 Kubernetes REST API 中 Replication controller 是顶级资源。 更多关于 API 对象的详细信息可以在 [ReplicationController API 对象](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#replicationcontroller-v1-core)找到。

##### ReplicationController 的替代方案[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#alternatives-to-replicationcontroller)

###### ReplicaSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#replicaset)

[`ReplicaSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicaset/) 是下一代 ReplicationController， 支持新的[基于集合的标签选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#set-based-requirement)。 它主要被 [`Deployment`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 用来作为一种编排 Pod 创建、删除及更新的机制。 请注意，我们推荐使用 Deployment 而不是直接使用 ReplicaSet，除非你需要自定义更新编排或根本不需要更新。

###### Deployment （推荐）[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#deployment-%E6%8E%A8%E8%8D%90)

[`Deployment`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 是一种更高级别的 API 对象，用于更新其底层 ReplicaSet 及其 Pod。 如果你想要这种滚动更新功能，那么推荐使用 Deployment，因为它们是声明式的、服务端的，并且具有其它特性。

###### 裸 Pod[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#%E8%A3%B8-pod)

与用户直接创建 Pod 的情况不同，ReplicationController 能够替换因某些原因被删除或被终止的 Pod， 例如在节点故障或中断节点维护的情况下，例如内核升级。 因此，我们建议你使用 ReplicationController，即使你的应用程序只需要一个 Pod。 可以将其看作类似于进程管理器，它只管理跨多个节点的多个 Pod，而不是单个节点上的单个进程。 ReplicationController 将本地容器重启委托给节点上的某个代理（例如 Kubelet)。

###### Job[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#job)

对于预期会自行终止的 Pod (即批处理任务)，使用 [`Job`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/job/) 而不是 ReplicationController。

###### DaemonSet[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#daemonset)

对于提供机器级功能（例如机器监控或机器日志记录）的 Pod， 使用 [`DaemonSet`](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/daemonset/) 而不是 ReplicationController。 这些 Pod 的生命期与机器的生命期绑定：它们需要在其他 Pod 启动之前在机器上运行， 并且在机器准备重新启动或者关闭时安全地终止。

##### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 了解 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。
- 了解 [Depolyment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/)，ReplicationController 的替代品。
- `ReplicationController` 是 Kubernetes REST API 的一部分，阅读 [ReplicationController](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/replication-controller-v1/) 对象定义以了解 replication controllers 的 API。

## 服务、负载均衡和联网

Kubernetes 网络背后的概念和资源。

### Kubernetes 网络模型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/#the-kubernetes-network-model)

集群中每一个 [`Pod`](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 都会获得自己的、 独一无二的 IP 地址， 这就意味着你不需要显式地在 `Pod` 之间创建链接，你几乎不需要处理容器端口到主机端口之间的映射。 这将形成一个干净的、向后兼容的模型；在这个模型里，从端口分配、命名、服务发现、 [负载均衡](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#load-balancing)、 应用配置和迁移的角度来看，`Pod` 可以被视作虚拟机或者物理主机。

Kubernetes 强制要求所有网络设施都满足以下基本要求（从而排除了有意隔离网络的策略）：

- Pod 能够与所有其他[节点](https://kubernetes.io/zh-cn/docs/concepts/architecture/nodes/)上的 Pod 通信， 且不需要网络地址转译（NAT）
- 节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有 Pod 通信

说明：对于支持在主机网络中运行 `Pod` 的平台（比如：Linux）， 当 Pod 挂接到节点的宿主网络上时，它们仍可以不通过 NAT 和所有节点上的 Pod 通信。

这个模型不仅不复杂，而且还和 Kubernetes 的实现从虚拟机向容器平滑迁移的初衷相符， 如果你的任务开始是在虚拟机中运行的，你的虚拟机有一个 IP， 可以和项目中其他虚拟机通信。这里的模型是基本相同的。

Kubernetes 的 IP 地址存在于 `Pod` 范围内 —— 容器共享它们的网络命名空间 —— 包括它们的 IP 地址和 MAC 地址。 这就意味着 `Pod` 内的容器都可以通过 `localhost` 到达对方端口。 这也意味着 `Pod` 内的容器需要相互协调端口的使用，但是这和虚拟机中的进程似乎没有什么不同， 这也被称为“一个 Pod 一个 IP”模型。

如何实现以上需求是所使用的特定容器运行时的细节。

也可以在 `Node` 本身请求端口，并用这类端口转发到你的 `Pod`（称之为主机端口）， 但这是一个很特殊的操作。转发方式如何实现也是容器运行时的细节。 `Pod` 自己并不知道这些主机端口的存在。

Kubernetes 网络解决四方面的问题：

- 一个 Pod 中的容器之间[通过本地回路（loopback）通信](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/)。
- 集群网络在不同 Pod 之间提供通信。
- [Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) API 允许你[向外暴露 Pod 中运行的应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)， 以支持来自于集群外部的访问。
    - [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/) 提供专门用于暴露 HTTP 应用程序、网站和 API 的额外功能。
- 你也可以使用 Service 来[发布仅供集群内部使用的服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-traffic-policy/)。

[使用 Service 连接到应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)教程通过一个实际的示例让你了解 Service 和 Kubernetes 如何联网。

[集群网络](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/)解释了如何为集群设置网络， 还概述了所涉及的技术。

---

### [服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)

将在集群中运行的应用程序暴露在单个外向端点后面，即使工作负载分散到多个后端也是如此。
Kubernetes 中 Service 是 将运行在一个或一组 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 上的网络应用程序公开为网络服务的方法。

Kubernetes 中 Service 的一个关键目标是让你无需修改现有应用程序就能使用不熟悉的服务发现机制。 你可以在 Pod 中运行代码，无需顾虑这是为云原生世界设计的代码，还是为已容器化的老应用程序设计的代码。 你可以使用 Service 让一组 Pod 在网络上可用，让客户端能够与其交互。

如果你使用 [Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 来运行你的应用， Deployment 可以动态地创建和销毁 Pod。不管是这一刻还是下一刻， 你不知道有多少个这样的 Pod 正在工作以及健康与否；你可能甚至不知道那些健康的 Pod 是如何命名的。 Kubernetes [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 被创建和销毁以匹配集群的预期状态。 Pod 是临时资源（你不应该期待单个 Pod 既可靠又耐用）。

每个 Pod 获取其自己的 IP 地址（Kubernetes 期待网络插件确保 IP 地址分配）。 对于集群中给定的 Deployment，这一刻运行的这组 Pod 可能不同于下一刻运行应用程序的那组 Pod。

这导致了一个问题： 如果一组 Pod（称为“后端”）为集群内的其他 Pod（称为“前端”）提供功能， 那么前端如何找出并跟踪要连接的 IP 地址，以便前端可以使用提供工作负载的后端部分？

#### Kubernetes 中的 Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-in-k8s)

Service API 是 Kubernetes 的组成部分，它是一种抽象，帮助你通过网络暴露 Pod 组合。 每个 Service 对象定义一个逻辑组的端点（通常这些端点是 Pod）以及如何才能访问这些 Pod 的策略。

举个例子，考虑一个图片处理后端，它运行了 3 个副本。这些副本是可互换的 —— 前端不需要关心它们调用了哪个后端副本。 然而组成这一组后端程序的 Pod 实际上可能会发生变化， 前端客户端不应该也没必要知道，而且也不需要跟踪这一组后端的状态。

Service 定义的抽象能够解耦这种关联。

Service 针对的这组 Pod 通常由你定义的[选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)来确定。 若想了解定义 Service 端点的其他方式，可以查阅[**不带**选择算符的 Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors)。

如果你的工作负载以 HTTP 通信，你可能会选择使用 [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/) 来控制 Web 流量如何到达该工作负载。Ingress 不是一种 Service，但它可用作集群的入口点。 Ingress 能让你将路由规则整合到单个资源，这样你就能在单个侦听器之后暴露工作负载的多个组件，在集群中分别运行这些组件。

Kubernetes 所用的 [Gateway](https://gateway-api.sigs.k8s.io/#what-is-the-gateway-api) API 提供了除 Ingress 和 Service 之外的更多功能。你可以添加 Gateway 到你的集群。Gateway 是使用 [CustomResourceDefinitions](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/) 实现的一系列扩展 API。将 Gateway 添加到你的集群后，就可以使用这些 Gateway 配置如何访问集群中正运行的网络服务。

##### 云原生服务发现[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#cloud-native-discovery)

如果你想要在应用程序中使用 Kubernetes API 进行服务发现，则可以查询 [API 服务器](https://kubernetes.io/zh-cn/docs/concepts/overview/components/#kube-apiserver)用于匹配 EndpointSlices。 只要服务中的这组 Pod 发生变化，Kubernetes 就会为服务更新 EndpointSlices。

对于非本机应用程序，Kubernetes 提供了在应用程序和后端 Pod 之间放置网络端口或负载均衡器的方法。

#### 定义 Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#defining-a-service)

Service 在 Kubernetes 中是一个[对象](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects) （与 Pod 或 ConfigMap 类似的对象）。你可以使用 Kubernetes API 创建、查看或修改 Service 定义。 通常你使用 `kubectl` 这类工具来进行这些 API 调用。

例如，假定有一组 Pod，每个 Pod 都在侦听 TCP 端口 9376，同时还被打上 `app.kubernetes.io/name=MyApp` 标签。 你可以定义一个 Service 来发布 TCP 侦听器。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
```

应用上述清单将创建一个名称为 "my-service" 的新 Service，它在所有 Pod 上指向 TCP 端口 9376，并且具有标签 `app.kubernetes.io/name: MyApp`。

Kubernetes 为该服务分配一个 IP 地址（有时称为 “集群 IP”），该 IP 地址由虚拟 IP 地址机制使用。 有关该机制的更多详情，请阅读[虚拟 IP 和服务代理](https://kubernetes.io/zh-cn/docs/reference/networking/virtual-ips/)。

Service 的控制器不断扫描与其选择算符匹配的 Pod，然后对 Service 的 EndpointSlices 集合执行所有必要的更新。

Service 对象的名称必须是有效的 [RFC 1035 标签名称](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#rfc-1035-label-names)。

**说明：**

需要注意的是，Service 能够将一个接收 `port` 映射到任意的 `targetPort`。 默认情况下，`targetPort` 将被设置为与 `port` 字段相同的值。

Pod 中的端口定义是有名字的，你可以在 Service 的 `targetPort` 属性中引用这些名称。 例如，我们可以通过以下方式将 Service 的 `targetPort` 绑定到 Pod 端口：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app.kubernetes.io/name: proxy
spec:
  containers:
  - name: nginx
    image: nginx:stable
    ports:
      - containerPort: 80
        name: http-web-svc

---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app.kubernetes.io/name: proxy
  ports:
  - name: name-of-service-port
    protocol: TCP
    port: 80
    targetPort: http-web-svc
```

即使 Service 中使用同一配置名称混合使用多个 Pod，各 Pod 通过不同的端口号支持相同的网络协议， 此功能也可以使用。这为 Service 的部署和演化提供了很大的灵活性。 例如，你可以在新版本中更改 Pod 中后端软件公开的端口号，而不会破坏客户端。

服务的默认协议是 [TCP](https://kubernetes.io/zh-cn/docs/reference/networking/service-protocols/#protocol-tcp)； 你还可以使用任何其他[受支持的协议](https://kubernetes.io/zh-cn/docs/reference/networking/service-protocols/)。

由于许多服务需要公开多个端口，因此 Kubernetes 在服务对象上支持多个端口定义。 每个端口定义可以具有相同的 `protocol`，也可以具有不同的协议。

##### 没有选择算符的 Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors)

由于选择算符的存在，服务最常见的用法是为 Kubernetes Pod 的访问提供抽象， 但是当与相应的 [EndpointSlices](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/) 对象一起使用且没有选择算符时， 服务也可以为其他类型的后端提供抽象，包括在集群外运行的后端。

例如：

- 希望在生产环境中使用外部的数据库集群，但测试环境使用自己的数据库。
- 希望服务指向另一个 [名字空间（Namespace）](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/) 中或其它集群中的服务。
- 你正在将工作负载迁移到 Kubernetes。在评估该方法时，你仅在 Kubernetes 中运行一部分后端。

在任何这些场景中，都能够定义**未**指定与 Pod 匹配的选择算符的 Service。例如： 实例:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
```

由于此服务没有选择算符，因此不会自动创建相应的 EndpointSlice（和旧版 Endpoint）对象。 你可以通过手动添加 EndpointSlice 对象，将服务映射到运行该服务的网络地址和端口：

```yaml
apiVersion: discovery.k8s.io/v1
kind: EndpointSlice
metadata:
  name: my-service-1 # 按惯例将服务的名称用作 EndpointSlice 名称的前缀
  labels:
    # 你应设置 "kubernetes.io/service-name" 标签。
    # 设置其值以匹配服务的名称
    kubernetes.io/service-name: my-service
addressType: IPv4
ports:
  - name: '' # 留空，因为 port 9376 未被 IANA 分配为已注册端口
    appProtocol: http
    protocol: TCP
    port: 9376
endpoints:
  - addresses:
      - "10.4.5.6" # 此列表中的 IP 地址可以按任何顺序显示
      - "10.1.2.3"
```

###### 自定义 EndpointSlices[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E8%87%AA%E5%AE%9A%E4%B9%89-endpointslices)

当为服务创建 [EndpointSlice](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#endpointslices) 对象时，可以为 EndpointSlice 使用任何名称。 命名空间中的每个 EndpointSlice 必须有一个唯一的名称。通过在 EndpointSlice 上设置 `kubernetes.io/service-name` [label](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/) 可以将 EndpointSlice 链接到服务。

**说明：**

端点 IP 地址**必须不是** ：本地回路地址（IPv4 的 127.0.0.0/8、IPv6 的 ::1/128） 或链路本地地址（IPv4 的 169.254.0.0/16 和 224.0.0.0/24、IPv6 的 fe80::/64）。

端点 IP 地址不能是其他 Kubernetes 服务的集群 IP，因为 [kube-proxy](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/) 不支持将虚拟 IP 作为目标。

对于你自己或在你自己代码中创建的 EndpointSlice，你还应该为 [`endpointslice.kubernetes.io/managed-by`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#endpointslicekubernetesiomanaged-by) 标签拣选一个值。如果你创建自己的控制器代码来管理 EndpointSlice， 请考虑使用类似于 `"my-domain.example/name-of-controller"` 的值。 如果你使用的是第三方工具，请使用全小写的工具名称，并将空格和其他标点符号更改为短划线 (`-`)。 如果人们直接使用 `kubectl` 之类的工具来管理 EndpointSlices，请使用描述这种手动管理的名称， 例如 `"staff"` 或 `"cluster-admins"`。你应该避免使用保留值 `"controller"`， 该值标识由 Kubernetes 自己的控制平面管理的 EndpointSlices。

###### 访问没有选择算符的 Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-no-selector-access)

访问没有选择算符的 Service，与有选择算符的 Service 的原理相同。 在没有选择算符的 Service [示例](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors)中， 流量被路由到 EndpointSlice 清单中定义的两个端点之一： 通过 TCP 协议连接到 10.1.2.3 或 10.4.5.6 的端口 9376。

**说明：**

Kubernetes API 服务器不允许代理到未被映射至 Pod 上的端点。由于此约束，当 Service 没有选择算符时，诸如 `kubectl proxy <service-name>` 之类的操作将会失败。这可以防止 Kubernetes API 服务器被用作调用者可能无权访问的端点的代理。

`ExternalName` Service 是 Service 的特例，它没有选择算符，而是使用 DNS 名称。 有关更多信息，请参阅 [ExternalName](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#externalname) 一节。

##### EndpointSlices[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#endpointslices)

**特性状态：** `Kubernetes v1.21 [stable]`

[EndpointSlices](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/) 这些对象表示针对服务的后备网络端点的子集（**切片**）。

你的 Kubernetes 集群会跟踪每个 EndpointSlice 表示的端点数量。 如果服务的端点太多以至于达到阈值，Kubernetes 会添加另一个空的 EndpointSlice 并在其中存储新的端点信息。 默认情况下，一旦现有 EndpointSlice 都包含至少 100 个端点，Kubernetes 就会创建一个新的 EndpointSlice。 在需要添加额外的端点之前，Kubernetes 不会创建新的 EndpointSlice。

参阅 [EndpointSlices](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/) 了解有关该 API 的更多信息。

##### Endpoints[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#endpoints)

在 Kubernetes API 中，[Endpoints](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/endpoints-v1/) （该资源类别为复数）定义了网络端点的列表，通常由 Service 引用，以定义可以将流量发送到哪些 Pod。

推荐用 EndpointSlice API 替换 Endpoints。

###### 超出容量的端点[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E8%B6%85%E5%87%BA%E5%AE%B9%E9%87%8F%E7%9A%84%E7%AB%AF%E7%82%B9)

Kubernetes 限制单个 Endpoints 对象中可以容纳的端点数量。 当一个服务有超过 1000 个后备端点时，Kubernetes 会截断 Endpoints 对象中的数据。 由于一个服务可以链接多个 EndpointSlice，所以 1000 个后备端点的限制仅影响旧版的 Endpoints API。

这种情况下，Kubernetes 选择最多 1000 个可能的后端端点来存储到 Endpoints 对象中，并在 Endpoints: [`endpoints.kubernetes.io/over-capacity: truncated`](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#endpoints-kubernetes-io-over-capacity) 上设置[注解](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/)。 如果后端 Pod 的数量低于 1000，控制平面也会移除该注解。

流量仍会发送到后端，但任何依赖旧版 Endpoints API 的负载均衡机制最多只能将流量发送到 1000 个可用的后备端点。

相同的 API 限制意味着你不能手动将 Endpoints 更新为拥有超过 1000 个端点。

##### 应用协议[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#application-protocol)

**特性状态：** `Kubernetes v1.20 [stable]`

`appProtocol` 字段提供了一种为每个 Service 端口指定应用协议的方式。 此字段的取值会被映射到对应的 Endpoints 和 EndpointSlices 对象。

该字段遵循标准的 Kubernetes 标签语法。 其值可以是 [IANA 标准服务名称](https://www.iana.org/assignments/service-names) 或以域名为前缀的名称，如 `mycompany.com/my-custom-protocol`。

#### 多端口 Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#multi-port-services)

对于某些服务，你需要公开多个端口。 Kubernetes 允许你在 Service 对象上配置多个端口定义。 为服务使用多个端口时，必须提供所有端口名称，以使它们无歧义。 例如：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 9376
    - name: https
      protocol: TCP
      port: 443
      targetPort: 9377
```

**说明：**

与一般的 Kubernetes 名称一样，端口名称只能包含小写字母数字字符 和 `-`。 端口名称还必须以字母数字字符开头和结尾。

例如，名称 `123-abc` 和 `web` 有效，但是 `123_abc` 和 `-web` 无效。

#### 选择自己的 IP 地址[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#choosing-your-own-ip-address)

在 `Service` 创建的请求中，可以通过设置 `spec.clusterIP` 字段来指定自己的集群 IP 地址。 比如，希望替换一个已经已存在的 DNS 条目，或者遗留系统已经配置了一个固定的 IP 且很难重新配置。

用户选择的 IP 地址必须合法，并且这个 IP 地址在 `service-cluster-ip-range` CIDR 范围内， 这对 API 服务器来说是通过一个标识来指定的。 如果 IP 地址不合法，API 服务器会返回 HTTP 状态码 422，表示值不合法。

#### 服务发现[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#discovering-services)

Kubernetes 支持两种基本的服务发现模式 —— 环境变量和 DNS。

##### 环境变量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#environment-variables)

当 Pod 运行在 `Node` 上，kubelet 会为每个活跃的 Service 添加一组环境变量。 kubelet 为 Pod 添加环境变量 `{SVCNAME}_SERVICE_HOST` 和 `{SVCNAME}_SERVICE_PORT`。 这里 Service 的名称需大写，横线被转换成下划线。 它还支持与 Docker Engine 的 "**[legacy container links](https://docs.docker.com/network/links/)**" 特性兼容的变量 （参阅 [makeLinkVariables](https://github.com/kubernetes/kubernetes/blob/dd2d12f6dc0e654c15d5db57a5f9f6ba61192726/pkg/kubelet/envvars/envvars.go#L72)) 。

举个例子，一个名称为 `redis-primary` 的 Service 暴露了 TCP 端口 6379， 同时给它分配了 Cluster IP 地址 10.0.0.11，这个 Service 生成了如下环境变量：

```shell
REDIS_PRIMARY_SERVICE_HOST=10.0.0.11
REDIS_PRIMARY_SERVICE_PORT=6379
REDIS_PRIMARY_PORT=tcp://10.0.0.11:6379
REDIS_PRIMARY_PORT_6379_TCP=tcp://10.0.0.11:6379
REDIS_PRIMARY_PORT_6379_TCP_PROTO=tcp
REDIS_PRIMARY_PORT_6379_TCP_PORT=6379
REDIS_PRIMARY_PORT_6379_TCP_ADDR=10.0.0.11
```

**说明：**

当你具有需要访问服务的 Pod 时，并且你正在使用环境变量方法将端口和集群 IP 发布到客户端 Pod 时，必须在客户端 Pod 出现 **之前** 创建服务。 否则，这些客户端 Pod 将不会设定其环境变量。

如果仅使用 DNS 查找服务的集群 IP，则无需担心此设定问题。

##### DNS[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#dns)

你可以（几乎总是应该）使用[附加组件](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/) 为 Kubernetes 集群设置 DNS 服务。

支持集群的 DNS 服务器（例如 CoreDNS）监视 Kubernetes API 中的新服务，并为每个服务创建一组 DNS 记录。 如果在整个集群中都启用了 DNS，则所有 Pod 都应该能够通过其 DNS 名称自动解析服务。

例如，如果你在 Kubernetes 命名空间 `my-ns` 中有一个名为 `my-service` 的服务， 则控制平面和 DNS 服务共同为 `my-service.my-ns` 创建 DNS 记录。 `my-ns` 命名空间中的 Pod 应该能够通过按名检索 `my-service` 来找到服务 （`my-service.my-ns` 也可以工作）。

其他命名空间中的 Pod 必须将名称限定为 `my-service.my-ns`。 这些名称将解析为为服务分配的集群 IP。

Kubernetes 还支持命名端口的 DNS SRV（服务）记录。 如果 `my-service.my-ns` 服务具有名为 `http`　的端口，且协议设置为 TCP， 则可以对 `_http._tcp.my-service.my-ns` 执行 DNS SRV 查询以发现该端口号、`"http"` 以及 IP 地址。

Kubernetes DNS 服务器是唯一的一种能够访问 `ExternalName` 类型的 Service 的方式。 更多关于 `ExternalName` 解析的信息可以查看 [Service 与 Pod 的 DNS](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/)。

#### 无头服务（Headless Services）[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)

有时不需要或不想要负载均衡，以及单独的 Service IP。 遇到这种情况，可以通过指定 Cluster IP（`spec.clusterIP`）的值为 `"None"` 来创建 `Headless` Service。

你可以使用一个无头 Service 与其他服务发现机制进行接口，而不必与 Kubernetes 的实现捆绑在一起。

对于无头 `Services` 并不会分配 Cluster IP，kube-proxy 不会处理它们， 而且平台也不会为它们进行负载均衡和路由。 DNS 如何实现自动配置，依赖于 Service 是否定义了选择算符。

##### 带选择算符的服务[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#with-selectors)

对定义了选择算符的无头服务，Kubernetes 控制平面在 Kubernetes API 中创建 EndpointSlice 对象， 并且修改 DNS 配置返回 A 或 AAA 条记录（IPv4 或 IPv6 地址），通过这个地址直接到达 `Service` 的后端 Pod 上。

##### 无选择算符的服务[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#without-selectors)

对没有定义选择算符的无头服务，控制平面不会创建 EndpointSlice 对象。 然而 DNS 系统会查找和配置以下之一：

- 对于 [`type: ExternalName`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#externalname) 服务，查找和配置其 CNAME 记录
- 对所有其他类型的服务，针对 Service 的就绪端点的所有 IP 地址，查找和配置 DNS A / AAAA 条记录
    - 对于 IPv4 端点，DNS 系统创建 A 条记录。
    - 对于 IPv6 端点，DNS 系统创建 AAAA 条记录。

#### 发布服务（服务类型）[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#publishing-services-service-types)

对一些应用的某些部分（如前端），可能希望将其暴露给 Kubernetes 集群外部的 IP 地址。

Kubernetes `ServiceTypes` 允许指定你所需要的 Service 类型。

`Type` 的取值以及行为如下：

- `ClusterIP`：通过集群的内部 IP 暴露服务，选择该值时服务只能够在集群内部访问。 这也是你没有为服务显式指定 `type` 时使用的默认值。 你可以使用 [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/) 或者 [Gateway API](https://gateway-api.sigs.k8s.io/) 向公众暴露服务。
    
- [`NodePort`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport)：通过每个节点上的 IP 和静态端口（`NodePort`）暴露服务。 为了让节点端口可用，Kubernetes 设置了集群 IP 地址，这等同于你请求 `type: ClusterIP` 的服务。
    
- [`LoadBalancer`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer)：使用云提供商的负载均衡器向外部暴露服务。 外部负载均衡器可以将流量路由到自动创建的 `NodePort` 服务和 `ClusterIP` 服务上。
    
- [`ExternalName`](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#externalname)：通过返回 `CNAME` 记录和对应值，可以将服务映射到 `externalName` 字段的内容（例如，`foo.bar.example.com`）。 无需创建任何类型代理。
    
    **说明：**
    
    你需要使用 kube-dns 1.7 及以上版本或者 CoreDNS 0.0.8 及以上版本才能使用 `ExternalName` 类型。
    

`type` 字段被设计为嵌套功能 - 每个级别都添加到前一个级别。 这并不是所有云提供商都严格要求的（例如：Google Compute Engine 不需要分配节点端口来使 `type: LoadBalancer` 工作，但另一个云提供商集成可能会这样做）。 虽然不需要严格的嵌套，但是 Service 的 Kubernetes API 设计无论如何都需要它。

你也可以使用 [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/) 来暴露自己的服务。 Ingress 不是一种服务类型，但它充当集群的入口点。 它可以将路由规则整合到一个资源中，因为它可以在同一 IP 地址下公开多个服务。

##### NodePort 类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport)

如果你将 `type` 字段设置为 `NodePort`，则 Kubernetes 控制平面将在 `--service-node-port-range` 标志指定的范围内分配端口（默认值：30000-32767）。 每个节点将那个端口（每个节点上的相同端口号）代理到你的服务中。 你的服务在其 `.spec.ports[*].nodePort` 字段中报告已分配的端口。

使用 NodePort 可以让你自由设置自己的负载均衡解决方案， 配置 Kubernetes 不完全支持的环境， 甚至直接暴露一个或多个节点的 IP 地址。

对于 NodePort 服务，Kubernetes 额外分配一个端口（TCP、UDP 或 SCTP 以匹配服务的协议）。 集群中的每个节点都将自己配置为监听分配的端口并将流量转发到与该服务关联的某个就绪端点。 通过使用适当的协议（例如 TCP）和适当的端口（分配给该服务）连接到所有节点， 你将能够从集群外部使用 `type: NodePort` 服务。

###### 选择你自己的端口[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#nodeport-custom-port)

如果需要特定的端口号，你可以在 `nodePort` 字段中指定一个值。 控制平面将为你分配该端口或报告 API 事务失败。 这意味着你需要自己注意可能发生的端口冲突。 你还必须使用有效的端口号，该端口号在配置用于 NodePort 的范围内。

以下是 `type: NodePort` 服务的一个示例清单，它指定了一个 NodePort 值（在本例中为 30007）。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  type: NodePort
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    # 默认情况下，为了方便起见，`targetPort` 被设置为与 `port` 字段相同的值。
    - port: 80
      targetPort: 80
      # 可选字段
      # 默认情况下，为了方便起见，Kubernetes 控制平面会从某个范围内分配一个端口号（默认：30000-32767）
      nodePort: 30007
```

###### 为 `type: NodePort` 服务自定义 IP 地址配置[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-nodeport-custom-listen-address)

你可以在集群中设置节点以使用特定 IP 地址来提供 NodePort 服务。 如果每个节点都连接到多个网络（例如：一个网络用于应用程序流量，另一个网络用于节点和控制平面之间的流量）， 你可能需要执行此操作。

如果你要指定特定的 IP 地址来代理端口，可以将 kube-proxy 的 `--nodeport-addresses` 标志或 [kube-proxy 配置文件](https://kubernetes.io/zh-cn/docs/reference/config-api/kube-proxy-config.v1alpha1/)的等效 `nodePortAddresses` 字段设置为特定的 IP 段。

此标志采用逗号分隔的 IP 段列表（例如 `10.0.0.0/8`、`192.0.2.0/25`）来指定 kube-proxy 应视为该节点本地的 IP 地址范围。

例如，如果你使用 `--nodeport-addresses=127.0.0.0/8` 标志启动 kube-proxy， 则 kube-proxy 仅选择 NodePort 服务的环回接口。 `--nodeport-addresses` 的默认值是一个空列表。 这意味着 kube-proxy 应考虑 NodePort 的所有可用网络接口。 （这也与早期的 Kubernetes 版本兼容。）

**说明：**

此服务呈现为 `<NodeIP>:spec.ports[*].nodePort` 和 `.spec.clusterIP:spec.ports[*].port`。 如果设置了 kube-proxy 的 `--nodeport-addresses` 标志或 kube-proxy 配置文件中的等效字段， 则 `<NodeIP>` 将是过滤的节点 IP 地址（或可能的 IP 地址）。

##### LoadBalancer 类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer)

在使用支持外部负载均衡器的云提供商的服务时，设置 `type` 的值为 `"LoadBalancer"`， 将为 Service 提供负载均衡器。 负载均衡器是异步创建的，关于被提供的负载均衡器的信息将会通过 Service 的 `status.loadBalancer` 字段发布出去。

实例：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  clusterIP: 10.0.171.239
  type: LoadBalancer
status:
  loadBalancer:
    ingress:
    - ip: 192.0.2.127
```

来自外部负载均衡器的流量将直接重定向到后端 Pod 上，不过实际它们是如何工作的，这要依赖于云提供商。

某些云提供商允许设置 `loadBalancerIP`。 在这些情况下，将根据用户设置的 `loadBalancerIP` 来创建负载均衡器。 如果没有设置 `loadBalancerIP` 字段，将会给负载均衡器指派一个临时 IP。 如果设置了 `loadBalancerIP`，但云提供商并不支持这种特性，那么设置的 `loadBalancerIP` 值将会被忽略掉。

要实现 `type: LoadBalancer` 的服务，Kubernetes 通常首先进行与请求 `type: NodePort` 服务等效的更改。 cloud-controller-manager 组件然后配置外部负载均衡器以将流量转发到已分配的节点端口。

你可以将负载均衡服务配置为[忽略](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#load-balancer-nodeport-allocation)分配节点端口， 前提是云提供商实现支持这点。

**说明：**

在 **Azure** 上，如果要使用用户指定的公共类型 `loadBalancerIP`， 则首先需要创建静态类型的公共 IP 地址资源。 此公共 IP 地址资源应与集群中其他自动创建的资源位于同一资源组中。 例如，`MC_myResourceGroup_myAKSCluster_eastus`。

将分配的 IP 地址设置为 loadBalancerIP。确保你已更新云提供程序配置文件中的 securityGroupName。 有关对 `CreatingLoadBalancerFailed` 权限问题进行故障排除的信息， 请参阅[与 Azure Kubernetes 服务（AKS）负载均衡器一起使用静态 IP 地址](https://docs.microsoft.com/zh-cn/azure/aks/static-ip) 或[在 AKS 集群上使用高级联网时出现 CreatingLoadBalancerFailed](https://github.com/Azure/AKS/issues/357)。

###### 混合协议类型的负载均衡器[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E6%B7%B7%E5%90%88%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8)

**特性状态：** `Kubernetes v1.20 [alpha]`

默认情况下，对于 LoadBalancer 类型的服务，当定义了多个端口时， 所有端口必须具有相同的协议，并且该协议必须是受云提供商支持的协议。

当服务中定义了多个端口时，特性门控 `MixedProtocolLBService`（在 kube-apiserver 1.24 版本默认为启用）允许 LoadBalancer 类型的服务使用不同的协议。

**说明：**

可用于 LoadBalancer 类型服务的协议集仍然由云提供商决定。 如果云提供商不支持混合协议，他们将只提供单一协议。

##### 禁用负载均衡器节点端口分配[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#load-balancer-nodeport-allocation)

**特性状态：** `Kubernetes v1.24 [stable]`

你可以通过设置 `spec.allocateLoadBalancerNodePorts` 为 `false` 对类型为 LoadBalancer 的服务禁用节点端口分配。 这仅适用于直接将流量路由到 Pod 而不是使用节点端口的负载均衡器实现。 默认情况下，`spec.allocateLoadBalancerNodePorts` 为 `true`， LoadBalancer 类型的服务继续分配节点端口。 如果现有服务已被分配节点端口，将参数 `spec.allocateLoadBalancerNodePorts` 设置为 `false` 时，这些服务上已分配置的节点端口**不会**被自动释放。 你必须显式地在每个服务端口中删除 `nodePorts` 项以释放对应端口。

###### 设置负载均衡器实现的类别[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#load-balancer-class)

**特性状态：** `Kubernetes v1.24 [stable]`

`spec.loadBalancerClass` 允许你不使用云提供商的默认负载均衡器实现，转而使用指定的负载均衡器实现。 默认情况下，`.spec.loadBalancerClass` 的取值是 `nil`，如果集群使用 `--cloud-provider` 配置了云提供商， `LoadBalancer` 类型服务会使用云提供商的默认负载均衡器实现。 如果设置了 `.spec.loadBalancerClass`，则假定存在某个与所指定的类相匹配的负载均衡器实现在监视服务变化。 所有默认的负载均衡器实现（例如，由云提供商所提供的）都会忽略设置了此字段的服务。`.spec.loadBalancerClass` 只能设置到类型为 `LoadBalancer` 的 Service 之上，而且一旦设置之后不可变更。

`.spec.loadBalancerClass` 的值必须是一个标签风格的标识符， 可以有选择地带有类似 "`internal-vip`" 或 "`example.com/internal-vip`" 这类前缀。 没有前缀的名字是保留给最终用户的。

###### 内部负载均衡器[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#internal-load-balancer)

在混合环境中，有时有必要在同一(虚拟)网络地址块内路由来自服务的流量。

在水平分割 DNS 环境中，你需要两个服务才能将内部和外部流量都路由到你的端点（Endpoints）。

如要设置内部负载均衡器，请根据你所使用的云运营商，为服务添加以下注解之一：

- [Default](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-0)
- [GCP](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-1)
- [AWS](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-2)
- [Azure](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-3)
- [IBM Cloud](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-4)
- [OpenStack](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-5)
- [Baidu Cloud](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-6)
- [Tencent Cloud](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-7)
- [Alibaba Cloud](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-8)
- [OCI](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#service-tabs-9)

选择一个标签。

```yaml
[...]
metadata:
    name: my-service
    annotations:
        cloud.google.com/load-balancer-type: "Internal"
[...]
```

```yaml
[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/aws-load-balancer-internal: "true"
[...]
```

```yaml
[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/azure-load-balancer-internal: "true"
[...]
```

```yaml
[...]
metadata:
    name: my-service
    annotations:
        service.kubernetes.io/ibm-load-balancer-cloud-provider-ip-type: "private"
[...]
```

```yaml
[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/openstack-internal-load-balancer: "true"
[...]
```

```yaml
[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/cce-load-balancer-internal-vpc: "true"
[...]
```

```yaml
[...]
metadata:
  annotations:
    service.kubernetes.io/qcloud-loadbalancer-internal-subnetid: subnet-xxxxx
[...]
```

```yaml
[...]
metadata:
  annotations:
    service.beta.kubernetes.io/alibaba-cloud-loadbalancer-address-type: "intranet"
[...]
```

```yaml
[...]
metadata:
    name: my-service
    annotations:
        service.beta.kubernetes.io/oci-load-balancer-internal: true
[...]
```

##### AWS TLS 支持[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#ssl-support-on-aws)

为了对在 AWS 上运行的集群提供 TLS/SSL 部分支持，你可以向 `LoadBalancer` 服务添加三个注解：

```yaml
metadata:
  name: my-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-ssl-cert: arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012
```

第一个指定要使用的证书的 ARN。 它可以是已上载到 IAM 的第三方颁发者的证书， 也可以是在 AWS Certificate Manager 中创建的证书。

```yaml
metadata:
  name: my-service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: (https|http|ssl|tcp)
```

第二个注解指定 Pod 使用哪种协议。对于 HTTPS 和 SSL，ELB 希望 Pod 使用证书通过加密连接对自己进行身份验证。

HTTP 和 HTTPS 选择第 7 层代理：ELB 终止与用户的连接，解析标头，并在转发请求时向 `X-Forwarded-For` 标头注入用户的 IP 地址（Pod 仅在连接的另一端看到 ELB 的 IP 地址）。

TCP 和 SSL 选择第 4 层代理：ELB 转发流量而不修改报头。

在某些端口处于安全状态而其他端口未加密的混合使用环境中，可以使用以下注解：

```yaml
    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-backend-protocol: http
        service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443,8443"
```

在上例中，如果服务包含 `80`、`443` 和 `8443` 三个端口， 那么 `443` 和 `8443` 将使用 SSL 证书， 而 `80` 端口将转发 HTTP 数据包。

从 Kubernetes v1.9 起可以使用 [预定义的 AWS SSL 策略](https://docs.aws.amazon.com/zh_cn/elasticloadbalancing/latest/classic/elb-security-policy-table.html) 为你的服务使用 HTTPS 或 SSL 侦听器。 要查看可以使用哪些策略，可以使用 `aws` 命令行工具：

```bash
aws elb describe-load-balancer-policies --query 'PolicyDescriptions[].PolicyName'
```

然后，你可以使用 "`service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy`" 注解; 例如：

```yaml
    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS-1-2-2017-01"
```

###### AWS 上的 PROXY 协议支持[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#aws-%E4%B8%8A%E7%9A%84-proxy-%E5%8D%8F%E8%AE%AE%E6%94%AF%E6%8C%81)

为了支持在 AWS 上运行的集群，启用 [PROXY 协议](https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt)。 你可以使用以下服务注解：

```yaml
    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: "*"
```

从 1.3.0 版开始，此注解的使用适用于 ELB 代理的所有端口，并且不能进行其他配置。

###### AWS 上的 ELB 访问日志[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#aws-%E4%B8%8A%E7%9A%84-elb-%E8%AE%BF%E9%97%AE%E6%97%A5%E5%BF%97)

有几个注解可用于管理 AWS 上 ELB 服务的访问日志。

注解 `service.beta.kubernetes.io/aws-load-balancer-access-log-enabled` 控制是否启用访问日志。

注解 `service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval` 控制发布访问日志的时间间隔（以分钟为单位）。你可以指定 5 分钟或 60 分钟的间隔。

注解 `service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name` 控制存储负载均衡器访问日志的 Amazon S3 存储桶的名称。

注解 `service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix` 指定为 Amazon S3 存储桶创建的逻辑层次结构。

```yaml
    metadata:
      name: my-service
      annotations:
        # 指定是否为负载均衡器启用访问日志
        service.beta.kubernetes.io/aws-load-balancer-access-log-enabled: "true"
        # 发布访问日志的时间间隔。你可以将其设置为 5 分钟或 60 分钟。
        service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval: "60"
        # 用来存放访问日志的 Amazon S3 Bucket 名称
        service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name: "my-bucket"
        # 你为 Amazon S3 Bucket 所创建的逻辑层次结构，例如 `my-bucket-prefix/prod`
        service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix: "my-bucket-prefix/prod"
```

###### AWS 上的连接排空[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#aws-%E4%B8%8A%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%8E%92%E7%A9%BA)

可以将注解 `service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled` 设置为 `"true"` 来管理 ELB 的连接排空。 注解 `service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout` 也可以用于设置最大时间（以秒为单位），以保持现有连接在注销实例之前保持打开状态。

```yaml
    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true"
        service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "60"
```

###### 其他 ELB 注解[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E5%85%B6%E4%BB%96-elb-%E6%B3%A8%E8%A7%A3)

还有其他一些注解，用于管理经典弹性负载均衡器，如下所述。

```yaml
    metadata:
      name: my-service
      annotations:
        # 按秒计的时间，表示负载均衡器关闭连接之前连接可以保持空闲
        # （连接上无数据传输）的时间长度
        service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout: "60"

        # 指定该负载均衡器上是否启用跨区的负载均衡能力
        service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"

        # 逗号分隔列表值，每一项都是一个键-值耦对，会作为额外的标签记录于 ELB 中
        service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: "environment=prod,owner=devops"

        # 将某后端视为健康、可接收请求之前需要达到的连续成功健康检查次数。
        # 默认为 2，必须介于 2 和 10 之间
        service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold: ""

        # 将某后端视为不健康、不可接收请求之前需要达到的连续不成功健康检查次数。
        # 默认为 6，必须介于 2 和 10 之间
        service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold: "3"

        # 对每个实例进行健康检查时，连续两次检查之间的大致间隔秒数
        # 默认为 10，必须介于 5 和 300 之间
        service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval: "20"

        # 时长秒数，在此期间没有响应意味着健康检查失败
        # 此值必须小于 service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval
        # 默认值为 5，必须介于 2 和 60 之间
        service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout: "5"

        # 由已有的安全组所构成的列表，可以配置到所创建的 ELB 之上。
        # 与注解 service.beta.kubernetes.io/aws-load-balancer-extra-security-groups 不同，
        # 这一设置会替代掉之前指定给该 ELB 的所有其他安全组，也会覆盖掉为此
        # ELB 所唯一创建的安全组。
        # 此列表中的第一个安全组 ID 被用来作为决策源，以允许入站流量流入目标工作节点
        # (包括服务流量和健康检查）。
        # 如果多个 ELB 配置了相同的安全组 ID，为工作节点安全组添加的允许规则行只有一个，
        # 这意味着如果你删除了这些 ELB 中的任何一个，都会导致该规则记录被删除，
        # 以至于所有共享该安全组 ID 的其他 ELB 都无法访问该节点。
        # 此注解如果使用不当，会导致跨服务的不可用状况。
        service.beta.kubernetes.io/aws-load-balancer-security-groups: "sg-53fae93f"

        # 额外的安全组列表，将被添加到所创建的 ELB 之上。
        # 添加时，会保留为 ELB 所专门创建的安全组。
        # 这样会确保每个 ELB 都有一个唯一的安全组 ID 和与之对应的允许规则记录，
        # 允许请求（服务流量和健康检查）发送到目标工作节点。
        # 这里顶一个安全组可以被多个服务共享。
        service.beta.kubernetes.io/aws-load-balancer-extra-security-groups: "sg-53fae93f,sg-42efd82e"

        # 用逗号分隔的一个键-值偶对列表，用来为负载均衡器选择目标节点
        service.beta.kubernetes.io/aws-load-balancer-target-node-labels: "ingress-gw,gw-name=public-api"
```

###### AWS 上网络负载均衡器支持[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#aws-nlb-support)

**特性状态：** `Kubernetes v1.15 [beta]`

要在 AWS 上使用网络负载均衡器，可以使用注解 `service.beta.kubernetes.io/aws-load-balancer-type`，将其取值设为 `nlb`。

```yaml
    metadata:
      name: my-service
      annotations:
        service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
```

**说明：**

NLB 仅适用于某些实例类。有关受支持的实例类型的列表， 请参见 [AWS 文档](https://docs.aws.amazon.com/zh_cn/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets) 中关于所支持的实例类型的 Elastic Load Balancing 说明。

与经典弹性负载均衡器不同，网络负载均衡器（NLB）将客户端的 IP 地址转发到该节点。 如果服务的 `.spec.externalTrafficPolicy` 设置为 `Cluster` ，则客户端的 IP 地址不会传达到最终的 Pod。

通过将 `.spec.externalTrafficPolicy` 设置为 `Local`，客户端 IP 地址将传播到最终的 Pod， 但这可能导致流量分配不均。 没有针对特定 LoadBalancer 服务的任何 Pod 的节点将无法通过自动分配的 `.spec.healthCheckNodePort` 进行 NLB 目标组的运行状况检查，并且不会收到任何流量。

为了获得均衡流量，请使用 DaemonSet 或指定 [Pod 反亲和性](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity) 使其不在同一节点上。

你还可以将 NLB 服务与[内部负载均衡器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#internal-load-balancer) 注解一起使用。

为了使客户端流量能够到达 NLB 后面的实例，使用以下 IP 规则修改了节点安全组：

| Rule | Protocol | Port(s) | IpRange(s) | IpRange Description |
| --- | --- | --- | --- | --- |
| Health Check | TCP | NodePort(s) (`.spec.healthCheckNodePort` for `.spec.externalTrafficPolicy = Local`) | Subnet CIDR | kubernetes.io/rule/nlb/health=<loadBalancerName> |
| Client Traffic | TCP | NodePort(s) | `.spec.loadBalancerSourceRanges` (默认值为 `0.0.0.0/0`) | kubernetes.io/rule/nlb/client=<loadBalancerName> |
| MTU Discovery | ICMP | 3,4 | `.spec.loadBalancerSourceRanges` (默认值为 `0.0.0.0/0`) | kubernetes.io/rule/nlb/mtu=<loadBalancerName> |

为了限制哪些客户端 IP 可以访问网络负载均衡器，请指定 `loadBalancerSourceRanges`。

```yaml
spec:
  loadBalancerSourceRanges:
    - "143.231.0.0/16"
```

**说明：**

如果未设置 `.spec.loadBalancerSourceRanges` ，则 Kubernetes 允许从 `0.0.0.0/0` 到节点安全组的流量。 如果节点具有公共 IP 地址，请注意，非 NLB 流量也可以到达那些修改后的安全组中的所有实例。

有关弹性 IP 注解和更多其他常见用例， 请参阅[AWS 负载均衡控制器文档](https://kubernetes-sigs.github.io/aws-load-balancer-controller/latest/guide/service/annotations/)。

##### ExternalName 类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#externalname)

类型为 ExternalName 的服务将服务映射到 DNS 名称，而不是典型的选择算符，例如 `my-service` 或者 `cassandra`。 你可以使用 `spec.externalName` 参数指定这些服务。

例如，以下 Service 定义将 `prod` 名称空间中的 `my-service` 服务映射到 `my.database.example.com`：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
  namespace: prod
spec:
  type: ExternalName
  externalName: my.database.example.com
```

**说明：**

ExternalName 服务接受 IPv4 地址字符串，但作为包含数字的 DNS 名称，而不是 IP 地址。 类似于 IPv4 地址的外部名称不能由 CoreDNS 或 ingress-nginx 解析，因为外部名称旨在指定规范的 DNS 名称。 要对 IP 地址进行硬编码，请考虑使用[无头 Services](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)。

当查找主机 `my-service.prod.svc.cluster.local` 时，集群 DNS 服务返回 `CNAME` 记录， 其值为 `my.database.example.com`。 访问 `my-service` 的方式与其他服务的方式相同，但主要区别在于重定向发生在 DNS 级别，而不是通过代理或转发。 如果以后你决定将数据库移到集群中，则可以启动其 Pod，添加适当的选择算符或端点以及更改服务的 `type`。

**警告：**

对于一些常见的协议，包括 HTTP 和 HTTPS，你使用 ExternalName 可能会遇到问题。 如果你使用 ExternalName，那么集群内客户端使用的主机名与 ExternalName 引用的名称不同。

对于使用主机名的协议，此差异可能会导致错误或意外响应。 HTTP 请求将具有源服务器无法识别的 `Host:` 标头； TLS 服务器将无法提供与客户端连接的主机名匹配的证书。

**说明：**

有关这部分内容，我们要感谢 [Alen Komljen](https://akomljen.com/) 刊登的 [Kubernetes Tips - Part1](https://akomljen.com/kubernetes-tips-part-1/) 这篇博文。

##### 外部 IP[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#external-ips)

如果外部的 IP 路由到集群中一个或多个 Node 上，Kubernetes Service 会被暴露给这些 `externalIPs`。 通过外部 IP（作为目的 IP 地址）进入到集群，打到 Service 的端口上的流量， 将会被路由到 Service 的 Endpoint 上。 `externalIPs` 不会被 Kubernetes 管理，它属于集群管理员的职责范畴。

根据 Service 的规定，`externalIPs` 可以同任意的 `ServiceType` 来一起指定。 在上面的例子中，`my-service` 可以在 "`198.51.100.32:80`" (`externalIP:port`) 上被客户端访问。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 49152
  externalIPs:
    - 198.51.100.32
```

#### 粘性会话[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#session-stickiness)

如果你想确保来自特定客户端的连接每次都传递到同一个 Pod，你可以配置根据客户端 IP 地址来执行的会话亲和性。 阅读[会话亲和性](https://kubernetes.io/zh-cn/docs/reference/networking/virtual-ips/#session-affinity)了解更多。

#### API 对象[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#api-object)

Service 是 Kubernetes REST API 中的顶级资源。你可以找到有关 [Service 对象 API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#service-v1-core) 的更多详细信息。

#### 虚拟 IP 寻址机制[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#virtual-ip-addressing-mechanism)

阅读[虚拟 IP 和 Service 代理](https://kubernetes.io/zh-cn/docs/reference/networking/virtual-ips/)以了解 Kubernetes 提供的使用虚拟 IP 地址公开服务的机制。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

进一步学习 Service 及其在 Kubernetes 中所发挥的作用：

- 遵循[使用 Service 连接到应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)教程。
- 阅读 [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/) 将来自集群外部的 HTTP 和 HTTPS 请求路由暴露给集群内的服务。
- 阅读 [Gateway](https://gateway-api.sigs.k8s.io/) 作为 Kubernetes 的扩展提供比 Ingress 更大的灵活性。

更多上下文，可以阅读以下内容：

- [虚拟 IP 和 Service 代理](https://kubernetes.io/zh-cn/docs/reference/networking/virtual-ips/)
- [EndpointSlices](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/)
- Service API 的 [API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/service-v1/)
- EndpointSlice API 的 [API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/endpoint-slice-v1/)
- Endpoint API 的 [API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/endpoints-v1/)
### [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/)

使用一种能感知协议配置的机制来理解 URI、主机名称、路径和更多 Web 概念，使得 HTTP（或 HTTPS）网络服务可用。 Ingress 概念允许你通过 Kubernetes API 定义的规则将流量映射到不同的后端。

**特性状态：** `Kubernetes v1.19 [stable]`

Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。

Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。

#### 术语[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#terminology)

为了表达更加清晰，本指南定义了以下术语：

- 节点（Node）: Kubernetes 集群中的一台工作机器，是集群的一部分。
- 集群（Cluster）: 一组运行由 Kubernetes 管理的容器化应用程序的节点。 在此示例和在大多数常见的 Kubernetes 部署环境中，集群中的节点都不在公共网络中。
- 边缘路由器（Edge Router）: 在集群中强制执行防火墙策略的路由器。可以是由云提供商管理的网关，也可以是物理硬件。
- 集群网络（Cluster Network）: 一组逻辑的或物理的连接，根据 Kubernetes [网络模型](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/)在集群内实现通信。
- 服务（Service）：Kubernetes [服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)， 使用[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)选择器（selectors）辨认一组 Pod。 除非另有说明，否则假定服务只具有在集群网络中可路由的虚拟 IP。

#### Ingress 是什么？[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#what-is-ingress)

[Ingress](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#ingress-v1-networking-k8s-io) 公开从集群外部到集群内[服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。

下面是一个将所有流量都发送到同一 Service 的简单 Ingress 示例：

[![ingress-diagram](https://d33wubrfki0l68.cloudfront.net/4f01eaec32889ff16ee255e97822b6d165b633f0/a54b4/zh-cn/docs/images/ingress.svg)](https://mermaid.live/edit#pako:eNqNkktLAzEQgP9KSC8Ku6XWBxKlJz0IHsQeuz1kN7M2uC-SrA9sb6X26MFLFZGKoCC0CIIn_Td1139halZq8eJlE2a--TI7yRn2YgaYYCc6EDRpod39DSdCyAs4RGqhMRndffRfs6dxc9Euox0NgZR2NhpmF73sqos2XVFD-ctt_vY2uTnPh8PJ4BGV7Ro3ZKOoaH5Li6Bt19r56zi7fM4fupP-oC1BHHEPGnWzGlimruno87qXvd__qjdpw2pXErOlxl7Mmn_j1VkcImb-i0q5BT5KAsoj5PMgICXGmCWViA-BlHzfL_b2MWeqRVaSE8uLg1iQUqVS2ZiTHK7LQrFcXfNg9V8WnZu3eEEqFYjCNCslJdd15zXVmcacODP9TMcqJmBN5zL9VKdt_uLM1ZoBzIVNF8WqM06ELRyCCCln-oWcTVkHqxaE4GCitwx8mgbK0Y-no9E0YVTBNuMqFpj4NJBgYZqquH4aeZgokcIPtMWpvtywoDpfU3_yww)

图. Ingress

Ingress 可为 Service 提供外部可访问的 URL、负载均衡流量、终止 SSL/TLS，以及基于名称的虚拟托管。 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers) 通常负责通过负载均衡器来实现 Ingress，尽管它也可以配置边缘路由器或其他前端来帮助处理流量。

Ingress 不会公开任意端口或协议。 将 HTTP 和 HTTPS 以外的服务公开到 Internet 时，通常使用 [Service.Type=NodePort](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#type-nodeport) 或 [Service.Type=LoadBalancer](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer) 类型的 Service。

#### 环境准备[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87)

你必须拥有一个 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers) 才能满足 Ingress 的要求。 仅创建 Ingress 资源本身没有任何效果。

你可能需要部署 Ingress 控制器，例如 [ingress-nginx](https://kubernetes.github.io/ingress-nginx/deploy/)。 你可以从许多 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers) 中进行选择。

理想情况下，所有 Ingress 控制器都应符合参考规范。但实际上，不同的 Ingress 控制器操作略有不同。

**说明：** 确保你查看了 Ingress 控制器的文档，以了解选择它的注意事项。

#### Ingress 资源[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#the-ingress-resource)

一个最小的 Ingress 资源示例：

[`service/networking/minimal-ingress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/minimal-ingress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/minimal-ingress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: minimal-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: nginx-example
  rules:
  - http:
      paths:
      - path: /testpath
        pathType: Prefix
        backend:
          service:
            name: test
            port:
              number: 80
```

Ingress 需要指定 `apiVersion`、`kind`、 `metadata`和 `spec` 字段。 Ingress 对象的命名必须是合法的 [DNS 子域名名称](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)。 关于如何使用配置文件，请参见[部署应用](https://kubernetes.io/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/)、 [配置容器](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/)、 [管理资源](https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/manage-deployment/)。 Ingress 经常使用注解（annotations）来配置一些选项，具体取决于 Ingress 控制器，例如[重写目标注解](https://github.com/kubernetes/ingress-nginx/blob/main/docs/examples/rewrite/README.md)。 不同的 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers)支持不同的注解。 查看你所选的 Ingress 控制器的文档，以了解其支持哪些注解。

Ingress [规约](https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status) 提供了配置负载均衡器或者代理服务器所需的所有信息。 最重要的是，其中包含与所有传入请求匹配的规则列表。 Ingress 资源仅支持用于转发 HTTP(S) 流量的规则。

如果 `ingressClassName` 被省略，那么你应该定义一个[默认 Ingress 类](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#default-ingress-class)。

有一些 Ingress 控制器不需要定义默认的 `IngressClass`。比如：Ingress-NGINX 控制器可以通过[参数](https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class) `--watch-ingress-without-class` 来配置。 不过仍然[推荐](https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do) 按[下文](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#default-ingress-class)所示来设置默认的 `IngressClass`。

##### Ingress 规则[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#ingress-rules)

每个 HTTP 规则都包含以下信息：

- 可选的 `host`。在此示例中，未指定 `host`，因此该规则适用于通过指定 IP 地址的所有入站 HTTP 通信。 如果提供了 `host`（例如 foo.bar.com），则 `rules` 适用于该 `host`。
- 路径列表（例如 `/testpath`），每个路径都有一个由 `service.name` 和 `service.port.name` 或 `service.port.number` 定义的关联后端。 在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。
- `backend`（后端）是 [Service 文档](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)中所述的服务和端口名称的组合， 或者是通过 [CRD](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/) 方式来实现的[自定义资源后端](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#resource-backend)。 与规则的 `host` 和 `path` 匹配的对 Ingress 的 HTTP（和 HTTPS ）请求将发送到列出的 `backend`。

通常在 Ingress 控制器中会配置 `defaultBackend`（默认后端），以服务于无法与规约中 `path` 匹配的所有请求。

##### 默认后端[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#default-backend)

没有设置规则的 Ingress 将所有流量发送到同一个默认后端，而 `.spec.defaultBackend` 则是在这种情况下处理请求的那个默认后端。 `defaultBackend` 通常是 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers)的配置选项， 而非在 Ingress 资源中指定。 如果未设置任何的 `.spec.rules`，那么必须指定 `.spec.defaultBackend`。 如果未设置 `defaultBackend`，那么如何处理所有与规则不匹配的流量将交由 Ingress 控制器决定（请参考你的 Ingress 控制器的文档以了解它是如何处理那些流量的）。

如果没有 `hosts` 或 `paths` 与 Ingress 对象中的 HTTP 请求匹配，则流量将被路由到默认后端。

##### 资源后端[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#resource-backend)

`Resource` 后端是一个引用，指向同一命名空间中的另一个 Kubernetes 资源，将其作为 Ingress 对象。 `Resource` 后端与 Service 后端是互斥的，在二者均被设置时会无法通过合法性检查。 `Resource` 后端的一种常见用法是将所有入站数据导向带有静态资产的对象存储后端。

[`service/networking/ingress-resource-backend.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/ingress-resource-backend.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/ingress-resource-backend.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-resource-backend
spec:
  defaultBackend:
    resource:
      apiGroup: k8s.example.com
      kind: StorageBucket
      name: static-assets
  rules:
    - http:
        paths:
          - path: /icons
            pathType: ImplementationSpecific
            backend:
              resource:
                apiGroup: k8s.example.com
                kind: StorageBucket
                name: icon-assets
```

创建了如上的 Ingress 之后，你可以使用下面的命令查看它：

```bash
kubectl describe ingress ingress-resource-backend
```

```
Name:             ingress-resource-backend
Namespace:        default
Address:
Default backend:  APIGroup: k8s.example.com, Kind: StorageBucket, Name: static-assets
Rules:
  Host        Path  Backends
  ----        ----  --------
  *
              /icons   APIGroup: k8s.example.com, Kind: StorageBucket, Name: icon-assets
Annotations:  <none>
Events:       <none>
```

##### 路径类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#path-types)

Ingress 中的每个路径都需要有对应的路径类型（Path Type）。未明确设置 `pathType` 的路径无法通过合法性检查。当前支持的路径类型有三种：

- `ImplementationSpecific`：对于这种路径类型，匹配方法取决于 IngressClass。 具体实现可以将其作为单独的 `pathType` 处理或者与 `Prefix` 或 `Exact` 类型作相同处理。
    
- `Exact`：精确匹配 URL 路径，且区分大小写。
    
- `Prefix`：基于以 `/` 分隔的 URL 路径前缀匹配。匹配区分大小写，并且对路径中的元素逐个完成。 路径元素指的是由 `/` 分隔符分隔的路径中的标签列表。 如果每个 **p** 都是请求路径 **p** 的元素前缀，则请求与路径 **p** 匹配。
    
    **说明：** 如果路径的最后一个元素是请求路径中最后一个元素的子字符串，则不会匹配 （例如：`/foo/bar` 匹配 `/foo/bar/baz`, 但不匹配 `/foo/barbaz`）。
    

##### 示例[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#%E7%A4%BA%E4%BE%8B)

| 类型 | 路径 | 请求路径 | 匹配与否？ |
| --- | --- | --- | --- |
| Prefix | `/` | （所有路径） | 是 |
| Exact | `/foo` | `/foo` | 是 |
| Exact | `/foo` | `/bar` | 否 |
| Exact | `/foo` | `/foo/` | 否 |
| Exact | `/foo/` | `/foo` | 否 |
| Prefix | `/foo` | `/foo`, `/foo/` | 是 |
| Prefix | `/foo/` | `/foo`, `/foo/` | 是 |
| Prefix | `/aaa/bb` | `/aaa/bbb` | 否 |
| Prefix | `/aaa/bbb` | `/aaa/bbb` | 是 |
| Prefix | `/aaa/bbb/` | `/aaa/bbb` | 是，忽略尾部斜线 |
| Prefix | `/aaa/bbb` | `/aaa/bbb/` | 是，匹配尾部斜线 |
| Prefix | `/aaa/bbb` | `/aaa/bbb/ccc` | 是，匹配子路径 |
| Prefix | `/aaa/bbb` | `/aaa/bbbxyz` | 否，字符串前缀不匹配 |
| Prefix | `/`, `/aaa` | `/aaa/ccc` | 是，匹配 `/aaa` 前缀 |
| Prefix | `/`, `/aaa`, `/aaa/bbb` | `/aaa/bbb` | 是，匹配 `/aaa/bbb` 前缀 |
| Prefix | `/`, `/aaa`, `/aaa/bbb` | `/ccc` | 是，匹配 `/` 前缀 |
| Prefix | `/aaa` | `/ccc` | 否，使用默认后端 |
| 混合 | `/foo` (Prefix), `/foo` (Exact) | `/foo` | 是，优选 Exact 类型 |

###### 多重匹配[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#multiple-matches)

在某些情况下，Ingress 中的多条路径会匹配同一个请求。 这种情况下最长的匹配路径优先。 如果仍然有两条同等的匹配路径，则精确路径类型优先于前缀路径类型。

#### 主机名通配符[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#hostname-wildcards)

主机名可以是精确匹配（例如 “`foo.bar.com`”）或者使用通配符来匹配 （例如 “`*.foo.com`”）。 精确匹配要求 HTTP `host` 头部字段与 `host` 字段值完全匹配。 通配符匹配则要求 HTTP `host` 头部字段与通配符规则中的后缀部分相同。

| 主机 | host 头部 | 匹配与否？ |
| --- | --- | --- |
| `*.foo.com` | `bar.foo.com` | 基于相同的后缀匹配 |
| `*.foo.com` | `baz.bar.foo.com` | 不匹配，通配符仅覆盖了一个 DNS 标签 |
| `*.foo.com` | `foo.com` | 不匹配，通配符仅覆盖了一个 DNS 标签 |

[`service/networking/ingress-wildcard-host.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/ingress-wildcard-host.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/ingress-wildcard-host.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-wildcard-host
spec:
  rules:
  - host: "foo.bar.com"
    http:
      paths:
      - pathType: Prefix
        path: "/bar"
        backend:
          service:
            name: service1
            port:
              number: 80
  - host: "*.foo.com"
    http:
      paths:
      - pathType: Prefix
        path: "/foo"
        backend:
          service:
            name: service2
            port:
              number: 80
```

#### Ingress 类[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#ingress-class)

Ingress 可以由不同的控制器实现，通常使用不同的配置。 每个 Ingress 应当指定一个类，也就是一个对 IngressClass 资源的引用。 IngressClass 资源包含额外的配置，其中包括应当实现该类的控制器名称。

[`service/networking/external-lb.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/external-lb.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/external-lb.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: external-lb
spec:
  controller: example.com/ingress-controller
  parameters:
    apiGroup: k8s.example.com
    kind: IngressParameters
    name: external-lb
```

IngressClass 中的 `.spec.parameters` 字段可用于引用其他资源以提供额外的相关配置。

参数（`parameters`）的具体类型取决于你在 `.spec.controller` 字段中指定的 Ingress 控制器。

##### IngressClass 的作用域[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#ingressclass-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F)

取决于你的 Ingress 控制器，你可能可以使用集群范围设置的参数或某个名字空间范围的参数。

- [集群作用域](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#tabs-ingressclass-parameter-scope-0)
- [命名空间作用域](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#tabs-ingressclass-parameter-scope-1)

IngressClass 的参数默认是集群范围的。

如果你设置了 `.spec.parameters` 字段且未设置 `.spec.parameters.scope` 字段，或是将 `.spec.parameters.scope` 字段设为了 `Cluster`， 那么该 IngressClass 所指代的即是一个集群作用域的资源。 参数的 `kind`（和 `apiGroup` 一起）指向一个集群作用域的 API（可能是一个定制资源（Custom Resource）），而它的 `name` 则为此 API 确定了一个具体的集群作用域的资源。

示例：

```yaml
---
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: external-lb-1
spec:
  controller: example.com/ingress-controller
  parameters:
    # 此 IngressClass 的配置定义在一个名为 “external-config-1” 的
    # ClusterIngressParameter（API 组为 k8s.example.net）资源中。
    # 这项定义告诉 Kubernetes 去寻找一个集群作用域的参数资源。
    scope: Cluster
    apiGroup: k8s.example.net
    kind: ClusterIngressParameter
    name: external-config-1
```

**特性状态：** `Kubernetes v1.23 [stable]`

如果你设置了 `.spec.parameters` 字段且将 `.spec.parameters.scope` 字段设为了 `Namespace`，那么该 IngressClass 将会引用一个命名空间作用域的资源。 `.spec.parameters.namespace` 必须和此资源所处的命名空间相同。

参数的 `kind`（和 `apiGroup` 一起）指向一个命名空间作用域的 API（例如：ConfigMap），而它的 `name` 则确定了一个位于你指定的命名空间中的具体的资源。

命名空间作用域的参数帮助集群操作者将控制细分到用于工作负载的各种配置中（比如：负载均衡设置、API 网关定义）。如果你使用集群作用域的参数，那么你必须从以下两项中选择一项执行：

- 每次修改配置，集群操作团队需要批准其他团队的修改。
- 集群操作团队定义具体的准入控制，比如 [RBAC](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/) 角色与角色绑定，以使得应用程序团队可以修改集群作用域的配置参数资源。

IngressClass API 本身是集群作用域的。

这里是一个引用命名空间作用域的配置参数的 IngressClass 的示例：

```yaml
---
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: external-lb-2
spec:
  controller: example.com/ingress-controller
  parameters:
    # 此 IngressClass 的配置定义在一个名为 “external-config” 的
    # IngressParameter（API 组为 k8s.example.com）资源中，
    # 该资源位于 “external-configuration” 命名空间中。
    scope: Namespace
    apiGroup: k8s.example.com
    kind: IngressParameter
    namespace: external-configuration
    name: external-config
```

##### 废弃的注解[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#deprecated-annotation)

在 Kubernetes 1.18 版本引入 IngressClass 资源和 `ingressClassName` 字段之前， Ingress 类是通过 Ingress 中的一个 `kubernetes.io/ingress.class` 注解来指定的。 这个注解从未被正式定义过，但是得到了 Ingress 控制器的广泛支持。

Ingress 中新的 `ingressClassName` 字段是该注解的替代品，但并非完全等价。 该注解通常用于引用实现该 Ingress 的控制器的名称，而这个新的字段则是对一个包含额外 Ingress 配置的 IngressClass 资源的引用，包括 Ingress 控制器的名称。

##### 默认 Ingress 类[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#default-ingress-class)

你可以将一个特定的 IngressClass 标记为集群默认 Ingress 类。 将一个 IngressClass 资源的 `ingressclass.kubernetes.io/is-default-class` 注解设置为 `true` 将确保新的未指定 `ingressClassName` 字段的 Ingress 能够分配为这个默认的 IngressClass.

**注意：** 如果集群中有多个 IngressClass 被标记为默认，准入控制器将阻止创建新的未指定 `ingressClassName` 的 Ingress 对象。 解决这个问题只需确保集群中最多只能有一个 IngressClass 被标记为默认。

有一些 Ingress 控制器不需要定义默认的 `IngressClass`。比如：Ingress-NGINX 控制器可以通过[参数](https://kubernetes.github.io/ingress-nginx/#what-is-the-flag-watch-ingress-without-class) `--watch-ingress-without-class` 来配置。 不过仍然[推荐](https://kubernetes.github.io/ingress-nginx/#i-have-only-one-instance-of-the-ingresss-nginx-controller-in-my-cluster-what-should-i-do) 设置默认的 `IngressClass`。

[`service/networking/default-ingressclass.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/default-ingressclass.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/default-ingressclass.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  labels:
    app.kubernetes.io/component: controller
  name: nginx-example
  annotations:
    ingressclass.kubernetes.io/is-default-class: "true"
spec:
  controller: k8s.io/ingress-nginx
```

#### Ingress 类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#types-of-ingress)

##### 由单个 Service 来完成的 Ingress[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#single-service-ingress)

现有的 Kubernetes 概念允许你暴露单个 Service (参见[替代方案](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#alternatives))。 你也可以通过指定无规则的**默认后端**来对 Ingress 进行此操作。

[`service/networking/test-ingress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/test-ingress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/test-ingress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: test-ingress
spec:
  defaultBackend:
    service:
      name: test
      port:
        number: 80
```

如果使用 `kubectl apply -f` 创建此 Ingress，则应该能够查看刚刚添加的 Ingress 的状态：

```shell
kubectl get ingress test-ingress
```

```
NAME           CLASS         HOSTS   ADDRESS         PORTS   AGE
test-ingress   external-lb   *       203.0.113.123   80      59s
```

其中 `203.0.113.123` 是由 Ingress 控制器分配以满足该 Ingress 的 IP。

**说明：** 入口控制器和负载平衡器可能需要一两分钟才能分配 IP 地址。 在此之前，你通常会看到地址字段的值被设定为 `<pending>`。

##### 简单扇出[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#simple-fanout)

一个扇出（fanout）配置根据请求的 HTTP URI 将来自同一 IP 地址的流量路由到多个 Service。 Ingress 允许你将负载均衡器的数量降至最低。例如，这样的设置：

[![ingress-fanout-diagram](https://d33wubrfki0l68.cloudfront.net/5f6bf2469aaebdd05f2e8ece0ee93502cd1e9dae/0b366/zh-cn/docs/images/ingressfanout.svg)](https://mermaid.live/edit#pako:eNqNUk1v0zAY_iuWewEpyRKnjM5FPY0DEgfEjk0PTvxmtZbGke3woW03NDjuChNCRRyQkMYFidP4NyXlX5DMjroykLg4j_x8vM6j9xhnkgOm-FCxao4ePx0nJUJZIaA0d6ary48_33xvvnyd3fUD9Kg8VKC131wum_Oz5t0r9CBVE7T-9mF9dbV6_3q9XK7efkaBPxFWOXUOD0X3R8FeFEQkDqKYzK6HOJHvT052cilPNKhnIoNoemAB6i_okIThbU_KVO8hf3oIHYUj59F1an_u18VZ8-PTjRhLuyltZiV5NH0i-ewvBLlFEEvE_yKGGwJKbmtlWu9DjqqCiRLloijogHPuaaPkEdBBnucO-88FN3M6rF54mSykooMwDMdbIUcj7SJispvBvf9KabntlKyotQHlkjZWOkjTdDuGbGLsxE1S36jXl9YD4nWldsc1irtj2D39htdumy1l69q-zH3H2MMLUAsmeLuux50uwWYOC0gwbSGHnNWFSXBSnrbSuuLMwEMujFSY5qzQ4GFWG3nwsswwNaqGXrQvWLsgC6c6_Q0zxBrK)

图. Ingress 扇出

将需要一个如下所示的 Ingress：

[`service/networking/simple-fanout-example.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/simple-fanout-example.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/simple-fanout-example.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: simple-fanout-example
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - path: /foo
        pathType: Prefix
        backend:
          service:
            name: service1
            port:
              number: 4200
      - path: /bar
        pathType: Prefix
        backend:
          service:
            name: service2
            port:
              number: 8080
```

当你使用 `kubectl apply -f` 创建 Ingress 时：

```shell
kubectl describe ingress simple-fanout-example
```

```
Name:             simple-fanout-example
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:4200 (10.8.0.90:4200)
               /bar   service2:8080 (10.8.0.91:8080)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     22s                loadbalancer-controller  default/test
```

Ingress 控制器将提供实现特定的负载均衡器来满足 Ingress， 只要 Service (`service1`，`service2`) 存在。 当它这样做时，你会在 Address 字段看到负载均衡器的地址。

**说明：** 取决于你所使用的 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/)， 你可能需要创建默认 HTTP 后端[服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)。

##### 基于名称的虚拟托管[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#name-based-virtual-hosting)

基于名称的虚拟主机支持将针对多个主机名的 HTTP 流量路由到同一 IP 地址上。

[![ingress-namebase-diagram](https://d33wubrfki0l68.cloudfront.net/9de148f39701c4bad43e4308119ba0c4e40cdc68/04cff/zh-cn/docs/images/ingressnamebased.svg)](https://mermaid.live/edit#pako:eNqNkk9v0zAYxr-K5V6GlESNU6B4qKdxQOKA2LHpwYnfrNaSOLId_mjbDQ2OXAdMUxEHJKRxQWLaND4NXcq3IJkT2gKTuDiv_Dzv73UevXs4lhwwxTuKFVP06MlmmCMUpwJyszGen364ev2t-vxlcsv10MN8R4HWbnU6q94cVm9fovuRGqHF15PF5eX8-NViNpsffUKeOxLWOW47HOTfHXr3fM8ngecHZHI9pDW57mj_x9nF1ftzihIpvYgpL5bZvgb1VMTgj7dtgboLOuzfCGiaG8gKgPwJIL8Buozsb_98d1h9_7jCtHI7sB5QSO6PH0s--YdA_hKIFYKbhMFSgJzbwJnWW5CgImUiR4lIU9rjnDvaKLkLtJckSVu7zwQ3UzoonjuxTKWivX6_v7kG2R3qFhGQOzHc_i9Kra1T4rTUBlRLWrbSXhRF6xiyxNiJS1KXqNOF1hXEaUJtjusqaI5B8_SVXruHNpS1a_uy9lsr2MEZqIwJXq_yXuMMsZlCBiGmdckhYWVqQhzmB7W1LDgz8IALIxWmCUs1OJiVRm6_yGNMjSqhM20JVq9I1roOfgEKNyn5)

图. 基于名称实现虚拟托管的 Ingress

以下 Ingress 让后台负载均衡器基于 [host 头部字段](https://tools.ietf.org/html/rfc7230#section-5.4)来路由请求。

[`service/networking/name-virtual-host-ingress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/name-virtual-host-ingress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/name-virtual-host-ingress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: name-virtual-host-ingress
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service1
            port:
              number: 80
  - host: bar.foo.com
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service2
            port:
              number: 80
```

如果你创建的 Ingress 资源没有在 `rules` 中定义的任何 `hosts`，则可以匹配指向 Ingress 控制器 IP 地址的任何网络流量，而无需基于名称的虚拟主机。

例如，以下 Ingress 会将请求 `first.bar.com` 的流量路由到 `service1`，将请求 `second.bar.com` 的流量路由到 `service2`，而所有其他流量都会被路由到 `service3`。

[`service/networking/name-virtual-host-ingress-no-third-host.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/name-virtual-host-ingress-no-third-host.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/name-virtual-host-ingress-no-third-host.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: name-virtual-host-ingress-no-third-host
spec:
  rules:
  - host: first.bar.com
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service1
            port:
              number: 80
  - host: second.bar.com
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service2
            port:
              number: 80
  - http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: service3
            port:
              number: 80
```

##### TLS[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#tls)

你可以通过设定包含 TLS 私钥和证书的[Secret](https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/) 来保护 Ingress。 Ingress 只支持单个 TLS 端口 443，并假定 TLS 连接终止于 Ingress 节点（与 Service 及其 Pod 之间的流量都以明文传输）。 如果 Ingress 中的 TLS 配置部分指定了不同的主机，那么它们将根据通过 SNI TLS 扩展指定的主机名（如果 Ingress 控制器支持 SNI）在同一端口上进行复用。 TLS Secret 的数据中必须包含用于 TLS 的以键名 `tls.crt` 保存的证书和以键名 `tls.key` 保存的私钥。 例如：

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: testsecret-tls
  namespace: default
data:
  tls.crt: base64 编码的证书
  tls.key: base64 编码的私钥
type: kubernetes.io/tls
```

在 Ingress 中引用此 Secret 将会告诉 Ingress 控制器使用 TLS 加密从客户端到负载均衡器的通道。 你需要确保创建的 TLS Secret 创建自包含 `https-example.foo.com` 的公用名称（CN）的证书。 这里的公共名称也被称为全限定域名（FQDN）。

**说明：**

注意，默认规则上无法使用 TLS，因为需要为所有可能的子域名发放证书。 因此，`tls` 字段中的 `hosts` 的取值需要与 `rules` 字段中的 `host` 完全匹配。

[`service/networking/tls-example-ingress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/tls-example-ingress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/tls-example-ingress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-example-ingress
spec:
  tls:
  - hosts:
      - https-example.foo.com
    secretName: testsecret-tls
  rules:
  - host: https-example.foo.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: service1
            port:
              number: 80
```

**说明：** 各种 Ingress 控制器所支持的 TLS 功能之间存在差异。请参阅有关 [nginx](https://kubernetes.github.io/ingress-nginx/user-guide/tls/)、 [GCE](https://git.k8s.io/ingress-gce/README.md#frontend-https) 或者任何其他平台特定的 Ingress 控制器的文档，以了解 TLS 如何在你的环境中工作。

##### 负载均衡[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#load-balancing)

Ingress 控制器启动引导时使用一些适用于所有 Ingress 的负载均衡策略设置，例如负载均衡算法、后端权重方案等。 更高级的负载均衡概念（例如持久会话、动态权重）尚未通过 Ingress 公开。 你可以通过用于服务的负载均衡器来获取这些功能。

值得注意的是，尽管健康检查不是通过 Ingress 直接暴露的，在 Kubernetes 中存在并行的概念，比如 [就绪检查](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)， 允许你实现相同的目的。 请检查特定控制器的说明文档（例如：[nginx](https://git.k8s.io/ingress-nginx/README.md)、 [GCE](https://git.k8s.io/ingress-gce/README.md#health-checks)）以了解它们是怎样处理健康检查的。

#### 更新 Ingress[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#updating-an-ingress)

要更新现有的 Ingress 以添加新的 Host，可以通过编辑资源来对其进行更新：

```shell
kubectl describe ingress test
```

```
Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     35s                loadbalancer-controller  default/test
```

```shell
kubectl edit ingress test
```

这一命令将打开编辑器，允许你以 YAML 格式编辑现有配置。 修改它来增加新的主机：

```yaml
spec:
  rules:
  - host: foo.bar.com
    http:
      paths:
      - backend:
          service:
            name: service1
            port:
              number: 80
        path: /foo
        pathType: Prefix
  - host: bar.baz.com
    http:
      paths:
      - backend:
          service:
            name: service2
            port:
              number: 80
        path: /foo
        pathType: Prefix
..
```

保存更改后，kubectl 将更新 API 服务器中的资源，该资源将告诉 Ingress 控制器重新配置负载均衡器。

验证：

```shell
kubectl describe ingress test
```

```
Name:             test
Namespace:        default
Address:          178.91.123.132
Default backend:  default-http-backend:80 (10.8.2.3:8080)
Rules:
  Host         Path  Backends
  ----         ----  --------
  foo.bar.com
               /foo   service1:80 (10.8.0.90:80)
  bar.baz.com
               /foo   service2:80 (10.8.0.91:80)
Annotations:
  nginx.ingress.kubernetes.io/rewrite-target:  /
Events:
  Type     Reason  Age                From                     Message
  ----     ------  ----               ----                     -------
  Normal   ADD     45s                loadbalancer-controller  default/test
```

你也可以通过 `kubectl replace -f` 命令调用修改后的 Ingress yaml 文件来获得同样的结果。

#### 跨可用区失败[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#failing-across-availability-zones)

不同的云厂商使用不同的技术来实现跨故障域的流量分布。详情请查阅相关 Ingress 控制器的文档。 请查看相关 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers)的文档以了解详细信息。

#### 替代方案[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#alternatives)

不直接使用 Ingress 资源，也有多种方法暴露 Service：

- 使用 [Service.Type=LoadBalancer](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer)
- 使用 [Service.Type=NodePort](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#nodeport)

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解 [Ingress](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/ingress-v1/) API
- 进一步了解 [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/)
- [使用 NGINX 控制器在 Minikube 上安装 Ingress](https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/ingress-minikube/)
### [EndpointSlice](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/)

EndpointSlice API 是 Kubernetes 用于扩缩 Service 以处理大量后端的机制，还允许集群高效更新其健康后端的列表。
**特性状态：** `Kubernetes v1.21 [stable]`

Kubernetes 的 _EndpointSlice_ API 提供了一种简单的方法来跟踪 Kubernetes 集群中的网络端点（network endpoints）。EndpointSlices 为 [Endpoints](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#endpoints) 提供了一种可扩缩和可拓展的替代方案。

#### EndpointSlice API[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#endpointslice-resource)

在 Kubernetes 中，`EndpointSlice` 包含对一组网络端点的引用。 控制面会自动为设置了[选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)的 Kubernetes Service 创建 EndpointSlice。 这些 EndpointSlice 将包含对与 Service 选择算符匹配的所有 Pod 的引用。 EndpointSlice 通过唯一的协议、端口号和 Service 名称将网络端点组织在一起。 EndpointSlice 的名称必须是合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)。

例如，下面是 Kubernetes Service `example` 所拥有的 EndpointSlice 对象示例。

```yaml
apiVersion: discovery.k8s.io/v1
kind: EndpointSlice
metadata:
  name: example-abc
  labels:
    kubernetes.io/service-name: example
addressType: IPv4
ports:
  - name: http
    protocol: TCP
    port: 80
endpoints:
  - addresses:
      - "10.1.2.3"
    conditions:
      ready: true
    hostname: pod-1
    nodeName: node-1
    zone: us-west2-a
```

默认情况下，控制面创建和管理的 EndpointSlice 将包含不超过 100 个端点。 你可以使用 [kube-controller-manager](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/) 的 `--max-endpoints-per-slice` 标志设置此值，最大值为 1000。

当涉及如何路由内部流量时，EndpointSlice 可以充当 [kube-proxy](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/) 的决策依据。

##### 地址类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B)

EndpointSlice 支持三种地址类型：

- IPv4
- IPv6
- FQDN (完全合格的域名)

每个 `EndpointSlice` 对象代表一个特定的 IP 地址类型。如果你有一个支持 IPv4 和 IPv6 的 Service， 那么将至少有两个 `EndpointSlice` 对象（一个用于 IPv4，一个用于 IPv6）。

##### 状况[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#%E7%8A%B6%E5%86%B5)

EndpointSlice API 存储了可能对使用者有用的、有关端点的状况。 这三个状况分别是 `ready`、`serving` 和 `terminating`。

###### Ready（就绪）[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#ready-%E5%B0%B1%E7%BB%AA)

`ready` 状况是映射 Pod 的 `Ready` 状况的。 对于处于运行中的 Pod，它的 `Ready` 状况被设置为 `True`，应该将此 EndpointSlice 状况也设置为 `true`。 出于兼容性原因，当 Pod 处于终止过程中，`ready` 永远不会为 `true`。 消费者应参考 `serving` 状况来检查处于终止中的 Pod 的就绪情况。 该规则的唯一例外是将 `spec.publishNotReadyAddresses` 设置为 `true` 的 Service。 这些 Service 的端点将始终将 `ready` 状况设置为 `true`。

###### Serving（服务中）[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#serving-%E6%9C%8D%E5%8A%A1%E4%B8%AD)

**特性状态：** `Kubernetes v1.22 [beta]`

`serving` 状况与 `ready` 状况相同，不同之处在于它不考虑终止状态。 如果 EndpointSlice API 的使用者关心 Pod 终止时的就绪情况，就应检查此状况。

**说明：**

尽管 `serving` 与 `ready` 几乎相同，但是它是为防止破坏 `ready` 的现有含义而增加的。 如果对于处于终止中的端点，`ready` 可能是 `true`，那么对于现有的客户端来说可能是有些意外的， 因为从始至终，Endpoints 或 EndpointSlice API 从未包含处于终止中的端点。 出于这个原因，`ready` 对于处于终止中的端点 **总是** `false`， 并且在 v1.20 中添加了新的状况 `serving`，以便客户端可以独立于 `ready` 的现有语义来跟踪处于终止中的 Pod 的就绪情况。

###### Terminating（终止中）[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#terminating-%E7%BB%88%E6%AD%A2%E4%B8%AD)

**特性状态：** `Kubernetes v1.22 [beta]`

`Terminating` 是表示端点是否处于终止中的状况。 对于 Pod 来说，这是设置了删除时间戳的 Pod。

##### 拓扑信息[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#topology)

EndpointSlice 中的每个端点都可以包含一定的拓扑信息。 拓扑信息包括端点的位置，对应节点、可用区的信息。 这些信息体现为 EndpointSlices 的如下端点字段：

- `nodeName` - 端点所在的 Node 名称；
- `zone` - 端点所处的可用区。

**说明：**

在 v1 API 中，逐个端点设置的 `topology` 实际上被去除， 以鼓励使用专用的字段 `nodeName` 和 `zone`。

对 `EndpointSlice` 对象的 `endpoint` 字段设置任意的拓扑结构信息这一操作已被废弃， 不再被 v1 API 所支持。取而代之的是 v1 API 所支持的 `nodeName` 和 `zone` 这些独立的字段。这些字段可以在不同的 API 版本之间自动完成转译。 例如，v1beta1 API 中 `topology` 字段的 `topology.kubernetes.io/zone` 取值可以在 v1 API 中通过 `zone` 字段访问。

##### 管理[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#management)

通常，控制面（尤其是端点切片的[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)） 会创建和管理 EndpointSlice 对象。EndpointSlice 对象还有一些其他使用场景， 例如作为服务网格（Service Mesh）的实现。 这些场景都会导致有其他实体或者控制器负责管理额外的 EndpointSlice 集合。

为了确保多个实体可以管理 EndpointSlice 而且不会相互产生干扰， Kubernetes 定义了[标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/) `endpointslice.kubernetes.io/managed-by`，用来标明哪个实体在管理某个 EndpointSlice。 端点切片控制器会在自己所管理的所有 EndpointSlice 上将该标签值设置为 `endpointslice-controller.k8s.io`。 管理 EndpointSlice 的其他实体也应该为此标签设置一个唯一值。

##### 属主关系[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#ownership)

在大多数场合下，EndpointSlice 都由某个 Service 所有， （因为）该端点切片正是为该服务跟踪记录其端点。这一属主关系是通过为每个 EndpointSlice 设置一个属主（owner）引用，同时设置 `kubernetes.io/service-name` 标签来标明的， 目的是方便查找隶属于某 Service 的所有 EndpointSlice。

##### EndpointSlice 镜像[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#endpointslice-mirroring)

在某些场合，应用会创建定制的 Endpoints 资源。为了保证这些应用不需要并发的更改 Endpoints 和 EndpointSlice 资源，集群的控制面将大多数 Endpoints 映射到对应的 EndpointSlice 之上。

控制面对 Endpoints 资源进行映射的例外情况有：

- Endpoints 资源上标签 `endpointslice.kubernetes.io/skip-mirror` 值为 `true`。
- Endpoints 资源包含标签 `control-plane.alpha.kubernetes.io/leader`。
- 对应的 Service 资源不存在。
- 对应的 Service 的选择算符不为空。

每个 Endpoints 资源可能会被转译到多个 EndpointSlices 中去。 当 Endpoints 资源中包含多个子网或者包含多个 IP 协议族（IPv4 和 IPv6）的端点时， 就有可能发生这种状况。 每个子网最多有 1000 个地址会被镜像到 EndpointSlice 中。

##### EndpointSlices 的分布问题[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#distribution-of-endpointslices)

每个 EndpointSlice 都有一组端口值，适用于资源内的所有端点。 当为 Service 使用命名端口时，Pod 可能会就同一命名端口获得不同的端口号， 因而需要不同的 EndpointSlice。这有点像 Endpoints 用来对子网进行分组的逻辑。

控制面尝试尽量将 EndpointSlice 填满，不过不会主动地在若干 EndpointSlice 之间执行再平衡操作。这里的逻辑也是相对直接的：

1. 列举所有现有的 EndpointSlices，移除那些不再需要的端点并更新那些已经变化的端点。
2. 列举所有在第一步中被更改过的 EndpointSlices，用新增加的端点将其填满。
3. 如果还有新的端点未被添加进去，尝试将这些端点添加到之前未更改的切片中， 或者创建新切片。

这里比较重要的是，与在 EndpointSlice 之间完成最佳的分布相比，第三步中更看重限制 EndpointSlice 更新的操作次数。例如，如果有 10 个端点待添加，有两个 EndpointSlice 中各有 5 个空位，上述方法会创建一个新的 EndpointSlice 而不是将现有的两个 EndpointSlice 都填满。换言之，与执行多个 EndpointSlice 更新操作相比较， 方法会优先考虑执行一个 EndpointSlice 创建操作。

由于 kube-proxy 在每个节点上运行并监视 EndpointSlice 状态，EndpointSlice 的每次变更都变得相对代价较高，因为这些状态变化要传递到集群中每个节点上。 这一方法尝试限制要发送到所有节点上的变更消息个数，即使这样做可能会导致有多个 EndpointSlice 没有被填满。

在实践中，上面这种并非最理想的分布是很少出现的。大多数被 EndpointSlice 控制器处理的变更都是足够小的，可以添加到某已有 EndpointSlice 中去的。 并且，假使无法添加到已有的切片中，不管怎样都很快就会创建一个新的 EndpointSlice 对象。Deployment 的滚动更新为重新为 EndpointSlice 打包提供了一个自然的机会，所有 Pod 及其对应的端点在这一期间都会被替换掉。

##### 重复的端点[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#duplicate-endpoints)

由于 EndpointSlice 变化的自身特点，端点可能会同时出现在不止一个 EndpointSlice 中。鉴于不同的 EndpointSlice 对象在不同时刻到达 Kubernetes 的监视/缓存中， 这种情况的出现是很自然的。

**说明：**

EndpointSlice API 的客户端必须遍历与 Service 关联的所有现有 EndpointSlices， 并构建唯一网络端点的完整列表。值得一提的是端点可能在不同的 EndpointSlices 中重复。

你可以在 `kube-proxy` 中的 `EndpointSliceCache` 代码中找到有关如何执行此端点聚合和重复数据删除的参考实现。

#### 与 Endpoints 的比较[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#motivation)

原来的 Endpoints API 提供了在 Kubernetes 中跟踪网络端点的一种简单而直接的方法。随着 Kubernetes 集群和[服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)逐渐开始为更多的后端 Pod 处理和发送请求， 原来的 API 的局限性变得越来越明显。最明显的是那些因为要处理大量网络端点而带来的挑战。

由于任一 Service 的所有网络端点都保存在同一个 Endpoints 对象中，这些 Endpoints 对象可能变得非常巨大。对于保持稳定的服务（长时间使用同一组端点），影响不太明显； 即便如此，Kubernetes 的一些使用场景也没有得到很好的服务。

当某 Service 存在很多后端端点并且该工作负载频繁扩缩或上线新更改时，对该 Service 的单个 Endpoints 对象的每次更新都意味着（在控制平面内以及在节点和 API 服务器之间）Kubernetes 集群组件之间会出现大量流量。 这种额外的流量在 CPU 使用方面也有开销。

使用 EndpointSlices 时，添加或移除单个 Pod 对于正监视变更的客户端会触发相同数量的更新， 但这些更新消息的大小在大规模场景下要小得多。

EndpointSlices 还支持围绕双栈网络和拓扑感知路由等新功能的创新。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 遵循[使用 Service 连接到应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)教程
- 阅读 EndpointSlice API 的 [API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/endpoint-slice-v1/)
- 阅读 Endpoints API 的 [API 参考](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/endpoints-v1/)
### [Ingress 控制器](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/)

为了让 [Ingress](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/) 在你的集群中工作， 必须有一个 Ingress 控制器正在运行。你需要选择至少一个 Ingress 控制器并确保其已被部署到你的集群中。 本页列出了你可以部署的常见 Ingress 控制器。
为了让 Ingress 资源工作，集群必须有一个正在运行的 Ingress 控制器。

与作为 `kube-controller-manager` 可执行文件的一部分运行的其他类型的控制器不同， Ingress 控制器不是随集群自动启动的。 基于此页面，你可选择最适合你的集群的 ingress 控制器实现。

Kubernetes 作为一个项目，目前支持和维护 [AWS](https://github.com/kubernetes-sigs/aws-load-balancer-controller#readme)、 [GCE](https://git.k8s.io/ingress-gce/README.md#readme) 和 [Nginx](https://git.k8s.io/ingress-nginx/README.md#readme) Ingress 控制器。

#### 其他控制器[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/#%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8)

**说明：** 本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循[CNCF 网站指南](https://github.com/cncf/foundation/blob/master/website-guidelines.md)，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读[内容指南](https://kubernetes.io/docs/contribute/style/content-guide/#third-party-content)。

- [AKS 应用程序网关 Ingress 控制器](https://docs.microsoft.com/zh-cn/azure/application-gateway/tutorial-ingress-controller-add-on-existing?toc=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Faks%2Ftoc.json&bc=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Fbread%2Ftoc.json) 是一个配置 [Azure 应用程序网关](https://docs.microsoft.com/zh-cn/azure/application-gateway/overview) 的 Ingress 控制器。
- [Ambassador](https://www.getambassador.io/) API 网关是一个基于 [Envoy](https://www.envoyproxy.io/) 的 Ingress 控制器。
- [Apache APISIX Ingress 控制器](https://github.com/apache/apisix-ingress-controller) 是一个基于 [Apache APISIX 网关](https://github.com/apache/apisix) 的 Ingress 控制器。
- [Avi Kubernetes Operator](https://github.com/vmware/load-balancer-and-ingress-services-for-kubernetes) 使用 [VMware NSX Advanced Load Balancer](https://avinetworks.com/) 提供第 4 到第 7 层的负载均衡。

- [BFE Ingress 控制器](https://github.com/bfenetworks/ingress-bfe)是一个基于 [BFE](https://www.bfe-networks.net/) 的 Ingress 控制器。
- [Citrix Ingress 控制器](https://github.com/citrix/citrix-k8s-ingress-controller#readme) 可以用来与 Citrix Application Delivery Controller 一起使用。
- [Contour](https://projectcontour.io/) 是一个基于 [Envoy](https://www.envoyproxy.io/) 的 Ingress 控制器。
- [EnRoute](https://getenroute.io/) 是一个基于 [Envoy](https://www.envoyproxy.io/) 的 API 网关，可以用作 Ingress 控制器。
- [Easegress IngressController](https://github.com/megaease/easegress/blob/main/doc/reference/ingresscontroller.md) 是一个基于 [Easegress](https://megaease.com/easegress/) 的 API 网关，可以用作 Ingress 控制器。

- F5 BIG-IP 的 [用于 Kubernetes 的容器 Ingress 服务](https://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest) 让你能够使用 Ingress 来配置 F5 BIG-IP 虚拟服务器。
- [Gloo](https://gloo.solo.io/) 是一个开源的、基于 [Envoy](https://www.envoyproxy.io/) 的 Ingress 控制器，能够提供 API 网关功能。
- [HAProxy Ingress](https://haproxy-ingress.github.io/) 是一个针对 [HAProxy](https://www.haproxy.org/#desc) 的 Ingress 控制器。
- [用于 Kubernetes 的 HAProxy Ingress 控制器](https://github.com/haproxytech/kubernetes-ingress#readme) 也是一个针对 [HAProxy](https://www.haproxy.org/#desc) 的 Ingress 控制器。
- [Istio Ingress](https://istio.io/latest/zh/docs/tasks/traffic-management/ingress/kubernetes-ingress/) 是一个基于 [Istio](https://istio.io/zh/) 的 Ingress 控制器。

- [用于 Kubernetes 的 Kong Ingress 控制器](https://github.com/Kong/kubernetes-ingress-controller#readme) 是一个用来驱动 [Kong Gateway](https://konghq.com/kong/) 的 Ingress 控制器。
- [Kusk Gateway](https://kusk.kubeshop.io/) 是一个基于 [Envoy](https://www.envoyproxy.io/) 的、 OpenAPI 驱动的 Ingress 控制器。
- [用于 Kubernetes 的 NGINX Ingress 控制器](https://www.nginx.com/products/nginx-ingress-controller/) 能够与 [NGINX](https://www.nginx.com/resources/glossary/nginx/) 网页服务器（作为代理）一起使用。
- [Pomerium Ingress 控制器](https://www.pomerium.com/docs/k8s/ingress.html) 基于 [Pomerium](https://pomerium.com/)，能提供上下文感知的准入策略。
- [Skipper](https://opensource.zalando.com/skipper/kubernetes/ingress-controller/) HTTP 路由器和反向代理可用于服务组装，支持包括 Kubernetes Ingress 这类使用场景，是一个用以构造你自己的定制代理的库。

- [Traefik Kubernetes Ingress 提供程序](https://doc.traefik.io/traefik/providers/kubernetes-ingress/) 是一个用于 [Traefik](https://traefik.io/traefik/) 代理的 Ingress 控制器。
- [Tyk Operator](https://github.com/TykTechnologies/tyk-operator) 使用自定义资源扩展 Ingress，为之带来 API 管理能力。Tyk Operator 使用开源的 Tyk Gateway & Tyk Cloud 控制面。
- [Voyager](https://appscode.com/products/voyager) 是一个针对 [HAProxy](https://www.haproxy.org/#desc) 的 Ingress 控制器。
- [Wallarm Ingress Controller](https://www.wallarm.com/solutions/waf-for-kubernetes) 是提供 WAAP（WAF） 和 API 安全功能的 Ingress Controller。

#### 使用多个 Ingress 控制器[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress-controllers/#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-ingress-%E6%8E%A7%E5%88%B6%E5%99%A8)

你可以使用 [Ingress 类](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#ingress-class)在集群中部署任意数量的 Ingress 控制器。 请注意你的 Ingress 类资源的 `.metadata.name` 字段。 当你创建 Ingress 时，你需要用此字段的值来设置 Ingress 对象的 `ingressClassName` 字段（请参考 [IngressSpec v1 reference](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/service-resources/ingress-v1/#IngressSpec)）。 `ingressClassName` 是之前的[注解](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#deprecated-annotation)做法的替代。

如果你不为 Ingress 指定 IngressClass，并且你的集群中只有一个 IngressClass 被标记为默认，那么 Kubernetes 会将此集群的默认 IngressClass [应用](https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/#default-ingress-class)到 Ingress 上。 IngressClass。 你可以通过将 [`ingressclass.kubernetes.io/is-default-class` 注解](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#ingressclass-kubernetes-io-is-default-class) 的值设置为 `"true"` 来将一个 IngressClass 标记为集群默认。

理想情况下，所有 Ingress 控制器都应满足此规范，但各种 Ingress 控制器的操作略有不同。

**说明：** 确保你查看了 ingress 控制器的文档，以了解选择它的注意事项。
### [网络策略](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/)

如果你希望在 IP 地址或端口层面（OSI 第 3 层或第 4 层）控制网络流量， NetworkPolicy 可以让你为集群内以及 Pod 与外界之间的网络流量指定规则。 你的集群必须使用支持 NetworkPolicy 实施的网络插件。
如果你希望在 IP 地址或端口层面（OSI 第 3 层或第 4 层）控制网络流量， 则你可以考虑为集群中特定应用使用 Kubernetes 网络策略（NetworkPolicy）。 NetworkPolicy 是一种以应用为中心的结构，允许你设置如何允许 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 与网络上的各类网络“实体” （我们这里使用实体以避免过度使用诸如“端点”和“服务”这类常用术语， 这些术语在 Kubernetes 中有特定含义）通信。 NetworkPolicy 适用于一端或两端与 Pod 的连接，与其他连接无关。

Pod 可以通信的 Pod 是通过如下三个标识符的组合来辩识的：

1. 其他被允许的 Pods（例外：Pod 无法阻塞对自身的访问）
2. 被允许的名字空间
3. IP 组块（例外：与 Pod 运行所在的节点的通信总是被允许的， 无论 Pod 或节点的 IP 地址）

在定义基于 Pod 或名字空间的 NetworkPolicy 时， 你会使用[选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/)来设定哪些流量可以进入或离开与该算符匹配的 Pod。 另外，当创建基于 IP 的 NetworkPolicy 时，我们基于 IP 组块（CIDR 范围）来定义策略。

#### 前置条件[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#prerequisites)

网络策略通过[网络插件](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)来实现。 要使用网络策略，你必须使用支持 NetworkPolicy 的网络解决方案。 创建一个 NetworkPolicy 资源对象而没有控制器来使它生效的话，是没有任何作用的。

#### Pod 隔离的两种类型[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#the-two-sorts-of-pod-isolation)

Pod 有两种隔离: 出口的隔离和入口的隔离。它们涉及到可以建立哪些连接。 这里的“隔离”不是绝对的，而是意味着“有一些限制”。 另外的，“非隔离方向”意味着在所述方向上没有限制。这两种隔离（或不隔离）是独立声明的， 并且都与从一个 Pod 到另一个 Pod 的连接有关。

默认情况下，一个 Pod 的出口是非隔离的，即所有外向连接都是被允许的。如果有任何的 NetworkPolicy 选择该 Pod 并在其 `policyTypes` 中包含 “Egress”，则该 Pod 是出口隔离的， 我们称这样的策略适用于该 Pod 的出口。当一个 Pod 的出口被隔离时， 唯一允许的来自 Pod 的连接是适用于出口的 Pod 的某个 NetworkPolicy 的 `egress` 列表所允许的连接。 这些 `egress` 列表的效果是相加的。

默认情况下，一个 Pod 对入口是非隔离的，即所有入站连接都是被允许的。如果有任何的 NetworkPolicy 选择该 Pod 并在其 `policyTypes` 中包含 “Ingress”，则该 Pod 被隔离入口， 我们称这种策略适用于该 Pod 的入口。当一个 Pod 的入口被隔离时，唯一允许进入该 Pod 的连接是来自该 Pod 节点的连接和适用于入口的 Pod 的某个 NetworkPolicy 的 `ingress` 列表所允许的连接。这些 `ingress` 列表的效果是相加的。

网络策略是相加的，所以不会产生冲突。如果策略适用于 Pod 某一特定方向的流量， Pod 在对应方向所允许的连接是适用的网络策略所允许的集合。 因此，评估的顺序不影响策略的结果。

要允许从源 Pod 到目的 Pod 的连接，源 Pod 的出口策略和目的 Pod 的入口策略都需要允许连接。 如果任何一方不允许连接，建立连接将会失败。

#### NetworkPolicy 资源[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#networkpolicy-resource)

参阅 [NetworkPolicy](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#networkpolicy-v1-networking-k8s-io) 来了解资源的完整定义。

下面是一个 NetworkPolicy 的示例:

[`service/networking/networkpolicy.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/networkpolicy.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/networkpolicy.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: test-network-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - ipBlock:
            cidr: 172.17.0.0/16
            except:
              - 172.17.1.0/24
        - namespaceSelector:
            matchLabels:
              project: myproject
        - podSelector:
            matchLabels:
              role: frontend
      ports:
        - protocol: TCP
          port: 6379
  egress:
    - to:
        - ipBlock:
            cidr: 10.0.0.0/24
      ports:
        - protocol: TCP
          port: 5978

```

**说明：**

除非选择支持网络策略的网络解决方案，否则将上述示例发送到API服务器没有任何效果。

**必需字段**：与所有其他的 Kubernetes 配置一样，NetworkPolicy 需要 `apiVersion`、 `kind` 和 `metadata` 字段。关于配置文件操作的一般信息， 请参考[配置 Pod 以使用 ConfigMap](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/) 和[对象管理](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/object-management)。

**spec**：NetworkPolicy [规约](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status) 中包含了在一个名字空间中定义特定网络策略所需的所有信息。

**podSelector**：每个 NetworkPolicy 都包括一个 `podSelector`， 它对该策略所适用的一组 Pod 进行选择。示例中的策略选择带有 "role=db" 标签的 Pod。 空的 `podSelector` 选择名字空间下的所有 Pod。

**policyTypes**：每个 NetworkPolicy 都包含一个 `policyTypes` 列表，其中包含 `Ingress` 或 `Egress` 或两者兼具。`policyTypes` 字段表示给定的策略是应用于进入所选 Pod 的入站流量还是来自所选 Pod 的出站流量，或两者兼有。 如果 NetworkPolicy 未指定 `policyTypes` 则默认情况下始终设置 `Ingress`； 如果 NetworkPolicy 有任何出口规则的话则设置 `Egress`。

**ingress**：每个 NetworkPolicy 可包含一个 `ingress` 规则的白名单列表。 每个规则都允许同时匹配 `from` 和 `ports` 部分的流量。示例策略中包含一条简单的规则： 它匹配某个特定端口，来自三个来源中的一个，第一个通过 `ipBlock` 指定，第二个通过 `namespaceSelector` 指定，第三个通过 `podSelector` 指定。

**egress**：每个 NetworkPolicy 可包含一个 `egress` 规则的白名单列表。 每个规则都允许匹配 `to` 和 `port` 部分的流量。该示例策略包含一条规则， 该规则将指定端口上的流量匹配到 `10.0.0.0/24` 中的任何目的地。

所以，该网络策略示例:

1. 隔离 `default` 名字空间下 `role=db` 的 Pod （如果它们不是已经被隔离的话）。
    
2. （Ingress 规则）允许以下 Pod 连接到 `default` 名字空间下的带有 `role=db` 标签的所有 Pod 的 6379 TCP 端口：
    
    - `default` 名字空间下带有 `role=frontend` 标签的所有 Pod
    - 带有 `project=myproject` 标签的所有名字空间中的 Pod
    - IP 地址范围为 172.17.0.0–172.17.0.255 和 172.17.2.0–172.17.255.255 （即，除了 172.17.1.0/24 之外的所有 172.17.0.0/16）
3. （Egress 规则）允许 `default` 名字空间中任何带有标签 `role=db` 的 Pod 到 CIDR 10.0.0.0/24 下 5978 TCP 端口的连接。
    

参阅[声明网络策略](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/declare-network-policy/)演练了解更多示例。

#### 选择器 `to` 和 `from` 的行为[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#behavior-of-to-and-from-selectors)

可以在 `ingress` 的 `from` 部分或 `egress` 的 `to` 部分中指定四种选择器：

**podSelector**：此选择器将在与 NetworkPolicy 相同的名字空间中选择特定的 Pod，应将其允许作为入站流量来源或出站流量目的地。

**namespaceSelector**：此选择器将选择特定的名字空间，应将所有 Pod 用作其入站流量来源或出站流量目的地。

**namespaceSelector 和 podSelector**：一个指定 `namespaceSelector` 和 `podSelector` 的 `to`/`from` 条目选择特定名字空间中的特定 Pod。 注意使用正确的 YAML 语法；下面的策略：

```yaml
  ...
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          user: alice
      podSelector:
        matchLabels:
          role: client
  ...
```

此策略在 `from` 数组中仅包含一个元素，只允许来自标有 `role=client` 的 Pod 且该 Pod 所在的名字空间中标有 `user=alice` 的连接。但是 **这项** 策略：

```yaml
  ...
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          user: alice
    - podSelector:
        matchLabels:
          role: client
  ...
```

它在 `from` 数组中包含两个元素，允许来自本地名字空间中标有 `role=client` 的 Pod 的连接，**或** 来自任何名字空间中标有 `user=alice` 的任何 Pod 的连接。

如有疑问，请使用 `kubectl describe` 查看 Kubernetes 如何解释该策略。

**ipBlock**：此选择器将选择特定的 IP CIDR 范围以用作入站流量来源或出站流量目的地。 这些应该是集群外部 IP，因为 Pod IP 存在时间短暂的且随机产生。

集群的入站和出站机制通常需要重写数据包的源 IP 或目标 IP。 在发生这种情况时，不确定在 NetworkPolicy 处理之前还是之后发生， 并且对于网络插件、云提供商、`Service` 实现等的不同组合，其行为可能会有所不同。

对入站流量而言，这意味着在某些情况下，你可以根据实际的原始源 IP 过滤传入的数据包， 而在其他情况下，NetworkPolicy 所作用的 `源IP` 则可能是 `LoadBalancer` 或 Pod 的节点等。

对于出站流量而言，这意味着从 Pod 到被重写为集群外部 IP 的 `Service` IP 的连接可能会或可能不会受到基于 `ipBlock` 的策略的约束。

#### 默认策略[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#default-policies)

默认情况下，如果名字空间中不存在任何策略，则所有进出该名字空间中 Pod 的流量都被允许。 以下示例使你可以更改该名字空间中的默认行为。

##### 默认拒绝所有入站流量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-traffic)

你可以通过创建选择所有容器但不允许任何进入这些容器的入站流量的 NetworkPolicy 来为名字空间创建 “default” 隔离策略。

[`service/networking/network-policy-default-deny-ingress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/network-policy-default-deny-ingress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
spec:
  podSelector: {}
  policyTypes:
  - Ingress
```

这确保即使没有被任何其他 NetworkPolicy 选择的 Pod 仍将被隔离以进行入口。 此策略不影响任何 Pod 的出口隔离。

##### 允许所有入站流量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#allow-all-ingress-traffic)

如果你想允许一个名字空间中所有 Pod 的所有入站连接，你可以创建一个明确允许的策略。

[`service/networking/network-policy-allow-all-ingress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/network-policy-allow-all-ingress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all-ingress
spec:
  podSelector: {}
  ingress:
  - {}
  policyTypes:
  - Ingress
```

有了这个策略，任何额外的策略都不会导致到这些 Pod 的任何入站连接被拒绝。 此策略对任何 Pod 的出口隔离没有影响。

##### 默认拒绝所有出站流量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic)

你可以通过创建选择所有容器但不允许来自这些容器的任何出站流量的 NetworkPolicy 来为名字空间创建 “default” 隔离策略。

[`service/networking/network-policy-default-deny-egress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/network-policy-default-deny-egress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/network-policy-default-deny-egress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-egress
spec:
  podSelector: {}
  policyTypes:
  - Egress
```

此策略可以确保即使没有被其他任何 NetworkPolicy 选择的 Pod 也不会被允许流出流量。 此策略不会更改任何 Pod 的入站流量隔离行为。

##### 允许所有出站流量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#allow-all-egress-traffic)

如果要允许来自名字空间中所有 Pod 的所有连接， 则可以创建一个明确允许来自该名字空间中 Pod 的所有出站连接的策略。

[`service/networking/network-policy-allow-all-egress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/network-policy-allow-all-egress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/network-policy-allow-all-egress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all-egress
spec:
  podSelector: {}
  egress:
  - {}
  policyTypes:
  - Egress
```

有了这个策略，任何额外的策略都不会导致来自这些 Pod 的任何出站连接被拒绝。 此策略对进入任何 Pod 的隔离没有影响。

##### 默认拒绝所有入站和所有出站流量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-and-all-egress-traffic)

你可以为名字空间创建“默认”策略，以通过在该名字空间中创建以下 NetworkPolicy 来阻止所有入站和出站流量。

[`service/networking/network-policy-default-deny-all.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/network-policy-default-deny-all.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/network-policy-default-deny-all.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
```

此策略可以确保即使没有被其他任何 NetworkPolicy 选择的 Pod 也不会被允许入站或出站流量。

#### SCTP 支持[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#sctp-support)

**特性状态：** `Kubernetes v1.20 [stable]`

作为一个稳定特性，SCTP 支持默认是被启用的。 要在集群层面禁用 SCTP，你（或你的集群管理员）需要为 API 服务器指定 `--feature-gates=SCTPSupport=false,...` 来禁用 `SCTPSupport` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。 启用该特性门控后，用户可以将 NetworkPolicy 的 `protocol` 字段设置为 `SCTP`。

**说明：**

你必须使用支持 SCTP 协议 NetworkPolicy 的 [CNI](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) 插件。

#### 针对某个端口范围[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#targeting-a-range-of-ports)

**特性状态：** `Kubernetes v1.25 [stable]`

在编写 NetworkPolicy 时，你可以针对一个端口范围而不是某个固定端口。

这一目的可以通过使用 `endPort` 字段来实现，如下例所示：

[`service/networking/networkpolicy-multiport-egress.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/networkpolicy-multiport-egress.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/networkpolicy-multiport-egress.yaml to clipboard")

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: multi-port-egress
  namespace: default
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:
    - Egress
  egress:
    - to:
        - ipBlock:
            cidr: 10.0.0.0/24
      ports:
        - protocol: TCP
          port: 32000
          endPort: 32768

```

上面的规则允许名字空间 `default` 中所有带有标签 `role=db` 的 Pod 使用 TCP 协议与 `10.0.0.0/24` 范围内的 IP 通信，只要目标端口介于 32000 和 32768 之间就可以。

使用此字段时存在以下限制：

- `endPort` 字段必须等于或者大于 `port` 字段的值。
- 只有在定义了 `port` 时才能定义 `endPort`。
- 两个字段的设置值都只能是数字。

**说明：**

你的集群所使用的 [CNI](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) 插件必须支持在 NetworkPolicy 规约中使用 `endPort` 字段。 如果你的[网络插件](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)不支持 `endPort` 字段，而你指定了一个包含 `endPort` 字段的 NetworkPolicy， 策略只对单个 `port` 字段生效。

#### 基于名字指向某名字空间[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#targeting-a-namespace-by-its-name)

**特性状态：** `Kubernetes 1.22 [stable]`

只要 `NamespaceDefaultLabelName` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)被启用， Kubernetes 控制面会在所有名字空间上设置一个不可变更的标签 `kubernetes.io/metadata.name`。该标签的值是名字空间的名称。

如果 NetworkPolicy 无法在某些对象字段中指向某名字空间， 你可以使用标准的标签方式来指向特定名字空间。

#### 通过网络策略（至少目前还）无法完成的工作[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#what-you-can-t-do-with-network-policies-at-least-not-yet)

到 Kubernetes 1.26 为止，NetworkPolicy API 还不支持以下功能， 不过你可能可以使用操作系统组件（如 SELinux、OpenVSwitch、IPTables 等等） 或者第七层技术（Ingress 控制器、服务网格实现）或准入控制器来实现一些替代方案。 如果你对 Kubernetes 中的网络安全性还不太了解，了解使用 NetworkPolicy API 还无法实现下面的用户场景是很值得的。

- 强制集群内部流量经过某公用网关（这种场景最好通过服务网格或其他代理来实现）；
- 与 TLS 相关的场景（考虑使用服务网格或者 Ingress 控制器）；
- 特定于节点的策略（你可以使用 CIDR 来表达这一需求不过你无法使用节点在 Kubernetes 中的其他标识信息来辩识目标节点）；
- 基于名字来选择服务（不过，你可以使用 [标签](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/) 来选择目标 Pod 或名字空间，这也通常是一种可靠的替代方案）；
- 创建或管理由第三方来实际完成的“策略请求”；

- 实现适用于所有名字空间或 Pods 的默认策略（某些第三方 Kubernetes 发行版本或项目可以做到这点）；
- 高级的策略查询或者可达性相关工具；
- 生成网络安全事件日志的能力（例如，被阻塞或接收的连接请求）；
- 显式地拒绝策略的能力（目前，NetworkPolicy 的模型默认采用拒绝操作， 其唯一的能力是添加允许策略）；
- 禁止本地回路或指向宿主的网络流量（Pod 目前无法阻塞 localhost 访问， 它们也无法禁止来自所在节点的访问请求）。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/network-policies/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 参阅[声明网络策略](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/declare-network-policy/)演练了解更多示例；
- 有关 NetworkPolicy 资源所支持的常见场景的更多信息， 请参见[此指南](https://github.com/ahmetb/kubernetes-network-policy-recipes)。

### [Service 与 Pod 的 DNS](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/)

你的工作负载可以使用 DNS 发现集群内的 Service，本页说明具体工作原理。
Kubernetes 为 Service 和 Pod 创建 DNS 记录。 你可以使用一致的 DNS 名称而非 IP 地址访问 Service。

Kubernetes 发布有关 Pod 和 Service 的信息，这些信息被用来对 DNS 进行编程。 Kubelet 配置 Pod 的 DNS，以便运行中的容器可以通过名称而不是 IP 来查找服务。

集群中定义的 Service 被赋予 DNS 名称。 默认情况下，客户端 Pod 的 DNS 搜索列表会包含 Pod 自身的名字空间和集群的默认域。

##### Service 的名字空间[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#namespaces-of-services)

DNS 查询可能因为执行查询的 Pod 所在的名字空间而返回不同的结果。 不指定名字空间的 DNS 查询会被限制在 Pod 所在的名字空间内。 要访问其他名字空间中的 Service，需要在 DNS 查询中指定名字空间。

例如，假定名字空间 `test` 中存在一个 Pod，`prod` 名字空间中存在一个服务 `data`。

Pod 查询 `data` 时没有返回结果，因为使用的是 Pod 的名字空间 `test`。

Pod 查询 `data.prod` 时则会返回预期的结果，因为查询中指定了名字空间。

DNS 查询可以使用 Pod 中的 `/etc/resolv.conf` 展开。 Kubelet 为每个 Pod 配置此文件。 例如，对 `data` 的查询可能被展开为 `data.test.svc.cluster.local`。 `search` 选项的取值会被用来展开查询。要进一步了解 DNS 查询，可参阅 [`resolv.conf` 手册页面](https://www.man7.org/linux/man-pages/man5/resolv.conf.5.html)。

```
nameserver 10.32.0.10
search <namespace>.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
```

概括起来，名字空间 _test_ 中的 Pod 可以成功地解析 `data.prod` 或者 `data.prod.svc.cluster.local`。

##### DNS 记录[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#dns-records)

哪些对象会获得 DNS 记录呢？

1. Services
2. Pods

以下各节详细介绍已支持的 DNS 记录类型和布局。 其它布局、名称或者查询即使碰巧可以工作，也应视为实现细节， 将来很可能被更改而且不会因此发出警告。 有关最新规范请查看 [Kubernetes 基于 DNS 的服务发现](https://github.com/kubernetes/dns/blob/master/docs/specification.md)。

##### Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#service)

###### A/AAAA 记录[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#a-aaaa-records)

除了无头 Service 之外的 “普通” Service 会被赋予一个形如 `my-svc.my-namespace.svc.cluster-domain.example` 的 DNS A 和/或 AAAA 记录，取决于 Service 的 IP 协议族（可能有多个）设置。 该名称会解析成对应 Service 的集群 IP。

没有集群 IP 的[无头 Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services) 也会被赋予一个形如 `my-svc.my-namespace.svc.cluster-domain.example` 的 DNS A 和/或 AAAA 记录。 与普通 Service 不同，这一记录会被解析成对应 Service 所选择的 Pod IP 的集合。 客户端要能够使用这组 IP，或者使用标准的轮转策略从这组 IP 中进行选择。

###### SRV 记录[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#srv-records)

Kubernetes 根据普通 Service 或无头 Service 中的命名端口创建 SRV 记录。每个命名端口， SRV 记录格式为 `_port-name._port-protocol.my-svc.my-namespace.svc.cluster-domain.example`。 普通 Service，该记录会被解析成端口号和域名：`my-svc.my-namespace.svc.cluster-domain.example`。 无头 Service，该记录会被解析成多个结果，及该服务的每个后端 Pod 各一个 SRV 记录， 其中包含 Pod 端口号和格式为 `hostname.my-svc.my-namespace.svc.cluster-domain.example` 的域名。

#### Pod[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod)

##### A/AAAA 记录[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#a-aaaa-records)

一般而言，Pod 会对应如下 DNS 名字解析：

`pod-ip-address.my-namespace.pod.cluster-domain.example`

例如，对于一个位于 `default` 名字空间，IP 地址为 172.17.0.3 的 Pod， 如果集群的域名为 `cluster.local`，则 Pod 会对应 DNS 名称：

`172-17-0-3.default.pod.cluster.local`

通过 Service 暴露出来的所有 Pod 都会有如下 DNS 解析名称可用：

`pod-ip-address.service-name.my-namespace.svc.cluster-domain.example`

##### Pod 的 hostname 和 subdomain 字段[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod-s-hostname-and-subdomain-fields)

当前，创建 Pod 时其主机名（从 Pod 内部观察）取自 Pod 的 `metadata.name` 值。

Pod 规约中包含一个可选的 `hostname` 字段，可以用来指定一个不同的主机名。 当这个字段被设置时，它将优先于 Pod 的名字成为该 Pod 的主机名（同样是从 Pod 内部观察）。 举个例子，给定一个 `spec.hostname` 设置为 `“my-host”` 的 Pod， 该 Pod 的主机名将被设置为 `“my-host”`。

Pod 规约还有一个可选的 `subdomain` 字段，可以用来表明该 Pod 是名字空间的子组的一部分。 举个例子，某 Pod 的 `spec.hostname` 设置为 `“foo”`，`spec.subdomain` 设置为 `“bar”`， 在名字空间 `“my-namespace”` 中，主机名称被设置成 `“foo”` 并且对应的完全限定域名（FQDN）为 “`foo.bar.my-namespace.svc.cluster-domain.example`”（还是从 Pod 内部观察）。

如果 Pod 所在的名字空间中存在一个无头服务，其名称与子域相同， 则集群的 DNS 服务器还会为 Pod 的完全限定主机名返回 A 和/或 AAAA 记录。

示例：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: busybox-subdomain
spec:
  selector:
    name: busybox
  clusterIP: None
  ports:
  - name: foo # 实际上不需要指定端口号
    port: 1234
---
apiVersion: v1
kind: Pod
metadata:
  name: busybox1
  labels:
    name: busybox
spec:
  hostname: busybox-1
  subdomain: busybox-subdomain
  containers:
  - image: busybox:1.28
    command:
      - sleep
      - "3600"
    name: busybox
---
apiVersion: v1
kind: Pod
metadata:
  name: busybox2
  labels:
    name: busybox
spec:
  hostname: busybox-2
  subdomain: busybox-subdomain
  containers:
  - image: busybox:1.28
    command:
      - sleep
      - "3600"
    name: busybox
```

鉴于上述服务 `“busybox-subdomain”` 和将 `spec.subdomain` 设置为 `“busybox-subdomain”` 的 Pod， 第一个 Pod 将看到自己的 FQDN 为 `“busybox-1.busybox-subdomain.my-namespace.svc.cluster-domain.example”`。 DNS 会为此名字提供一个 A 记录和/或 AAAA 记录，指向该 Pod 的 IP。 Pod “`busybox1`” 和 “`busybox2`” 都将有自己的地址记录。

[EndpointSlice](https://kubernetes.io/zh-cn/docs/concepts/services-networking/endpoint-slices/) 对象可以为任何端点地址及其 IP 指定 `hostname`。

**说明：** 由于 A 和 AAAA 记录不是基于 Pod 名称创建，因此需要设置了 `hostname` 才会生成 Pod 的 A 或 AAAA 记录。 没有设置 `hostname` 但设置了 `subdomain` 的 Pod 只会为 无头 Service 创建 A 或 AAAA 记录（`busybox-subdomain.my-namespace.svc.cluster-domain.example`） 指向 Pod 的 IP 地址。 另外，除非在服务上设置了 `publishNotReadyAddresses=True`，否则只有 Pod 准备就绪 才会有与之对应的记录。

##### Pod 的 setHostnameAsFQDN 字段[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod-sethostnameasfqdn-field)

**特性状态：** `Kubernetes v1.22 [stable]`

当 Pod 配置为具有全限定域名 (FQDN) 时，其主机名是短主机名。 例如，如果你有一个具有完全限定域名 `busybox-1.busybox-subdomain.my-namespace.svc.cluster-domain.example` 的 Pod， 则默认情况下，该 Pod 内的 `hostname` 命令返回 `busybox-1`，而 `hostname --fqdn` 命令返回 FQDN。

当你在 Pod 规约中设置了 `setHostnameAsFQDN: true` 时，kubelet 会将 Pod 的全限定域名（FQDN）作为该 Pod 的主机名记录到 Pod 所在名字空间。 在这种情况下，`hostname` 和 `hostname --fqdn` 都会返回 Pod 的全限定域名。

**说明：**

在 Linux 中，内核的主机名字段（`struct utsname` 的 `nodename` 字段）限定最多 64 个字符。

如果 Pod 启用这一特性，而其 FQDN 超出 64 字符，Pod 的启动会失败。 Pod 会一直出于 `Pending` 状态（通过 `kubectl` 所看到的 `ContainerCreating`）， 并产生错误事件，例如 "Failed to construct FQDN from Pod hostname and cluster domain, FQDN `long-FQDN` is too long (64 characters is the max, 70 characters requested)." （无法基于 Pod 主机名和集群域名构造 FQDN，FQDN `long-FQDN` 过长，至多 64 个字符，请求字符数为 70）。 对于这种场景而言，改善用户体验的一种方式是创建一个 [准入 Webhook 控制器](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks)， 在用户创建顶层对象（如 Deployment）的时候控制 FQDN 的长度。

##### Pod 的 DNS 策略[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy)

DNS 策略可以逐个 Pod 来设定。目前 Kubernetes 支持以下特定 Pod 的 DNS 策略。 这些策略可以在 Pod 规约中的 `dnsPolicy` 字段设置：

- "`Default`": Pod 从运行所在的节点继承名称解析配置。 参考[相关讨论](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/dns-custom-nameservers)获取更多信息。
- "`ClusterFirst`": 与配置的集群域后缀不匹配的任何 DNS 查询（例如 "www.kubernetes.io"） 都会由 DNS 服务器转发到上游名称服务器。集群管理员可能配置了额外的存根域和上游 DNS 服务器。 参阅[相关讨论](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/dns-custom-nameservers) 了解在这些场景中如何处理 DNS 查询的信息。
- "`ClusterFirstWithHostNet`": 对于以 hostNetwork 方式运行的 Pod，应将其 DNS 策略显式设置为 "`ClusterFirstWithHostNet`"。否则，以 hostNetwork 方式和 `"ClusterFirst"` 策略运行的 Pod 将会做出回退至 `"Default"` 策略的行为。
    - 注意：这在 Windows 上不支持。 有关详细信息，请参见[下文](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#dns-windows)。
- "`None`": 此设置允许 Pod 忽略 Kubernetes 环境中的 DNS 设置。Pod 会使用其 `dnsConfig` 字段所提供的 DNS 设置。 参见 [Pod 的 DNS 配置](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod-dns-config)节。

**说明：**

"Default" 不是默认的 DNS 策略。如果未明确指定 `dnsPolicy`，则使用 "ClusterFirst"。

下面的示例显示了一个 Pod，其 DNS 策略设置为 "`ClusterFirstWithHostNet`"， 因为它已将 `hostNetwork` 设置为 `true`。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: busybox
  namespace: default
spec:
  containers:
  - image: busybox:1.28
    command:
      - sleep
      - "3600"
    imagePullPolicy: IfNotPresent
    name: busybox
  restartPolicy: Always
  hostNetwork: true
  dnsPolicy: ClusterFirstWithHostNet
```

##### Pod 的 DNS 配置[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#pod-dns-config)

**特性状态：** `Kubernetes v1.14 [stable]`

Pod 的 DNS 配置可让用户对 Pod 的 DNS 设置进行更多控制。

`dnsConfig` 字段是可选的，它可以与任何 `dnsPolicy` 设置一起使用。 但是，当 Pod 的 `dnsPolicy` 设置为 "`None`" 时，必须指定 `dnsConfig` 字段。

用户可以在 `dnsConfig` 字段中指定以下属性：

- `nameservers`：将用作于 Pod 的 DNS 服务器的 IP 地址列表。 最多可以指定 3 个 IP 地址。当 Pod 的 `dnsPolicy` 设置为 "`None`" 时， 列表必须至少包含一个 IP 地址，否则此属性是可选的。 所列出的服务器将合并到从指定的 DNS 策略生成的基本名称服务器，并删除重复的地址。
    
- `searches`：用于在 Pod 中查找主机名的 DNS 搜索域的列表。此属性是可选的。 指定此属性时，所提供的列表将合并到根据所选 DNS 策略生成的基本搜索域名中。 重复的域名将被删除。Kubernetes 最多允许 6 个搜索域。
    
- `options`：可选的对象列表，其中每个对象可能具有 `name` 属性（必需）和 `value` 属性（可选）。 此属性中的内容将合并到从指定的 DNS 策略生成的选项。 重复的条目将被删除。
    

以下是具有自定义 DNS 设置的 Pod 示例：

[`service/networking/custom-dns.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/custom-dns.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/custom-dns.yaml to clipboard")

```yaml
apiVersion: v1
kind: Pod
metadata:
  namespace: default
  name: dns-example
spec:
  containers:
    - name: test
      image: nginx
  dnsPolicy: "None"
  dnsConfig:
    nameservers:
      - 192.0.2.1 # 这是一个示例
    searches:
      - ns1.svc.cluster-domain.example
      - my.dns.search.suffix
    options:
      - name: ndots
        value: "2"
      - name: edns0
```

创建上面的 Pod 后，容器 `test` 会在其 `/etc/resolv.conf` 文件中获取以下内容：

```
nameserver 192.0.2.1
search ns1.svc.cluster-domain.example my.dns.search.suffix
options ndots:2 edns0
```

对于 IPv6 设置，搜索路径和名称服务器应按以下方式设置：

```shell
kubectl exec -it dns-example -- cat /etc/resolv.conf
```

输出类似于：

```
nameserver 2001:db8:30::a
search default.svc.cluster-domain.example svc.cluster-domain.example cluster-domain.example
options ndots:5
```

#### DNS 搜索域列表限制[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#dns-search-domain-list-limits)

**特性状态：** `Kubernetes 1.26 [beta]`

Kubernetes 本身不限制 DNS 配置，最多可支持 32 个搜索域列表，所有搜索域的总长度不超过 2048。 此限制分别适用于节点的解析器配置文件、Pod 的 DNS 配置和合并的 DNS 配置。

**说明：**

早期版本的某些容器运行时可能对 DNS 搜索域的数量有自己的限制。 根据容器运行环境，那些具有大量 DNS 搜索域的 Pod 可能会卡在 Pending 状态。

众所周知 containerd v1.5.5 或更早版本和 CRI-O v1.21 或更早版本都有这个问题。

#### Windows 节点上的 DNS 解析[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#dns-windows)

- 在 Windows 节点上运行的 Pod 不支持 ClusterFirstWithHostNet。 Windows 将所有带有 `.` 的名称视为全限定域名（FQDN）并跳过全限定域名（FQDN）解析。
- 在 Windows 上，可以使用的 DNS 解析器有很多。 由于这些解析器彼此之间会有轻微的行为差别，建议使用 [`Resolve-DNSName`](https://docs.microsoft.com/powershell/module/dnsclient/resolve-dnsname) powershell cmdlet 进行名称查询解析。
- 在 Linux 上，有一个 DNS 后缀列表，当解析全名失败时可以使用。 在 Windows 上，你只能有一个 DNS 后缀， 即与该 Pod 的命名空间相关联的 DNS 后缀（例如：`mydns.svc.cluster.local`）。 Windows 可以解析全限定域名（FQDN），和使用了该 DNS 后缀的 Services 或者网络名称。 例如，在 `default` 命名空间中生成一个 Pod，该 Pod 会获得的 DNS 后缀为 `default.svc.cluster.local`。 在 Windows 的 Pod 中，你可以解析 `kubernetes.default.svc.cluster.local` 和 `kubernetes`， 但是不能解析部分限定名称（`kubernetes.default` 和 `kubernetes.default.svc`）。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dns-pod-service/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

有关管理 DNS 配置的指导， 请查看[配置 DNS 服务](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/dns-custom-nameservers/)
### [IPv4/IPv6 双协议栈](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/)

Kubernetes 允许你配置单协议栈 IPv4 网络、单协议栈 IPv6 网络或同时激活这两种网络的双协议栈网络。本页说明具体配置方法。
**特性状态：** `Kubernetes v1.23 [stable]`

IPv4/IPv6 双协议栈网络能够将 IPv4 和 IPv6 地址分配给 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 和 [Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)。

从 1.21 版本开始，Kubernetes 集群默认启用 IPv4/IPv6 双协议栈网络， 以支持同时分配 IPv4 和 IPv6 地址。

#### 支持的功能[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#supported-features)

Kubernetes 集群的 IPv4/IPv6 双协议栈可提供下面的功能：

- 双协议栈 pod 网络 (每个 pod 分配一个 IPv4 和 IPv6 地址)
- IPv4 和 IPv6 启用的服务
- Pod 的集群外出口通过 IPv4 和 IPv6 路由

#### 先决条件[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#prerequisites)

为了使用 IPv4/IPv6 双栈的 Kubernetes 集群，需要满足以下先决条件：

- Kubernetes 1.20 版本或更高版本，有关更早 Kubernetes 版本的使用双栈服务的信息， 请参考对应版本的 Kubernetes 文档。
- 提供商支持双协议栈网络（云提供商或其他提供商必须能够为 Kubernetes 节点提供可路由的 IPv4/IPv6 网络接口）
- 支持双协议栈的[网络插件](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)

#### 配置 IPv4/IPv6 双协议栈[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#%E9%85%8D%E7%BD%AE-ipv4-ipv6-%E5%8F%8C%E5%8D%8F%E8%AE%AE%E6%A0%88)

如果配置 IPv4/IPv6 双栈，请分配双栈集群网络：

- kube-apiserver:
    - `--service-cluster-ip-range=<IPv4 CIDR>,<IPv6 CIDR>`
- kube-controller-manager:
    - `--cluster-cidr=<IPv4 CIDR>,<IPv6 CIDR>`
    - `--service-cluster-ip-range=<IPv4 CIDR>,<IPv6 CIDR>`
    - `--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6` 对于 IPv4 默认为 /24， 对于 IPv6 默认为 /64
- kube-proxy:
    - `--cluster-cidr=<IPv4 CIDR>,<IPv6 CIDR>`
- kubelet:
    - 当没有 `--cloud-provider` 时，管理员可以通过 `--node-ip` 来传递逗号分隔的 IP 地址， 为该节点手动配置双栈 `.status.addresses`。 如果 Pod 以 HostNetwork 模式在该节点上运行，则 Pod 会用 `.status.podIPs` 字段来报告它的 IP 地址。 一个节点中的所有 `podIP` 都会匹配该节点的由 `.status.addresses` 字段定义的 IP 组。

**说明：**

IPv4 CIDR 的一个例子：`10.244.0.0/16`（尽管你会提供你自己的地址范围）。

IPv6 CIDR 的一个例子：`fdXY:IJKL:MNOP:15::/64` （这里演示的是格式而非有效地址 - 请看 [RFC 4193](https://tools.ietf.org/html/rfc4193)）。

#### 服务[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#services)

你可以使用 IPv4 或 IPv6 地址来创建 [Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)。

服务的地址族默认为第一个服务集群 IP 范围的地址族（通过 kube-apiserver 的 `--service-cluster-ip-range` 参数配置）。

当你定义服务时，可以选择将其配置为双栈。若要指定所需的行为，你可以设置 `.spec.ipFamilyPolicy` 字段为以下值之一：

- `SingleStack`：单栈服务。控制面使用第一个配置的服务集群 IP 范围为服务分配集群 IP。
- `PreferDualStack`：
    - 为服务分配 IPv4 和 IPv6 集群 IP 地址。
- `RequireDualStack`：从 IPv4 和 IPv6 的地址范围分配服务的 `.spec.ClusterIPs`
    - 从基于在 `.spec.ipFamilies` 数组中第一个元素的地址族的 `.spec.ClusterIPs` 列表中选择 `.spec.ClusterIP`

如果你想要定义哪个 IP 族用于单栈或定义双栈 IP 族的顺序，可以通过设置 服务上的可选字段 `.spec.ipFamilies` 来选择地址族。

**说明：**

`.spec.ipFamilies` 字段是不可变的，因为系统无法为已经存在的服务重新分配 `.spec.ClusterIP`。如果你想改变 `.spec.ipFamilies`，则需要删除并重新创建服务。

你可以设置 `.spec.ipFamily` 为以下任何数组值：

- `["IPv4"]`
- `["IPv6"]`
- `["IPv4","IPv6"]` （双栈）
- `["IPv6","IPv4"]` （双栈）

你所列出的第一个地址族用于原来的 `.spec.ClusterIP` 字段。

##### 双栈服务配置场景[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#dual-stack-service-configuration-scenarios)

以下示例演示多种双栈服务配置场景下的行为。

###### 新服务的双栈选项[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#dual-stack-options-on-new-services)

1. 此服务规约中没有显式设定 `.spec.ipFamilyPolicy`。当你创建此服务时，Kubernetes 从所配置的第一个 `service-cluster-ip-range` 中为服务分配一个集群 IP，并设置 `.spec.ipFamilyPolicy` 为 `SingleStack`。 （[无选择算符的服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#services-without-selectors) 和[无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services)的行为方式 与此相同。）
    
    [`service/networking/dual-stack-default-svc.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/dual-stack-default-svc.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/dual-stack-default-svc.yaml to clipboard")
    
    ```yaml
    apiVersion: v1
       kind: Service
       metadata:
         name: my-service
         labels:
           app.kubernetes.io/name: MyApp
       spec:
         selector:
           app.kubernetes.io/name: MyApp
         ports:
           - protocol: TCP
             port: 80
       
    ```
    

2. 此服务规约显式地将 `.spec.ipFamilyPolicy` 设置为 `PreferDualStack`。 当你在双栈集群上创建此服务时，Kubernetes 会为该服务分配 IPv4 和 IPv6 地址。 控制平面更新服务的 `.spec` 以记录 IP 地址分配。 字段 `.spec.ClusterIPs` 是主要字段，包含两个分配的 IP 地址；`.spec.ClusterIP` 是次要字段， 其取值从 `.spec.ClusterIPs` 计算而来。
    
    - 对于 `.spec.ClusterIP` 字段，控制面记录来自第一个服务集群 IP 范围 对应的地址族的 IP 地址。
    - 对于单协议栈的集群，`.spec.ClusterIPs` 和 `.spec.ClusterIP` 字段都 仅仅列出一个地址。
    - 对于启用了双协议栈的集群，将 `.spec.ipFamilyPolicy` 设置为 `RequireDualStack` 时，其行为与 `PreferDualStack` 相同。
    
    [`service/networking/dual-stack-preferred-svc.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/dual-stack-preferred-svc.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/dual-stack-preferred-svc.yaml to clipboard")
    
    ```yaml
    apiVersion: v1
       kind: Service
       metadata:
         name: my-service
         labels:
           app.kubernetes.io/name: MyApp
       spec:
         ipFamilyPolicy: PreferDualStack
         selector:
           app.kubernetes.io/name: MyApp
         ports:
           - protocol: TCP
             port: 80
       
    ```
    

3. 下面的服务规约显式地在 `.spec.ipFamilies` 中指定 `IPv6` 和 `IPv4`，并 将 `.spec.ipFamilyPolicy` 设定为 `PreferDualStack`。 当 Kubernetes 为 `.spec.ClusterIPs` 分配一个 IPv6 和一个 IPv4 地址时， `.spec.ClusterIP` 被设置成 IPv6 地址，因为它是 `.spec.ClusterIPs` 数组中的第一个元素， 覆盖其默认值。
    
    [`service/networking/dual-stack-preferred-ipfamilies-svc.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/dual-stack-preferred-ipfamilies-svc.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/dual-stack-preferred-ipfamilies-svc.yaml to clipboard")
    
    ```yaml
    apiVersion: v1
       kind: Service
       metadata:
         name: my-service
         labels:
           app.kubernetes.io/name: MyApp
       spec:
         ipFamilyPolicy: PreferDualStack
         ipFamilies:
         - IPv6
         - IPv4
         selector:
           app.kubernetes.io/name: MyApp
         ports:
           - protocol: TCP
             port: 80
       
    ```
    

###### 现有服务的双栈默认值[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#dual-stack-defaults-on-existing-services)

下面示例演示了在服务已经存在的集群上新启用双栈时的默认行为。 （将现有集群升级到 1.21 或者更高版本会启用双协议栈支持。）

1. 在集群上启用双栈时，控制面会将现有服务（无论是 `IPv4` 还是 `IPv6`）配置 `.spec.ipFamilyPolicy` 为 `SingleStack` 并设置 `.spec.ipFamilies` 为服务的当前地址族。
    
    [`service/networking/dual-stack-default-svc.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/dual-stack-default-svc.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/dual-stack-default-svc.yaml to clipboard")
    
    ```yaml
    apiVersion: v1
       kind: Service
       metadata:
         name: my-service
         labels:
           app.kubernetes.io/name: MyApp
       spec:
         selector:
           app.kubernetes.io/name: MyApp
         ports:
           - protocol: TCP
             port: 80
       
    ```
    
    你可以通过使用 kubectl 检查现有服务来验证此行为。
    
    ```shell
    kubectl get svc my-service -o yaml
    ```
    
    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
      labels:
        app.kubernetes.io/name: MyApp
      name: my-service
    spec:
      clusterIP: 10.0.197.123
      clusterIPs:
      - 10.0.197.123
      ipFamilies:
      - IPv4
      ipFamilyPolicy: SingleStack
      ports:
      - port: 80
        protocol: TCP
        targetPort: 80
      selector:
        app.kubernetes.io/name: MyApp
      type: ClusterIP
    status:
      loadBalancer: {}
    ```
    

2. 在集群上启用双栈时，带有选择算符的现有 [无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#headless-services) 由控制面设置 `.spec.ipFamilyPolicy` 为 `SingleStack` 并设置 `.spec.ipFamilies` 为第一个服务集群 IP 范围的地址族（通过配置 kube-apiserver 的 `--service-cluster-ip-range` 参数），即使 `.spec.ClusterIP` 的设置值为 `None` 也如此。
    
    [`service/networking/dual-stack-default-svc.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/service/networking/dual-stack-default-svc.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy service/networking/dual-stack-default-svc.yaml to clipboard")
    
    ```yaml
    apiVersion: v1
       kind: Service
       metadata:
         name: my-service
         labels:
           app.kubernetes.io/name: MyApp
       spec:
         selector:
           app.kubernetes.io/name: MyApp
         ports:
           - protocol: TCP
             port: 80
       
    ```
    
    你可以通过使用 kubectl 检查带有选择算符的现有无头服务来验证此行为。
    
    ```shell
    kubectl get svc my-service -o yaml
    ```
    
    ```yaml
    apiVersion: v1
    kind: Service
    metadata:
      labels:
        app.kubernetes.io/name: MyApp
      name: my-service
    spec:
      clusterIP: None
      clusterIPs:
      - None
      ipFamilies:
      - IPv4
      ipFamilyPolicy: SingleStack
      ports:
      - port: 80
        protocol: TCP
        targetPort: 80
      selector:
        app.kubernetes.io/name: MyApp
    ```
    

###### 在单栈和双栈之间切换服务[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#switching-services-between-single-stack-and-dual-stack)

服务可以从单栈更改为双栈，也可以从双栈更改为单栈。

1. 要将服务从单栈更改为双栈，根据需要将 `.spec.ipFamilyPolicy` 从 `SingleStack` 改为 `PreferDualStack` 或 `RequireDualStack`。 当你将此服务从单栈更改为双栈时，Kubernetes 将分配缺失的地址族， 以便现在该服务具有 IPv4 和 IPv6 地址。 编辑服务规约将 `.spec.ipFamilyPolicy` 从 `SingleStack` 改为 `PreferDualStack`。
    
    之前：
    
    ```yaml
    spec:
      ipFamilyPolicy: SingleStack
    ```
    
    之后：
    
    ```yaml
    spec:
      ipFamilyPolicy: PreferDualStack
    ```
    

2. 要将服务从双栈更改为单栈，请将 `.spec.ipFamilyPolicy` 从 `PreferDualStack` 或 `RequireDualStack` 改为 `SingleStack`。 当你将此服务从双栈更改为单栈时，Kubernetes 只保留 `.spec.ClusterIPs` 数组中的第一个元素，并设置 `.spec.ClusterIP` 为那个 IP 地址， 并设置 `.spec.ipFamilies` 为 `.spec.ClusterIPs` 地址族。

##### 无选择算符的无头服务[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#headless-services-without-selector)

对于[不带选择算符的无头服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#without-selectors)， 若没有显式设置 `.spec.ipFamilyPolicy`，则 `.spec.ipFamilyPolicy` 字段默认设置为 `RequireDualStack`。

##### LoadBalancer 类型服务[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#service-type-loadbalancer)

要为你的服务提供双栈负载均衡器：

- 将 `.spec.type` 字段设置为 `LoadBalancer`
- 将 `.spec.ipFamilyPolicy` 字段设置为 `PreferDualStack` 或者 `RequireDualStack`

**说明：**

为了使用双栈的负载均衡器类型服务，你的云驱动必须支持 IPv4 和 IPv6 的负载均衡器。

#### 出站流量[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#egress-traffic)

如果你要启用出站流量，以便使用非公开路由 IPv6 地址的 Pod 到达集群外地址 （例如公网），则需要通过透明代理或 IP 伪装等机制使 Pod 使用公共路由的 IPv6 地址。 [ip-masq-agent](https://github.com/kubernetes-sigs/ip-masq-agent)项目 支持在双栈集群上进行 IP 伪装。

**说明：**

确认你的 [CNI](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/) 驱动支持 IPv6。

#### Windows 支持[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#windows-support)

Windows 上的 Kubernetes 不支持单栈“仅 IPv6” 网络。 然而， 对于 Pod 和节点而言，仅支持单栈形式服务的双栈 IPv4/IPv6 网络是被支持的。

你可以使用 `l2bridge` 网络来实现 IPv4/IPv6 双栈联网。

**说明：**

Windows 上的 Overlay (VXLAN) 网络**不**支持双栈网络。

关于 Windows 的不同网络模式，你可以进一步阅读 [Windows 上的网络](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking#network-modes)。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/dual-stack/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- [验证 IPv4/IPv6 双协议栈](https://kubernetes.io/zh-cn/docs/tasks/network/validate-dual-stack)网络
- [使用 kubeadm 启用双协议栈网络](https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/dual-stack-support/)
### [拓扑感知提示](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/)

**拓扑感知提示（Topology Aware Hints）** 提供了一种机制来帮助将网络流量保持在其请求方所在的区域内。 在集群中的 Pod 之间优先选用相同区域的流量有助于提高可靠性、增强性能（网络延迟和吞吐量）或降低成本。
**特性状态：** `Kubernetes v1.23 [beta]`

**拓扑感知提示**包含客户怎么使用服务端点的建议，从而实现了拓扑感知的路由功能。 这种方法添加了元数据，以启用 EndpointSlice（或 Endpoints）对象的调用者， 这样，访问这些网络端点的请求流量就可以在它的发起点附近就近路由。

例如，你可以在一个地域内路由流量，以降低通信成本，或提高网络性能。

#### 动机[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#motivation)

Kubernetes 集群越来越多的部署到多区域环境中。 **拓扑感知提示**提供了一种把流量限制在它的发起区域之内的机制。 这个概念一般被称之为 “拓扑感知路由”。 在计算 [服务（Service）](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 的端点时， EndpointSlice 控制器会评估每一个端点的拓扑（地域和区域），填充提示字段，并将其分配到某个区域。 集群组件，例如[kube-proxy](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/) 就可以使用这些提示信息，并用他们来影响流量的路由（倾向于拓扑上相邻的端点）。

#### 使用拓扑感知提示[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#using-topology-aware-hints)

你可以通过把注解 `service.kubernetes.io/topology-aware-hints` 的值设置为 `auto`， 来激活服务的拓扑感知提示功能。 这告诉 EndpointSlice 控制器在它认为安全的时候来设置拓扑提示。 重要的是，这并不能保证总会设置提示（hints）。

#### 工作原理[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#implementation)

此特性启用的功能分为两个组件：EndpointSlice 控制器和 kube-proxy。 本节概述每个组件如何实现此特性。

##### EndpointSlice 控制器[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#implementation-control-plane)

此特性开启后，EndpointSlice 控制器负责在 EndpointSlice 上设置提示信息。 控制器按比例给每个区域分配一定比例数量的端点。 这个比例来源于此区域中运行节点的 [可分配](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable) CPU 核心数。 例如，如果一个区域拥有 2 CPU 核心，而另一个区域只有 1 CPU 核心， 那控制器将给那个有 2 CPU 的区域分配两倍数量的端点。

以下示例展示了提供提示信息后 EndpointSlice 的样子：

```yaml
apiVersion: discovery.k8s.io/v1
kind: EndpointSlice
metadata:
  name: example-hints
  labels:
    kubernetes.io/service-name: example-svc
addressType: IPv4
ports:
  - name: http
    protocol: TCP
    port: 80
endpoints:
  - addresses:
      - "10.1.2.3"
    conditions:
      ready: true
    hostname: pod-1
    zone: zone-a
    hints:
      forZones:
        - name: "zone-a"
```

##### kube-proxy[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#implementation-kube-proxy)

kube-proxy 组件依据 EndpointSlice 控制器设置的提示，过滤由它负责路由的端点。 在大多数场合，这意味着 kube-proxy 可以把流量路由到同一个区域的端点。 有时，控制器从某个不同的区域分配端点，以确保在多个区域之间更平均的分配端点。 这会导致部分流量被路由到其他区域。

#### 保护措施[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#safeguards)

Kubernetes 控制平面和每个节点上的 kube-proxy，在使用拓扑感知提示功能前，会应用一些保护措施规则。 如果没有检出，kube-proxy 将无视区域限制，从集群中的任意节点上选择端点。

1. **端点数量不足：** 如果一个集群中，端点数量少于区域数量，控制器不创建任何提示。

2. **不可能实现均衡分配：** 在一些场合中，不可能实现端点在区域中的平衡分配。 例如，假设 zone-a 比 zone-b 大两倍，但只有 2 个端点， 那分配到 zone-a 的端点可能收到比 zone-b 多两倍的流量。 如果控制器不能确定此“期望的过载”值低于每一个区域可接受的阈值，控制器将不指派提示信息。 重要的是，这不是基于实时反馈。所以对于单独的端点仍有可能超载。

3. **一个或多个节点信息不足：** 如果任一节点没有设置标签 `topology.kubernetes.io/zone`， 或没有上报可分配的 CPU 数据，控制平面将不会设置任何拓扑感知提示， 继而 kube-proxy 也就不能通过区域过滤端点。

4. **一个或多个端点没有设置区域提示：** 当这类事情发生时， kube-proxy 会假设这是正在执行一个从/到拓扑感知提示的转移。 在这种场合下过滤Service 的端点是有风险的，所以 kube-proxy 回撤为使用所有的端点。

5. **不在提示中的区域：** 如果 kube-proxy 不能根据一个指示在它所在的区域中发现一个端点， 它将回退到使用来自所有区域的端点。当你的集群新增一个新的区域时，这种情况发生概率很高。

#### 限制[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#constraints)

- 当 Service 的 `externalTrafficPolicy` 或 `internalTrafficPolicy` 设置值为 `Local` 时， 拓扑感知提示功能不可用。 你可以在一个集群的不同服务中使用这两个特性，但不能在同一个服务中这么做。

- 这种方法不适用于大部分流量来自于一部分区域的服务。 相反的，这里假设入站流量将根据每个区域中节点的服务能力按比例的分配。

- EndpointSlice 控制器在计算每一个区域的容量比例时，会忽略未就绪的节点。 在大量节点未就绪的场景下，这样做会带来非预期的结果。

- EndpointSlice 控制器在计算每一个区域的部署比例时，并不会考虑 [容忍度](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/)。 如果服务后台的 Pod 被限制只能运行在集群节点的一个子集上，这些信息并不会被使用。

- 这种方法和自动扩展机制之间不能很好的协同工作。例如，如果大量流量来源于一个区域， 那只有分配到该区域的端点才可用来处理流量。这会导致 [Pod 自动水平扩展](https://kubernetes.io/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/) 要么不能拾取此事件，要么新增 Pod 被启动到其他区域。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 参阅[使用 Service 连接到应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)教程
### [Windows 网络](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/)
Kubernetes 支持运行 Linux 或 Windows 节点。 你可以在统一集群内混布这两种节点。 本页提供了特定于 Windows 操作系统的网络概述。

#### Windows 容器网络[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#networking)

Windows 容器网络通过 [CNI 插件](https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)暴露。 Windows 容器网络的工作方式与虚拟机类似。 每个容器都有一个连接到 Hyper-V 虚拟交换机（vSwitch）的虚拟网络适配器（vNIC）。 主机网络服务（Host Networking Service，HNS）和主机计算服务（Host Comute Service，HCS） 协同创建容器并将容器 vNIC 挂接到网络。 HCS 负责管理容器，而 HNS 负责管理以下网络资源：

- 虚拟网络（包括创建 vSwitch）
- Endpoint / vNIC
- 命名空间
- 包括数据包封装、负载均衡规则、ACL 和 NAT 规则在内的策略。

Windows HNS 和 vSwitch 实现命名空间划分，且可以按需为 Pod 或容器创建虚拟 NIC。 然而，诸如 DNS、路由和指标等许多配置将存放在 Windows 注册表数据库中， 而不是像 Linux 将这些配置作为文件存放在 `/etc` 内。 针对容器的 Windows 注册表与主机的注册表是分开的，因此将 `/etc/resolv.conf` 从主机映射到一个容器的类似概念与 Linux 上的效果不同。 这些必须使用容器环境中运行的 Windows API 进行配置。 因此，实现 CNI 时需要调用 HNS，而不是依赖文件映射将网络详情传递到 Pod 或容器中。

#### 网络模式[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#network-mode)

Windows 支持五种不同的网络驱动/模式：L2bridge、L2tunnel、Overlay (Beta)、Transparent 和 NAT。 在 Windows 和 Linux 工作节点组成的异构集群中，你需要选择一个同时兼容 Windows 和 Linux 的网络方案。 下表列出了 Windows 支持的树外插件，并给出了何时使用每种 CNI 的建议：

| 网络驱动 | 描述 | 容器数据包修改 | 网络插件 | 网络插件特点 |
| --- | --- | --- | --- | --- |
| L2bridge | 容器挂接到一个外部 vSwitch。容器挂接到下层网络，但物理网络不需要了解容器的 MAC，因为这些 MAC 在入站/出站时被重写。 | MAC 被重写为主机 MAC，可使用 HNS OutboundNAT 策略将 IP 重写为主机 IP。 | [win-bridge](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-bridge)、[Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md)、Flannel host-gateway 使用 win-bridge | win-bridge 使用 L2bridge 网络模式，将容器连接到主机的下层，提供最佳性能。节点间连接需要用户定义的路由（UDR）。 |
| L2Tunnel | 这是 L2bridge 的一种特例，但仅用在 Azure 上。所有数据包都会被发送到应用了 SDN 策略的虚拟化主机。 | MAC 被重写，IP 在下层网络上可见。 | [Azure-CNI](https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md) | Azure-CNI 允许将容器集成到 Azure vNET，允许容器充分利用 [Azure 虚拟网络](https://azure.microsoft.com/zh-cn/services/virtual-network/)所提供的能力集合。例如，安全地连接到 Azure 服务或使用 Azure NSG。参考 [azure-cni 了解有关示例](https://docs.microsoft.com/zh-cn/azure/aks/concepts-network#azure-cni-advanced-networking)。 |
| Overlay | 容器被赋予一个 vNIC，连接到外部 vSwitch。每个上层网络都有自己的 IP 子网，由自定义 IP 前缀进行定义。该上层网络驱动使用 VXLAN 封装。 | 用外部头进行封装。 | [win-overlay](https://github.com/containernetworking/plugins/tree/master/plugins/main/windows/win-overlay)、Flannel VXLAN（使用 win-overlay） | 当需要将虚拟容器网络与主机的下层隔离时（例如出于安全原因），应使用 win-overlay。如果你的数据中心的 IP 个数有限，可以将 IP 在不同的上层网络中重用（带有不同的 VNID 标记）。在 Windows Server 2019 上这个选项需要 [KB4489899](https://support.microsoft.com/zh-cn/help/4489899)。 |
| Transparent（[ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes) 的特殊用例） | 需要一个外部 vSwitch。容器挂接到一个外部 vSwitch，由后者通过逻辑网络（逻辑交换机和路由器）实现 Pod 内通信。 | 数据包通过 [GENEVE](https://datatracker.ietf.org/doc/draft-gross-geneve/) 或 [STT](https://datatracker.ietf.org/doc/draft-davie-stt/) 隧道进行封装，以到达其它主机上的 Pod。  
数据包基于 OVN 网络控制器提供的隧道元数据信息被转发或丢弃。  
南北向通信使用 NAT。 | [ovn-kubernetes](https://github.com/openvswitch/ovn-kubernetes) | [通过 ansible 部署](https://github.com/openvswitch/ovn-kubernetes/tree/master/contrib)。通过 Kubernetes 策略可以实施分布式 ACL。支持 IPAM。无需 kube-proxy 即可实现负载均衡。无需 iptables/netsh 即可进行 NAT。 |
| NAT（**Kubernetes 中未使用**） | 容器被赋予一个 vNIC，连接到内部 vSwitch。DNS/DHCP 是使用一个名为 [WinNAT 的内部组件](https://techcommunity.microsoft.com/t5/virtualization/windows-nat-winnat-capabilities-and-limitations/ba-p/382303)实现的 | MAC 和 IP 重写为主机 MAC/IP。 | [nat](https://github.com/Microsoft/windows-container-networking/tree/master/plugins/nat) | 放在此处保持完整性。 |

如上所述，Windows 通过 [VXLAN 网络后端](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan)（**Beta 支持**；委派给 win-overlay） 和 [host-gateway 网络后端](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#host-gw)（稳定支持；委派给 win-bridge） 也[支持](https://github.com/flannel-io/cni-plugin#windows-support-experimental) [Flannel](https://github.com/coreos/flannel) 的 [CNI 插件](https://github.com/flannel-io/cni-plugin)。

此插件支持委派给参考 CNI 插件（win-overlay、win-bridge）之一，配合使用 Windows 上的 Flannel 守护程序（Flanneld），以便自动分配节点子网租赁并创建 HNS 网络。 该插件读取自己的配置文件（cni.conf），并聚合 FlannelD 生成的 subnet.env 文件中的环境变量。 然后，委派给网络管道的参考 CNI 插件之一，并将包含节点分配子网的正确配置发送给 IPAM 插件（例如：`host-local`）。

对于 Node、Pod 和 Service 对象，TCP/UDP 流量支持以下网络流：

- Pod → Pod（IP）
- Pod → Pod（名称）
- Pod → Service（集群 IP）
- Pod → Service（PQDN，但前提是没有 "."）
- Pod → Service（FQDN）
- Pod → 外部（IP）
- Pod → 外部（DNS）
- Node → Pod
- Pod → Node

#### IP 地址管理（IPAM）[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#ipam)

Windows 支持以下 IPAM 选项：

- [host-local](https://github.com/containernetworking/plugins/tree/master/plugins/ipam/host-local)
- [azure-vnet-ipam](https://github.com/Azure/azure-container-networking/blob/master/docs/ipam.md)（仅适用于 azure-cni）
- [Windows Server IPAM](https://docs.microsoft.com/zh-cn/windows-server/networking/technologies/ipam/ipam-top)（未设置 IPAM 时的回滚选项）

#### 负载均衡和 Service[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#load-balancing-and-services)

Kubernetes [Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 是一种抽象：定义了逻辑上的一组 Pod 和一种通过网络访问这些 Pod 的方式。 在包含 Windows 节点的集群中，你可以使用以下类别的 Service：

- `NodePort`
- `ClusterIP`
- `LoadBalancer`
- `ExternalName`

Windows 容器网络与 Linux 网络有着很重要的差异。 更多细节和背景信息，参考 [Microsoft Windows 容器网络文档](https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/container-networking/architecture)。

在 Windows 上，你可以使用以下设置来配置 Service 和负载均衡行为：

| 功能特性 | 描述 | 支持的 Windows 操作系统最低版本 | 启用方式 |
| --- | --- | --- | --- |
| 会话亲和性 | 确保每次都将来自特定客户端的连接传递到同一个 Pod。 | Windows Server 2022 | 将 `service.spec.sessionAffinity` 设为 “ClientIP” |
| Direct Server Return (DSR) | 在负载均衡模式中 IP 地址修正和 LBNAT 直接发生在容器 vSwitch 端口；服务流量到达时源 IP 设置为原始 Pod IP。 | Windows Server 2019 | 在 kube-proxy 中设置以下标志：`--feature-gates="WinDSR=true" --enable-dsr=true` |
| 保留目标（Preserve-Destination） | 跳过服务流量的 DNAT，从而在到达后端 Pod 的数据包中保留目标服务的虚拟 IP。也会禁用节点间的转发。 | Windows Server，version 1903 | 在服务注解中设置 `"preserve-destination": "true"` 并在 kube-proxy 中启用 DSR。 |
| IPv4/IPv6 双栈网络 | 进出集群和集群内通信都支持原生的 IPv4 间与 IPv6 间流量 | Windows Server 2019 | 参考 [IPv4/IPv6 双栈](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#ipv4ipv6-dual-stack)。 |
| 客户端 IP 保留 | 确保入站流量的源 IP 得到保留。也会禁用节点间转发。 | Windows Server 2019 | 将 `service.spec.externalTrafficPolicy` 设置为 “Local” 并在 kube-proxy 中启用 DSR。 |

**警告：**

如果目的地节点在运行 Windows Server 2022，则上层网络的 NodePort Service 存在已知问题。 要完全避免此问题，可以使用 `externalTrafficPolicy: Local` 配置服务。

在安装了 KB5005619 的 Windows Server 2022 或更高版本上，采用 L2bridge 网络时 Pod 间连接存在已知问题。 要解决此问题并恢复 Pod 间连接，你可以在 kube-proxy 中禁用 WinDSR 功能。

这些问题需要操作系统修复。 有关更新，请参考 [https://github.com/microsoft/Windows-Containers/issues/204](https://github.com/microsoft/Windows-Containers/issues/204)。

#### 限制[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/windows-networking/#limitations)

Windows 节点**不支持**以下网络功能：

- 主机网络模式
- 从节点本身访问本地 NodePort（可以从其他节点或外部客户端进行访问）
- 为同一 Service 提供 64 个以上后端 Pod（或不同目的地址）
- 在连接到上层网络的 Windows Pod 之间使用 IPv6 通信
- 非 DSR 模式中的本地流量策略（Local Traffic Policy）

- 通过 `win-overlay`、`win-bridge` 使用 ICMP 协议，或使用 Azure-CNI 插件进行出站通信。  
    具体而言，Windows 数据平面（[VFP](https://www.microsoft.com/research/project/azure-virtual-filtering-platform/)）不支持 ICMP 数据包转换，这意味着：
    - 指向同一网络内目的地址的 ICMP 数据包（例如 Pod 间的 ping 通信）可正常工作；
    - TCP/UDP 数据包可正常工作；
    - 通过远程网络指向其它地址的 ICMP 数据包（例如通过 ping 从 Pod 到外部公网的通信）无法被转换， 因此无法被路由回到这些数据包的源点；
    - 由于 TCP/UDP 数据包仍可被转换，所以在调试与外界的连接时， 你可以将 `ping <destination>` 替换为 `curl <destination>`。

其他限制：

- 由于缺少 `CHECK` 实现，Windows 参考网络插件 win-bridge 和 win-overlay 未实现 [CNI 规约](https://github.com/containernetworking/cni/blob/master/SPEC.md) 的 v0.4.0 版本。
- Flannel VXLAN CNI 插件在 Windows 上有以下限制：
    - 使用 Flannel v0.12.0（或更高版本）时，节点到 Pod 的连接仅适用于本地 Pod。
    - Flannel 仅限于使用 VNI 4096 和 UDP 端口 4789。 有关这些参数的更多详细信息，请参考官方的 [Flannel VXLAN](https://github.com/coreos/flannel/blob/master/Documentation/backends.md#vxlan) 后端文档。
### [Service ClusterIP 分配](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/)
在 Kubernetes 中，[Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 是一种抽象的方式， 用于公开在一组 Pod 上运行的应用。 Service 可以具有集群作用域的虚拟 IP 地址（使用 `type: ClusterIP` 的 Service）。 客户端可以使用该虚拟 IP 地址进行连接，Kubernetes 通过不同的后台 Pod 对该 Service 的流量进行负载均衡。

#### Service ClusterIP 是如何分配的？[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#service-clusterip-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%9A%84)

当 Kubernetes 需要为 Service 分配虚拟 IP 地址时，该分配会通过以下两种方式之一进行：

**动态分配**

集群的控制面自动从所配置的 IP 范围内为 `type: ClusterIP` 选择一个空闲 IP 地址。

**静态分配**

根据为 Service 所配置的 IP 范围，选定并设置你的 IP 地址。

在整个集群中，每个 Service 的 `ClusterIP` 都必须是唯一的。 尝试使用已分配的 `ClusterIP` 创建 Service 将返回错误。

#### 为什么需要预留 Service 的 ClusterIP ？[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A2%84%E7%95%99-service-%E7%9A%84-clusterip)

有时你可能希望 Services 在众所周知的 IP 上面运行，以便集群中的其他组件和用户可以使用它们。

最好的例子是集群的 DNS Service。作为一种非强制性的约定，一些 Kubernetes 安装程序 将 Service IP 范围中的第 10 个 IP 地址分配给 DNS 服务。假设将集群的 Service IP 范围配置为 10.96.0.0/16，并且希望 DNS Service IP 为 10.96.0.10，则必须创建如下 Service：

```yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    k8s-app: kube-dns
    kubernetes.io/cluster-service: "true"
    kubernetes.io/name: CoreDNS
  name: kube-dns
  namespace: kube-system
spec:
  clusterIP: 10.96.0.10
  ports:
  - name: dns
    port: 53
    protocol: UDP
    targetPort: 53
  - name: dns-tcp
    port: 53
    protocol: TCP
    targetPort: 53
  selector:
    k8s-app: kube-dns
  type: ClusterIP
```

但如前所述，IP 地址 10.96.0.10 尚未被保留。如果在 DNS 启动之前或同时采用动态分配机制创建其他 Service， 则它们有可能被分配此 IP，因此，你将无法创建 DNS Service，因为它会因冲突错误而失败。

#### 如何避免 Service ClusterIP 冲突？[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#avoid-ClusterIP-conflict)

Kubernetes 中用來将 ClusterIP 分配给 Service 的分配策略降低了冲突的风险。

`ClusterIP` 范围根据公式 `min(max(16, cidrSize / 16), 256)` 进行划分， 描述为不小于 16 且不大于 256，并在二者之间有一个渐进的步长。

默认情况下，动态 IP 分配使用地址较高的一段，一旦用完，它将使用较低范围。 这将允许用户在冲突风险较低的较低地址段上使用静态分配。

#### 示例[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#allocation-examples)

##### 示例 1[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#allocation-example-1)

此示例使用 IP 地址范围：10.96.0.0/24（CIDR 表示法）作为 Service 的 IP 地址。

范围大小：2<sup>8</sup> - 2 = 254  
带宽偏移量：`min(max(16, 256/16), 256)` = `min(16, 256)` = 16  
静态带宽起始地址：10.96.0.1  
静态带宽结束地址：10.96.0.16  
范围结束地址：10.96.0.254

#mermaid-1679620122551 {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1679620122551 .error-icon{fill:#552222;}#mermaid-1679620122551 .error-text{fill:#552222;stroke:#552222;}#mermaid-1679620122551 .edge-thickness-normal{stroke-width:2px;}#mermaid-1679620122551 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1679620122551 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1679620122551 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1679620122551 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1679620122551 .marker{fill:#333333;stroke:#333333;}#mermaid-1679620122551 .marker.cross{stroke:#333333;}#mermaid-1679620122551 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1679620122551 .pieCircle{stroke:black;stroke-width:2px;opacity:0.7;}#mermaid-1679620122551 .pieTitleText{text-anchor:middle;font-size:25px;fill:black;font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-1679620122551 .slice{font-family:"trebuchet ms",verdana,arial,sans-serif;fill:#333;font-size:17px;}#mermaid-1679620122551 .legend text{fill:black;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:17px;}#mermaid-1679620122551 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}6%94%10.96.0.0/24静态分配 \[16\]动态分配 \[238\]

_必须[启用](https://www.enable-javascript.com/) JavaScript 才能查看此页内容_

##### 示例 2[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#allocation-example-2)

此示例使用 IP 地址范围 10.96.00/20（CIDR 表示法）作为 Service 的 IP 地址。

范围大小：2<sup>12</sup> - 2 = 4094  
带宽偏移量：`min(max(16, 4096/16), 256)` = `min(256, 256)` = 256  
静态带宽起始地址：10.96.0.1  
静态带宽结束地址：10.96.1.0  
范围结束地址：10.96.15.254

#mermaid-1679620122570 {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1679620122570 .error-icon{fill:#552222;}#mermaid-1679620122570 .error-text{fill:#552222;stroke:#552222;}#mermaid-1679620122570 .edge-thickness-normal{stroke-width:2px;}#mermaid-1679620122570 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1679620122570 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1679620122570 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1679620122570 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1679620122570 .marker{fill:#333333;stroke:#333333;}#mermaid-1679620122570 .marker.cross{stroke:#333333;}#mermaid-1679620122570 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1679620122570 .pieCircle{stroke:black;stroke-width:2px;opacity:0.7;}#mermaid-1679620122570 .pieTitleText{text-anchor:middle;font-size:25px;fill:black;font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-1679620122570 .slice{font-family:"trebuchet ms",verdana,arial,sans-serif;fill:#333;font-size:17px;}#mermaid-1679620122570 .legend text{fill:black;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:17px;}#mermaid-1679620122570 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}6%94%10.96.0.0/20静态分配 \[256\]动态分配 \[3838\]

_必须[启用](https://www.enable-javascript.com/) JavaScript 才能查看此页内容_

##### 示例 3[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#allocation-example-3)

此示例使用 IP 地址范围 10.96.0.0/16（CIDR 表示法）作为 Service 的 IP 地址。

范围大小：2<sup>16</sup> - 2 = 65534  
带宽偏移量：`min(max(16, 65536/16), 256)` = `min(4096, 256)` = 256  
静态带宽起始地址：10.96.0.1  
静态带宽结束地址：10.96.1.0  
范围结束地址：10.96.255.254

#mermaid-1679620122591 {font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;fill:#333;}#mermaid-1679620122591 .error-icon{fill:#552222;}#mermaid-1679620122591 .error-text{fill:#552222;stroke:#552222;}#mermaid-1679620122591 .edge-thickness-normal{stroke-width:2px;}#mermaid-1679620122591 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1679620122591 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1679620122591 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1679620122591 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1679620122591 .marker{fill:#333333;stroke:#333333;}#mermaid-1679620122591 .marker.cross{stroke:#333333;}#mermaid-1679620122591 svg{font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:16px;}#mermaid-1679620122591 .pieCircle{stroke:black;stroke-width:2px;opacity:0.7;}#mermaid-1679620122591 .pieTitleText{text-anchor:middle;font-size:25px;fill:black;font-family:"trebuchet ms",verdana,arial,sans-serif;}#mermaid-1679620122591 .slice{font-family:"trebuchet ms",verdana,arial,sans-serif;fill:#333;font-size:17px;}#mermaid-1679620122591 .legend text{fill:black;font-family:"trebuchet ms",verdana,arial,sans-serif;font-size:17px;}#mermaid-1679620122591 :root{--mermaid-font-family:"trebuchet ms",verdana,arial,sans-serif;}0%100%10.96.0.0/16静态分配 \[256\]动态分配 \[65278\]

_必须[启用](https://www.enable-javascript.com/) JavaScript 才能查看此页内容_

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/cluster-ip-allocation/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读[服务外部流量策略](https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip)
- 阅读[应用程序与服务连接](https://kubernetes.io/zh-cn/docs/concepts/services-networking/connect-applications-service/)
- 阅读[服务](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/)
### [服务内部流量策略](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-traffic-policy/)

如果集群中的两个 Pod 想要通信，并且两个 Pod 实际上都在同一节点运行， **服务内部流量策略** 可以将网络流量限制在该节点内。 通过集群网络避免流量往返有助于提高可靠性、增强性能（网络延迟和吞吐量）或降低成本。
**特性状态：** `Kubernetes v1.26 [stable]`

**服务内部流量策略**开启了内部流量限制，将内部流量只路由到发起方所处节点内的服务端点。 这里的”内部“流量指当前集群中的 Pod 所发起的流量。 这种机制有助于节省开销，提升效率。

#### 使用服务内部流量策略[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-traffic-policy/#using-service-internal-traffic-policy)

你可以通过将 [Service](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/) 的 `.spec.internalTrafficPolicy` 项设置为 `Local`， 来为它指定一个内部专用的流量策略。 此设置就相当于告诉 kube-proxy 对于集群内部流量只能使用节点本地的服务端口。

**说明：** 如果某节点上的 Pod 均不提供指定 Service 的服务端点， 即使该 Service 在其他节点上有可用的服务端点， Service 的行为看起来也像是它只有 0 个服务端点（只针对此节点上的 Pod）。

以下示例展示了把 Service 的 `.spec.internalTrafficPolicy` 项设为 `Local` 时， Service 的样子：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app.kubernetes.io/name: MyApp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  internalTrafficPolicy: Local
```

#### 工作原理[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-traffic-policy/#how-it-works)

kube-proxy 基于 `spec.internalTrafficPolicy` 的设置来过滤路由的目标服务端点。 当它的值设为 `Local` 时，只会选择节点本地的服务端点。 当它的值设为 `Cluster` 或缺省时，Kubernetes 会选择所有的服务端点。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-traffic-policy/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 请阅读[拓扑感知提示](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints)
- 请阅读 [Service 的外部流量策略](https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip)
- 遵循[使用 Service 连接到应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)教程
### [使用拓扑键实现拓扑感知的流量路由](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/)
**特性状态：** `Kubernetes v1.21 [deprecated]`

**说明：**

此功能特性，尤其是 Alpha 阶段的 `topologyKeys` API，在 Kubernetes v1.21 版本中已被废弃。Kubernetes v1.21 版本中引入的 [拓扑感知的提示](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/), 提供类似的功能。

服务拓扑（Service Topology）可以让一个服务基于集群的 Node 拓扑进行流量路由。 例如，一个服务可以指定流量是被优先路由到一个和客户端在同一个 Node 或者在同一可用区域的端点。

#### 拓扑感知的流量路由[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#topology-aware-traffic-routing)

默认情况下，发往 `ClusterIP` 或者 `NodePort` 服务的流量可能会被路由到服务的任一后端的地址。 Kubernetes 1.7 允许将“外部”流量路由到接收到流量的节点上的 Pod。对于 `ClusterIP` 服务，无法完成同节点优先的路由，你也无法配置集群优选路由到同一可用区中的端点。 通过在 Service 上配置 `topologyKeys`，你可以基于来源节点和目标节点的标签来定义流量路由策略。

通过对源和目的之间的标签匹配，作为集群操作者的你可以根据节点间彼此“较近”和“较远” 来定义节点集合。你可以基于符合自身需求的任何度量值来定义标签。 例如，在公有云上，你可能更偏向于把流量控制在同一区内，因为区间流量是有费用成本的， 而区内流量则没有。 其它常见需求还包括把流量路由到由 `DaemonSet` 管理的本地 Pod 上，或者把将流量转发到连接在同一机架交换机的节点上，以获得低延时。

#### 使用服务拓扑[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#using-service-topology)

如果集群启用了 `ServiceTopology` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)， 你就可以在 Service 规约中设定 `topologyKeys` 字段，从而控制其流量路由。 此字段是 `Node` 标签的优先顺序字段，将用于在访问这个 `Service` 时对端点进行排序。 流量会被定向到第一个标签值和源 `Node` 标签值相匹配的 `Node`。 如果这个 `Service` 没有匹配的后端 `Node`，那么第二个标签会被使用做匹配， 以此类推，直到没有标签。

如果没有匹配到，流量会被拒绝，就如同这个 `Service` 根本没有后端。 换言之，系统根据可用后端的第一个拓扑键来选择端点。 如果这个字段被配置了而没有后端可以匹配客户端拓扑，那么这个 `Service` 对那个客户端是没有后端的，链接应该是失败的。 这个字段配置为 `"*"` 意味着任意拓扑。 这个通配符值如果使用了，那么只有作为配置值列表中的最后一个才有用。

如果 `topologyKeys` 没有指定或者为空，就没有启用这个拓扑约束。

一个集群中，其 `Node` 的标签被打为其主机名，区域名和地区名。 那么就可以设置 `Service` 的 `topologyKeys` 的值，像下面的做法一样定向流量了。

- 只定向到同一个 `Node` 上的端点，`Node` 上没有端点存在时就失败： 配置 `["kubernetes.io/hostname"]`。
- 偏向定向到同一个 `Node` 上的端点，回退同一区域的端点上，然后是同一地区， 其它情况下就失败：配置 `["kubernetes.io/hostname", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]`。 这或许很有用，例如，数据局部性很重要的情况下。
- 偏向于同一区域，但如果此区域中没有可用的终结点，则回退到任何可用的终结点： 配置 `["topology.kubernetes.io/zone", "*"]`。

#### 约束条件[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#constraints)

- 服务拓扑和 `externalTrafficPolicy=Local` 是不兼容的，所以 `Service` 不能同时使用这两种特性。 但是在同一个集群的不同 `Service` 上是可以分别使用这两种特性的，只要不在同一个 `Service` 上就可以。
    
- 有效的拓扑键目前只有：`kubernetes.io/hostname`、`topology.kubernetes.io/zone` 和 `topology.kubernetes.io/region`，但是未来会推广到其它的 `Node` 标签。
    
- 拓扑键必须是有效的标签，并且最多指定16个。
    
- 通配符：`"*"`，如果要用，则必须是拓扑键值的最后一个值。
    

#### 示例[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#examples)

以下是使用服务拓扑功能的常见示例。

##### 仅节点本地端点[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#only-node-local-endpoints)

仅路由到节点本地端点的一种服务。如果节点上不存在端点，流量则被丢弃：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  topologyKeys:
    - "kubernetes.io/hostname"
```

##### 首选节点本地端点[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#prefer-node-local-endpoints)

首选节点本地端点，如果节点本地端点不存在，则回退到集群范围端点的一种服务：

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  topologyKeys:
    - "kubernetes.io/hostname"
    - "*"
```

##### 仅地域或区域端点[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#only-zonal-or-regional-endpoints)

首选地域端点而不是区域端点的一种服务。 如果以上两种范围内均不存在端点， 流量则被丢弃。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  topologyKeys:
    - "topology.kubernetes.io/zone"
    - "topology.kubernetes.io/region"
```

##### 优先选择节点本地端点、地域端点，然后是区域端点[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#prefer-node-local-zonal-then-regional-endpoints)

优先选择节点本地端点，地域端点，然后是区域端点，最后才是集群范围端点的一种服务。

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 9376
  topologyKeys:
    - "kubernetes.io/hostname"
    - "topology.kubernetes.io/zone"
    - "topology.kubernetes.io/region"
    - "*"
```

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/services-networking/service-topology/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 阅读关于[拓扑感知提示](https://kubernetes.io/zh-cn/docs/concepts/services-networking/topology-aware-hints/)
- 阅读[使用 Service 连接到应用](https://kubernetes.io/zh-cn/docs/tutorials/services/connect-applications-service/)


## 存储

为集群中的 Pods 提供长期和临时存储的方法。

---

### [卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)
Container 中的文件在磁盘上是临时存放的，这给 Container 中运行的较重要的应用程序带来一些问题。 问题之一是当容器崩溃时文件丢失。 kubelet 会重新启动容器，但容器会以干净的状态重启。 第二个问题会在同一 `Pod` 中运行多个容器并共享文件时出现。 Kubernetes [卷（Volume）](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/) 这一抽象概念能够解决这两个问题。

阅读本文前建议你熟悉一下 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods)。

#### 背景[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#background)

Docker 也有[卷（Volume）](https://docs.docker.com/storage/) 的概念，但对它只有少量且松散的管理。 Docker 卷是磁盘上或者另外一个容器内的一个目录。 Docker 提供卷驱动程序，但是其功能非常有限。

Kubernetes 支持很多类型的卷。 [Pod](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/) 可以同时使用任意数目的卷类型。 临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod 的存活期长。 当 Pod 不再存在时，Kubernetes 也会销毁临时卷；不过 Kubernetes 不会销毁持久卷。 对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。

卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。 所采用的特定的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。

使用卷时, 在 `.spec.volumes` 字段中设置为 Pod 提供的卷，并在 `.spec.containers[*].volumeMounts` 字段中声明卷在容器中的挂载位置。 容器中的进程看到的文件系统视图是由它们的[容器镜像](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-image) 的初始内容以及挂载在容器中的卷（如果定义了的话）所组成的。 其中根文件系统同容器镜像的内容相吻合。 任何在该文件系统下的写入操作，如果被允许的话，都会影响接下来容器中进程访问文件系统时所看到的内容。

卷挂载在镜像中的[指定路径](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath)下。 Pod 配置中的每个容器必须独立指定各个卷的挂载位置。

卷不能挂载到其他卷之上（不过存在一种[使用 subPath](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath) 的相关机制），也不能与其他卷有硬链接。

#### 卷类型[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#volume-types)

Kubernetes 支持下列类型的卷：

##### awsElasticBlockStore （已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore)

**特性状态：** `Kubernetes v1.17 [deprecated]`

`awsElasticBlockStore` 卷将 Amazon Web 服务（AWS）[EBS 卷](https://aws.amazon.com/ebs/)挂载到你的 Pod 中。`emptyDir` 在 Pod 被删除时也会一起被删除，但 EBS 卷的内容在删除 Pod 时会被保留，卷只是被卸载掉了。 这意味着 EBS 卷可以预先填充数据，并且该数据可以在 Pod 之间共享。

**说明：**

你在使用 EBS 卷之前必须使用 `aws ec2 create-volume` 命令或者 AWS API 创建该卷。

使用 `awsElasticBlockStore` 卷时有一些限制：

- Pod 运行所在的节点必须是 AWS EC2 实例。
- 这些实例需要与 EBS 卷在相同的地域（Region）和可用区（Availability-Zone）。
- EBS 卷只支持被挂载到单个 EC2 实例上。

###### 创建 AWS EBS 卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#%E5%88%9B%E5%BB%BA-aws-ebs-%E5%8D%B7)

在将 EBS 卷用到 Pod 上之前，你首先要创建它。

```shell
aws ec2 create-volume --availability-zone=eu-west-1a --size=10 --volume-type=gp2
```

确保该区域与你的集群所在的区域相匹配。还要检查卷的大小和 EBS 卷类型都适合你的用途。

###### AWS EBS 配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#aws-ebs-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-ebs
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-ebs
      name: test-volume
  volumes:
  - name: test-volume
    # 此 AWS EBS 卷必须已经存在
    awsElasticBlockStore:
      volumeID: "<volume id>"
      fsType: ext4
```

如果 EBS 卷是分区的，你可以提供可选的字段 `partition: "<partition number>"` 来指定要挂载到哪个分区上。

###### AWS EBS CSI 卷迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#aws-ebs-csi-%E5%8D%B7%E8%BF%81%E7%A7%BB)

**特性状态：** `Kubernetes v1.25 [stable]`

启用 `awsElasticBlockStore` 的 `CSIMigration` 特性后，所有插件操作将从现有的树内插件重定向到 `ebs.csi.aws.com` 容器存储接口（CSI）驱动程序。 为了使用此特性，必须在集群中安装 [AWS EBS CSI 驱动](https://github.com/kubernetes-sigs/aws-ebs-csi-driver)。

###### AWS EBS CSI 迁移结束[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#aws-ebs-csi-%E8%BF%81%E7%A7%BB%E7%BB%93%E6%9D%9F)

**特性状态：** `Kubernetes v1.17 [alpha]`

要禁止控制器管理器和 kubelet 加载 `awsElasticBlockStore` 存储插件， 请将 `InTreePluginAWSUnregister` 标志设置为 `true`。

##### azureDisk （已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azuredisk)

**特性状态：** `Kubernetes v1.19 [deprecated]`

`azureDisk` 卷类型用来在 Pod 上挂载 Microsoft Azure [数据盘（Data Disk）](https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-about-disks-vhds/) 。 若需了解更多详情，请参考 [`azureDisk` 卷插件](https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md)。

###### azureDisk 的 CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azuredisk-csi-migration)

**特性状态：** `Kubernetes v1.24 [stable]`

启用 `azureDisk` 的 `CSIMigration` 特性后，所有插件操作从现有的树内插件重定向到 `disk.csi.azure.com` 容器存储接口（CSI）驱动程序。 为了使用此特性，必须在集群中安装 [Azure 磁盘 CSI 驱动程序](https://github.com/kubernetes-sigs/azuredisk-csi-driver)。

###### azureDisk CSI 迁移完成[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azuredisk-csi-%E8%BF%81%E7%A7%BB%E5%AE%8C%E6%88%90)

**特性状态：** `Kubernetes v1.21 [alpha]`

要禁止控制器管理器和 kubelet 加载 `azureDisk` 存储插件， 请将 `InTreePluginAzureDiskUnregister` 标志设置为 `true`。

##### azureFile （已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azurefile)

**特性状态：** `Kubernetes v1.21 [deprecated]`

`azureFile` 卷类型用来在 Pod 上挂载 Microsoft Azure 文件卷（File Volume）（SMB 2.1 和 3.0）。 更多详情请参考 [`azureFile` 卷插件](https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md)。

###### azureFile CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azurefile-csi-migration)

**特性状态：** `Kubernetes v1.26 [stable]`

启用 `azureFile` 的 `CSIMigration` 特性后，所有插件操作将从现有的树内插件重定向到 `file.csi.azure.com` 容器存储接口（CSI）驱动程序。要使用此特性，必须在集群中安装 [Azure 文件 CSI 驱动程序](https://github.com/kubernetes-sigs/azurefile-csi-driver)， 并且 `CSIMigrationAzureFile` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/) 必须被启用。

Azure 文件 CSI 驱动尚不支持为同一卷设置不同的 fsgroup。 如果 `CSIMigrationAzureFile` 特性被启用，用不同的 fsgroup 来使用同一卷也是不被支持的。

###### azureFile CSI 迁移完成[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azurefile-csi-%E8%BF%81%E7%A7%BB%E5%AE%8C%E6%88%90)

**特性状态：** `Kubernetes v1.21 [alpha]`

要禁止控制器管理器和 kubelet 加载 `azureFile` 存储插件， 请将 `InTreePluginAzureFileUnregister` 标志设置为 `true`。

##### cephfs[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#cephfs)

`cephfs` 卷允许你将现存的 CephFS 卷挂载到 Pod 中。 不像 `emptyDir` 那样会在 Pod 被删除的同时也会被删除，`cephfs` 卷的内容在 Pod 被删除时会被保留，只是卷被卸载了。 这意味着 `cephfs` 卷可以被预先填充数据，且这些数据可以在 Pod 之间共享。同一 `cephfs` 卷可同时被多个写者挂载。

**说明：**

在使用 Ceph 卷之前，你的 Ceph 服务器必须已经运行并将要使用的 share 导出（exported）。

更多信息请参考 [CephFS 示例](https://github.com/kubernetes/examples/tree/master/volumes/cephfs/)。

##### cinder （已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#cinder)

**特性状态：** `Kubernetes v1.18 [deprecated]`

**说明：**

Kubernetes 必须配置了 OpenStack Cloud Provider。

`cinder` 卷类型用于将 OpenStack Cinder 卷挂载到 Pod 中。

###### Cinder 卷示例配置[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#cinder-volume-example-configuration)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-cinder
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-cinder-container
    volumeMounts:
    - mountPath: /test-cinder
      name: test-volume
  volumes:
  - name: test-volume
    # 此 OpenStack 卷必须已经存在
    cinder:
      volumeID: "<volume id>"
      fsType: ext4
```

###### OpenStack CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#openstack-csi-%E8%BF%81%E7%A7%BB)

**特性状态：** `Kubernetes v1.24 [stable]`

自 Kubernetes 1.21 版本起，Cinder 的 `CSIMigration` 特性是默认被启用的。 此特性会将插件的所有操作从现有的树内插件重定向到 `cinder.csi.openstack.org` 容器存储接口（CSI）驱动程序。 为了使用此特性，必须在集群中安装 [OpenStack Cinder CSI 驱动程序](https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md)， 你可以通过设置 `CSIMigrationOpenStack` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/) 为 `false` 来禁止 Cinder CSI 迁移。

要禁止控制器管理器和 kubelet 加载树内 Cinder 插件，你可以启用 `InTreePluginOpenStackUnregister` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。

##### configMap[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#configmap)

[`configMap`](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/) 卷提供了向 Pod 注入配置数据的方法。 ConfigMap 对象中存储的数据可以被 `configMap` 类型的卷引用，然后被 Pod 中运行的容器化应用使用。

引用 configMap 对象时，你可以在卷中通过它的名称来引用。 你可以自定义 ConfigMap 中特定条目所要使用的路径。 下面的配置显示了如何将名为 `log-config` 的 ConfigMap 挂载到名为 `configmap-pod` 的 Pod 中：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-pod
spec:
  containers:
    - name: test
      image: busybox:1.28
      volumeMounts:
        - name: config-vol
          mountPath: /etc/config
  volumes:
    - name: config-vol
      configMap:
        name: log-config
        items:
          - key: log_level
            path: log_level
```

`log-config` ConfigMap 以卷的形式挂载，并且存储在 `log_level` 条目中的所有内容都被挂载到 Pod 的 `/etc/config/log_level` 路径下。 请注意，这个路径来源于卷的 `mountPath` 和 `log_level` 键对应的 `path`。

**说明：**

- 在使用 [ConfigMap](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/) 之前你首先要创建它。
- 容器以 [subPath](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath) 卷挂载方式使用 ConfigMap 时，将无法接收 ConfigMap 的更新。
- 文本数据挂载成文件时采用 UTF-8 字符编码。如果使用其他字符编码形式，可使用 `binaryData` 字段。

##### downwardAPI[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#downwardapi)

`downwardAPI` 卷用于为应用提供 [downward API](https://kubernetes.io/docs/concepts/workloads/pods/downward-api/) 数据。 在这类卷中，所公开的数据以纯文本格式的只读文件形式存在。

**说明：** 容器以 [subPath](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath) 卷挂载方式使用 downward API 时，在字段值更改时将不能接收到它的更新。

更多详细信息请参考[通过文件将 Pod 信息呈现给容器](https://kubernetes.io/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/)。

##### emptyDir[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir)

当 Pod 分派到某个节点上时，`emptyDir` 卷会被创建，并且在 Pod 在该节点上运行期间，卷一直存在。 就像其名称表示的那样，卷最初是空的。 尽管 Pod 中的容器挂载 `emptyDir` 卷的路径可能相同也可能不同，这些容器都可以读写 `emptyDir` 卷中相同的文件。 当 Pod 因为某些原因被从节点上删除时，`emptyDir` 卷中的数据也会被永久删除。

**说明：**

容器崩溃并**不**会导致 Pod 被从节点上移除，因此容器崩溃期间 `emptyDir` 卷中的数据是安全的。

`emptyDir` 的一些用途：

- 缓存空间，例如基于磁盘的归并排序。
- 为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。
- 在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。

`emptyDir.medium` 字段用来控制 `emptyDir` 卷的存储位置。 默认情况下，`emptyDir` 卷存储在该节点所使用的介质上； 此处的介质可以是磁盘、SSD 或网络存储，这取决于你的环境。 你可以将 `emptyDir.medium` 字段设置为 `"Memory"`， 以告诉 Kubernetes 为你挂载 tmpfs（基于 RAM 的文件系统）。 虽然 tmpfs 速度非常快，但是要注意它与磁盘不同：tmpfs 在节点重启时会被清除， 并且你所写入的所有文件都会计入容器的内存消耗，受容器内存限制约束。

你可以通过为默认介质指定大小限制，来限制 `emptyDir` 卷的存储容量。 此存储是从[节点临时存储](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#setting-requests-and-limits-for-local-ephemeral-storage)中分配的。 如果来自其他来源（如日志文件或镜像分层数据）的数据占满了存储，`emptyDir` 可能会在达到此限制之前发生存储容量不足的问题。

**说明：**

当启用 `SizeMemoryBackedVolumes` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)时， 你可以为基于内存提供的卷指定大小。 如果未指定大小，则基于内存的卷的大小为 Linux 主机上内存的 50%。

###### emptyDir 配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /cache
      name: cache-volume
  volumes:
  - name: cache-volume
    emptyDir:
      sizeLimit: 500Mi
```

##### fc (光纤通道)[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#fc)

`fc` 卷类型允许将现有的光纤通道块存储卷挂载到 Pod 中。 可以使用卷配置中的参数 `targetWWNs` 来指定单个或多个目标 WWN（World Wide Names）。 如果指定了多个 WWN，targetWWNs 期望这些 WWN 来自多路径连接。

**说明：**

你必须配置 FC SAN Zoning，以便预先向目标 WWN 分配和屏蔽这些 LUN（卷），这样 Kubernetes 主机才可以访问它们。

更多详情请参考 [FC 示例](https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel)。

##### gcePersistentDisk（已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk)

**特性状态：** `Kubernetes v1.17 [deprecated]`

`gcePersistentDisk` 卷能将谷歌计算引擎 (GCE) [持久盘（PD）](http://cloud.google.com/compute/docs/disks) 挂载到你的 Pod 中。 不像 `emptyDir` 那样会在 Pod 被删除的同时也会被删除，持久盘卷的内容在删除 Pod 时会被保留，卷只是被卸载了。 这意味着持久盘卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

**说明：**

在使用 PD 前，你必须使用 `gcloud` 或者 GCE API 或 UI 创建它。

使用 `gcePersistentDisk` 时有一些限制：

- 运行 Pod 的节点必须是 GCE VM
- 这些 VM 必须和持久盘位于相同的 GCE 项目和区域（zone）

GCE PD 的一个特点是它们可以同时被多个消费者以只读方式挂载。 这意味着你可以用数据集预先填充 PD，然后根据需要并行地在尽可能多的 Pod 中提供该数据集。 不幸的是，PD 只能由单个使用者以读写模式挂载，即不允许同时写入。

在由 ReplicationController 所管理的 Pod 上使用 GCE PD 将会失败，除非 PD 是只读模式或者副本的数量是 0 或 1。

###### 创建 GCE 持久盘（PD）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gce-create-persistent-disk)

在 Pod 中使用 GCE 持久盘之前，你首先要创建它。

```shell
gcloud compute disks create --size=500GB --zone=us-central1-a my-data-disk
```

###### GCE 持久盘配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gce-pd-configuration-example)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: test-volume
    # 此 GCE PD 必须已经存在
    gcePersistentDisk:
      pdName: my-data-disk
      fsType: ext4
```

###### 区域持久盘[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#regional-persistent-disks)

[区域持久盘](https://cloud.google.com/compute/docs/disks/#repds)特性允许你创建能在同一区域的两个可用区中使用的持久盘。 要使用这个特性，必须以持久卷（PersistentVolume）的方式提供卷；直接从 Pod 引用这种卷是不可以的。

###### 手动供应基于区域 PD 的 PersistentVolume[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#manually-provisioning-regional-pd-pv)

使用[为 GCE PD 定义的存储类](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#gce-pd) 可以实现动态供应。在创建 PersistentVolume 之前，你首先要创建 PD。

```shell
gcloud compute disks create --size=500GB my-data-disk
  --region us-central1
  --replica-zones us-central1-a,us-central1-b
```

###### 区域持久盘配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#%E5%8C%BA%E5%9F%9F%E6%8C%81%E4%B9%85%E7%9B%98%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B)

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: test-volume
spec:
  capacity:
    storage: 400Gi
  accessModes:
  - ReadWriteOnce
  gcePersistentDisk:
    pdName: my-data-disk
    fsType: ext4
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        # failure-domain.beta.kubernetes.io/zone 应在 1.21 之前使用
        - key: topology.kubernetes.io/zone
          operator: In
          values:
          - us-central1-a
          - us-central1-b
```

###### GCE CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gce-csi-migration)

**特性状态：** `Kubernetes v1.25 [stable]`

启用 GCE PD 的 `CSIMigration` 特性后，所有插件操作将从现有的树内插件重定向到 `pd.csi.storage.gke.io` 容器存储接口（CSI）驱动程序。 为了使用此特性，必须在集群中上安装 [GCE PD CSI 驱动程序](https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver)。

###### GCE CSI 迁移完成[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gce-csi-%E8%BF%81%E7%A7%BB%E5%AE%8C%E6%88%90)

**特性状态：** `Kubernetes v1.21 [alpha]`

要禁止控制器管理器和 kubelet 加载 `gcePersistentDisk` 存储插件，请将 `InTreePluginGCEUnregister` 标志设置为 `true`。

##### gitRepo (已弃用)[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gitrepo)

**警告：**

`gitRepo` 卷类型已经被废弃。如果需要在容器中提供 git 仓库，请将一个 [EmptyDir](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir) 卷挂载到 InitContainer 中，使用 git 命令完成仓库的克隆操作，然后将 [EmptyDir](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir) 卷挂载到 Pod 的容器中。

`gitRepo` 卷是一个卷插件的例子。 该查卷挂载一个空目录，并将一个 Git 代码仓库克隆到这个目录中供 Pod 使用。

下面给出一个 `gitRepo` 卷的示例：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: server
spec:
  containers:
  - image: nginx
    name: nginx
    volumeMounts:
    - mountPath: /mypath
      name: git-volume
  volumes:
  - name: git-volume
    gitRepo:
      repository: "git@somewhere:me/my-git-repository.git"
      revision: "22f1d8406d464b0c0874075539c1f2e96c253775"
```

##### glusterfs（已移除）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#glusterfs)

Kubernetes 1.26 不包含 `glusterfs` 卷类型。

GlusterFS 树内存储驱动程序在 Kubernetes v1.25 版本中被弃用，然后在 v1.26 版本中被完全移除。

##### hostPath[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath)

**警告：**

HostPath 卷存在许多安全风险，最佳做法是尽可能避免使用 HostPath。 当必须使用 HostPath 卷时，它的范围应仅限于所需的文件或目录，并以只读方式挂载。

如果通过 AdmissionPolicy 限制 HostPath 对特定目录的访问，则必须要求 `volumeMounts` 使用 `readOnly` 挂载以使策略生效。

`hostPath` 卷能将主机节点文件系统上的文件或目录挂载到你的 Pod 中。 虽然这不是大多数 Pod 需要的，但是它为一些应用程序提供了强大的逃生舱。

例如，`hostPath` 的一些用法有：

- 运行一个需要访问 Docker 内部机制的容器；可使用 `hostPath` 挂载 `/var/lib/docker` 路径。
- 在容器中运行 cAdvisor 时，以 `hostPath` 方式挂载 `/sys`。
- 允许 Pod 指定给定的 `hostPath` 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。

除了必需的 `path` 属性之外，你可以选择性地为 `hostPath` 卷指定 `type`。

支持的 `type` 值如下：

| 取值 | 行为 |
| --- | --- |
|  | 空字符串（默认）用于向后兼容，这意味着在安装 hostPath 卷之前不会执行任何检查。 |
| `DirectoryOrCreate` | 如果在给定路径上什么都不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 kubelet 相同的组和属主信息。 |
| `Directory` | 在给定路径上必须存在的目录。 |
| `FileOrCreate` | 如果在给定路径上什么都不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 kubelet 相同的组和所有权。 |
| `File` | 在给定路径上必须存在的文件。 |
| `Socket` | 在给定路径上必须存在的 UNIX 套接字。 |
| `CharDevice` | 在给定路径上必须存在的字符设备。 |
| `BlockDevice` | 在给定路径上必须存在的块设备。 |

当使用这种类型的卷时要小心，因为：

- HostPath 卷可能会暴露特权系统凭据（例如 Kubelet）或特权 API（例如容器运行时套接字），可用于容器逃逸或攻击集群的其他部分。
- 具有相同配置（例如基于同一 PodTemplate 创建）的多个 Pod 会由于节点上文件的不同而在不同节点上有不同的行为。
- 下层主机上创建的文件或目录只能由 root 用户写入。 你需要在[特权容器](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/security-context/)中以 root 身份运行进程，或者修改主机上的文件权限以便容器能够写入 `hostPath` 卷。

###### hostPath 配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath-%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: test-volume
    hostPath:
      # 宿主上目录位置
      path: /data
      # 此字段为可选
      type: Directory
```

**注意：**

`FileOrCreate` 模式不会负责创建文件的父目录。 如果欲挂载的文件的父目录不存在，Pod 启动会失败。 为了确保这种模式能够工作，可以尝试把文件和它对应的目录分开挂载，如 [`FileOrCreate` 配置](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath-fileorcreate-example) 所示。

###### hostPath FileOrCreate 配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath-fileorcreate-example)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-webserver
spec:
  containers:
  - name: test-webserver
    image: registry.k8s.io/test-webserver:latest
    volumeMounts:
    - mountPath: /var/local/aaa
      name: mydir
    - mountPath: /var/local/aaa/1.txt
      name: myfile
  volumes:
  - name: mydir
    hostPath:
      # 确保文件所在目录成功创建。
      path: /var/local/aaa
      type: DirectoryOrCreate
  - name: myfile
    hostPath:
      path: /var/local/aaa/1.txt
      type: FileOrCreate
```

##### iscsi[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#iscsi)

`iscsi` 卷能将 iSCSI (基于 IP 的 SCSI) 卷挂载到你的 Pod 中。 不像 `emptyDir` 那样会在删除 Pod 的同时也会被删除，`iscsi` 卷的内容在删除 Pod 时会被保留，卷只是被卸载。 这意味着 `iscsi` 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

**说明：**

在使用 iSCSI 卷之前，你必须拥有自己的 iSCSI 服务器，并在上面创建卷。

iSCSI 的一个特点是它可以同时被多个用户以只读方式挂载。 这意味着你可以用数据集预先填充卷，然后根据需要在尽可能多的 Pod 上使用它。 不幸的是，iSCSI 卷只能由单个使用者以读写模式挂载。不允许同时写入。

更多详情请参考 [iSCSI 示例](https://github.com/kubernetes/examples/tree/master/volumes/iscsi)。

##### local[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#local)

`local` 卷所代表的是某个被挂载的本地存储设备，例如磁盘、分区或者目录。

`local` 卷只能用作静态创建的持久卷。不支持动态配置。

与 `hostPath` 卷相比，`local` 卷能够以持久和可移植的方式使用，而无需手动将 Pod 调度到节点。系统通过查看 PersistentVolume 的节点亲和性配置，就能了解卷的节点约束。

然而，`local` 卷仍然取决于底层节点的可用性，并不适合所有应用程序。 如果节点变得不健康，那么 `local` 卷也将变得不可被 Pod 访问。使用它的 Pod 将不能运行。 使用 `local` 卷的应用程序必须能够容忍这种可用性的降低，以及因底层磁盘的耐用性特征而带来的潜在的数据丢失风险。

下面是一个使用 `local` 卷和 `nodeAffinity` 的持久卷示例：

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 100Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local:
    path: /mnt/disks/ssd1
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node
```

使用 `local` 卷时，你需要设置 PersistentVolume 对象的 `nodeAffinity` 字段。 Kubernetes 调度器使用 PersistentVolume 的 `nodeAffinity` 信息来将使用 `local` 卷的 Pod 调度到正确的节点。

PersistentVolume 对象的 `volumeMode` 字段可被设置为 "Block" （而不是默认值 "Filesystem"），以将 `local` 卷作为原始块设备暴露出来。

使用 `local` 卷时，建议创建一个 StorageClass 并将其 `volumeBindingMode` 设置为 `WaitForFirstConsumer`。要了解更多详细信息，请参考 [local StorageClass 示例](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#local)。 延迟卷绑定的操作可以确保 Kubernetes 在为 PersistentVolumeClaim 作出绑定决策时，会评估 Pod 可能具有的其他节点约束，例如：如节点资源需求、节点选择器、Pod 亲和性和 Pod 反亲和性。

你可以在 Kubernetes 之外单独运行静态驱动以改进对 local 卷的生命周期管理。 请注意，此驱动尚不支持动态配置。 有关如何运行外部 `local` 卷驱动，请参考 [local 卷驱动用户指南](https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner)。

**说明：**

如果不使用外部静态驱动来管理卷的生命周期，用户需要手动清理和删除 local 类型的持久卷。

##### nfs[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#nfs)

`nfs` 卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。 不像 `emptyDir` 那样会在删除 Pod 的同时也会被删除，`nfs` 卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 `nfs` 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /my-nfs-data
      name: test-volume
  volumes:
  - name: test-volume
    nfs:
      server: my-nfs-server.example.com
      path: /my-nfs-volume
      readOnly: true
```

**说明：**

在使用 NFS 卷之前，你必须运行自己的 NFS 服务器并将目标 share 导出备用。

还需要注意，不能在 Pod spec 中指定 NFS 挂载可选项。 可以选择设置服务端的挂载可选项，或者使用 [/etc/nfsmount.conf](https://man7.org/linux/man-pages/man5/nfsmount.conf.5.html)。 此外，还可以通过允许设置挂载可选项的持久卷挂载 NFS 卷。

如需了解用持久卷挂载 NFS 卷的示例，请参考 [NFS 示例](https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs)。

##### persistentVolumeClaim[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#persistentvolumeclaim)

`persistentVolumeClaim` 卷用来将[持久卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/)（PersistentVolume）挂载到 Pod 中。 持久卷申领（PersistentVolumeClaim）是用户在不知道特定云环境细节的情况下“申领”持久存储（例如 GCE PersistentDisk 或者 iSCSI 卷）的一种方法。

更多详情请参考[持久卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/)。

##### portworxVolume（已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#portworxvolume)

**特性状态：** `Kubernetes v1.25 [deprecated]`

`portworxVolume` 是一个可伸缩的块存储层，能够以超融合（hyperconverged）的方式与 Kubernetes 一起运行。 [Portworx](https://portworx.com/use-case/kubernetes-storage/) 支持对服务器上存储的指纹处理、基于存储能力进行分层以及跨多个服务器整合存储容量。 Portworx 可以以 in-guest 方式在虚拟机中运行，也可以在裸金属 Linux 节点上运行。

`portworxVolume` 类型的卷可以通过 Kubernetes 动态创建，也可以预先配备并在 Pod 内引用。 下面是一个引用预先配备的 Portworx 卷的示例 Pod：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-portworx-volume-pod
spec:
  containers:
  - image: registry.k8s.io/test-webserver
    name: test-container
    volumeMounts:
    - mountPath: /mnt
      name: pxvol
  volumes:
  - name: pxvol
    # 此 Portworx 卷必须已经存在
    portworxVolume:
      volumeID: "pxvol"
      fsType: "<fs-type>"
```

**说明：**

在 Pod 中使用 portworxVolume 之前，你要确保有一个名为 `pxvol` 的 PortworxVolume 存在。

更多详情可以参考 [Portworx 卷](https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md)。

###### Portworx CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#portworx-csi-%E8%BF%81%E7%A7%BB)

**特性状态：** `Kubernetes v1.25 [beta]`

已针对 Portworx 添加 `CSIMigration` 特性，但在 Kubernetes 1.23 中默认禁用，因为它处于 Alpha 状态。 自 v1.25 以来它已进入 Beta 阶段，但默认仍关闭。 它将所有插件操作不再指向树内插件（In-Tree Plugin），转而指向 `pxd.portworx.com` 容器存储接口（Container Storage Interface，CSI）驱动。 [Portworx CSI 驱动程序](https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/)必须安装在集群上。 要启用此特性，需在 kube-controller-manager 和 kubelet 中设置 `CSIMigrationPortworx=true`。

##### projected （投射）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#projected)

投射卷能将若干现有的卷来源映射到同一目录上。更多详情请参考[投射卷](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/)。

##### rbd[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#rbd)

`rbd` 卷允许将 [Rados 块设备](https://docs.ceph.com/en/latest/rbd/)卷挂载到你的 Pod 中。 不像 `emptyDir` 那样会在删除 Pod 的同时也会被删除，`rbd` 卷的内容在删除 Pod 时会被保存，卷只是被卸载。 这意味着 `rbd` 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。

**说明：**

在使用 RBD 之前，你必须安装运行 Ceph。

RBD 的一个特性是它可以同时被多个用户以只读方式挂载。 这意味着你可以用数据集预先填充卷，然后根据需要在尽可能多的 Pod 中并行地使用卷。 不幸的是，RBD 卷只能由单个使用者以读写模式安装。不允许同时写入。

更多详情请参考 [RBD 示例](https://github.com/kubernetes/examples/tree/master/volumes/rbd)。

###### RBD CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#rbd-csi-migration)

**特性状态：** `Kubernetes v1.23 [alpha]`

启用 RBD 的 `CSIMigration` 特性后，所有插件操作从现有的树内插件重定向到 `rbd.csi.ceph.com` [CSI](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi) 驱动程序。 要使用该特性，必须在集群内安装 [Ceph CSI 驱动](https://github.com/ceph/ceph-csi)，并启用 `csiMigrationRBD` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。 （请注意，`csiMigrationRBD` 标志已在 v1.24 版本中移除且替换为 `CSIMigrationRBD`。）

**说明：**

作为一位管理存储的 Kubernetes 集群操作者，在尝试迁移到 RBD CSI 驱动前，你必须完成下列先决事项：

- 你必须在集群中安装 v3.5.0 或更高版本的 Ceph CSI 驱动（`rbd.csi.ceph.com`）。
- 因为 `clusterID` 是 CSI 驱动程序必需的参数，而树内存储类又将 `monitors` 作为一个必需的参数，所以 Kubernetes 存储管理者需要根据 `monitors` 的哈希值（例：`#echo -n '<monitors_string>' | md5sum`）来创建 `clusterID`，并保持该 `monitors` 存在于该 `clusterID` 的配置中。
- 同时，如果树内存储类的 `adminId` 的值不是 `admin`，那么其 `adminSecretName` 就需要被修改成 `adminId` 参数的 base64 编码值。

##### secret[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#secret)

`secret` 卷用来给 Pod 传递敏感信息，例如密码。你可以将 Secret 存储在 Kubernetes API 服务器上，然后以文件的形式挂载到 Pod 中，无需直接与 Kubernetes 耦合。 `secret` 卷由 tmpfs（基于 RAM 的文件系统）提供存储，因此它们永远不会被写入非易失性（持久化的）存储器。

**说明：**

使用前你必须在 Kubernetes API 中创建 Secret。

**说明：**

容器以 [`subPath`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath) 卷挂载方式挂载 Secret 时，将感知不到 Secret 的更新。

更多详情请参考[配置 Secrets](https://kubernetes.io/zh-cn/docs/concepts/configuration/secret/)。

##### vsphereVolume（已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#vspherevolume)

**说明：**

建议你改用 vSphere CSI 树外驱动程序。

`vsphereVolume` 用来将 vSphere VMDK 卷挂载到你的 Pod 中。 在卸载卷时，卷的内容会被保留。 vSphereVolume 卷类型支持 VMFS 和 VSAN 数据仓库。

进一步信息可参考 [vSphere 卷](https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere)。

###### vSphere CSI 迁移[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#vsphere-csi-migration)

**特性状态：** `Kubernetes v1.26 [stable]`

在 Kubernetes 1.26 中，对树内 `vsphereVolume` 类的所有操作都会被重定向至 `csi.vsphere.vmware.com` [CSI](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi) 驱动程序。

[vSphere CSI 驱动](https://github.com/kubernetes-sigs/vsphere-csi-driver)必须安装到集群上。 你可以在 VMware 的文档页面[迁移树内 vSphere 卷插件到 vSphere 容器存储插件](https://docs.vmware.com/en/VMware-vSphere-Container-Storage-Plug-in/2.0/vmware-vsphere-csp-getting-started/GUID-968D421F-D464-4E22-8127-6CB9FF54423F.html) 中找到有关如何迁移树内 `vsphereVolume` 的其他建议。 如果未安装 vSphere CSI 驱动程序，则无法对由树内 `vsphereVolume` 类型创建的 PV 执行卷操作。

你必须运行 vSphere 7.0u2 或更高版本才能迁移到 vSphere CSI 驱动程序。

如果你正在运行 Kubernetes v1.26，请查阅该 Kubernetes 版本的文档。

**说明：**

vSphere CSI 驱动不支持内置 `vsphereVolume` 的以下 StorageClass 参数：

- `diskformat`
- `hostfailurestotolerate`
- `forceprovisioning`
- `cachereservation`
- `diskstripes`
- `objectspacereservation`
- `iopslimit`

使用这些参数创建的现有卷将被迁移到 vSphere CSI 驱动，不过使用 vSphere CSI 驱动所创建的新卷都不会理会这些参数。

###### vSphere CSI 迁移完成[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#vsphere-csi-migration-complete)

**特性状态：** `Kubernetes v1.19 [beta]`

为了避免控制器管理器和 kubelet 加载 `vsphereVolume` 插件，你需要将 `InTreePluginvSphereUnregister` 特性设置为 `true`。你还必须在所有工作节点上安装 `csi.vsphere.vmware.com` [CSI](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi) 驱动。

#### 使用 subPath[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath)

有时，在单个 Pod 中共享卷以供多方使用是很有用的。 `volumeMounts.subPath` 属性可用于指定所引用的卷内的子路径，而不是其根路径。

下面例子展示了如何配置某包含 LAMP 堆栈（Linux Apache MySQL PHP）的 Pod 使用同一共享卷。 此示例中的 `subPath` 配置不建议在生产环境中使用。 PHP 应用的代码和相关数据映射到卷的 `html` 文件夹，MySQL 数据库存储在卷的 `mysql` 文件夹中：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-lamp-site
spec:
    containers:
    - name: mysql
      image: mysql
      env:
      - name: MYSQL_ROOT_PASSWORD
        value: "rootpasswd"
      volumeMounts:
      - mountPath: /var/lib/mysql
        name: site-data
        subPath: mysql
    - name: php
      image: php:7.0-apache
      volumeMounts:
      - mountPath: /var/www/html
        name: site-data
        subPath: html
    volumes:
    - name: site-data
      persistentVolumeClaim:
        claimName: my-lamp-site-data
```

##### 使用带有扩展环境变量的 subPath[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath-expanded-environment)

**特性状态：** `Kubernetes v1.17 [stable]`

使用 `subPathExpr` 字段可以基于 downward API 环境变量来构造 `subPath` 目录名。 `subPath` 和 `subPathExpr` 属性是互斥的。

在这个示例中，`Pod` 使用 `subPathExpr` 来 `hostPath` 卷 `/var/log/pods` 中创建目录 `pod1`。 `hostPath` 卷采用来自 `downwardAPI` 的 Pod 名称生成目录名。 宿主目录 `/var/log/pods/pod1` 被挂载到容器的 `/logs` 中。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod1
spec:
  containers:
  - name: container1
    env:
    - name: POD_NAME
      valueFrom:
        fieldRef:
          apiVersion: v1
          fieldPath: metadata.name
    image: busybox:1.28
    command: [ "sh", "-c", "while [ true ]; do echo 'Hello'; sleep 10; done | tee -a /logs/hello.txt" ]
    volumeMounts:
    - name: workdir1
      mountPath: /logs
      # 包裹变量名的是小括号，而不是大括号
      subPathExpr: $(POD_NAME)
  restartPolicy: Never
  volumes:
  - name: workdir1
    hostPath:
      path: /var/log/pods
```

#### 资源[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#resources)

`emptyDir` 卷的存储介质（例如磁盘、SSD 等）是由保存 kubelet 数据的根目录（通常是 `/var/lib/kubelet`）的文件系统的介质确定。 Kubernetes 对 `emptyDir` 卷或者 `hostPath` 卷可以消耗的空间没有限制，容器之间或 Pod 之间也没有隔离。

要了解如何使用资源规约来请求空间， 可参考[如何管理资源](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/)。

#### 树外（Out-of-Tree）卷插件[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#out-of-tree-volume-plugins)

Out-of-Tree 卷插件包括[容器存储接口（CSI）](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi)和 FlexVolume（已弃用）。它们使存储供应商能够创建自定义存储插件，而无需将插件源码添加到 Kubernetes 代码仓库。

以前，所有卷插件（如上面列出的卷类型）都是“树内（In-Tree）”的。 “树内”插件是与 Kubernetes 的核心组件一同构建、链接、编译和交付的。 这意味着向 Kubernetes 添加新的存储系统（卷插件）需要将代码合并到 Kubernetes 核心代码库中。

CSI 和 FlexVolume 都允许独立于 Kubernetes 代码库开发卷插件，并作为扩展部署（安装）在 Kubernetes 集群上。

对于希望创建树外（Out-Of-Tree）卷插件的存储供应商，请参考 [卷插件常见问题](https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md)。

##### CSI[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi)

[容器存储接口](https://github.com/container-storage-interface/spec/blob/master/spec.md) (CSI) 为容器编排系统（如 Kubernetes）定义标准接口，以将任意存储系统暴露给它们的容器工作负载。

更多详情请阅读 [CSI 设计方案](https://git.k8s.io/design-proposals-archive/storage/container-storage-interface.md)。

**说明：**

Kubernetes v1.13 废弃了对 CSI 规范版本 0.2 和 0.3 的支持，并将在以后的版本中删除。

**说明：**

CSI 驱动可能并非兼容所有的 Kubernetes 版本。 请查看特定 CSI 驱动的文档，以了解各个 Kubernetes 版本所支持的部署步骤以及兼容性列表。

一旦在 Kubernetes 集群上部署了 CSI 兼容卷驱动程序，用户就可以使用 `csi` 卷类型来挂接、挂载 CSI 驱动所提供的卷。

`csi` 卷可以在 Pod 中以三种方式使用：

- 通过 PersistentVolumeClaim(#persistentvolumeclaim) 对象引用
- 使用[一般性的临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes)
- 使用 [CSI 临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes)， 前提是驱动支持这种用法

存储管理员可以使用以下字段来配置 CSI 持久卷：

- `driver`：指定要使用的卷驱动名称的字符串值。 这个值必须与 CSI 驱动程序在 `GetPluginInfoResponse` 中返回的值相对应；该接口定义在 [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo)中。 Kubernetes 使用所给的值来标识要调用的 CSI 驱动程序；CSI 驱动程序也使用该值来辨识哪些 PV 对象属于该 CSI 驱动程序。

- `volumeHandle`：唯一标识卷的字符串值。 该值必须与 CSI 驱动在 `CreateVolumeResponse` 的 `volume_id` 字段中返回的值相对应；接口定义在 [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume) 中。 在所有对 CSI 卷驱动程序的调用中，引用该 CSI 卷时都使用此值作为 `volume_id` 参数。

- `readOnly`：一个可选的布尔值，指示通过 `ControllerPublished` 关联该卷时是否设置该卷为只读。默认值是 false。 该值通过 `ControllerPublishVolumeRequest` 中的 `readonly` 字段传递给 CSI 驱动。

- `fsType`：如果 PV 的 `VolumeMode` 为 `Filesystem`，那么此字段指定挂载卷时应该使用的文件系统。 如果卷尚未格式化，并且支持格式化，此值将用于格式化卷。 此值可以通过 `ControllerPublishVolumeRequest`、`NodeStageVolumeRequest` 和 `NodePublishVolumeRequest` 的 `VolumeCapability` 字段传递给 CSI 驱动。

- `volumeAttributes`：一个字符串到字符串的映射表，用来设置卷的静态属性。 该映射必须与 CSI 驱动程序返回的 `CreateVolumeResponse` 中的 `volume.attributes` 字段的映射相对应； [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume)中有相应的定义。 该映射通过`ControllerPublishVolumeRequest`、`NodeStageVolumeRequest`、和 `NodePublishVolumeRequest` 中的 `volume_context` 字段传递给 CSI 驱动。

- `controllerPublishSecretRef`：对包含敏感信息的 Secret 对象的引用； 该敏感信息会被传递给 CSI 驱动来完成 CSI `ControllerPublishVolume` 和 `ControllerUnpublishVolume` 调用。 此字段是可选的；在不需要 Secret 时可以是空的。 如果 Secret 包含多个 Secret 条目，则所有的 Secret 条目都会被传递。

- `nodeExpandSecretRef`：对包含敏感信息的 Secret 对象的引用， 该信息会传递给 CSI 驱动以完成 CSI `NodeExpandVolume` 调用。 此字段是可选的，如果不需要 Secret，则可能是空的。 如果 Secret 包含多个 Secret 条目，则传递所有 Secret 条目。 当你为节点初始化的卷扩展配置 Secret 数据时，kubelet 会通过 `NodeExpandVolume()` 调用将该数据传递给 CSI 驱动。 为了使用 `nodeExpandSecretRef` 字段，你的集群应运行 Kubernetes 1.25 或更高版本， 并且你必须为每个 kube-apiserver 和每个节点上的 kubelet 启用名为 `CSINodeExpandSecret` 的[特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。 在节点初始化的存储大小调整操作期间，你还必须使用支持或需要 Secret 数据的 CSI 驱动。

- `nodePublishSecretRef`：对包含敏感信息的 Secret 对象的引用。 该信息传递给 CSI 驱动来完成 CSI `NodePublishVolume` 调用。 此字段是可选的，如果不需要 Secret，则可能是空的。 如果 Secret 对象包含多个 Secret 条目，则传递所有 Secret 条目。

- `nodeStageSecretRef`：对包含敏感信息的 Secret 对象的引用， 该信息会传递给 CSI 驱动以完成 CSI `NodeStageVolume` 调用。 此字段是可选的，如果不需要 Secret，则可能是空的。 如果 Secret 包含多个 Secret 条目，则传递所有 Secret 条目。

###### CSI 原始块卷支持[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi-raw-block-volume-support)

**特性状态：** `Kubernetes v1.18 [stable]`

具有外部 CSI 驱动程序的供应商能够在 Kubernetes 工作负载中实现原始块卷支持。

你可以和以前一样， 安装自己的[带有原始块卷支持的 PV/PVC](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#raw-block-volume-support)， 采用 CSI 对此过程没有影响。

###### CSI 临时卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi-ephemeral-volumes)

**特性状态：** `Kubernetes v1.25 [stable]`

你可以直接在 Pod 规约中配置 CSI 卷。采用这种方式配置的卷都是临时卷， 无法在 Pod 重新启动后继续存在。 进一步的信息可参阅[临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes)。

有关如何开发 CSI 驱动的更多信息，请参考 [kubernetes-csi 文档](https://kubernetes-csi.github.io/docs/)。

###### Windows CSI 代理[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#windows-csi-proxy)

**特性状态：** `Kubernetes v1.22 [stable]`

CSI 节点插件需要执行多种特权操作，例如扫描磁盘设备和挂载文件系统等。 这些操作在每个宿主操作系统上都是不同的。对于 Linux 工作节点而言，容器化的 CSI 节点插件通常部署为特权容器。对于 Windows 工作节点而言，容器化 CSI 节点插件的特权操作是通过 [csi-proxy](https://github.com/kubernetes-csi/csi-proxy) 来支持的。csi-proxy 是一个由社区管理的、独立的可执行二进制文件， 需要被预安装到每个 Windows 节点上。

要了解更多的细节，可以参考你要部署的 CSI 插件的部署指南。

###### 从树内插件迁移到 CSI 驱动程序[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#migrating-to-csi-drivers-from-in-tree-plugins)

**特性状态：** `Kubernetes v1.25 [stable]`

`CSIMigration` 特性针对现有树内插件的操作会被定向到相应的 CSI 插件（应已安装和配置）。 因此，操作员在过渡到取代树内插件的 CSI 驱动时，无需对现有存储类、PV 或 PVC（指树内插件）进行任何配置更改。

所支持的操作和特性包括：配备（Provisioning）/删除、挂接（Attach）/解挂（Detach）、 挂载（Mount）/卸载（Unmount）和调整卷大小。

上面的[卷类型](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#volume-types)节列出了支持 `CSIMigration` 并已实现相应 CSI 驱动程序的树内插件。

下面是支持 Windows 节点上持久性存储的树内插件：

- [`awsElasticBlockStore`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore)
- [`azureDisk`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azuredisk)
- [`azureFile`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azurefile)
- [`gcePersistentDisk`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk)
- [`vsphereVolume`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#vspherevolume)

##### flexVolume（已弃用）[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#flexvolume)

**特性状态：** `Kubernetes v1.23 [deprecated]`

FlexVolume 是一个使用基于 exec 的模型来与驱动程序对接的树外插件接口。 用户必须在每个节点上的预定义卷插件路径中安装 FlexVolume 驱动程序可执行文件，在某些情况下，控制平面节点中也要安装。

Pod 通过 `flexvolume` 树内插件与 FlexVolume 驱动程序交互。 更多详情请参考 FlexVolume [README](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme) 文档。

下面的 FlexVolume [插件](https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows) 以 PowerShell 脚本的形式部署在宿主系统上，支持 Windows 节点：

- [SMB](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd)
- [iSCSI](https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd)

**说明：**

FlexVolume 已被弃用。推荐使用树外 CSI 驱动来将外部存储整合进 Kubernetes。

FlexVolume 驱动的维护者应开发一个 CSI 驱动并帮助用户从 FlexVolume 驱动迁移到 CSI。 FlexVolume 用户应迁移工作负载以使用对等的 CSI 驱动。

#### 挂载卷的传播[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#mount-propagation)

挂载卷的传播能力允许将容器安装的卷共享到同一 Pod 中的其他容器，甚至共享到同一节点上的其他 Pod。

卷的挂载传播特性由 `Container.volumeMounts` 中的 `mountPropagation` 字段控制。 它的值包括：

- `None` - 此卷挂载将不会感知到主机后续在此卷或其任何子目录上执行的挂载变化。 类似的，容器所创建的卷挂载在主机上是不可见的。这是默认模式。
    
    该模式等同于 [`mount(8)`](https://man7.org/linux/man-pages/man8/mount.8.html)中描述的 `rprivate` 挂载传播选项。
    
    然而，当 `rprivate` 传播选项不适用时，CRI 运行时可以转为选择 `rslave` 挂载传播选项 （即 `HostToContainer`）。当挂载源包含 Docker 守护进程的根目录（`/var/lib/docker`）时， cri-dockerd (Docker) 已知可以选择 `rslave` 挂载传播选项。 。
    

- `HostToContainer` - 此卷挂载将会感知到主机后续针对此卷或其任何子目录的挂载操作。
    
    换句话说，如果主机在此挂载卷中挂载任何内容，容器将能看到它被挂载在那里。
    
    类似的，配置了 `Bidirectional` 挂载传播选项的 Pod 如果在同一卷上挂载了内容，挂载传播设置为 `HostToContainer` 的容器都将能看到这一变化。
    
    该模式等同于 [`mount(8)`](https://man7.org/linux/man-pages/man8/mount.8.html)中描述的 `rslave` 挂载传播选项。
    

- `Bidirectional` - 这种卷挂载和 `HostToContainer` 挂载表现相同。 另外，容器创建的卷挂载将被传播回至主机和使用同一卷的所- 有 Pod 的所有容器。
    
    该模式等同于 [`mount(8)`](https://man7.org/linux/man-pages/man8/mount.8.html)中描述的 `rshared` 挂载传播选项。
    
    **警告：**
    
    `Bidirectional` 形式的挂载传播可能比较危险。 它可以破坏主机操作系统，因此它只被允许在特权容器中使用。 强烈建议你熟悉 Linux 内核行为。 此外，由 Pod 中的容器创建的任何卷挂载必须在终止时由容器销毁（卸载）。
    

##### 配置[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#configuration)

在某些部署环境中，挂载传播正常工作前，必须在 Docker 中正确配置挂载共享（mount share），如下所示。

编辑你的 Docker `systemd` 服务文件，按下面的方法设置 `MountFlags`：

```shell
MountFlags=shared
```

或者，如果存在 `MountFlags=slave` 就删除掉。然后重启 Docker 守护进程：

```shell
sudo systemctl daemon-reload
sudo systemctl restart docker
```

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

参考[使用持久卷部署 WordPress 和 MySQL](https://kubernetes.io/zh-cn/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/) 示例。
### [持久卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/)
本文描述 Kubernetes 中的**持久卷（Persistent Volume）** 。 建议先熟悉[卷（Volume）](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)的概念。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#introduction)

存储的管理是一个与计算实例的管理完全不同的问题。 PersistentVolume 子系统为用户和管理员提供了一组 API， 将存储如何制备的细节从其如何被使用中抽象出来。 为了实现这点，我们引入了两个新的 API 资源：PersistentVolume 和 PersistentVolumeClaim。

**持久卷（PersistentVolume，PV）** 是集群中的一块存储，可以由管理员事先制备， 或者使用[存储类（Storage Class）](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)来动态制备。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样， 也是使用卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。 此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。

**持久卷申领（PersistentVolumeClaim，PVC）** 表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载，参见[访问模式](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#access-modes)）。

尽管 PersistentVolumeClaim 允许用户消耗抽象的存储资源， 常见的情况是针对不同的问题用户需要的是具有不同属性（如，性能）的 PersistentVolume 卷。 集群管理员需要能够提供不同性质的 PersistentVolume， 并且这些 PV 卷之间的差别不仅限于卷大小和访问模式，同时又不能将卷是如何实现的这些细节暴露给用户。 为了满足这类需求，就有了**存储类（StorageClass）** 资源。

参见[基于运行示例的详细演练](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/)。

#### 卷和申领的生命周期[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#lifecycle-of-a-volume-and-claim)

PV 卷是集群中的资源。PVC 申领是对这些资源的请求，也被用来执行对资源的申领检查。 PV 卷和 PVC 申领之间的互动遵循如下生命周期：

##### 制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#provisioning)

PV 卷的制备有两种方式：静态制备或动态制备。

###### 静态制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#static)

集群管理员创建若干 PV 卷。这些卷对象带有真实存储的细节信息， 并且对集群用户可用（可见）。PV 卷对象存在于 Kubernetes API 中，可供用户消费（使用）。

###### 动态制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#dynamic)

如果管理员所创建的所有静态 PV 卷都无法与用户的 PersistentVolumeClaim 匹配， 集群可以尝试为该 PVC 申领动态制备一个存储卷。 这一制备操作是基于 StorageClass 来实现的：PVC 申领必须请求某个 [存储类](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)， 同时集群管理员必须已经创建并配置了该类，这样动态制备卷的动作才会发生。 如果 PVC 申领指定存储类为 `""`，则相当于为自身禁止使用动态制备的卷。

为了基于存储类完成动态的存储制备，集群管理员需要在 API 服务器上启用 `DefaultStorageClass` [准入控制器](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass)。 举例而言，可以通过保证 `DefaultStorageClass` 出现在 API 服务器组件的 `--enable-admission-plugins` 标志值中实现这点；该标志的值可以是逗号分隔的有序列表。 关于 API 服务器标志的更多信息，可以参考 [kube-apiserver](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/) 文档。

##### 绑定[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#binding)

用户创建一个带有特定存储容量和特定访问模式需求的 PersistentVolumeClaim 对象； 在动态制备场景下，这个 PVC 对象可能已经创建完毕。 主控节点中的控制回路监测新的 PVC 对象，寻找与之匹配的 PV 卷（如果可能的话）， 并将二者绑定到一起。 如果为了新的 PVC 申领动态制备了 PV 卷，则控制回路总是将该 PV 卷绑定到这一 PVC 申领。 否则，用户总是能够获得他们所请求的资源，只是所获得的 PV 卷可能会超出所请求的配置。 一旦绑定关系建立，则 PersistentVolumeClaim 绑定就是排他性的， 无论该 PVC 申领是如何与 PV 卷建立的绑定关系。 PVC 申领与 PV 卷之间的绑定是一种一对一的映射，实现上使用 ClaimRef 来记述 PV 卷与 PVC 申领间的双向绑定关系。

如果找不到匹配的 PV 卷，PVC 申领会无限期地处于未绑定状态。 当与之匹配的 PV 卷可用时，PVC 申领会被绑定。 例如，即使某集群上制备了很多 50 Gi 大小的 PV 卷，也无法与请求 100 Gi 大小的存储的 PVC 匹配。当新的 100 Gi PV 卷被加入到集群时， 该 PVC 才有可能被绑定。

##### 使用[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#using)

Pod 将 PVC 申领当做存储卷来使用。集群会检视 PVC 申领，找到所绑定的卷， 并为 Pod 挂载该卷。对于支持多种访问模式的卷， 用户要在 Pod 中以卷的形式使用申领时指定期望的访问模式。

一旦用户有了申领对象并且该申领已经被绑定， 则所绑定的 PV 卷在用户仍然需要它期间一直属于该用户。 用户通过在 Pod 的 `volumes` 块中包含 `persistentVolumeClaim` 节区来调度 Pod，访问所申领的 PV 卷。 相关细节可参阅[使用申领作为卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#claims-as-volumes)。

##### 保护使用中的存储对象[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection)

保护使用中的存储对象（Storage Object in Use Protection） 这一功能特性的目的是确保仍被 Pod 使用的 PersistentVolumeClaim（PVC） 对象及其所绑定的 PersistentVolume（PV）对象在系统中不会被删除，因为这样做可能会引起数据丢失。

**说明：**

当使用某 PVC 的 Pod 对象仍然存在时，认为该 PVC 仍被此 Pod 使用。

如果用户删除被某 Pod 使用的 PVC 对象，该 PVC 申领不会被立即移除。 PVC 对象的移除会被推迟，直至其不再被任何 Pod 使用。 此外，如果管理员删除已绑定到某 PVC 申领的 PV 卷，该 PV 卷也不会被立即移除。 PV 对象的移除也要推迟到该 PV 不再绑定到 PVC。

你可以看到当 PVC 的状态为 `Terminating` 且其 `Finalizers` 列表中包含 `kubernetes.io/pvc-protection` 时，PVC 对象是处于被保护状态的。

```shell
kubectl describe pvc hostpath
```

```
Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        <none>
Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath
               volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath
Finalizers:    [kubernetes.io/pvc-protection]
...
```

你也可以看到当 PV 对象的状态为 `Terminating` 且其 `Finalizers` 列表中包含 `kubernetes.io/pv-protection` 时，PV 对象是处于被保护状态的。

```shell
kubectl describe pv task-pv-volume
```

```
Name:            task-pv-volume
Labels:          type=local
Annotations:     <none>
Finalizers:      [kubernetes.io/pv-protection]
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath (bare host directory volume)
    Path:          /tmp/data
    HostPathType:
Events:            <none>
```

##### 回收（Reclaiming）[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#reclaiming)

当用户不再使用其存储卷时，他们可以从 API 中将 PVC 对象删除， 从而允许该资源被回收再利用。PersistentVolume 对象的回收策略告诉集群， 当其被从申领中释放时如何处理该数据卷。 目前，数据卷可以被 Retained（保留）、Recycled（回收）或 Deleted（删除）。

###### 保留（Retain）[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#retain)

回收策略 `Retain` 使得用户可以手动回收资源。当 PersistentVolumeClaim 对象被删除时，PersistentVolume 卷仍然存在，对应的数据卷被视为"已释放（released）"。 由于卷上仍然存在这前一申领人的数据，该卷还不能用于其他申领。 管理员可以通过下面的步骤来手动回收该卷：

1. 删除 PersistentVolume 对象。与之相关的、位于外部基础设施中的存储资产 （例如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷）在 PV 删除之后仍然存在。
2. 根据情况，手动清除所关联的存储资产上的数据。
3. 手动删除所关联的存储资产。

如果你希望重用该存储资产，可以基于存储资产的定义创建新的 PersistentVolume 卷对象。

###### 删除（Delete）[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#delete)

对于支持 `Delete` 回收策略的卷插件，删除动作会将 PersistentVolume 对象从 Kubernetes 中移除，同时也会从外部基础设施（如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷）中移除所关联的存储资产。 动态制备的卷会继承[其 StorageClass 中设置的回收策略](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#reclaim-policy)， 该策略默认为 `Delete`。管理员需要根据用户的期望来配置 StorageClass； 否则 PV 卷被创建之后必须要被编辑或者修补。 参阅[更改 PV 卷的回收策略](https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/change-pv-reclaim-policy/)。

###### 回收（Recycle）[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#recycle)

**警告：**

回收策略 `Recycle` 已被废弃。取而代之的建议方案是使用动态制备。

如果下层的卷插件支持，回收策略 `Recycle` 会在卷上执行一些基本的擦除 （`rm -rf /thevolume/*`）操作，之后允许该卷用于新的 PVC 申领。

不过，管理员可以按[参考资料](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/)中所述， 使用 Kubernetes 控制器管理器命令行参数来配置一个定制的回收器（Recycler） Pod 模板。此定制的回收器 Pod 模板必须包含一个 `volumes` 规约，如下例所示：

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pv-recycler
  namespace: default
spec:
  restartPolicy: Never
  volumes:
  - name: vol
    hostPath:
      path: /any/path/it/will/be/replaced
  containers:
  - name: pv-recycler
    image: "registry.k8s.io/busybox"
    command: ["/bin/sh", "-c", "test -e /scrub && rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  && test -z \"$(ls -A /scrub)\" || exit 1"]
    volumeMounts:
    - name: vol
      mountPath: /scrub
```

定制回收器 Pod 模板中在 `volumes` 部分所指定的特定路径要替换为正被回收的卷的路径。

##### PersistentVolume 删除保护 finalizer[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolume-deletion-protection-finalizer)

**特性状态：** `Kubernetes v1.23 [alpha]`

可以在 PersistentVolume 上添加终结器（Finalizer）， 以确保只有在删除对应的存储后才删除具有 `Delete` 回收策略的 PersistentVolume。

新引入的 `kubernetes.io/pv-controller` 和 `external-provisioner.volume.kubernetes.io/finalizer` 终结器仅会被添加到动态制备的卷上。

终结器 `kubernetes.io/pv-controller` 会被添加到树内插件卷上。 下面是一个例子：

```shell
kubectl describe pv pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
```

```none
Name:            pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
Labels:          <none>
Annotations:     kubernetes.io/createdby: vsphere-volume-dynamic-provisioner
                 pv.kubernetes.io/bound-by-controller: yes
                 pv.kubernetes.io/provisioned-by: kubernetes.io/vsphere-volume
Finalizers:      [kubernetes.io/pv-protection kubernetes.io/pv-controller]
StorageClass:    vcp-sc
Status:          Bound
Claim:           default/vcp-pvc-1
Reclaim Policy:  Delete
Access Modes:    RWO
VolumeMode:      Filesystem
Capacity:        1Gi
Node Affinity:   <none>
Message:         
Source:
    Type:               vSphereVolume (a Persistent Disk resource in vSphere)
    VolumePath:         [vsanDatastore] d49c4a62-166f-ce12-c464-020077ba5d46/kubernetes-dynamic-pvc-74a498d6-3929-47e8-8c02-078c1ece4d78.vmdk
    FSType:             ext4
    StoragePolicyName:  vSAN Default Storage Policy
Events:                 <none>
```

终结器 `external-provisioner.volume.kubernetes.io/finalizer` 会被添加到 CSI 卷上。下面是一个例子：

```none
Name:            pvc-2f0bab97-85a8-4552-8044-eb8be45cf48d
Labels:          <none>
Annotations:     pv.kubernetes.io/provisioned-by: csi.vsphere.vmware.com
Finalizers:      [kubernetes.io/pv-protection external-provisioner.volume.kubernetes.io/finalizer]
StorageClass:    fast
Status:          Bound
Claim:           demo-app/nginx-logs
Reclaim Policy:  Delete
Access Modes:    RWO
VolumeMode:      Filesystem
Capacity:        200Mi
Node Affinity:   <none>
Message:         
Source:
    Type:              CSI (a Container Storage Interface (CSI) volume source)
    Driver:            csi.vsphere.vmware.com
    FSType:            ext4
    VolumeHandle:      44830fa8-79b4-406b-8b58-621ba25353fd
    ReadOnly:          false
    VolumeAttributes:      storage.kubernetes.io/csiProvisionerIdentity=1648442357185-8081-csi.vsphere.vmware.com
                           type=vSphere CNS Block Volume
Events:                <none>
```

当为特定的树内卷插件启用了 `CSIMigration{provider}` 特性标志时，`kubernetes.io/pv-controller` 终结器将被替换为 `external-provisioner.volume.kubernetes.io/finalizer` 终结器。

##### 预留 PersistentVolume[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#reserving-a-persistentvolume)

控制平面可以在集群中[将 PersistentVolumeClaims 绑定到匹配的 PersistentVolumes](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#binding)。 但是，如果你希望 PVC 绑定到特定 PV，则需要预先绑定它们。

通过在 PersistentVolumeClaim 中指定 PersistentVolume，你可以声明该特定 PV 与 PVC 之间的绑定关系。如果该 PersistentVolume 存在且未被通过其 `claimRef` 字段预留给 PersistentVolumeClaim，则该 PersistentVolume 会和该 PersistentVolumeClaim 绑定到一起。

绑定操作不会考虑某些卷匹配条件是否满足，包括节点亲和性等等。 控制面仍然会检查[存储类](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)、 访问模式和所请求的存储尺寸都是合法的。

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: foo-pvc
  namespace: foo
spec:
  storageClassName: "" # 此处须显式设置空字符串，否则会被设置为默认的 StorageClass
  volumeName: foo-pv
  ...
```

此方法无法对 PersistentVolume 的绑定特权做出任何形式的保证。 如果有其他 PersistentVolumeClaim 可以使用你所指定的 PV， 则你应该首先预留该存储卷。你可以将 PV 的 `claimRef` 字段设置为相关的 PersistentVolumeClaim 以确保其他 PVC 不会绑定到该 PV 卷。

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: foo-pv
spec:
  storageClassName: ""
  claimRef:
    name: foo-pvc
    namespace: foo
  ...
```

如果你想要使用 `claimPolicy` 属性设置为 `Retain` 的 PersistentVolume 卷时， 包括你希望复用现有的 PV 卷时，这点是很有用的

##### 扩充 PVC 申领[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims)

**特性状态：** `Kubernetes v1.24 [stable]`

现在，对扩充 PVC 申领的支持默认处于被启用状态。你可以扩充以下类型的卷：

- azureDisk
- azureFile
- awsElasticBlockStore
- cinder （已弃用）
- [csi](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi)
- flexVolume （已弃用）
- gcePersistentDisk
- rbd
- portworxVolume

只有当 PVC 的存储类中将 `allowVolumeExpansion` 设置为 true 时，你才可以扩充该 PVC 申领。

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: example-vol-default
provisioner: vendor-name.example/magicstorage
parameters:
  resturl: "http://192.168.10.100:8080"
  restuser: ""
  secretNamespace: ""
  secretName: ""
allowVolumeExpansion: true
```

如果要为某 PVC 请求较大的存储卷，可以编辑 PVC 对象，设置一个更大的尺寸值。 这一编辑操作会触发为下层 PersistentVolume 提供存储的卷的扩充。 Kubernetes 不会创建新的 PV 卷来满足此申领的请求。 与之相反，现有的卷会被调整大小。

**警告：**

直接编辑 PersistentVolume 的大小可以阻止该卷自动调整大小。 如果对 PersistentVolume 的容量进行编辑，然后又将其所对应的 PersistentVolumeClaim 的 `.spec` 进行编辑，使该 PersistentVolumeClaim 的大小匹配 PersistentVolume 的话，则不会发生存储大小的调整。 Kubernetes 控制平面将看到两个资源的所需状态匹配， 并认为其后备卷的大小已被手动增加，无需调整。

###### CSI 卷的扩充[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#csi-volume-expansion)

**特性状态：** `Kubernetes v1.24 [stable]`

对 CSI 卷的扩充能力默认是被启用的，不过扩充 CSI 卷要求 CSI 驱动支持卷扩充操作。可参阅特定 CSI 驱动的文档了解更多信息。

###### 重设包含文件系统的卷的大小[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#resizing-a-volume-containing-a-file-system)

只有卷中包含的文件系统是 XFS、Ext3 或者 Ext4 时，你才可以重设卷的大小。

当卷中包含文件系统时，只有在 Pod 使用 `ReadWrite` 模式来使用 PVC 申领的情况下才能重设其文件系统的大小。文件系统扩充的操作或者是在 Pod 启动期间完成，或者在下层文件系统支持在线扩充的前提下在 Pod 运行期间完成。

如果 FlexVolumes 的驱动将 `RequiresFSResize` 能力设置为 `true`， 则该 FlexVolume 卷（于 Kubernetes v1.23 弃用）可以在 Pod 重启期间调整大小。

###### 重设使用中 PVC 申领的大小[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#resizing-an-in-use-persistentvolumevlaim)

**特性状态：** `Kubernetes v1.24 [stable]`

在这种情况下，你不需要删除和重建正在使用某现有 PVC 的 Pod 或 Deployment。 所有使用中的 PVC 在其文件系统被扩充之后，立即可供其 Pod 使用。 此功能特性对于没有被 Pod 或 Deployment 使用的 PVC 而言没有效果。 你必须在执行扩展操作之前创建一个使用该 PVC 的 Pod。

与其他卷类型类似，FlexVolume 卷也可以在被 Pod 使用期间执行扩充操作。

**说明：**

FlexVolume 卷的重设大小只能在下层驱动支持重设大小的时候才可进行。

**说明：**

扩充 EBS 卷的操作非常耗时。同时还存在另一个配额限制： 每 6 小时只能执行一次（尺寸）修改操作。

###### 处理扩充卷过程中的失败[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes)

如果用户指定的新大小过大，底层存储系统无法满足，PVC 的扩展将不断重试， 直到用户或集群管理员采取一些措施。这种情况是不希望发生的，因此 Kubernetes 提供了以下从此类故障中恢复的方法。

- [集群管理员手动处理](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#recovery-methods-0)
- [通过请求扩展为更小尺寸](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#recovery-methods-1)

如果扩充下层存储的操作失败，集群管理员可以手动地恢复 PVC 申领的状态并取消重设大小的请求。否则，在没有管理员干预的情况下， 控制器会反复重试重设大小的操作。

1. 将绑定到 PVC 申领的 PV 卷标记为 `Retain` 回收策略。
2. 删除 PVC 对象。由于 PV 的回收策略为 `Retain`，我们不会在重建 PVC 时丢失数据。
3. 删除 PV 规约中的 `claimRef` 项，这样新的 PVC 可以绑定到该卷。 这一操作会使得 PV 卷变为 "可用（Available）"。
4. 使用小于 PV 卷大小的尺寸重建 PVC，设置 PVC 的 `volumeName` 字段为 PV 卷的名称。 这一操作将把新的 PVC 对象绑定到现有的 PV 卷。
5. 不要忘记恢复 PV 卷上设置的回收策略。

**特性状态：** `Kubernetes v1.23 [alpha]`

**说明：**

Kubernetes 从 1.23 版本开始将允许用户恢复失败的 PVC 扩展这一能力作为 alpha 特性支持。`RecoverVolumeExpansionFailure` 必须被启用以允许使用此特性。 可参考[特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/) 文档了解更多信息。

如果集群中的特性门控 `RecoverVolumeExpansionFailure` 已启用，在 PVC 的扩展发生失败时，你可以使用比先前请求的值更小的尺寸来重试扩展。 要使用一个更小的尺寸尝试请求新的扩展，请编辑该 PVC 的 `.spec.resources` 并选择一个比你之前所尝试的值更小的值。 如果由于容量限制而无法成功扩展至更高的值，这将很有用。 如果发生了这种情况，或者你怀疑可能发生了这种情况， 你可以通过指定一个在底层存储制备容量限制内的尺寸来重试扩展。 你可以通过查看 `.status.resizeStatus` 以及 PVC 上的事件来监控调整大小操作的状态。

请注意， 尽管你可以指定比之前的请求更低的存储量，新值必须仍然高于 `.status.capacity`。 Kubernetes 不支持将 PVC 缩小到小于其当前的尺寸。

#### 持久卷的类型[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes)

PV 持久卷是用插件的形式来实现的。Kubernetes 目前支持以下插件：

- [`cephfs`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#cephfs) - CephFS volume
- [`csi`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi) - 容器存储接口 (CSI)
- [`fc`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#fc) - Fibre Channel (FC) 存储
- [`hostPath`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#hostpath) - HostPath 卷 （仅供单节点测试使用；不适用于多节点集群；请尝试使用 `local` 卷作为替代）
- [`iscsi`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#iscsi) - iSCSI (SCSI over IP) 存储
- [`local`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#local) - 节点上挂载的本地存储设备
- [`nfs`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#nfs) - 网络文件系统 (NFS) 存储
- [`rbd`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#rbd) - Rados 块设备 (RBD) 卷

以下的持久卷已被弃用。这意味着当前仍是支持的，但是 Kubernetes 将来的发行版会将其移除。

- [`awsElasticBlockStore`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore) - AWS 弹性块存储（EBS） （于 v1.17 **弃用**）
- [`azureDisk`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azuredisk) - Azure Disk （于 v1.19 **弃用**）
- [`azureFile`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azurefile) - Azure File （于 v1.21 **弃用**）
- [`cinder`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#cinder) - Cinder（OpenStack 块存储）（于 v1.18 **弃用**）
- [`flexVolume`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#flexVolume) - FlexVolume （于 v1.23 **弃用**）
- [`gcePersistentDisk`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk) - GCE Persistent Disk （于 v1.17 **弃用**）
- [`portworxVolume`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#portworxvolume) - Portworx 卷 （于 v1.25 **弃用**）
- [`vsphereVolume`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#vspherevolume) - vSphere VMDK 卷 （于 v1.19 **弃用**）

旧版本的 Kubernetes 仍支持这些“树内（In-Tree）”持久卷类型：

- `photonPersistentDisk` - Photon 控制器持久化盘。（从 v1.15 版本开始将**不可用**）
- [`scaleIO`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#scaleio) - ScaleIO 卷（v1.21 之后**不可用**）
- [`flocker`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#flocker) - Flocker 存储 （v1.25 之后**不可用**）
- [`quobyte`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#quobyte) - Quobyte 卷 （v1.25 之后**不可用**）
- [`storageos`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#storageos) - StorageOS 卷 （v1.25 之后**不可用**）

#### 持久卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistent-volumes)

每个 PV 对象都包含 `spec` 部分和 `status` 部分，分别对应卷的规约和状态。 PersistentVolume 对象的名称必须是合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names).

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0003
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  storageClassName: slow
  mountOptions:
    - hard
    - nfsvers=4.1
  nfs:
    path: /tmp
    server: 172.17.0.2
```

**说明：**

在集群中使用持久卷存储通常需要一些特定于具体卷类型的辅助程序。 在这个例子中，PersistentVolume 是 NFS 类型的，因此需要辅助程序 `/sbin/mount.nfs` 来支持挂载 NFS 文件系统。

##### 容量[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#capacity)

一般而言，每个 PV 卷都有确定的存储容量。 容量属性是使用 PV 对象的 `capacity` 属性来设置的。 参考词汇表中的[量纲（Quantity）](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-quantity) 词条，了解 `capacity` 字段可以接受的单位。

目前，存储大小是可以设置和请求的唯一资源。 未来可能会包含 IOPS、吞吐量等属性。

##### 卷模式[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-mode)

**特性状态：** `Kubernetes v1.18 [stable]`

针对 PV 持久卷，Kubernetes 支持两种卷模式（`volumeModes`）：`Filesystem（文件系统）` 和 `Block（块）`。 `volumeMode` 是一个可选的 API 参数。 如果该参数被省略，默认的卷模式是 `Filesystem`。

`volumeMode` 属性设置为 `Filesystem` 的卷会被 Pod **挂载（Mount）** 到某个目录。 如果卷的存储来自某块设备而该设备目前为空，Kuberneretes 会在第一次挂载卷之前在设备上创建文件系统。

你可以将 `volumeMode` 设置为 `Block`，以便将卷作为原始块设备来使用。 这类卷以块设备的方式交给 Pod 使用，其上没有任何文件系统。 这种模式对于为 Pod 提供一种使用最快可能方式来访问卷而言很有帮助， Pod 和卷之间不存在文件系统层。另外，Pod 中运行的应用必须知道如何处理原始块设备。 关于如何在 Pod 中使用 `volumeMode: Block` 的卷， 可参阅[原始块卷支持](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#raw-block-volume-support)。

##### 访问模式[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#access-modes)

PersistentVolume 卷可以用资源提供者所支持的任何方式挂载到宿主系统上。 如下表所示，提供者（驱动）的能力不同，每个 PV 卷的访问模式都会设置为对应卷所支持的模式值。 例如，NFS 可以支持多个读写客户，但是某个特定的 NFS PV 卷可能在服务器上以只读的方式导出。 每个 PV 卷都会获得自身的访问模式集合，描述的是特定 PV 卷的能力。

访问模式有：

`ReadWriteOnce`

卷可以被一个节点以读写方式挂载。 ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。

`ReadOnlyMany`

卷可以被多个节点以只读方式挂载。

`ReadWriteMany`

卷可以被多个节点以读写方式挂载。

`ReadWriteOncePod`

卷可以被单个 Pod 以读写方式挂载。 如果你想确保整个集群中只有一个 Pod 可以读取或写入该 PVC， 请使用 ReadWriteOncePod 访问模式。这只支持 CSI 卷以及需要 Kubernetes 1.22 以上版本。

这篇博客文章 [Introducing Single Pod Access Mode for PersistentVolumes](https://kubernetes.io/blog/2021/09/13/read-write-once-pod-access-mode-alpha/) 描述了更详细的内容。

在命令行接口（CLI）中，访问模式也使用以下缩写形式：

- RWO - ReadWriteOnce
- ROX - ReadOnlyMany
- RWX - ReadWriteMany
- RWOP - ReadWriteOncePod

**说明：**

Kubernetes 使用卷访问模式来匹配 PersistentVolumeClaim 和 PersistentVolume。 在某些场合下，卷访问模式也会限制 PersistentVolume 可以挂载的位置。 卷访问模式并**不会**在存储已经被挂载的情况下为其实施写保护。 即使访问模式设置为 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany，它们也不会对卷形成限制。 例如，即使某个卷创建时设置为 ReadOnlyMany，也无法保证该卷是只读的。 如果访问模式设置为 ReadWriteOncePod，则卷会被限制起来并且只能挂载到一个 Pod 上。

> **重要提醒！** 每个卷同一时刻只能以一种访问模式挂载，即使该卷能够支持多种访问模式。 例如，一个 GCEPersistentDisk 卷可以被某节点以 ReadWriteOnce 模式挂载，或者被多个节点以 ReadOnlyMany 模式挂载，但不可以同时以两种模式挂载。

| 卷插件 | ReadWriteOnce | ReadOnlyMany | ReadWriteMany | ReadWriteOncePod |
| --- | --- | --- | --- | --- |
| AWSElasticBlockStore | ✓ | \- | \- | \- |
| AzureFile | ✓ | ✓ | ✓ | \- |
| AzureDisk | ✓ | \- | \- | \- |
| CephFS | ✓ | ✓ | ✓ | \- |
| Cinder | ✓ | \- | ([如果多次挂接卷可用](https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/features.md#multi-attach-volumes)) | \- |
| CSI | 取决于驱动 | 取决于驱动 | 取决于驱动 | 取决于驱动 |
| FC | ✓ | ✓ | \- | \- |
| FlexVolume | ✓ | ✓ | 取决于驱动 | \- |
| GCEPersistentDisk | ✓ | ✓ | \- | \- |
| Glusterfs | ✓ | ✓ | ✓ | \- |
| HostPath | ✓ | \- | \- | \- |
| iSCSI | ✓ | ✓ | \- | \- |
| NFS | ✓ | ✓ | ✓ | \- |
| RBD | ✓ | ✓ | \- | \- |
| VsphereVolume | ✓ | \- | \-（Pod 运行于同一节点上时可行） | \- |
| PortworxVolume | ✓ | \- | ✓ | \- |

##### 类[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#class)

每个 PV 可以属于某个类（Class），通过将其 `storageClassName` 属性设置为某个 [StorageClass](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/) 的名称来指定。 特定类的 PV 卷只能绑定到请求该类存储卷的 PVC 申领。 未设置 `storageClassName` 的 PV 卷没有类设定，只能绑定到那些没有指定特定存储类的 PVC 申领。

早前，Kubernetes 使用注解 `volume.beta.kubernetes.io/storage-class` 而不是 `storageClassName` 属性。这一注解目前仍然起作用，不过在将来的 Kubernetes 发布版本中该注解会被彻底废弃。

##### 回收策略[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#reclaim-policy)

目前的回收策略有：

- Retain -- 手动回收
- Recycle -- 基本擦除 (`rm -rf /thevolume/*`)
- Delete -- 诸如 AWS EBS、GCE PD、Azure Disk 或 OpenStack Cinder 卷这类关联存储资产也被删除

目前，仅 NFS 和 HostPath 支持回收（Recycle）。 AWS EBS、GCE PD、Azure Disk 和 Cinder 卷都支持删除（Delete）。

##### 挂载选项[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#mount-options)

Kubernetes 管理员可以指定持久卷被挂载到节点上时使用的附加挂载选项。

**说明：**

并非所有持久卷类型都支持挂载选项。

以下卷类型支持挂载选项：

- `awsElasticBlockStore`
- `azureDisk`
- `azureFile`
- `cephfs`
- `cinder`（于 v1.18 **弃用**）
- `gcePersistentDisk`
- `iscsi`
- `nfs`
- `rbd`
- `vsphereVolume`

Kubernetes 不对挂载选项执行合法性检查。如果挂载选项是非法的，挂载就会失败。

早前，Kubernetes 使用注解 `volume.beta.kubernetes.io/mount-options` 而不是 `mountOptions` 属性。这一注解目前仍然起作用，不过在将来的 Kubernetes 发布版本中该注解会被彻底废弃。

##### 节点亲和性[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#node-affinity)

**说明：**

对大多数类型的卷而言，你不需要设置节点亲和性字段。 [AWS EBS](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore)、 [GCE PD](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk) 和 [Azure Disk](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#azuredisk) 卷类型都能自动设置相关字段。 你需要为 [local](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#local) 卷显式地设置此属性。

每个 PV 卷可以通过设置节点亲和性来定义一些约束，进而限制从哪些节点上可以访问此卷。 使用这些卷的 Pod 只会被调度到节点亲和性规则所选择的节点上执行。 要设置节点亲和性，配置 PV 卷 `.spec` 中的 `nodeAffinity`。 [持久卷](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec) API 参考关于该字段的更多细节。

##### 阶段[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#phase)

每个卷会处于以下阶段（Phase）之一：

- Available（可用）-- 卷是一个空闲资源，尚未绑定到任何申领；
- Bound（已绑定）-- 该卷已经绑定到某申领；
- Released（已释放）-- 所绑定的申领已被删除，但是资源尚未被集群回收；
- Failed（失败）-- 卷的自动回收操作失败。

命令行接口能够显示绑定到某 PV 卷的 PVC 对象。

#### PersistentVolumeClaims[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims)

每个 PVC 对象都有 `spec` 和 `status` 部分，分别对应申领的规约和状态。 PersistentVolumeClaim 对象的名称必须是合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names).

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
      storage: 8Gi
  storageClassName: slow
  selector:
    matchLabels:
      release: "stable"
    matchExpressions:
      - {key: environment, operator: In, values: [dev]}
```

##### 访问模式[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#access-modes)

申领在请求具有特定访问模式的存储时，使用与卷相同的[访问模式约定](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#access-modes)。

##### 卷模式[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-modes)

申领使用[与卷相同的约定](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-mode)来表明是将卷作为文件系统还是块设备来使用。

##### 资源[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#resources)

申领和 Pod 一样，也可以请求特定数量的资源。在这个上下文中，请求的资源是存储。 卷和申领都使用相同的 [资源模型](https://git.k8s.io/design-proposals-archive/scheduling/resources.md)。

##### 选择算符[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#selector)

申领可以设置[标签选择算符](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors) 来进一步过滤卷集合。只有标签与选择算符相匹配的卷能够绑定到申领上。 选择算符包含两个字段：

- `matchLabels` - 卷必须包含带有此值的标签
- `matchExpressions` - 通过设定键（key）、值列表和操作符（operator） 来构造的需求。合法的操作符有 In、NotIn、Exists 和 DoesNotExist。

来自 `matchLabels` 和 `matchExpressions` 的所有需求都按逻辑与的方式组合在一起。 这些需求都必须被满足才被视为匹配。

##### 类[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#class)

申领可以通过为 `storageClassName` 属性设置 [StorageClass](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/) 的名称来请求特定的存储类。 只有所请求的类的 PV 卷，即 `storageClassName` 值与 PVC 设置相同的 PV 卷， 才能绑定到 PVC 申领。

PVC 申领不必一定要请求某个类。如果 PVC 的 `storageClassName` 属性值设置为 `""`， 则被视为要请求的是没有设置存储类的 PV 卷，因此这一 PVC 申领只能绑定到未设置存储类的 PV 卷（未设置注解或者注解值为 `""` 的 PersistentVolume（PV）对象在系统中不会被删除， 因为这样做可能会引起数据丢失。未设置 `storageClassName` 的 PVC 与此大不相同， 也会被集群作不同处理。具体筛查方式取决于 [`DefaultStorageClass` 准入控制器插件](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass) 是否被启用。

- 如果准入控制器插件被启用，则管理员可以设置一个默认的 StorageClass。 所有未设置 `storageClassName` 的 PVC 都只能绑定到隶属于默认存储类的 PV 卷。 设置默认 StorageClass 的工作是通过将对应 StorageClass 对象的注解 `storageclass.kubernetes.io/is-default-class` 赋值为 `true` 来完成的。 如果管理员未设置默认存储类，集群对 PVC 创建的处理方式与未启用准入控制器插件时相同。 如果设定的默认存储类不止一个，准入控制插件会禁止所有创建 PVC 操作。
- 如果准入控制器插件被关闭，则不存在默认 StorageClass 的说法。 所有将 `storageClassName` 设为 `""` 的 PVC 只能被绑定到也将 `storageClassName` 设为 `""` 的 PV。 不过，只要默认的 StorageClass 可用，就可以稍后更新缺少 `storageClassName` 的 PVC。 如果这个 PVC 更新了，它将不再绑定到也将 `storageClassName` 设为 `""` 的 PV。

参阅[可追溯的默认 StorageClass 赋值](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#retroactive-default-storageclass-assignment)了解更多详细信息。

取决于安装方法，默认的 StorageClass 可能在集群安装期间由插件管理器（Addon Manager）部署到集群中。

当某 PVC 除了请求 StorageClass 之外还设置了 `selector`，则这两种需求会按逻辑与关系处理： 只有隶属于所请求类且带有所请求标签的 PV 才能绑定到 PVC。

**说明：**

目前，设置了非空 `selector` 的 PVC 对象无法让集群为其动态制备 PV 卷。

早前，Kubernetes 使用注解 `volume.beta.kubernetes.io/storage-class` 而不是 `storageClassName` 属性。这一注解目前仍然起作用，不过在将来的 Kubernetes 发布版本中该注解会被彻底废弃。

###### 可追溯的默认 StorageClass 赋值[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#retroactive-default-storageclass-assignment)

**特性状态：** `Kubernetes v1.26 [beta]`

你可以创建 PersistentVolumeClaim，而无需为新 PVC 指定 `storageClassName`。 即使你的集群中不存在默认 StorageClass，你也可以这样做。 在这种情况下，新的 PVC 会按照你的定义进行创建，并且在默认值可用之前，该 PVC 的 `storageClassName` 保持不设置。

当一个默认的 StorageClass 变得可用时，控制平面会识别所有未设置 `storageClassName` 的现有 PVC。 对于 `storageClassName` 为空值或没有此主键的 PVC， 控制平面会更新这些 PVC 以设置其 `storageClassName` 与新的默认 StorageClass 匹配。 如果你有一个现有的 PVC，其中 `storageClassName` 是 `""`， 并且你配置了默认 StorageClass，则此 PVC 将不会得到更新。

为了保持绑定到 `storageClassName` 设为 `""` 的 PV（当存在默认 StorageClass 时）， 你需要将关联 PVC 的 `storageClassName` 设置为 `""`。

此行为可帮助管理员更改默认 StorageClass，方法是先移除旧的 PVC，然后再创建或设置另一个 PVC。 这一时间窗口内因为没有指定默认值，会导致所创建的未设置 `storageClassName` 的 PVC 也没有默认值设置， 但由于默认 StorageClass 赋值是可追溯的，这种更改默认值的方式是安全的。

#### 使用申领作为卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#claims-as-volumes)

Pod 将申领作为卷来使用，并藉此访问存储资源。 申领必须位于使用它的 Pod 所在的同一名字空间内。 集群在 Pod 的名字空间中查找申领，并使用它来获得申领所使用的 PV 卷。 之后，卷会被挂载到宿主上并挂载到 Pod 中。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim
```

##### 关于名字空间的说明[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#a-note-on-namespaces)

PersistentVolume 卷的绑定是排他性的。 由于 PersistentVolumeClaim 是名字空间作用域的对象，使用 "Many" 模式（`ROX`、`RWX`）来挂载申领的操作只能在同一名字空间内进行。

##### 类型为 `hostpath` 的 PersistentVolume[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumes-typed-hostpath)

`hostPath` PersistentVolume 使用节点上的文件或目录来模拟网络附加（network-attached）存储。 相关细节可参阅 [`hostPath` 卷示例](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume)。

#### 原始块卷支持[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#raw-block-volume-support)

**特性状态：** `Kubernetes v1.18 [stable]`

以下卷插件支持原始块卷，包括其动态制备（如果支持的话）的卷：

- AWSElasticBlockStore
- AzureDisk
- CSI
- FC（光纤通道）
- GCEPersistentDisk
- iSCSI
- Local 卷
- OpenStack Cinder
- RBD（Ceph 块设备）
- VsphereVolume

##### 使用原始块卷的持久卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistent-volume-using-a-raw-block-volume)

```yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: block-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  volumeMode: Block
  persistentVolumeReclaimPolicy: Retain
  fc:
    targetWWNs: ["50060e801049cfd1"]
    lun: 0
    readOnly: false
```

##### 申请原始块卷的 PVC 申领[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistent-volume-claim-requesting-a-raw-block-volume)

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: block-pvc
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Block
  resources:
    requests:
      storage: 10Gi
```

##### 在容器中添加原始块设备路径的 Pod 规约[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#pod-spec-adding-raw-block-device-path-in-container)

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-with-block-volume
spec:
  containers:
    - name: fc-container
      image: fedora:26
      command: ["/bin/sh", "-c"]
      args: [ "tail -f /dev/null" ]
      volumeDevices:
        - name: data
          devicePath: /dev/xvda
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: block-pvc
```

**说明：**

向 Pod 中添加原始块设备时，你要在容器内设置设备路径而不是挂载路径。

##### 绑定块卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#binding-block-volumes)

如果用户通过 PersistentVolumeClaim 规约的 `volumeMode` 字段来表明对原始块设备的请求， 绑定规则与之前版本中未在规约中考虑此模式的实现略有不同。 下面列举的表格是用户和管理员可以为请求原始块设备所作设置的组合。 此表格表明在不同的组合下卷是否会被绑定。

静态制备卷的卷绑定矩阵：

| PV volumeMode | PVC volumeMode | Result |
| --- | --- | --- |
| 未指定 | 未指定 | 绑定 |
| 未指定 | Block | 不绑定 |
| 未指定 | Filesystem | 绑定 |
| Block | 未指定 | 不绑定 |
| Block | Block | 绑定 |
| Block | Filesystem | 不绑定 |
| Filesystem | Filesystem | 绑定 |
| Filesystem | Block | 不绑定 |
| Filesystem | 未指定 | 绑定 |

**说明：**

Alpha 发行版本中仅支持静态制备的卷。 管理员需要在处理原始块设备时小心处理这些值。

#### 对卷快照及从卷快照中恢复卷的支持[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-snapshot-and-restore-volume-from-snapshot-support)

**特性状态：** `Kubernetes v1.20 [stable]`

卷快照（Volume Snapshot）仅支持树外 CSI 卷插件。 有关细节可参阅[卷快照](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/)文档。 树内卷插件被弃用。你可以查阅[卷插件 FAQ](https://git.k8s.io/community/sig-storage/volume-plugin-faq.md) 了解已弃用的卷插件。

##### 基于卷快照创建 PVC 申领[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#create-persistent-volume-claim-from-volume-snapshot)

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: restore-pvc
spec:
  storageClassName: csi-hostpath-sc
  dataSource:
    name: new-snapshot-test
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

#### 卷克隆[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-cloning)

[卷克隆](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-pvc-datasource/)功能特性仅适用于 CSI 卷插件。

##### 基于现有 PVC 创建新的 PVC 申领[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#create-persistent-volume-claim-from-an-existing-pvc)

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: cloned-pvc
spec:
  storageClassName: my-csi-plugin
  dataSource:
    name: existing-src-pvc-name
    kind: PersistentVolumeClaim
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

#### 卷填充器（Populator）与数据源[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-populators-and-data-sources)

**特性状态：** `Kubernetes v1.24 [beta]`

Kubernetes 支持自定义的卷填充器。要使用自定义的卷填充器，你必须为 kube-apiserver 和 kube-controller-manager 启用 `AnyVolumeDataSource` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。

卷填充器利用了 PVC 规约字段 `dataSourceRef`。 不像 `dataSource` 字段只能包含对另一个持久卷申领或卷快照的引用， `dataSourceRef` 字段可以包含对同一命名空间中任何对象的引用（不包含除 PVC 以外的核心资源）。 对于启用了特性门控的集群，使用 `dataSourceRef` 比 `dataSource` 更好。

#### 跨名字空间数据源[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#cross-namespace-data-sources)

**特性状态：** `Kubernetes v1.26 [alpha]`

Kubernetes 支持跨名字空间卷数据源。 要使用跨名字空间卷数据源，你必须为 kube-apiserver、kube-controller 管理器启用 `AnyVolumeDataSource` 和 `CrossNamespaceVolumeDataSource` [特性门控](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/feature-gates/)。 此外，你必须为 csi-provisioner 启用 `CrossNamespaceVolumeDataSource` 特性门控。

启用 `CrossNamespaceVolumeDataSource` 特性门控允许你在 dataSourceRef 字段中指定名字空间。

**说明：**

当你为卷数据源指定名字空间时，Kubernetes 在接受此引用之前在另一个名字空间中检查 ReferenceGrant。 ReferenceGrant 是 `gateway.networking.k8s.io` 扩展 API 的一部分。更多细节请参见 Gateway API 文档中的 [ReferenceGrant](https://gateway-api.sigs.k8s.io/api-types/referencegrant/)。 这意味着你必须在使用此机制之前至少使用 Gateway API 的 ReferenceGrant 来扩展 Kubernetes 集群。

#### 数据源引用[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#data-source-references)

`dataSourceRef` 字段的行为与 `dataSource` 字段几乎相同。 如果其中一个字段被指定而另一个字段没有被指定，API 服务器将给两个字段相同的值。 这两个字段都不能在创建后改变，如果试图为这两个字段指定不同的值，将导致验证错误。 因此，这两个字段将总是有相同的内容。

在 `dataSourceRef` 字段和 `dataSource` 字段之间有两个用户应该注意的区别：

- `dataSource` 字段会忽略无效的值（如同是空值）， 而 `dataSourceRef` 字段永远不会忽略值，并且若填入一个无效的值，会导致错误。 无效值指的是 PVC 之外的核心对象（没有 apiGroup 的对象）。
- `dataSourceRef` 字段可以包含不同类型的对象，而 `dataSource` 字段只允许 PVC 和卷快照。

当 `CrossNamespaceVolumeDataSource` 特性被启用时，存在其他区别：

- `dataSource` 字段仅允许本地对象，而 `dataSourceRef` 字段允许任何名字空间中的对象。
- 若指定了 namespace，则 `dataSource` 和 `dataSourceRef` 不会被同步。

用户始终应该在启用了此特性门控的集群上使用 `dataSourceRef`， 在没有启用该特性门控的集群上使用 `dataSource`。 在任何情况下都没有必要查看这两个字段。 这两个字段的值看似相同但是语义稍微不一样，是为了向后兼容。 特别是混用旧版本和新版本的控制器时，它们能够互通。

#### 使用卷填充器[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#using-volume-populators)

卷填充器是能创建非空卷的[控制器](https://kubernetes.io/zh-cn/docs/concepts/architecture/controller/)， 其卷的内容通过一个自定义资源决定。 用户通过使用 `dataSourceRef` 字段引用自定义资源来创建一个被填充的卷：

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: populated-pvc
spec:
  dataSourceRef:
    name: example-name
    kind: ExampleDataSource
    apiGroup: example.storage.k8s.io
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
```

因为卷填充器是外部组件，如果没有安装所有正确的组件，试图创建一个使用卷填充器的 PVC 就会失败。 外部控制器应该在 PVC 上产生事件，以提供创建状态的反馈，包括在由于缺少某些组件而无法创建 PVC 的情况下发出警告。

你可以把 alpha 版本的[卷数据源验证器](https://github.com/kubernetes-csi/volume-data-source-validator) 控制器安装到你的集群中。 如果没有填充器处理该数据源的情况下，该控制器会在 PVC 上产生警告事件。 当一个合适的填充器被安装到 PVC 上时，该控制器的职责是上报与卷创建有关的事件，以及在该过程中发生的问题。

##### 使用跨名字空间的卷数据源[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#using-a-cross-namespace-volume-data-source)

**特性状态：** `Kubernetes v1.26 [alpha]`

创建 ReferenceGrant 以允许名字空间属主接受引用。 你通过使用 `dataSourceRef` 字段指定跨名字空间卷数据源，定义填充的卷。 你必须在源名字空间中已经有一个有效的 ReferenceGrant：

```yaml
apiVersion: gateway.networking.k8s.io/v1beta1
kind: ReferenceGrant
metadata:
  name: allow-ns1-pvc
  namespace: default
spec:
  from:
  - group: ""
    kind: PersistentVolumeClaim
    namespace: ns1
  to:
  - group: snapshot.storage.k8s.io
    kind: VolumeSnapshot
    name: new-snapshot-demo
```

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: foo-pvc
  namespace: ns1
spec:
  storageClassName: example
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  dataSourceRef:
    apiGroup: snapshot.storage.k8s.io
    kind: VolumeSnapshot
    name: new-snapshot-demo
    namespace: default
  volumeMode: Filesystem
```

#### 编写可移植的配置[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#writing-portable-configuration)

如果你要编写配置模板和示例用来在很多集群上运行并且需要持久性存储，建议你使用以下模式：

- 将 PersistentVolumeClaim 对象包含到你的配置包（Bundle）中，和 Deployment 以及 ConfigMap 等放在一起。
- 不要在配置中包含 PersistentVolume 对象，因为对配置进行实例化的用户很可能 没有创建 PersistentVolume 的权限。

- 为用户提供在实例化模板时指定存储类名称的能力。
    - 仍按用户提供存储类名称，将该名称放到 `persistentVolumeClaim.storageClassName` 字段中。 这样会使得 PVC 在集群被管理员启用了存储类支持时能够匹配到正确的存储类，
    - 如果用户未指定存储类名称，将 `persistentVolumeClaim.storageClassName` 留空（nil）。 这样，集群会使用默认 `StorageClass` 为用户自动制备一个存储卷。 很多集群环境都配置了默认的 `StorageClass`，或者管理员也可以自行创建默认的 `StorageClass`。

- 在你的工具链中，监测经过一段时间后仍未被绑定的 PVC 对象，要让用户知道这些对象， 因为这可能意味着集群不支持动态存储（因而用户必须先创建一个匹配的 PV），或者 集群没有配置存储系统（因而用户无法配置需要 PVC 的工作负载配置）。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 进一步了解[创建持久卷](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume)。
- 进一步学习[创建 PVC 申领](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim)。
- 阅读[持久存储的设计文档](https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md)
### [投射卷](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/)
本文档描述 Kubernetes 中的**投射卷（Projected Volumes）**。 建议先熟悉[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)概念。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#introduction)

一个 `projected` 卷可以将若干现有的卷源映射到同一个目录之上。

目前，以下类型的卷源可以被投射：

- [`secret`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#secret)
- [`downwardAPI`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#downwardapi)
- [`configMap`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#configmap)
- [`serviceAccountToken`](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#serviceaccounttoken)

所有的卷源都要求处于 Pod 所在的同一个名字空间内。更多详细信息， 可参考[一体化卷](https://git.k8s.io/design-proposals-archive/node/all-in-one-volume.md)设计文档。

##### 带有 Secret、DownwardAPI 和 ConfigMap 的配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#example-configuration-secret-downwardapi-configmap)

[`pods/storage/projected-secret-downwardapi-configmap.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected-secret-downwardapi-configmap.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy pods/storage/projected-secret-downwardapi-configmap.yaml to clipboard")

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: container-test
    image: busybox:1.28
    volumeMounts:
    - name: all-in-one
      mountPath: "/projected-volume"
      readOnly: true
  volumes:
  - name: all-in-one
    projected:
      sources:
      - secret:
          name: mysecret
          items:
            - key: username
              path: my-group/my-username
      - downwardAPI:
          items:
            - path: "labels"
              fieldRef:
                fieldPath: metadata.labels
            - path: "cpu_limit"
              resourceFieldRef:
                containerName: container-test
                resource: limits.cpu
      - configMap:
          name: myconfigmap
          items:
            - key: config
              path: my-group/my-config
```

##### 带有非默认权限模式设置的 Secret 的配置示例[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#example-configuration-secrets-nondefault-permission-mode)

[`pods/storage/projected-secrets-nondefault-permission-mode.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected-secrets-nondefault-permission-mode.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy pods/storage/projected-secrets-nondefault-permission-mode.yaml to clipboard")

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: volume-test
spec:
  containers:
  - name: container-test
    image: busybox:1.28
    volumeMounts:
    - name: all-in-one
      mountPath: "/projected-volume"
      readOnly: true
  volumes:
  - name: all-in-one
    projected:
      sources:
      - secret:
          name: mysecret
          items:
            - key: username
              path: my-group/my-username
      - secret:
          name: mysecret2
          items:
            - key: password
              path: my-group/my-password
              mode: 511
```

每个被投射的卷源都列举在规约中的 `sources` 下面。参数几乎相同，只有两个例外：

- 对于 Secret，`secretName` 字段被改为 `name` 以便于 ConfigMap 的命名一致；
- `defaultMode` 只能在投射层级设置，不能在卷源层级设置。不过，正如上面所展示的， 你可以显式地为每个投射单独设置 `mode` 属性。

#### serviceAccountToken 投射卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#serviceaccounttoken)

你可以将当前[服务账号](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/authentication/#service-account-tokens)的令牌注入到 Pod 中特定路径下。例如：

[`pods/storage/projected-service-account-token.yaml`](https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected-service-account-token.yaml) ![](https://d33wubrfki0l68.cloudfront.net/0901162ab78eb4ff2e9e5dc8b17c3824befc91a6/44ccd/images/copycode.svg "Copy pods/storage/projected-service-account-token.yaml to clipboard")

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: sa-token-test
spec:
  containers:
  - name: container-test
    image: busybox:1.28
    volumeMounts:
    - name: token-vol
      mountPath: "/service-account"
      readOnly: true
  serviceAccountName: default
  volumes:
  - name: token-vol
    projected:
      sources:
      - serviceAccountToken:
          audience: api
          expirationSeconds: 3600
          path: token
```

示例 Pod 中包含一个投射卷，其中包含注入的服务账号令牌。 此 Pod 中的容器可以使用该令牌访问 Kubernetes API 服务器， 使用 [Pod 的 ServiceAccount](https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-service-account/) 进行身份验证。`audience` 字段包含令牌所针对的受众。 收到令牌的主体必须使用令牌受众中所指定的某个标识符来标识自身，否则应该拒绝该令牌。 此字段是可选的，默认值为 API 服务器的标识。

字段 `expirationSeconds` 是服务账号令牌预期的生命期长度。默认值为 1 小时， 必须至少为 10 分钟（600 秒）。管理员也可以通过设置 API 服务器的命令行参数 `--service-account-max-token-expiration` 来为其设置最大值上限。 `path` 字段给出与投射卷挂载点之间的相对路径。

**说明：**

以 [`subPath`](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#using-subpath) 形式使用投射卷源的容器无法收到对应卷源的更新。

#### 与 SecurityContext 间的关系[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#securitycontext-interactions)

关于在投射的服务账号卷中处理文件访问权限的[提案](https://git.k8s.io/enhancements/keps/sig-storage/2451-service-account-token-volumes#proposal) 介绍了如何使得所投射的文件具有合适的属主访问权限。

##### Linux[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#linux)

在包含了投射卷并在 [`SecurityContext`](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context) 中设置了 `RunAsUser` 属性的 Linux Pod 中，投射文件具有正确的属主属性设置， 其中包含了容器用户属主。

当 Pod 中的所有容器在其 [`PodSecurityContext`](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context) 或容器 [`SecurityContext`](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-1) 中设置了相同的 `runAsUser` 时，kubelet 将确保 `serviceAccountToken` 卷的内容归该用户所有，并且令牌文件的权限模式会被设置为 `0600`。

**说明：**

在某 Pod 被创建后为其添加的[临时容器](https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/)**不会**更改创建该 Pod 时设置的卷权限。

如果 Pod 的 `serviceAccountToken` 卷权限被设为 `0600` 是因为 Pod 中的其他所有容器都具有相同的 `runAsUser`， 则临时容器必须使用相同的 `runAsUser` 才能读取令牌。

##### Windows[](https://kubernetes.io/zh-cn/docs/concepts/storage/projected-volumes/#windows)

在包含了投射卷并在 `SecurityContext` 中设置了 `RunAsUsername` 的 Windows Pod 中, 由于 Windows 中用户账号的管理方式问题，文件的属主无法正确设置。 Windows 在名为安全账号管理器（Security Account Manager，SAM） 的数据库中保存本地用户和组信息。每个容器会维护其自身的 SAM 数据库实例， 宿主系统无法窥视到容器运行期间数据库内容。Windows 容器被设计用来运行操作系统的用户态部分， 与宿主系统之间隔离，因此维护了一个虚拟的 SAM 数据库。 所以，在宿主系统上运行的 kubelet 无法动态为虚拟的容器账号配置宿主文件的属主。 如果需要将宿主机器上的文件与容器共享，建议将它们放到挂载于 `C:\` 之外的独立卷中。

默认情况下，所投射的文件会具有如下例所示的属主属性设置：

```powershell
PS C:\> Get-Acl C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.318230061\ca.crt | Format-List

Path   : Microsoft.PowerShell.Core\FileSystem::C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.318230061\ca.crt
Owner  : BUILTIN\Administrators
Group  : NT AUTHORITY\SYSTEM
Access : NT AUTHORITY\SYSTEM Allow  FullControl
         BUILTIN\Administrators Allow  FullControl
         BUILTIN\Users Allow  ReadAndExecute, Synchronize
Audit  :
Sddl   : O:BAG:SYD:AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)
```

这意味着，所有类似 `ContainerAdministrator` 的管理员用户都具有读、写和执行访问权限， 而非管理员用户将具有读和执行访问权限。

**说明：**

总体而言，为容器授予访问宿主系统的权限这种做法是不推荐的，因为这样做可能会打开潜在的安全性攻击之门。

在创建 Windows Pod 时，如果在其 `SecurityContext` 中设置了 `RunAsUser`， Pod 会一直阻塞在 `ContainerCreating` 状态。因此，建议不要在 Windows 节点上使用仅针对 Linux 的 `RunAsUser` 选项。
### [临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/)
本文档描述 Kubernetes 中的 **临时卷（Ephemeral Volume）**。 建议先了解[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)，特别是 PersistentVolumeClaim 和 PersistentVolume。

有些应用程序需要额外的存储，但并不关心数据在重启后是否仍然可用。 例如，缓存服务经常受限于内存大小，而且可以将不常用的数据转移到比内存慢的存储中，对总体性能的影响并不大。

另有些应用程序需要以文件形式注入的只读数据，比如配置数据或密钥。

**临时卷** 就是为此类用例设计的。因为卷会遵从 Pod 的生命周期，与 Pod 一起创建和删除， 所以停止和重新启动 Pod 时，不会受持久卷在何处可用的限制。

临时卷在 Pod 规约中以 **内联** 方式定义，这简化了应用程序的部署和管理。

##### 临时卷的类型[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#types-of-ephemeral-volumes)

Kubernetes 为了不同的用途，支持几种不同类型的临时卷：

- [emptyDir](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#emptydir)： Pod 启动时为空，存储空间来自本地的 kubelet 根目录（通常是根磁盘）或内存
- [configMap](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#configmap)、 [downwardAPI](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#downwardapi)、 [secret](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#secret)： 将不同类型的 Kubernetes 数据注入到 Pod 中
- [CSI 临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi-ephemeral-volumes)： 类似于前面的卷类型，但由专门[支持此特性](https://kubernetes-csi.github.io/docs/drivers.html) 的指定 [CSI 驱动程序](https://github.com/container-storage-interface/spec/blob/master/spec.md)提供
- [通用临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes)： 它可以由所有支持持久卷的存储驱动程序提供

`emptyDir`、`configMap`、`downwardAPI`、`secret` 是作为 [本地临时存储](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage) 提供的。它们由各个节点上的 kubelet 管理。

CSI 临时卷 **必须** 由第三方 CSI 存储驱动程序提供。

通用临时卷 **可以** 由第三方 CSI 存储驱动程序提供，也可以由支持动态制备的任何其他存储驱动程序提供。 一些专门为 CSI 临时卷编写的 CSI 驱动程序，不支持动态制备：因此这些驱动程序不能用于通用临时卷。

使用第三方驱动程序的优势在于，它们可以提供 Kubernetes 本身不支持的功能， 例如，与 kubelet 管理的磁盘具有不同性能特征的存储，或者用来注入不同的数据。

##### CSI 临时卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes)

**特性状态：** `Kubernetes v1.25 [stable]`

**说明：** 只有一部分 CSI 驱动程序支持 CSI 临时卷。Kubernetes CSI [驱动程序列表](https://kubernetes-csi.github.io/docs/drivers.html) 显示了支持临时卷的驱动程序。

从概念上讲，CSI 临时卷类似于 `configMap`、`downwardAPI` 和 `secret` 类型的卷： 在各个本地节点管理卷的存储，并在 Pod 调度到节点后与其他本地资源一起创建。 在这个阶段，Kubernetes 没有重新调度 Pod 的概念。卷创建不太可能失败，否则 Pod 启动将会受阻。 特别是，这些卷 **不** 支持[感知存储容量的 Pod 调度](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/)。 它们目前也没包括在 Pod 的存储资源使用限制中，因为 kubelet 只能对它自己管理的存储强制执行。

下面是使用 CSI 临时存储的 Pod 的示例清单：

```yaml
kind: Pod
apiVersion: v1
metadata:
  name: my-csi-app
spec:
  containers:
    - name: my-frontend
      image: busybox:1.28
      volumeMounts:
      - mountPath: "/data"
        name: my-csi-inline-vol
      command: [ "sleep", "1000000" ]
  volumes:
    - name: my-csi-inline-vol
      csi:
        driver: inline.storage.kubernetes.io
        volumeAttributes:
          foo: bar
```

`volumeAttributes` 决定驱动程序准备什么样的卷。每个驱动程序的属性不尽相同，没有实现标准化。 有关进一步的说明，请参阅每个 CSI 驱动程序的文档。

##### CSI 驱动程序限制[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-driver-restrictions)

CSI 临时卷允许用户直接向 CSI 驱动程序提供 `volumeAttributes`，它会作为 Pod 规约的一部分。 有些 `volumeAttributes` 通常仅限于管理员使用，允许这一类 `volumeAttributes` 的 CSI 驱动程序不适合在内联临时卷中使用。 例如，通常在 StorageClass 中定义的参数不应通过使用内联临时卷向用户公开。

如果集群管理员需要限制在 Pod 规约中作为内联卷使用的 CSI 驱动程序，可以这样做：

- 从 CSIDriver 规约的 `volumeLifecycleModes` 中删除 `Ephemeral`，这可以防止驱动程序被用作内联临时卷。
- 使用[准入 Webhook](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/) 来限制如何使用此驱动程序。

##### 通用临时卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes)

**特性状态：** `Kubernetes v1.23 [stable]`

通用临时卷类似于 `emptyDir` 卷，因为它为每个 Pod 提供临时数据存放目录， 在最初制备完毕时一般为空。不过通用临时卷也有一些额外的功能特性：

- 存储可以是本地的，也可以是网络连接的。
- 卷可以有固定的大小，Pod 不能超量使用。
- 卷可能有一些初始数据，这取决于驱动程序和参数。

- 支持典型的卷操作，前提是相关的驱动程序也支持该操作，包括 [快照](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/)、 [克隆](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-pvc-datasource/)、 [调整大小](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims)和 [存储容量跟踪](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/)）。

示例：

```yaml
kind: Pod
apiVersion: v1
metadata:
  name: my-app
spec:
  containers:
    - name: my-frontend
      image: busybox:1.28
      volumeMounts:
      - mountPath: "/scratch"
        name: scratch-volume
      command: [ "sleep", "1000000" ]
  volumes:
    - name: scratch-volume
      ephemeral:
        volumeClaimTemplate:
          metadata:
            labels:
              type: my-frontend-volume
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: "scratch-storage-class"
            resources:
              requests:
                storage: 1Gi
```

##### 生命周期和 PersistentVolumeClaim[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#lifecycle-and-persistentvolumeclaim)

关键的设计思想是在 Pod 的卷来源中允许使用 [卷申领的参数](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.26/#ephemeralvolumesource-v1alpha1-core)。 PersistentVolumeClaim 的标签、注解和整套字段集均被支持。 创建这样一个 Pod 后， 临时卷控制器在 Pod 所属的命名空间中创建一个实际的 PersistentVolumeClaim 对象， 并确保删除 Pod 时，同步删除 PersistentVolumeClaim。

如上设置将触发卷的绑定与/或制备，相应动作或者在 [StorageClass](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/) 使用即时卷绑定时立即执行， 或者当 Pod 被暂时性调度到某节点时执行 (`WaitForFirstConsumer` 卷绑定模式)。 对于通用的临时卷，建议采用后者，这样调度器就可以自由地为 Pod 选择合适的节点。 对于即时绑定，调度器则必须选出一个节点，使得在卷可用时，能立即访问该卷。

就[资源所有权](https://kubernetes.io/zh-cn/docs/concepts/architecture/garbage-collection/#owners-dependents)而言， 拥有通用临时存储的 Pod 是提供临时存储 (ephemeral storage) 的 PersistentVolumeClaim 的所有者。 当 Pod 被删除时，Kubernetes 垃圾收集器会删除 PVC， 然后 PVC 通常会触发卷的删除，因为存储类的默认回收策略是删除卷。 你可以使用带有 `retain` 回收策略的 StorageClass 创建准临时 (quasi-ephemeral) 本地存储： 该存储比 Pod 寿命长，在这种情况下，你需要确保单独进行卷清理。

当这些 PVC 存在时，它们可以像其他 PVC 一样使用。 特别是，它们可以被引用作为批量克隆或快照的数据源。 PVC 对象还保持着卷的当前状态。

##### PersistentVolumeClaim 的命名[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#persistentvolumeclaim-naming)

自动创建的 PVC 采取确定性的命名机制：名称是 Pod 名称和卷名称的组合，中间由连字符(`-`)连接。 在上面的示例中，PVC 将命名为 `my-app-scratch-volume` 。 这种确定性的命名机制使得与 PVC 交互变得更容易，因为一旦知道 Pod 名称和卷名，就不必搜索它。

这种命名机制也引入了潜在的冲突， 不同的 Pod 之间（名为 “Pod-a” 的 Pod 挂载名为 "scratch" 的卷， 和名为 "pod" 的 Pod 挂载名为 “a-scratch” 的卷，这两者均会生成名为 "pod-a-scratch" 的 PVC），或者在 Pod 和手工创建的 PVC 之间可能出现冲突。

以下冲突会被检测到：如果 PVC 是为 Pod 创建的，那么它只用于临时卷。 此检测基于所有权关系。现有的 PVC 不会被覆盖或修改。 但这并不能解决冲突，因为如果没有正确的 PVC，Pod 就无法启动。

**注意：** 当同一个命名空间中命名 Pod 和卷时，要小心，以防止发生此类冲突。

##### 安全[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#security)

启用 GenericEphemeralVolume 特性会有一些副作用，用户能创建 Pod 就能间接地创建 PVC， 即使他们没有权限直接创建 PVC。 集群管理员必须意识到这一点。 如果这不符合他们的安全模型，他们应该使用[准入 Webhook](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/) 拒绝包含通用临时卷的对象，例如 Pod。

正常的 [PVC 的名字空间配额](https://kubernetes.io/zh-cn/docs/concepts/policy/resource-quotas/#storage-resource-quota) 仍然有效，因此即使允许用户使用这种新机制，他们也不能使用它来规避其他策略。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

##### kubelet 管理的临时卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#ephemeral-volumes-managed-by-kubelet)

参阅[本地临时存储](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage)。

##### CSI 临时卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes)

- 有关设计的更多信息，参阅 [Ephemeral Inline CSI volumes KEP](https://github.com/kubernetes/enhancements/blob/ad6021b3d61a49040a3f835e12c8bb5424db2bbb/keps/sig-storage/20190122-csi-inline-volumes.md)。
- 本特性下一步开发的更多信息，参阅 [enhancement tracking issue #596](https://github.com/kubernetes/enhancements/issues/596)。

##### 通用临时卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes)

- 有关设计的更多信息，参阅 [Generic ephemeral inline volumes KEP](https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1698-generic-ephemeral-volumes/README.md)。
### [存储类](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)
本文描述了 Kubernetes 中 StorageClass 的概念。 建议先熟悉[卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)和[持久卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes)的概念。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#introduction)

StorageClass 为管理员提供了描述存储 "类" 的方法。 不同的类型可能会映射到不同的服务质量等级或备份策略，或是由集群管理员制定的任意策略。 Kubernetes 本身并不清楚各种类代表的什么。这个类的概念在其他存储系统中有时被称为 "配置文件"。

#### StorageClass 资源[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#the-storageclass-resource)

每个 StorageClass 都包含 `provisioner`、`parameters` 和 `reclaimPolicy` 字段， 这些字段会在 StorageClass 需要动态制备 PersistentVolume 时会使用到。

StorageClass 对象的命名很重要，用户使用这个命名来请求生成一个特定的类。 当创建 StorageClass 对象时，管理员设置 StorageClass 对象的命名和其他参数，一旦创建了对象就不能再对其更新。

管理员可以为没有申请绑定到特定 StorageClass 的 PVC 指定一个默认的存储类： 更多详情请参阅 [PersistentVolumeClaim 章节](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims)。

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: standard
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
reclaimPolicy: Retain
allowVolumeExpansion: true
mountOptions:
  - debug
volumeBindingMode: Immediate
```

##### 存储制备器[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#provisioner)

每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。 该字段必须指定。

| 卷插件 | 内置制备器 | 配置示例 |
| --- | --- | --- |
| AWSElasticBlockStore | ✓ | [AWS EBS](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#aws-ebs) |
| AzureFile | ✓ | [Azure File](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-file) |
| AzureDisk | ✓ | [Azure Disk](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-disk) |
| CephFS | \- | \- |
| Cinder | ✓ | [OpenStack Cinder](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#openstack-cinder) |
| FC | \- | \- |
| FlexVolume | \- | \- |
| GCEPersistentDisk | ✓ | [GCE PD](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#gce-pd) |
| iSCSI | \- | \- |
| NFS | \- | [NFS](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#nfs) |
| RBD | ✓ | [Ceph RBD](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#ceph-rbd) |
| VsphereVolume | ✓ | [vSphere](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#vsphere) |
| PortworxVolume | ✓ | [Portworx Volume](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#portworx-volume) |
| Local | \- | [Local](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#local) |

你不限于指定此处列出的 "内置" 制备器（其名称前缀为 "kubernetes.io" 并打包在 Kubernetes 中）。 你还可以运行和指定外部制备器，这些独立的程序遵循由 Kubernetes 定义的[规范](https://git.k8s.io/design-proposals-archive/storage/volume-provisioning.md)。 外部供应商的作者完全可以自由决定他们的代码保存于何处、打包方式、运行方式、使用的插件（包括 Flex）等。 代码仓库 [kubernetes-sigs/sig-storage-lib-external-provisioner](https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner) 包含一个用于为外部制备器编写功能实现的类库。你可以访问代码仓库 [kubernetes-sigs/sig-storage-lib-external-provisioner](https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner) 了解外部驱动列表。

例如，NFS 没有内部制备器，但可以使用外部制备器。 也有第三方存储供应商提供自己的外部制备器。

##### 回收策略[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#reclaim-policy)

由 StorageClass 动态创建的 PersistentVolume 会在类的 `reclaimPolicy` 字段中指定回收策略，可以是 `Delete` 或者 `Retain`。如果 StorageClass 对象被创建时没有指定 `reclaimPolicy`，它将默认为 `Delete`。

通过 StorageClass 手动创建并管理的 PersistentVolume 会使用它们被创建时指定的回收策略。

##### 允许卷扩展[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#allow-volume-expansion)

**特性状态：** `Kubernetes v1.11 [beta]`

PersistentVolume 可以配置为可扩展。将此功能设置为 `true` 时，允许用户通过编辑相应的 PVC 对象来调整卷大小。

当下层 StorageClass 的 `allowVolumeExpansion` 字段设置为 true 时，以下类型的卷支持卷扩展。

| 卷类型 | Kubernetes 版本要求 |
| --- | --- |
| gcePersistentDisk | 1.11 |
| awsElasticBlockStore | 1.11 |
| Cinder | 1.11 |
| rbd | 1.11 |
| Azure File | 1.11 |
| Azure Disk | 1.11 |
| Portworx | 1.11 |
| FlexVolume | 1.13 |
| CSI | 1.14 (alpha), 1.16 (beta) |

**说明：**

此功能仅可用于扩容卷，不能用于缩小卷。

##### 挂载选项[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#mount-options)

由 StorageClass 动态创建的 PersistentVolume 将使用类中 `mountOptions` 字段指定的挂载选项。

如果卷插件不支持挂载选项，却指定了挂载选项，则制备操作会失败。 挂载选项在 StorageClass 和 PV 上都不会做验证。如果其中一个挂载选项无效，那么这个 PV 挂载操作就会失败。

##### 卷绑定模式[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#volume-binding-mode)

`volumeBindingMode` 字段控制了[卷绑定和动态制备](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#provisioning)应该发生在什么时候。 当未设置时，默认使用 `Immediate` 模式。

`Immediate` 模式表示一旦创建了 PersistentVolumeClaim 也就完成了卷绑定和动态制备。 对于由于拓扑限制而非集群所有节点可达的存储后端，PersistentVolume 会在不知道 Pod 调度要求的情况下绑定或者制备。

集群管理员可以通过指定 `WaitForFirstConsumer` 模式来解决此问题。 该模式将延迟 PersistentVolume 的绑定和制备，直到使用该 PersistentVolumeClaim 的 Pod 被创建。 PersistentVolume 会根据 Pod 调度约束指定的拓扑来选择或制备。 这些包括但不限于[资源需求](https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/)、 [节点筛选器](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector)、 [Pod 亲和性和互斥性](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity/)、 以及[污点和容忍度](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration)。

以下插件支持动态制备的 `WaitForFirstConsumer` 模式:

- [AWSElasticBlockStore](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#aws-ebs)
- [GCEPersistentDisk](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#gce-pd)
- [AzureDisk](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-disk)

以下插件支持预创建绑定 PersistentVolume 的 `WaitForFirstConsumer` 模式：

- 上述全部
- [Local](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#local)

**特性状态：** `Kubernetes v1.17 [stable]`

动态制备和预先创建的 PV 也支持 [CSI 卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi)， 但是你需要查看特定 CSI 驱动的文档以查看其支持的拓扑键名和例子。

**说明：**

如果你选择使用 `WaitForFirstConsumer`，请不要在 Pod 规约中使用 `nodeName` 来指定节点亲和性。 如果在这种情况下使用 `nodeName`，Pod 将会绕过调度程序，PVC 将停留在 `pending` 状态。

相反，在这种情况下，你可以使用节点选择器作为主机名，如下所示。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: task-pv-pod
spec:
  nodeSelector:
    kubernetes.io/hostname: kube-01
  volumes:
    - name: task-pv-storage
      persistentVolumeClaim:
        claimName: task-pv-claim
  containers:
    - name: task-pv-container
      image: nginx
      ports:
        - containerPort: 80
          name: "http-server"
      volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: task-pv-storage
```

##### 允许的拓扑结构[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#allowed-topologies)

当集群操作人员使用了 `WaitForFirstConsumer` 的卷绑定模式， 在大部分情况下就没有必要将制备限制为特定的拓扑结构。 然而，如果还有需要的话，可以使用 `allowedTopologies`。

这个例子描述了如何将制备卷的拓扑限制在特定的区域， 在使用时应该根据插件支持情况替换 `zone` 和 `zones` 参数。

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: standard
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-standard
volumeBindingMode: WaitForFirstConsumer
allowedTopologies:
- matchLabelExpressions:
  - key: failure-domain.beta.kubernetes.io/zone
    values:
    - us-central-1a
    - us-central-1b
```

#### 参数[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#parameters)

Storage Classes 的参数描述了存储类的卷。取决于制备器，可以接受不同的参数。 例如，参数 type 的值 io1 和参数 iopsPerGB 特定于 EBS PV。 当参数被省略时，会使用默认值。

一个 StorageClass 最多可以定义 512 个参数。这些参数对象的总长度不能超过 256 KiB, 包括参数的键和值。

##### AWS EBS[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#aws-ebs)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow
provisioner: kubernetes.io/aws-ebs
parameters:
  type: io1
  iopsPerGB: "10"
  fsType: ext4
```

- `type`：`io1`，`gp2`，`sc1`，`st1`。详细信息参见 [AWS 文档](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)。默认值：`gp2`。
- `zone`(弃用)：AWS 区域。如果没有指定 `zone` 和 `zones`， 通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。 `zone` 和 `zones` 参数不能同时使用。
- `zones`(弃用)：以逗号分隔的 AWS 区域列表。 如果没有指定 `zone` 和 `zones`，通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。 `zone`和`zones`参数不能同时使用。
- `iopsPerGB`：只适用于 `io1` 卷。每 GiB 每秒 I/O 操作。 AWS 卷插件将其与请求卷的大小相乘以计算 IOPS 的容量， 并将其限制在 20000 IOPS（AWS 支持的最高值，请参阅 [AWS 文档](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)）。 这里需要输入一个字符串，即 `"10"`，而不是 `10`。
- `fsType`：受 Kubernetes 支持的文件类型。默认值：`"ext4"`。
- `encrypted`：指定 EBS 卷是否应该被加密。合法值为 `"true"` 或者 `"false"`。 这里需要输入字符串，即 `"true"`, 而非 `true`。
- `kmsKeyId`：可选。加密卷时使用密钥的完整 Amazon 资源名称。 如果没有提供，但 `encrypted` 值为 true，AWS 生成一个密钥。关于有效的 ARN 值，请参阅 AWS 文档。

**说明：**

`zone` 和 `zones` 已被弃用并被[允许的拓扑结构](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#allowed-topologies)取代。

##### GCE PD[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#gce-pd)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-standard
  fstype: ext4
  replication-type: none
```

- `type`：`pd-standard` 或者 `pd-ssd`。默认：`pd-standard`
- `zone`(弃用)：GCE 区域。如果没有指定 `zone` 和 `zones`， 通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。 `zone` 和 `zones` 参数不能同时使用。
- `zones`(弃用)：逗号分隔的 GCE 区域列表。如果没有指定 `zone` 和 `zones`， 通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度（round-robin）分配。 `zone` 和 `zones` 参数不能同时使用。
- `fstype`：`ext4` 或 `xfs`。 默认：`ext4`。宿主机操作系统必须支持所定义的文件系统类型。
- `replication-type`：`none` 或者 `regional-pd`。默认值：`none`。

如果 `replication-type` 设置为 `none`，会制备一个常规（当前区域内的）持久化磁盘。

如果 `replication-type` 设置为 `regional-pd`， 会制备一个[区域性持久化磁盘（Regional Persistent Disk）](https://cloud.google.com/compute/docs/disks/#repds)。

强烈建议设置 `volumeBindingMode: WaitForFirstConsumer`，这样设置后， 当你创建一个 Pod，它使用的 PersistentVolumeClaim 使用了这个 StorageClass， 区域性持久化磁盘会在两个区域里制备。 其中一个区域是 Pod 所在区域。 另一个区域是会在集群管理的区域中任意选择。磁盘区域可以通过 `allowedTopologies` 加以限制。

**说明：**

`zone` 和 `zones` 已被弃用并被 [allowedTopologies](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#allowed-topologies) 取代。

##### NFS[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#nfs)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: example-nfs
provisioner: example.com/external-nfs
parameters:
  server: nfs-server.example.com
  path: /share
  readOnly: "false"
```

- `server`：NFS 服务器的主机名或 IP 地址。
- `path`：NFS 服务器导出的路径。
- `readOnly`：是否将存储挂载为只读的标志（默认为 false）。

Kubernetes 不包含内部 NFS 驱动。你需要使用外部驱动为 NFS 创建 StorageClass。 这里有些例子：

- [NFS Ganesha 服务器和外部驱动](https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner)
- [NFS subdir 外部驱动](https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner)

##### OpenStack Cinder[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#openstack-cinder)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: gold
provisioner: kubernetes.io/cinder
parameters:
  availability: nova
```

- `availability`：可用区域。如果没有指定，通常卷会在 Kubernetes 集群节点所在的活动区域中轮转调度。

**说明：**

**特性状态：** `Kubernetes v1.11 [deprecated]`

OpenStack 的内部驱动已经被弃用。请使用 [OpenStack 的外部云驱动](https://github.com/kubernetes/cloud-provider-openstack)。

##### vSphere[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#vsphere)

vSphere 存储类有两种制备器：

- [CSI 制备器](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#vsphere-provisioner-csi)：`csi.vsphere.vmware.com`
- [vCP 制备器](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#vcp-provisioner)：`kubernetes.io/vsphere-volume`

树内制备器已经被 [弃用](https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/#why-are-we-migrating-in-tree-plugins-to-csi)。 更多关于 CSI 制备器的详情，请参阅 [Kubernetes vSphere CSI 驱动](https://vsphere-csi-driver.sigs.k8s.io/) 和 [vSphereVolume CSI 迁移](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#vsphere-csi-migration)。

###### CSI 制备器[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#vsphere-provisioner-csi)

vSphere CSI StorageClass 制备器在 Tanzu Kubernetes 集群下运行。示例请参阅 [vSphere CSI 仓库](https://github.com/kubernetes-sigs/vsphere-csi-driver/blob/master/example/vanilla-k8s-RWM-filesystem-volumes/example-sc.yaml)。

###### vCP 制备器[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#vcp-provisioner)

以下示例使用 VMware Cloud Provider (vCP) StorageClass 制备器。

1. 使用用户指定的磁盘格式创建一个 StorageClass。
    
    ```yaml
    apiVersion: storage.k8s.io/v1
    kind: StorageClass
    metadata:
      name: fast
    provisioner: kubernetes.io/vsphere-volume
    parameters:
      diskformat: zeroedthick
    ```
    
    `diskformat`：`thin`、`zeroedthick` 和 `eagerzeroedthick`。默认值：`"thin"`。
    

2. 在用户指定的数据存储上创建磁盘格式的 StorageClass。
    
    ```yaml
    apiVersion: storage.k8s.io/v1
    kind: StorageClass
    metadata:
      name: fast
    provisioner: kubernetes.io/vsphere-volume
    parameters:
      diskformat: zeroedthick
      datastore: VSANDatastore
    ```
    
    `datastore`：用户也可以在 StorageClass 中指定数据存储。 卷将在 StorageClass 中指定的数据存储上创建，在这种情况下是 `VSANDatastore`。 该字段是可选的。 如果未指定数据存储，则将在用于初始化 vSphere Cloud Provider 的 vSphere 配置文件中指定的数据存储上创建该卷。
    

3. Kubernetes 中的存储策略管理
    
    - 使用现有的 vCenter SPBM 策略
        
        vSphere 用于存储管理的最重要特性之一是基于策略的管理。 基于存储策略的管理（SPBM）是一个存储策略框架，提供单一的统一控制平面的跨越广泛的数据服务和存储解决方案。 SPBM 使得 vSphere 管理员能够克服先期的存储配置挑战，如容量规划、差异化服务等级和管理容量空间。
        
        SPBM 策略可以在 StorageClass 中使用 `storagePolicyName` 参数声明。
        
    
    - Kubernetes 内的 Virtual SAN 策略支持
        
        Vsphere Infrastructure（VI）管理员将能够在动态卷配置期间指定自定义 Virtual SAN 存储功能。你现在可以在动态制备卷期间以存储能力的形式定义存储需求，例如性能和可用性。 存储能力需求会转换为 Virtual SAN 策略，之后当持久卷（虚拟磁盘）被创建时， 会将其推送到 Virtual SAN 层。虚拟磁盘分布在 Virtual SAN 数据存储中以满足要求。
        
        你可以参考[基于存储策略的动态制备卷管理](https://github.com/vmware-archive/vsphere-storage-for-kubernetes/blob/fa4c8b8ad46a85b6555d715dd9d27ff69839df53/documentation/policy-based-mgmt.md)， 进一步了解有关持久卷管理的存储策略的详细信息。
        

有几个 [vSphere 例子](https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere)供你在 Kubernetes for vSphere 中尝试进行持久卷管理。

##### Ceph RBD[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#ceph-rbd)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/rbd
parameters:
  monitors: 10.16.153.105:6789
  adminId: kube
  adminSecretName: ceph-secret
  adminSecretNamespace: kube-system
  pool: kube
  userId: kube
  userSecretName: ceph-secret-user
  userSecretNamespace: default
  fsType: ext4
  imageFormat: "2"
  imageFeatures: "layering"
```

- `monitors`：Ceph monitor，逗号分隔。该参数是必需的。
- `adminId`：Ceph 客户端 ID，用于在池 ceph 池中创建映像。默认是 "admin"。
- `adminSecret`：`adminId` 的 Secret 名称。该参数是必需的。 提供的 secret 必须有值为 "kubernetes.io/rbd" 的 type 参数。
- `adminSecretNamespace`：`adminSecret` 的命名空间。默认是 "default"。
- `pool`：Ceph RBD 池。默认是 "rbd"。
- `userId`：Ceph 客户端 ID，用于映射 RBD 镜像。默认与 `adminId` 相同。

- `userSecretName`：用于映射 RBD 镜像的 `userId` 的 Ceph Secret 的名字。 它必须与 PVC 存在于相同的 namespace 中。该参数是必需的。 提供的 secret 必须具有值为 "kubernetes.io/rbd" 的 type 参数，例如以这样的方式创建：
    
    ```shell
    kubectl create secret generic ceph-secret --type="kubernetes.io/rbd" \
      --from-literal=key='QVFEQ1pMdFhPUnQrSmhBQUFYaERWNHJsZ3BsMmNjcDR6RFZST0E9PQ==' \
      --namespace=kube-system
    ```
    

- `userSecretNamespace`：`userSecretName` 的命名空间。
- `fsType`：Kubernetes 支持的 fsType。默认：`"ext4"`。
- `imageFormat`：Ceph RBD 镜像格式，"1" 或者 "2"。默认值是 "1"。
- `imageFeatures`：这个参数是可选的，只能在你将 `imageFormat` 设置为 "2" 才使用。 目前支持的功能只是 `layering`。默认是 ""，没有功能打开。

##### Azure 磁盘[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-disk)

###### Azure Unmanaged Disk Storage Class（非托管磁盘存储类）[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-unmanaged-disk-storage-class)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow
provisioner: kubernetes.io/azure-disk
parameters:
  skuName: Standard_LRS
  location: eastus
  storageAccount: azure_storage_account_name
```

- `skuName`：Azure 存储帐户 Sku 层。默认为空。
- `location`：Azure 存储帐户位置。默认为空。
- `storageAccount`：Azure 存储帐户名称。 如果提供存储帐户，它必须位于与集群相同的资源组中，并且 `location` 是被忽略的。如果未提供存储帐户，则会在与集群相同的资源组中创建新的存储帐户。

###### Azure 磁盘 Storage Class（从 v1.7.2 开始）[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-disk-storage-class)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow
provisioner: kubernetes.io/azure-disk
parameters:
  storageaccounttype: Standard_LRS
  kind: managed
```

- `storageaccounttype`：Azure 存储帐户 Sku 层。默认为空。
- `kind`：可能的值是 `shared`、`dedicated` 和 `managed`（默认）。 当 `kind` 的值是 `shared` 时，所有非托管磁盘都在集群的同一个资源组中的几个共享存储帐户中创建。 当 `kind` 的值是 `dedicated` 时，将为在集群的同一个资源组中新的非托管磁盘创建新的专用存储帐户。
- `resourceGroup`：指定要创建 Azure 磁盘所属的资源组。必须是已存在的资源组名称。 若未指定资源组，磁盘会默认放入与当前 Kubernetes 集群相同的资源组中。

- Premium VM 可以同时添加 Standard\_LRS 和 Premium\_LRS 磁盘，而 Standard 虚拟机只能添加 Standard\_LRS 磁盘。
- 托管虚拟机只能连接托管磁盘，非托管虚拟机只能连接非托管磁盘。

##### Azure 文件[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#azure-file)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: azurefile
provisioner: kubernetes.io/azure-file
parameters:
  skuName: Standard_LRS
  location: eastus
  storageAccount: azure_storage_account_name
```

- `skuName`：Azure 存储帐户 Sku 层。默认为空。
- `location`：Azure 存储帐户位置。默认为空。
- `storageAccount`：Azure 存储帐户名称。默认为空。 如果不提供存储帐户，会搜索所有与资源相关的存储帐户，以找到一个匹配 `skuName` 和 `location` 的账号。 如果提供存储帐户，它必须存在于与集群相同的资源组中，`skuName` 和 `location` 会被忽略。
- `secretNamespace`：包含 Azure 存储帐户名称和密钥的密钥的名字空间。 默认值与 Pod 相同。
- `secretName`：包含 Azure 存储帐户名称和密钥的密钥的名称。 默认值为 `azure-storage-account-<accountName>-secret`
- `readOnly`：指示是否将存储安装为只读的标志。默认为 false，表示"读/写"挂载。 该设置也会影响 VolumeMounts 中的 `ReadOnly` 设置。

在存储制备期间，为挂载凭证创建一个名为 `secretName` 的 Secret。如果集群同时启用了 [RBAC](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/) 和[控制器角色](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/rbac/#controller-roles)， 为 `system:controller:persistent-volume-binder` 的 clusterrole 添加 `Secret` 资源的 `create` 权限。

在多租户上下文中，强烈建议显式设置 `secretNamespace` 的值，否则其他用户可能会读取存储帐户凭据。

##### Portworx 卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#portworx-volume)

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: portworx-io-priority-high
provisioner: kubernetes.io/portworx-volume
parameters:
  repl: "1"
  snap_interval: "70"
  priority_io: "high"
```

- `fs`：选择的文件系统：`none/xfs/ext4`（默认：`ext4`）。
- `block_size`：以 Kbytes 为单位的块大小（默认值：`32`）。
- `repl`：同步副本数量，以复制因子 `1..3`（默认值：`1`）的形式提供。 这里需要填写字符串，即，`"1"` 而不是 `1`。
- `io_priority`：决定是否从更高性能或者较低优先级存储创建卷 `high/medium/low`（默认值：`low`）。
- `snap_interval`：触发快照的时钟/时间间隔（分钟）。 快照是基于与先前快照的增量变化，0 是禁用快照（默认：`0`）。 这里需要填写字符串，即，是 `"70"` 而不是 `70`。
- `aggregation_level`：指定卷分配到的块数量，0 表示一个非聚合卷（默认：`0`）。 这里需要填写字符串，即，是 `"0"` 而不是 `0`。
- `ephemeral`：指定卷在卸载后进行清理还是持久化。 `emptyDir` 的使用场景可以将这个值设置为 true， `persistent volumes` 的使用场景可以将这个值设置为 false （例如 Cassandra 这样的数据库） `true/false`（默认为 `false`）。这里需要填写字符串，即， 是 `"true"` 而不是 `true`。

##### 本地[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#local)

**特性状态：** `Kubernetes v1.14 [stable]`

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
```

本地卷还不支持动态制备，然而还是需要创建 StorageClass 以延迟卷绑定， 直到完成 Pod 的调度。这是由 `WaitForFirstConsumer` 卷绑定模式指定的。

延迟卷绑定使得调度器在为 PersistentVolumeClaim 选择一个合适的 PersistentVolume 时能考虑到所有 Pod 的调度限制。
### [动态卷制备](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/)
动态卷制备允许按需创建存储卷。 如果没有动态制备，集群管理员必须手动地联系他们的云或存储提供商来创建新的存储卷， 然后在 Kubernetes 集群创建 [`PersistentVolume` 对象](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/)来表示这些卷。 动态制备功能消除了集群管理员预先配置存储的需要。相反，它在用户请求时自动制备存储。

#### 背景[](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/#background)

动态卷制备的实现基于 `storage.k8s.io` API 组中的 `StorageClass` API 对象。 集群管理员可以根据需要定义多个 `StorageClass` 对象，每个对象指定一个**卷插件**（又名 **provisioner**）， 卷插件向卷制备商提供在创建卷时需要的数据卷信息及相关参数。

集群管理员可以在集群中定义和公开多种存储（来自相同或不同的存储系统），每种都具有自定义参数集。 该设计也确保终端用户不必担心存储制备的复杂性和细微差别，但仍然能够从多个存储选项中进行选择。

点击[这里](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)查阅有关存储类的更多信息。

#### 启用动态卷制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/#enabling-dynamic-provisioning)

要启用动态制备功能，集群管理员需要为用户预先创建一个或多个 `StorageClass` 对象。 `StorageClass` 对象定义当动态制备被调用时，哪一个驱动将被使用和哪些参数将被传递给驱动。 StorageClass 对象的名字必须是一个合法的 [DNS 子域名](https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)。 以下清单创建了一个 `StorageClass` 存储类 "slow"，它提供类似标准磁盘的永久磁盘。

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: slow
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-standard
```

以下清单创建了一个 "fast" 存储类，它提供类似 SSD 的永久磁盘。

```yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-ssd
```

#### 使用动态卷制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/#using-dynamic-provisioning)

用户通过在 `PersistentVolumeClaim` 中包含存储类来请求动态制备的存储。 在 Kubernetes v1.9 之前，这通过 `volume.beta.kubernetes.io/storage-class` 注解实现。 然而，这个注解自 v1.6 起就不被推荐使用了。 用户现在能够而且应该使用 `PersistentVolumeClaim` 对象的 `storageClassName` 字段。 这个字段的值必须能够匹配到集群管理员配置的 `StorageClass` 名称（见[下面](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/#enabling-dynamic-provisioning)）。

例如，要选择 “fast” 存储类，用户将创建如下的 PersistentVolumeClaim：

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: claim1
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: fast
  resources:
    requests:
      storage: 30Gi
```

该声明会自动制备一块类似 SSD 的永久磁盘。 在删除该声明后，这个卷也会被销毁。

#### 设置默认值的行为[](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/#defaulting-behavior)

可以在集群上启用动态卷制备，以便在未指定存储类的情况下动态设置所有声明。 集群管理员可以通过以下方式启用此行为：

- 标记一个 `StorageClass` 为 **默认**；
- 确保 [`DefaultStorageClass` 准入控制器](https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass)在 API 服务器端被启用。

管理员可以通过向其添加 [`storageclass.kubernetes.io/is-default-class` 注解](https://kubernetes.io/zh-cn/docs/reference/labels-annotations-taints/#storageclass-kubernetes-io-is-default-class) 来将特定的 `StorageClass` 标记为默认。 当集群中存在默认的 `StorageClass` 并且用户创建了一个未指定 `storageClassName` 的 `PersistentVolumeClaim` 时， `DefaultStorageClass` 准入控制器会自动向其中添加指向默认存储类的 `storageClassName` 字段。

请注意，集群上最多只能有一个 **默认** 存储类，否则无法创建没有明确指定 `storageClassName` 的 `PersistentVolumeClaim`。

#### 拓扑感知[](https://kubernetes.io/zh-cn/docs/concepts/storage/dynamic-provisioning/#topology-awareness)

在[多可用区](https://kubernetes.io/zh-cn/docs/setup/best-practices/multiple-zones/)集群中，Pod 可以被分散到某个区域的多个可用区。 单可用区存储后端应该被制备到 Pod 被调度到的可用区。 这可以通过设置[卷绑定模式](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#volume-binding-mode)来实现。
### [卷快照](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/)
在 Kubernetes 中，**卷快照** 是一个存储系统上卷的快照，本文假设你已经熟悉了 Kubernetes 的[持久卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/)。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#introduction)

与 `PersistentVolume` 和 `PersistentVolumeClaim` 这两个 API 资源用于给用户和管理员制备卷类似， `VolumeSnapshotContent` 和 `VolumeSnapshot` 这两个 API 资源用于给用户和管理员创建卷快照。

`VolumeSnapshotContent` 是从一个卷获取的一种快照，该卷由管理员在集群中进行制备。 就像持久卷（PersistentVolume）是集群的资源一样，它也是集群中的资源。

`VolumeSnapshot` 是用户对于卷的快照的请求。它类似于持久卷声明（PersistentVolumeClaim）。

`VolumeSnapshotClass` 允许指定属于 `VolumeSnapshot` 的不同属性。在从存储系统的相同卷上获取的快照之间， 这些属性可能有所不同，因此不能通过使用与 `PersistentVolumeClaim` 相同的 `StorageClass` 来表示。

卷快照能力为 Kubernetes 用户提供了一种标准的方式来在指定时间点复制卷的内容，并且不需要创建全新的卷。 例如，这一功能使得数据库管理员能够在执行编辑或删除之类的修改之前对数据库执行备份。

当使用该功能时，用户需要注意以下几点：

- API 对象 `VolumeSnapshot`，`VolumeSnapshotContent` 和 `VolumeSnapshotClass` 是 [CRD](https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/)， 不属于核心 API。
- `VolumeSnapshot` 支持仅可用于 CSI 驱动。
- 作为 `VolumeSnapshot` 部署过程的一部分，Kubernetes 团队提供了一个部署于控制平面的快照控制器， 并且提供了一个叫做 `csi-snapshotter` 的边车（Sidecar）辅助容器，和 CSI 驱动程序一起部署。 快照控制器监视 `VolumeSnapshot` 和 `VolumeSnapshotContent` 对象， 并且负责创建和删除 `VolumeSnapshotContent` 对象。 边车 csi-snapshotter 监视 `VolumeSnapshotContent` 对象， 并且触发针对 CSI 端点的 `CreateSnapshot` 和 `DeleteSnapshot` 的操作。
- 还有一个验证性质的 Webhook 服务器，可以对快照对象进行更严格的验证。 Kubernetes 发行版应将其与快照控制器和 CRD（而非 CSI 驱动程序）一起安装。 此服务器应该安装在所有启用了快照功能的 Kubernetes 集群中。
- CSI 驱动可能实现，也可能没有实现卷快照功能。CSI 驱动可能会使用 csi-snapshotter 来提供对卷快照的支持。详见 [CSI 驱动程序文档](https://kubernetes-csi.github.io/docs/)
- Kubernetes 负责 CRD 和快照控制器的安装。

#### 卷快照和卷快照内容的生命周期[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#lifecycle-of-a-volume-snapshot-and-volume-snapshot-content)

`VolumeSnapshotContents` 是集群中的资源。`VolumeSnapshots` 是对于这些资源的请求。 `VolumeSnapshotContents` 和 `VolumeSnapshots` 之间的交互遵循以下生命周期：

##### 制备卷快照[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#provisioning-volume-snapshot)

快照可以通过两种方式进行制备：预制备或动态制备。

###### 预制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#static)

集群管理员创建多个 `VolumeSnapshotContents`。它们带有存储系统上实际卷快照的详细信息，可以供集群用户使用。 它们存在于 Kubernetes API 中，并且能够被使用。

###### 动态制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#dynamic)

可以从 `PersistentVolumeClaim` 中动态获取快照，而不用使用已经存在的快照。 在获取快照时，[卷快照类](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/) 指定要用的特定于存储提供程序的参数。

##### 绑定[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#binding)

在预制备和动态制备场景下，快照控制器处理绑定 `VolumeSnapshot` 对象和其合适的 `VolumeSnapshotContent` 对象。 绑定关系是一对一的。

在预制备快照绑定场景下，`VolumeSnapshotContent` 对象创建之后，才会和 `VolumeSnapshot` 进行绑定。

##### 快照源的持久性卷声明保护[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#persistent-volume-claim-as-snapshot-source-protection)

这种保护的目的是确保在从系统中获取快照时，不会将正在使用的 [PersistentVolumeClaim](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims) API 对象从系统中删除（因为这可能会导致数据丢失）。

在为某 `PersistentVolumeClaim` 生成快照时，该 `PersistentVolumeClaim` 处于被使用状态。 如果删除一个正作为快照源使用的 `PersistentVolumeClaim` API 对象，该 `PersistentVolumeClaim` 对象不会立即被移除。 相反，移除 `PersistentVolumeClaim` 对象的动作会被推迟，直到快照状态变为 ReadyToUse 或快照操作被中止时再执行。

##### 删除[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#delete)

删除 `VolumeSnapshot` 对象触发删除 `VolumeSnapshotContent` 操作，并且 `DeletionPolicy` 会紧跟着执行。 如果 `DeletionPolicy` 是 `Delete`，那么底层存储快照会和 `VolumeSnapshotContent` 一起被删除。 如果 `DeletionPolicy` 是 `Retain`，那么底层快照和 `VolumeSnapshotContent` 都会被保留。

#### 卷快照[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#volume-snapshots)

每个 `VolumeSnapshot` 包含一个 spec 和一个 status。

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: new-snapshot-test
spec:
  volumeSnapshotClassName: csi-hostpath-snapclass
  source:
    persistentVolumeClaimName: pvc-test
```

`persistentVolumeClaimName` 是 `PersistentVolumeClaim` 数据源对快照的名称。 这个字段是动态制备快照中的必填字段。

卷快照可以通过指定 [VolumeSnapshotClass](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/) 使用 `volumeSnapshotClassName` 属性来请求特定类。如果没有设置，那么使用默认类（如果有）。

如下面例子所示，对于预制备的快照，需要给快照指定 `volumeSnapshotContentName` 作为来源。 对于预制备的快照 `source` 中的`volumeSnapshotContentName` 字段是必填的。

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: test-snapshot
spec:
  source:
    volumeSnapshotContentName: test-content
```

#### 卷快照内容[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#volume-snapshot-contents)

每个 VolumeSnapshotContent 对象包含 spec 和 status。 在动态制备时，快照通用控制器创建 `VolumeSnapshotContent` 对象。下面是例子：

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotContent
metadata:
  name: snapcontent-72d9a349-aacd-42d2-a240-d775650d2455
spec:
  deletionPolicy: Delete
  driver: hostpath.csi.k8s.io
  source:
    volumeHandle: ee0cfb94-f8d4-11e9-b2d8-0242ac110002
  sourceVolumeMode: Filesystem
  volumeSnapshotClassName: csi-hostpath-snapclass
  volumeSnapshotRef:
    name: new-snapshot-test
    namespace: default
    uid: 72d9a349-aacd-42d2-a240-d775650d2455
```

`volumeHandle` 是存储后端创建卷的唯一标识符，在卷创建期间由 CSI 驱动程序返回。 动态设置快照需要此字段。它指出了快照的卷源。

对于预制备快照，你（作为集群管理员）要按如下命令来创建 `VolumeSnapshotContent` 对象。

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotContent
metadata:
  name: new-snapshot-content-test
spec:
  deletionPolicy: Delete
  driver: hostpath.csi.k8s.io
  source:
    snapshotHandle: 7bdd0de3-aaeb-11e8-9aae-0242ac110002
  sourceVolumeMode: Filesystem
  volumeSnapshotRef:
    name: new-snapshot-test
    namespace: default
```

`snapshotHandle` 是存储后端创建卷的唯一标识符。对于预制备的快照，这个字段是必需的。 它指定此 `VolumeSnapshotContent` 表示的存储系统上的 CSI 快照 ID。

`sourceVolumeMode` 是创建快照的卷的模式。`sourceVolumeMode` 字段的值可以是 `Filesystem` 或 `Block`。如果没有指定源卷模式，Kubernetes 会将快照视为未知的源卷模式。

`volumeSnapshotRef` 字段是对相应的 `VolumeSnapshot` 的引用。 请注意，当 `VolumeSnapshotContent` 被创建为预配置快照时。 `volumeSnapshotRef` 中引用的 `VolumeSnapshot` 可能还不存在。

#### 转换快照的卷模式[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#convert-volume-mode)

如果在你的集群上安装的 `VolumeSnapshots` API 支持 `sourceVolumeMode` 字段，则该 API 可以防止未经授权的用户转换卷的模式。

要检查你的集群是否具有此特性的能力，可以运行如下命令：

```shell
kubectl get crd volumesnapshotcontent -o yaml
```

如果你希望允许用户从现有的 `VolumeSnapshot` 创建 `PersistentVolumeClaim`， 但是使用与源卷不同的卷模式，则需要添加注解 `snapshot.storage.kubernetes.io/allow-volume-mode-change: "true"` 到对应 `VolumeSnapshot` 的 `VolumeSnapshotContent` 中。

对于预制备的快照，`spec.sourceVolumeMode` 需要由集群管理员填充。

启用此特性的 `VolumeSnapshotContent` 资源示例如下所示：

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotContent
metadata:
  name: new-snapshot-content-test
  annotations:
    - snapshot.storage.kubernetes.io/allow-volume-mode-change: "true"
spec:
  deletionPolicy: Delete
  driver: hostpath.csi.k8s.io
  source:
    snapshotHandle: 7bdd0de3-aaeb-11e8-9aae-0242ac110002
  sourceVolumeMode: Filesystem
  volumeSnapshotRef:
    name: new-snapshot-test
    namespace: default
```

#### 从快照制备卷[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/#provisioning-volumes-from-snapshots)

你可以制备一个新卷，该卷预填充了快照中的数据，在 `PersistentVolumeClaim` 对象中使用 **dataSource** 字段。

更多详细信息， 请参阅[卷快照和从快照还原卷](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#volume-snapshot-and-restore-volume-from-snapshot-support)。
### [卷快照类](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/)
本文档描述了 Kubernetes 中 VolumeSnapshotClass 的概念。建议熟悉 [卷快照（Volume Snapshots）](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/)和 [存储类（Storage Class）](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes)。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/#introduction)

就像 StorageClass 为管理员提供了一种在配置卷时描述存储“类”的方法， VolumeSnapshotClass 提供了一种在配置卷快照时描述存储“类”的方法。

#### VolumeSnapshotClass 资源[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/#the-volumesnapshortclass-resource)

每个 VolumeSnapshotClass 都包含 `driver`、`deletionPolicy` 和 `parameters` 字段， 在需要动态配置属于该类的 VolumeSnapshot 时使用。

VolumeSnapshotClass 对象的名称很重要，是用户可以请求特定类的方式。 管理员在首次创建 VolumeSnapshotClass 对象时设置类的名称和其他参数， 对象一旦创建就无法更新。

**说明：** CRD 的安装是 Kubernetes 发行版的责任。 如果不存在所需的 CRD，则 VolumeSnapshotClass 的创建将失败。

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snapclass
driver: hostpath.csi.k8s.io
deletionPolicy: Delete
parameters:
```

管理员可以为未请求任何特定类绑定的 VolumeSnapshots 指定默认的 VolumeSnapshotClass， 方法是设置注解 `snapshot.storage.kubernetes.io/is-default-class: "true"`：

```yaml
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snapclass
  annotations:
    snapshot.storage.kubernetes.io/is-default-class: "true"
driver: hostpath.csi.k8s.io
deletionPolicy: Delete
parameters:
```

##### 驱动程序[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/#driver)

卷快照类有一个驱动程序，用于确定配置 VolumeSnapshot 的 CSI 卷插件。 此字段必须指定。

##### 删除策略[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/#deletion-policy)

卷快照类具有 `deletionPolicy` 属性。用户可以配置当所绑定的 VolumeSnapshot 对象将被删除时，如何处理 VolumeSnapshotContent 对象。 卷快照类的这个策略可以是 `Retain` 或者 `Delete`。这个策略字段必须指定。

如果删除策略是 `Delete`，那么底层的存储快照会和 VolumeSnapshotContent 对象 一起删除。如果删除策略是 `Retain`，那么底层快照和 VolumeSnapshotContent 对象都会被保留。

#### 参数[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshot-classes/#parameters)

卷快照类具有描述属于该卷快照类的卷快照的参数，可根据 `driver` 接受不同的参数。
### [CSI 卷克隆](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-pvc-datasource/)
本文档介绍 Kubernetes 中克隆现有 CSI 卷的概念。阅读前建议先熟悉 [卷](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes)。

#### 介绍[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-pvc-datasource/#%E4%BB%8B%E7%BB%8D)

[CSI](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/#csi) 卷克隆功能增加了通过在 `dataSource` 字段中指定存在的 [PVC](https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims)， 来表示用户想要克隆的 [卷（Volume）](https://kubernetes.io/zh-cn/docs/concepts/storage/volumes/)。

克隆（Clone），意思是为已有的 Kubernetes 卷创建副本，它可以像任何其它标准卷一样被使用。 唯一的区别就是配置后，后端设备将创建指定完全相同的副本，而不是创建一个“新的”空卷。

从 Kubernetes API 的角度看，克隆的实现只是在创建新的 PVC 时， 增加了指定一个现有 PVC 作为数据源的能力。源 PVC 必须是 bound 状态且可用的（不在使用中）。

用户在使用该功能时，需要注意以下事项：

- 克隆支持（`VolumePVCDataSource`）仅适用于 CSI 驱动。
- 克隆支持仅适用于 动态供应器。
- CSI 驱动可能实现，也可能未实现卷克隆功能。
- 仅当 PVC 与目标 PVC 存在于同一命名空间（源和目标 PVC 必须在相同的命名空间）时，才可以克隆 PVC。
- 支持用一个不同存储类进行克隆。
    - 目标卷和源卷可以是相同的存储类，也可以不同。
    - 可以使用默认的存储类，也可以在 spec 中省略 storageClassName 字段。
- 克隆只能在两个使用相同 VolumeMode 设置的卷中进行 （如果请求克隆一个块存储模式的卷，源卷必须也是块存储模式）。

#### 制备[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-pvc-datasource/#%E5%88%B6%E5%A4%87)

克隆卷与其他任何 PVC 一样配置，除了需要增加 dataSource 来引用同一命名空间中现有的 PVC。

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
    name: clone-of-pvc-1
    namespace: myns
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: cloning
  resources:
    requests:
      storage: 5Gi
  dataSource:
    kind: PersistentVolumeClaim
    name: pvc-1
```

**说明：**

你必须为 `spec.resources.requests.storage` 指定一个值，并且你指定的值必须大于或等于源卷的值。

结果是一个名称为 `clone-of-pvc-1` 的新 PVC 与指定的源 `pvc-1` 拥有相同的内容。

#### 使用[](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-pvc-datasource/#%E4%BD%BF%E7%94%A8)

一旦新的 PVC 可用，被克隆的 PVC 像其他 PVC 一样被使用。 可以预期的是，新创建的 PVC 是一个独立的对象。 可以独立使用、克隆、快照或删除它，而不需要考虑它的原始数据源 PVC。 这也意味着，源没有以任何方式链接到新创建的 PVC，它也可以被修改或删除，而不会影响到新创建的克隆。
### [存储容量](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/)
存储容量是有限的，并且会因为运行 Pod 的节点不同而变化： 网络存储可能并非所有节点都能够访问，或者对于某个节点存储是本地的。

**特性状态：** `Kubernetes v1.24 [stable]`

本页面描述了 Kubernetes 如何跟踪存储容量以及调度程序如何为了余下的尚未挂载的卷使用该信息将 [Pod 调度](https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/)到能够访问到足够存储容量的节点上。 如果没有跟踪存储容量，调度程序可能会选择一个没有足够容量来提供卷的节点，并且需要多次调度重试。

#### 准备开始[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B)

Kubernetes v1.26 包含了对存储容量跟踪的集群级 API 支持。 要使用它，你还必须使用支持容量跟踪的 CSI 驱动程序。请查阅你使用的 CSI 驱动程序的文档， 以了解此支持是否可用，如果可用，该如何使用它。如果你运行的不是 Kubernetes v1.26，请查看对应版本的 Kubernetes 文档。

#### API[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/#api)

这个特性有两个 API 扩展接口：

- [CSIStorageCapacity](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1/) 对象：这些对象由 CSI 驱动程序在安装驱动程序的命名空间中产生。 每个对象都包含一个存储类的容量信息，并定义哪些节点可以访问该存储。
- [`CSIDriverSpec.StorageCapacity` 字段](https://kubernetes.io/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/#CSIDriverSpec)： 设置为 true 时，Kubernetes 调度程序将考虑使用 CSI 驱动程序的卷的存储容量。

#### 调度[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/#scheduling)

如果有以下情况，存储容量信息将会被 Kubernetes 调度程序使用：

- Pod 使用的卷还没有被创建，
- 卷使用引用了 CSI 驱动的 [StorageClass](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/)， 并且使用了 `WaitForFirstConsumer` [卷绑定模式](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/#volume-binding-mode)，
- 驱动程序的 `CSIDriver` 对象的 `StorageCapacity` 被设置为 true。

在这种情况下，调度程序仅考虑将 Pod 调度到有足够存储容量的节点上。这个检测非常简单， 仅将卷的大小与 `CSIStorageCapacity` 对象中列出的容量进行比较，并使用包含该节点的拓扑。

对于具有 `Immediate` 卷绑定模式的卷，存储驱动程序将决定在何处创建该卷，而不取决于将使用该卷的 Pod。 然后，调度程序将 Pod 调度到创建卷后可使用该卷的节点上。

对于 [CSI 临时卷](https://kubernetes.io/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes)， 调度总是在不考虑存储容量的情况下进行。 这是基于这样的假设：该卷类型仅由节点本地的特殊 CSI 驱动程序使用，并且不需要大量资源。

#### 重新调度[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/#rescheduling)

当为带有 `WaitForFirstConsumer` 的卷的 Pod 来选择节点时，该决定仍然是暂定的。 下一步是要求 CSI 存储驱动程序创建卷，并提示该卷在被选择的节点上可用。

因为 Kubernetes 可能会根据已经过时的存储容量信息来选择一个节点，因此可能无法真正创建卷。 然后就会重置节点选择，Kubernetes 调度器会再次尝试为 Pod 查找节点。

#### 限制[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/#limitations)

存储容量跟踪增加了调度器第一次尝试即成功的机会，但是并不能保证这一点，因为调度器必须根据可能过期的信息来进行决策。 通常，与没有任何存储容量信息的调度相同的重试机制可以处理调度失败。

当 Pod 使用多个卷时，调度可能会永久失败：一个卷可能已经在拓扑段中创建，而该卷又没有足够的容量来创建另一个卷， 要想从中恢复，必须要进行手动干预，比如通过增加存储容量或者删除已经创建的卷。

#### 接下来[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-capacity/#%E6%8E%A5%E4%B8%8B%E6%9D%A5)

- 想要获得更多该设计的信息，查看 [Storage Capacity Constraints for Pod Scheduling KEP](https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md)。
### [特定于节点的卷数限制](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-limits/)
此页面描述了各个云供应商可关联至一个节点的最大卷数。

谷歌、亚马逊和微软等云供应商通常对可以关联到节点的卷数量进行限制。 Kubernetes 需要尊重这些限制。 否则，在节点上调度的 Pod 可能会卡住去等待卷的关联。

#### Kubernetes 的默认限制[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-limits/#kubernetes-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%99%90%E5%88%B6)

The Kubernetes 调度器对关联于一个节点的卷数有默认限制：

| 云服务 | 每节点最大卷数 |
| --- | --- |
| [Amazon Elastic Block Store (EBS)](https://aws.amazon.com/ebs/) | 39 |
| [Google Persistent Disk](https://cloud.google.com/persistent-disk/) | 16 |
| [Microsoft Azure Disk Storage](https://azure.microsoft.com/en-us/services/storage/main-disks/) | 16 |

#### 自定义限制[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-limits/#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%99%90%E5%88%B6)

你可以通过设置 `KUBE_MAX_PD_VOLS` 环境变量的值来设置这些限制，然后再启动调度器。 CSI 驱动程序可能具有不同的过程，关于如何自定义其限制请参阅相关文档。

如果设置的限制高于默认限制，请谨慎使用。请参阅云提供商的文档以确保节点可支持你设置的限制。

此限制应用于整个集群，所以它会影响所有节点。

#### 动态卷限制[](https://kubernetes.io/zh-cn/docs/concepts/storage/storage-limits/#%E5%8A%A8%E6%80%81%E5%8D%B7%E9%99%90%E5%88%B6)

**特性状态：** `Kubernetes v1.17 [stable]`

以下卷类型支持动态卷限制。

- Amazon EBS
- Google Persistent Disk
- Azure Disk
- CSI

对于由内建插件管理的卷，Kubernetes 会自动确定节点类型并确保节点上可关联的卷数目合规。 例如：

- 在 [Google Compute Engine](https://cloud.google.com/compute/)环境中, [根据节点类型](https://cloud.google.com/compute/docs/disks/#pdnumberlimits)最多可以将127个卷关联到节点。
    
- 对于 M5、C5、R5、T3 和 Z1D 类型实例的 Amazon EBS 磁盘，Kubernetes 仅允许 25 个卷关联到节点。 对于 ec2 上的其他实例类型 [Amazon Elastic Compute Cloud (EC2)](https://aws.amazon.com/ec2/), Kubernetes 允许 39 个卷关联至节点。
    
- 在 Azure 环境中, 根据节点类型，最多 64 个磁盘可以关联至一个节点。 更多详细信息，请参阅[Azure 虚拟机的数量大小](https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes)。
    
- 如果 CSI 存储驱动程序（使用 `NodeGetInfo` ）为节点通告卷数上限，则 [kube-scheduler](https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/) 将遵守该限制值。 参考 [CSI 规范](https://github.com/container-storage-interface/spec/blob/master/spec.md#nodegetinfo) 获取更多详细信息。
    
- 对于由已迁移到 CSI 驱动程序的树内插件管理的卷，最大卷数将是 CSI 驱动程序报告的卷数。
### [卷健康监测](https://kubernetes.io/zh-cn/docs/concepts/storage/volume-health-monitoring/)

### [Windows 存储](https://kubernetes.io/zh-cn/docs/concepts/storage/windows-storage/)