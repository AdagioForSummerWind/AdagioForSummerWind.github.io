---
title: "Mysql_base_13"
date: 2021-11-09T11:28:55+08:00
lastmod: 2021-11-15
tags: [mysql]
categories: [School courses]
slug: Database transaction processing technology
draft: true
---
> 笔记来自哈工大深圳2021秋数据库系统理论课授课老师：刘圣鑫

# 事务处理
## 为什么需要并发控制
并发控制的缘由:   
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115213756.png)
并发控制及相应的事务处理技术是DBMS的核心技术:
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115213906.png)
## 事务调度及可串行性
**事务**是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证.

事务的宏观性和微观性:
- 事务的宏观性(应用程序员看到的事务): 一个存取或改变数据库内容的
程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务。事务一般是由应用程序员提出，因此有开始和结束, 结束前需要提交或撤消。   
在嵌入式SQL程序中，任何一条数据库操纵语句(如exec sql select等)都会引发一个新事务的开始，只要该程序当前没有正在处理的事务。而事务的结束是需要应用程序员通过commit或rollback确认的。因此Begin Transaction 和End Transaction两行语句是不需要的
```
Begin Transaction
exec sql …
…
exec sql …
exec sql commit work | exec sql rollback work
End Transaction
```
- 事务的微观性(DBMS看到的事务): 对数据库的一系列基本操作(读、
写)的一个整体性执行.事务的并发执行：多个事务从宏观上看是并行执行的，但其微观上的基本操作(读、写)则可以是交叉执行的

事务的特性: ACID
- 原子性Atomicity : DBMS能够保证事务的一组更新操作是原子不可分的，即对 DB而言，要么全做，要么全不做。
- 一致性Consistency: DBMS保证事务的操作状态是正确的，符合一致性的操作 规则，不能出现三种典型的不一致性。它是进一步由隔离性来保证的。
- 隔离性Isolation: DBMS保证并发执行的多个事务之间互相不受影响。例如两个事务T1和T2, 即使并发执行，也相当于或者先执行了T1,再执行T2;反之亦然。
- 持久性Durability: DBMS保证已提交事务的影响是持久的，被撤销事务的影响是可恢复的
- 具有ACID特性的若干数据库基本操作的组合体被称为事务

 DBMS对事务的控制:
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115214503.png)

事务调度与可串行性:   
- 事务调度(schedule)：一组事务的基本步(读、写、其他控制操作如加锁、解锁等)的一种执行顺序称为对这组事务的一个调度。 并发(或并行)调度：多个事务从宏观上看是并行执行的，但其微观上的基本 操作(读、写)则是交叉执行的。
- 并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。
- 可串行性：如果不管数据库初始状态如何，一个调度对数据 库状态的影响都和某个串行调度相同，则我们说这个调度是可串行化的 
(Serializable)或具有可串行性(Serializability)。
- 可串行化调度一定是正确的并行调度，但正确的并行调度，却未必都是可串行化的调度。
- 并行调度的正确性是指内容上结果正确性，而可串行性是指形式上结果正确性，便于操作(如右侧图T2中的B=B-20改为B=B-0,则调度是正确的，但是不可串行化)
- 可串行化的等效串行序列不一定唯一。
- 一种简单的事务调度的标记模型,表达事务调度的一种模型
    - rT(A): 事务T读A。 wT(A)：事务T写A
- 冲突可串行性
    - 冲突：调度中一对连续的动作：如果它们的顺序交换，那么涉及的事务中至少有一个事务的行为会改变。
    - 有冲突的两个操作是不能交换次序的，没有冲突的两个事务是可交换的
    - 几种冲突的情况：
    ![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115215140.png)
    - 冲突可串行性： 一个调度，如果通过交换相邻两个无冲突的操作能够转换到某一个串行的调度，则称此调度为冲突可串行化的调度
    - 冲突可串行性是比可串行性要严格的概念
    - 满足冲突可串行性，一定满足可串行性；反之不然

冲突可串行性判别算法
- 并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与 分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。
- 并发调度的正确性 ⊇ 可串行性 ⊇ 冲突可串行
- 算法表达
    - 冲突可串行性判别算法
        - 构造一个前驱图(有向图)
        - 结点是每一个事务Ti。如果Ti的一个操作与Tj的一个操作发生冲突，且Ti在Tj前执行，则绘制一条边，由Ti指向Tj, 表征Ti要在Tj前执行。
        - 测试检查: 如果此有向图没有环，则是冲突可串行化的!
## 基于封锁的并发控制方法
基于封锁的并发控制方法：   
- 并发调度的正确性：当且仅当在这个并发调度下所得到的新数据库结果与分别串行地运行这些事务所得的新数据库完全一致，则说调度是正确的。
- 并发调度的正确性 ⊇ 可串行性 ⊇ 冲突可串行性
- 什么是锁
    - “锁”是控制并发的一种手段
    - 每一数据元素都有一唯一的锁
    - 每一事务读写数据元素前，要获得锁。
    - 如果被其他事务持有该元素的锁，则要等待。
    - 事务处理完成后要释放锁。
    - Li(A) : 事务Ti对数据元素A加锁 
    - Ui(A) : 事务Ti对数据元素A解锁
    - 锁本身并不能保证冲突可串行性。
    - 锁为调度提供了控制的手段。但如何用锁，仍需说明。---不同的协议
- 封锁协议需要考虑什么
- 封锁协议之锁的类型
    - 排他锁X (exclusive locks)
        - 只有一个事务能读、写，其他任何事务都不能读、写
    - 共享锁S (shared locks)
        - 所有事务都可以读，但任何事务都不能写
    - 更新锁U (Update locks)
        - 初始读，以后可升级为写
    - 增量锁I (Incremental lock)
        - 增量更新(例如A=A+x) 区分增量更新和其他类型的更新
- 封锁协议之相容性矩阵
    ![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115220735.png)
    - 当某事务对一数据对象持有一种锁时，另一事务再申请对该对象加某一类型的锁，是允许(是)还是不允许(否)
- 封锁协议需要考虑什么?
    - 封锁协议之加锁/解锁时机
    ![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115220858.png)
    - SQL之隔离性级别(允许程序员选择使用) 
        - 读未提交(read uncommitted) 
        - 读已提交(read committed) 
        - 可重复读(repeatable read) 
        - 可串行化(serializable)
    - 封锁协议之封锁粒度(LOCKING GRANULARITY)
        - 封锁粒度是指封锁数据对象的大小。
        - 粒度单位：属性值->元组->元组集合->整个关系->整个DB某索引项->整个索引
        - 由前往后:并发度小，封锁开销小
        - 由后往前:并发度大，封锁开销也
    - 封锁协议需要考虑:
        - 封锁的类型
        - 封锁的粒度
        - 相容性矩阵
        - 封锁的时机

衍生出不同的封锁协议：   
- 两段封锁协议
    - 是一种基于锁的控制方法
    - 读写数据之前要获得锁。每个事务中所有封锁请求先于任何一个解锁请求
    - 两阶段：加锁段，解锁段。加锁段中不能有解锁操作，解锁段中不能有加锁操作
    - 两段封锁协议是可以保证冲突可串行性的！
    - 两段锁协议是可能产生“死锁”的协议！
## 基于时间戳的并发控制方法

基于时间戳的并发控制方法：
- 时间戳(TIMESTAMP)
    - 一种基于时间的标志，将某一时刻转换成的一个数值。
    - 时间戳具有唯一性和递增性。
- 事务的时间戳
    - 事务T启动时，系统将该时刻赋予T，为T的时间戳
    - 时间戳可以表征一系列事务执行的先后次序：
        - 时间戳小的事务先执行，时间戳大的事务后执行。
    - 利用时间戳，可以不用锁，来进行并发控制
- 基于时间戳的并发控制：
    - 借助于时间戳，强制使一组并发事务的交叉执行，等价于一个特定顺序的串行执行。
    - 特定顺序：时间戳由小到大
    - 如何强制：执行时判断冲突
        - 如无冲突，予以执行；
        - 如有冲突，则撤销事务，并重启该事务，此时该事务获得了一个更大的时间戳，表明是后执行的事务。
    - 有哪些冲突：
        - 读-读无冲突；
        - 读-写或写-读冲突；
        - 写-写冲突
    - 基于时间戳的简单调度规则
        - 对DB中的每个数据元素x，系统保留其上的最大时间戳
            - RT(x): 即R-timestamp(x)
                - 读过该数据事务中最大的时间戳，即最后读x的事务的时间戳。
            - WT(x): 即W-timestamp(x)
                - 写过该数据事务中最大的时间戳，即最后写x的事务的时间戳。 
        - 事务的时间戳
            - TS(T): 即TimeStam
        
        ![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115222650.png)

    - 基于时间戳的另一种调度规则
        - 需要解决的问题：如何放行一些事实上可实现的冲突?—托马斯写规则
        - 对DB中的每个数据元素x，系统保留其上的最大时间戳
            - RT(x): 即R-timestamp(x)
                - 读过该数据事务中最大的时间戳，即最后读x的事务的时间戳。
            - WT(x): 即W-timestamp(x)
                - 写过该数据事务中最大的时间戳，即最后写x的事务的时间戳。
            - C(x): x的提交位。
                -该位为真，当且仅当最近写x的事务已经提交。C(x)的目的是避免出现事务读另一事务U所写数据然后U终止这样的情况。
        - 事务的时间戳
            - TS(T): 即TimeStamp
        - 对来自事务T的读写请求，调度器可以：
            - 同意请求
            - 撤销/终止T，并重启具有新时间戳的T(终止+重启，被称回滚)
            - 推迟T，并在以后决定是终止T还是同意请求(如果请求是读，且此读可能是脏的
        - 调度规则
            - 假设调度器收到请求rT(X)
                - (1)如果TS(T)>=WT(x), 此读是事实上可实现的
                    - 如C(x)为真，同意请求。如果TS(T)>RT(x), 置RT(x):=TS(T); 否则不改变RT(x).
                    - 如C(x)为假，推迟Ｔ直到C(x)为真或写x的事务终止。
                - (2)如果TS(T) < WT(x), 此读是事实上不可实现的
                    - 回滚T(终止并重启T)；(过晚的读)
            - 假设调度器收到请求wT(X)
                - (1)如果TS(T)>=RT(x), 且TS(T)>=WT(x), 此写是事实上是可实现的
                为x写入新值；置WT(x):=TS(T)；置C(x):=false.
                - (2)如果TS(T)>=RT(x),但是TS(T)< WT(x)，此写是事实上可实现的。但x已经有一个更晚的值
                    - 如果C(x)为真，那么前一个x的写已提交；则忽略T的写；继续进行。(托马斯写规则)
                    - 如果C(x)为假，则我们需推迟T，直到C(x)为真或写x的事务终止。
                - (3)如果TS(T)< RT(x), 此写是事实上不可实现的
                    - T必须回滚。(过晚的写)
        - 假设调度器收到提交T的请求。
            - 它必须找到T所写的所有数据库元素x, 并置C(x):=true。
            - 如果有任何等待x被提交的事务，这些事务就被允许继续进行。
        - 假设调度器收到终止T的请求
            - 像前述步骤一样确定回滚T。那么任何等待T所写元素x的事务必须重新尝试读或写，看这一动作现在T的写被终止后是否合法。
## 基于有效性确认的并发控制方法

基于有效性确认的并发控制方法:
- 基于时间戳的并发控制的思想
    - 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。
    - 为每一数据库元素保存读时间戳和写时间戳，以记录读或写该数据元素的最后的事务。
    - 通过在事务读写数据时判断是否存在冲突(读写冲突、写读冲突、写写冲突)来强制事务以可串行化的方式执行。 
- 基于有效性确认的并发控制的思想
    - 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。
    - 为每一活跃事务保存其读写数据的集合，RS(T)：事务T读数据的集合；
    WS(T)：事务T写数据的集合。
    - 通过对多个事务的读写集合，判断是否有冲突(存在事实上不可实现的行为)，即有效性确认，来完成事务的提交与回滚，强制事务以可串行化的方式执行。
- 基于有效性确认的调度器
    - 事务在启动时刻被赋予唯一的时间戳，以示其启动顺序。
    - 每一事务读写数据的集合，RS(T)：事务T读数据的集合；WS(T)：事务T 写数据的集合。
    - 事务分三个阶段进行
        - 读阶段。事务从数据库中读取读集合中的所有元素。事务还在其局部地址空间计算它将要写的所有值；
        - 有效性确认阶段。调度器通过比较该事务与其它事务的读写集合来确认该事务的有效性。
        - 写阶段。事务往数据库中写入其写集合中元素的值。
    - 每个成功确认的事务是在其有效性确认的瞬间执行的。
    - 并发事务串行的顺序即事务有效性确认的顺序。
    - 调度器维护三个集合
        - START集合。已经开始但尚未完成有效性确认的事务集合。对此
        集合中的事务，调度器维护START(T)，即事务T开始的时间。
        - VAL集合。已经确认有效性但尚未完成第3阶段写的事务。对此集
        合中的事务，调度器维护START(T)和VAL(T)，即T确认的时间。
        - FIN集合。已经完成第3阶段的事务。对这样的事务T,
        START(T), VAL(T)和FIN(T)，即T完成的时间。
    - 有效性确认规则:
        - 冲突一：假设存在事务U 和 T满足：
            - (1)U 在VAL或FIN中, 即U已经过有效性确认。 
            - (2)FIN(U)>START(T), 即U在T开始前没有完成。 
            - (3)RS(T) ∩ WS(U)非空, 特别地，设其均包含数据库元素为x。则T和U的执行存在冲突，T不应进行有效性确认
            - 如果一个较早的事务U现在正在写入T应该读过的某些对象，则T的有效性不能确认
        - 冲突二：假设存在事务U 和T 满足:
            - (1)U 在VAL, 即U有效性已经成功确认。
            - (2)FIN(U)>VAL(T), 即U在T进入其有效性确认阶段以前没有完成。 
            - (3)WS(T)∩WS(U)非空, 特别地，设其均包含数据库元素x。 则T和U的执行存在冲突，T不应进行有效性确认
            - 如果T在有效性确认后可能比一个较早的事务先写某个对象，则T的有效性不能确认
        - 有效性确认规则
            - (1)对于所有已经过有效性确认, 且在T开始前没有完成的U, 即对于满足FIN(U)>START(T)的U,检测:RS(T) ∩ WS(U)是否为空。若为空，则确认。否则，不予确认。
            - (2)对于所有已经过有效性确认，且在T有效性确认前没有完成的U, 即对于满足FIN(U)>VAL(T)的U, 检测：WS(T) ∩ WS(U)是否为空。若为空，则确认。否则，不予确认。
            - 1. U的有效性确认 无需检测，直接确认U。
            - 2. T的有效性确认因FIN(U)>START(T), 需检测RS(T) ∩ WS(U) 因FIN(U)>VAL(T),需检测WS(T) ∩ WS(U)
            检测结果：均为空，则确认T。
            - 3. V的有效性确认
            因FIN(U)>START(V), 需检测RS(V) ∩ WS(U) 因FIN(T)>START(V),需检测RS(V) ∩ WS(T) 因FIN(T)>VAL(V),需检测WS(T) ∩ WS(V)检测结果：均为空，则确认V。
            - 4. W的有效性确认
            因FIN(T)>START(W), 需检测RS(W) ∩ WS(T) 因FIN(V)>START(W),需检测RS(W) ∩ WS(V)
            因FIN(V)>VAL(W),需检测WS(V) ∩ WS(W)
            检测结果：不全为空,则W不能确认,W被回滚。
## 总结
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20211115224634.png)






