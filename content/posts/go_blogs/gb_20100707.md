---
title: "Gb_20100707"
date: 2022-05-08T20:48:44+08:00
lastmod: 2022-05-08
tags: [go official blogs]
categories: [2022]
slug: 
draft: false
---
# Go 的声明语法

罗布派克  
2010 年 7 月 7 日

## 介绍

Go 的新手想知道为什么声明语法与 C 家族中建立的传统不同。在这篇文章中，我们将比较这两种方法并解释为什么 Go 的声明看起来如此。

## C 语法

首先，让我们谈谈C语法。C 对声明语法采取了一种不同寻常且聪明的方法。不是用特殊语法描述类型，而是编写一个涉及被声明项的表达式，并说明该表达式将具有什么类型。因此

```
int x;
```

将 x 声明为 int：表达式 'x' 将具有 int 类型。一般来说，要弄清楚如何编写新变量的类型，请编写一个涉及该变量的表达式，该变量的计算结果为基本类型，然后将基本类型放在左侧，将表达式放在右侧。

因此，声明

```
int *p;
int a[3];
```

声明 p 是指向 int 的指针，因为 '\*p' 具有 int 类型，并且 a 是 int 数组，因为 a\[3\] （忽略特定的索引值，它被标记为数组的大小）具有类型诠释。

函数呢？最初，C 的函数声明将参数的类型写在括号之外，如下所示：

```
int main(argc, argv)
    int argc;
    char *argv[];
{ /* ... */ }
```

同样，我们看到 main 是一个函数，因为表达式 main(argc, argv) 返回一个 int。在现代符号中，我们会写

```
int main(int argc, char *argv[]) { /* ... */ }
```

但基本结构是一样的。

这是一个巧妙的句法理念，适用于简单类型，但很快就会让人困惑。著名的例子是声明一个函数指针。遵守规则，你会得到：

```
int (*fp)(int a, int b);
```

在这里，fp 是一个指向函数的指针，因为如果您编写表达式 (\*fp)(a, b)，您将调用一个返回 int 的函数。如果 fp 的一个参数本身就是一个函数怎么办？

```
int (*fp)(int (*ff)(int x, int y), int b)
```

这开始变得难以阅读。

当然，我们可以在声明函数的时候省略参数名，所以可以声明main

```
int main(int, char *[])
```

回想一下 argv 是这样声明的，

```
char *argv[]
```

所以你从它的声明中间去掉名字来构造它的类型。但是，通过将名称放在中间来声明 char \*\[\] 类型的东西并不明显。

如果你不命名参数，看看 fp 的声明会发生什么：

```
int (*fp)(int (*)(int, int), int)
```

不仅不明显把名字放在里面

```
int (*)(int, int)
```

根本不清楚它是一个函数指针声明。如果返回类型是函数指针怎么办？

```
int (*(*fp)(int (*)(int, int), int))(int, int)
```

甚至很难看出这个声明是关于 fp 的。

您可以构建更详细的示例，但这些示例应该说明 C 的声明语法可能引入的一些困难。

不过，还有一点需要说明。因为类型和声明语法相同，所以很难解析中间有类型的表达式。这就是为什么，例如，C 强制转换总是给类型加上括号，如

```
(int)M_PI
```

## go 语法

C 系列之外的语言通常在声明中使用不同的类型语法。虽然它是一个单独的点，但名称通常是第一位的，通常后跟一个冒号。因此，我们上面的示例变成了类似（以虚构但说明性的语言）

```
x: int
p: pointer to int
a: array[3] of int
```

这些声明很清楚，如果冗长的话 - 你只需从左到右阅读它们。Go 从这里得到提示，但为了简洁起见，它删除了冒号并删除了一些关键字：

```
x int
p *int
a [3]int
```

\[3\]int 的外观与如何在表达式中使用 a 之间没有直接对应关系。（我们将在下一节中回到指针。）您以单独的语法为代价获得清晰。

现在考虑函数。让我们将 main 的声明转录成 Go 中的样子，尽管 Go 中真正的 main 函数不带参数：

```
func main(argc int, argv []string) int
```

从表面上看，除了从数组到字符串的变化之外，它与 C 并没有太大区别`char`，但从左到右读起来很好：

函数 main 接受一个 int 和一个字符串切片并返回一个 int。

去掉参数名称，它就很清楚了——它们总是第一个，所以没有混淆。

```
func main(int, []string) int
```

这种从左到右的风格的一个优点是随着类型变得越来越复杂，它的工作效果如何。这是函数变量的声明（类似于 C 中的函数指针）：

```
f func(func(int,int) int, int) int
```

或者如果 f 返回一个函数：

```
f func(func(int,int) int, int) func(int, int) int
```

它仍然从左到右清晰地读取，并且总是很明显正在声明哪个名称 - 名称在前。

类型和表达式语法之间的区别使得在 Go 中编写和调用闭包变得很容易：

```
sum := func(a, b int) int { return a+b } (3, 4)
```

## 指针

指针是证明规则的例外。请注意，例如，在数组和切片中，Go 的类型语法将括号放在类型的左侧，但表达式语法将它们放在表达式的右侧：

```
var a []int
x = a[1]
```

为熟悉起见，Go 的指针使用 C 中的 \* 表示法，但我们无法对指针类型进行类似的反转。因此指针像这样工作

```
var p *int
x = *p
```

我们不能说

```
var p *int
x = p*
```

因为那个后缀 \* 会与乘法混为一谈。我们可以使用 Pascal ^，例如：

```
var p ^int
x = p^
```

也许我们应该有（并为 xor 选择另一个运算符），因为类型和表达式上的前缀星号在许多方面使事情复杂化。例如，虽然可以写

```
[]int("hi")
```

作为一种转换，如果类型以 \* 开头，则必须用括号括起来：

```
(*int)(nil)
```

如果我们愿意放弃 \* 作为指针语法，那么这些括号将是不必要的。

所以 Go 的指针语法与熟悉的 C 形式联系在一起，但这些联系意味着我们不能完全摆脱使用括号来消除语法中的类型和表达式的歧义。

不过总的来说，我们相信 Go 的类型语法比 C 的更容易理解，尤其是当事情变得复杂时。

## 笔记

Go 的声明从左到右阅读。有人指出，C 是螺旋式读取的！参见David Anderson[的“顺时针/螺旋规则”](http://c-faq.com/decl/spiral.anderson.html)。
