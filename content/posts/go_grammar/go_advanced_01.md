---
title: "Go_advanced_01"
date: 2022-08-05T16:42:35+08:00
lastmod:
tags: []
categories: []
slug:
draft: true
---
# Go语言核心36讲
[戳此查看 Go 语言专栏文章配套详细代码。](https://github.com/hyper0x/Golang_Puzzlers)

## 开篇词 | 跟着学，你也能成为Go语言高手
郝林 2018-08-06

- 基础概念：我会讲述 Go 语言基础中的基础，包括一些基本概念和运作机制。它们都应该是你初识 Go 语言时必须知道的，同时也有助于你理解后面的知识。
- 数据类型和语句：Go 语言中的数据类型大都是很有特色的，你只有理解了它们才能真正玩转 Go 语言。我将和你一起与探索它们的奥妙。另外，我也会一一揭示怎样使用各种语法和语句操纵它们。
- Go 程序的测试：很多程序员总以为测试是另一个团队的事情，其实不然。单元测试甚至接口测试其实都应该是程序员去做的，并且应该受到重视。在 Go 语言中怎样做好测试这件事？我会跟你说清楚、讲明白。
- 标准库的用法：虽然 Go 语言提供了自己的高效并发编程方式，但是同步方法依然不容忽视。这些方法集中在sync代码包及其子包中。这部分还涉及了字节和字符问题、OS 操控方法和 Web 服务写法等，这些都是我们在日常工作中很可能会用到的。
- Go 语言拾遗：这部分将会讲述一些我们使用 Go 语言做软件项目的过程中很可能会遇到的问题，至少会包含两篇文章，是附赠给广大 Go 语言爱好者的。虽然我已经有一个计划了，但是具体会讲哪些内容我还是选择暂时保密。请你和我一起小期待一下吧。


## 导读 | 写给0基础入门的Go语言学习者

![img](https://static001.geekbang.org/resource/image/ad/85/add8566dc5431378bda313a32a6ebb85.jpg?wh=2602*10316)

## 导读 | 学习专栏的正确姿势

![img](https://static001.geekbang.org/resource/image/29/f8/29c794731d9fb43f9fd37cc4d91994f8.png?wh=1920*4240)

## 基础知识
## 01 | 工作区和GOPATH
今天我们的面试问题是：你知道设置 GOPATH 有什么意义吗？

关于这个问题，它的典型回答是这样的：

你可以把 GOPATH 简单理解成 Go 语言的工作目录，它的值是一个目录的路径，也可以是多个目录路径，每个目录都代表 Go 语言的一个工作区（workspace）。我们需要利用这些工作区，去放置 Go 语言的源码文件（source file），以及安装（install）后的归档文件（archive file，也就是以“.a”为扩展名的文件）和可执行文件（executable file）。

事实上，由于 Go 语言项目在其生命周期内的所有操作（编码、依赖管理、构建、测试、安装等）基本上都是围绕着 GOPATH 和工作区进行的。所以，它的背后至少有 3 个知识点，分别是：

1. Go 语言源码的组织方式是怎样的；2. 你是否了解源码安装后的结果（只有在安装后，Go 语言源码才能被我们或其他代码使用）；3. 你是否理解构建和安装 Go 程序的过程（这在开发程序以及查找程序问题的时候都很有用，否则你很可能会走弯路）。


### 1. Go 语言源码的组织方式

与许多编程语言一样，Go 语言的源码也是以代码包为基本组织单位的。在文件系统中，这些代码包其实是与目录一一对应的。由于目录可以有子目录，所以代码包也可以有子包。一个代码包中可以包含任意个以.go 为扩展名的源码文件，这些源码文件都需要被声明属于同一个代码包。代码包的名称一般会与源码文件所在的目录同名。如果不同名，那么在构建、安装的过程中会以代码包名称为准。每个代码包都会有导入路径。代码包的导入路径是其他代码在使用该包中的程序实体时，需要引入的路径。在实际使用程序实体之前，我们必须先导入其所在的代码包。具体的方式就是import该代码包的导入路径。就像这样：

```
import "github.com/labstack/echo"
```
在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。所以说，Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为主线的。一般情况下，Go 语言的源码文件都需要被存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。

### 2. 了解源码安装后的结果

了解了 Go 语言源码的组织方式后，我们很有必要知道 Go 语言源码在安装后会产生怎样的结果。源码文件以及安装后的结果文件都会放到哪里呢？我们都知道，源码文件通常会被放在某个工作区的 src 子目录下。那么在安装后如果产生了归档文件（以“.a”为扩展名的文件），就会放进该工作区的 pkg 子目录；如果产生了可执行文件，就可能会放进该工作区的 bin 子目录。我再讲一下归档文件存放的具体位置和规则。源码文件会以代码包的形式组织起来，一个代码包其实就对应一个目录。安装某个代码包而产生的归档文件是与这个代码包同名的。放置它的相对目录就是该代码包的导入路径的直接父级。比如，一个已存在的代码包的导入路径是

```
github.com/labstack/echo
```
那么执行命令

```
go install github.com/labstack/echo
```
生成的归档文件的相对目录就是 github.com/labstack ，文件名为 echo.a 。顺便说一下，上面这个代码包导入路径还有另外一层含义，那就是：该代码包的源码文件存在于 GitHub 网站的 labstack 组的代码仓库 echo 中。再说回来，归档文件的相对目录与 pkg 目录之间还有一级目录，叫做平台相关目录。平台相关目录的名称是由 build（也称“构建”）的目标操作系统、下划线和目标计算架构的代号组成的。比如，构建某个代码包时的目标操作系统是 Linux，目标计算架构是 64 位的，那么对应的平台相关目录就是 linux_amd64。因此，上述代码包的归档文件就会被放置在当前工作区的子目录 pkg/linux_amd64/github.com/labstack 中。

![img](https://static001.geekbang.org/resource/image/2f/3c/2fdfb5620e072d864907870e61ae5f3c.png?wh=1472*797)



（GOPATH 与工作区）总之，你需要记住的是，某个工作区的 src 子目录下的源码文件在安装后一般会被放置到当前工作区的 pkg 子目录下对应的目录中，或者被直接放置到该工作区的 bin 子目录中。

### 3. 理解构建和安装 Go 程序的过程

我们再来说说构建和安装 Go 程序的过程都是怎样的，以及它们的异同点。构建使用命令go build，安装使用命令go install。构建和安装代码包的时候都会执行编译、打包等操作，并且，这些操作生成的任何文件都会先被保存到某个临时的目录中。如果构建的是库源码文件，那么操作后产生的结果文件只会存在于临时目录中。这里的构建的主要意义在于检查和验证。

如果构建的是命令源码文件，那么操作的结果文件会被搬运到源码文件所在的目录中。（这里讲到的两种源码文件我在“预习篇”的基础知识图中提到过，在后面的文章中我也会带你详细了解。）

安装操作会先执行构建，然后还会进行链接操作，并且把结果文件搬运到指定目录。进一步说，如果安装的是库源码文件，那么结果文件会被搬运到它所在工作区的 pkg 目录下的某个子目录中。如果安装的是命令源码文件，那么结果文件会被搬运到它所在工作区的 bin 目录中，或者环境变量GOBIN指向的目录中。这里你需要记住的是，构建和安装的不同之处，以及执行相应命令后得到的结果文件都会出现在哪里。

### 总结

工作区和 GOPATH 的概念和含义是每个 Go 工程师都需要了解的。虽然它们都比较简单，但是说它们是 Go 程序开发的核心知识并不为过。然而，我在招聘面试的过程中仍然发现有人忽略掉了它们。Go 语言提供的很多工具都是在 GOPATH 和工作区的基础上运行的，比如上面提到的go build、go install和go get，这三个命令也是我们最常用到的。



## 02 | 命令源码文件
这里的源码文件又分为三种，即：命令源码文件、库源码文件和测试源码文件，它们都有着不同的用途和编写规则。（ 我在“预习篇”的基础知识图介绍过这三种文件的基本情况。）

![img](https://static001.geekbang.org/resource/image/9d/cb/9d08647d238e21e7184d60c0afe5afcb.png?wh=1570*1363)

我今天的问题就是：命令源码文件的用途是什么，怎样编写它？

这里，我给出你一个参考的回答：命令源码文件是程序的运行入口，是每个可独立运行的程序必须拥有的。我们可以通过构建或安装，生成与其对应的可执行文件，后者一般会与该命令源码文件的直接父目录同名。

如果一个源码文件声明属于main包，并且包含一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。 就像下面这段代码：

```
package main

import "fmt"

func main() {
  fmt.Println("Hello, world!")
}
```
如果你把这段代码存成 demo1.go 文件，那么运行go run demo1.go命令后就会在屏幕（标准输出）中看到Hello, world!

当需要模块化编程时，我们往往会将代码拆分到多个文件，甚至拆分到不同的代码包中。但无论怎样，对于一个独立的程序来说，命令源码文件永远只会也只能有一个。如果有与命令源码文件同包的源码文件，那么它们也应该声明属于main包。

### 问题解析

命令源码文件如此重要，以至于它毫无疑问地成为了我们学习 Go 语言的第一助手。不过，只会打印Hello, world是远远不够的，咱们千万不要成为“Hello, world”党。既然决定学习 Go 语言，你就应该从每一个知识点深入下去。无论是 Linux 还是 Windows，如果你用过命令行（command line）的话，肯定就会知道几乎所有命令（command）都是可以接收参数（argument）的。通过构建或安装命令源码文件，生成的可执行文件就可以被视为“命令”，既然是命令，那么就应该具备接收参数的能力。下面，我就带你深入了解一下与命令参数的接收和解析有关的一系列问题。


……


## 03 | 库源码文件


## 04 | 程序实体的那些事儿（上）


## 05 | 程序实体的那些事儿（中）

## 06 | 程序实体的那些事儿 （下）


## 进阶技术
## 07 | 数组和切片

## 08 | container包中的那些容器


## 09 | 字典的操作和约束


## 10 | 通道的基本操作


## 11 | 通道的高级玩法


## 12 | 使用函数的正确姿势


## 13 | 结构体及其方法的使用法门

## 15 | 关于指针的有限操作

## 16 | go语句及其执行规则（上）

## 17 | go语句及其执行规则（下）


## 18 | if语句、for语句和switch语句


## 19 | 错误处理（上）

## 20 | 错误处理 （下）


## 21 | panic函数、recover函数以及defer语句 （上）

## 22 | panic函数、recover函数以及defer语句（下）

## 实战与应用
## 23 | 测试的基本规则和流程 （上）


## 24 | 测试的基本规则和流程（下）

## 25 | 更多的测试手法

## 26 | sync.Mutex与sync.RWMutex


## 27 | 条件变量sync.Cond （上）

## 28 | 条件变量sync.Cond （下）

## 29 | 原子操作（上）


## 30 | 原子操作（下）



## 31 | sync.WaitGroup和sync.Once


## 32 | context.Context类型


## 33 | 临时对象池sync.Pool

## 34 | 并发安全字典sync.Map （上）


## 35 | 并发安全字典sync.Map (下)

## 36 | unicode与字符编码


## 37 | strings包与字符串操作


## 38 | bytes包与字节串操作（上）


## 39 | bytes包与字节串操作（下）


## 40 | io包中的接口和工具 （上）


## 41 | io包中的接口和工具 （下）


## 42 | bufio包中的数据类型 （上）

## 43 | bufio包中的数据类型（下）



## 44 | 使用os包中的API （上）

## 45 | 使用os包中的API （下）


## 46 | 访问网络服务

## 47 | 基于HTTP协议的网络服务


## 48 | 程序性能分析基础（上）


## 49 | 程序性能分析基础（下）


## 尾声 | 愿你披荆斩棘，所向无敌


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































