---
title: "interview"
date: 2022-06-28T15:30:06+08:00
lastmod: 2022-08-28
tags: [interview]
categories: [interview]
slug: all-interview
draft: false
---

## Go


### slice

#### 切片和数组的区别？

数据类型不同。这是从数据结构上决定的，因为数组的数据结构只有元素类型和长度，而切片的数据结构是一个结构体，结构体有一个指向数组的指针，长度和容量，所以切片是一个引用类型而不是像数组一样的不可变的值类型。

额外一点说，在 go 中虽然函数传递中是值传递的，但是由于切片的数据结构中的结构体里面包含了指针，所以函数传递的时候会将指针的值拷贝走，从结果来说会操作到同一个切片。

#### 为什么切片的应用比数组多？

在日常业务上，更需要存储一个可变的序列。业务中有一个确定的长度序列的场景是比较少的，或者说要确定一个序列的长度是会需要做额外的操作损耗性能的。

#### 切片的访问的复杂度？

切片的底层实现是一块连续的内存地址，所以能进行 O(1) 的随机访问元素。 具体的源码都是在编译时编译好（类似于 内存地址=元素类型*下标，不在此处细究。 

#### 切片的扩容机制？

当扩容的时候需要扩容的容量是现在容量的 2 倍以上时，会直接扩容需要扩容的容量。否则的话，如果现在的长度（1.16 改成了容量）是 1024 以下时，会直接翻倍扩容。但是如果超过 1024 时，会反复扩容 25 % 直到达到或超过需要扩容的容量

#### 为什么切片底层不用链表？

1. 设计上，切片的设计上允许随机访问，而随机访问对于链表是不友好的 		
2. 容量上，切片的扩容机制无论从小切片是翻倍扩容，还是到大切片不断扩容 25 % 直至扩容到指定值的扩容机制，在容量上已经能覆盖大多数的场景内存上，使用链表会产生内存碎片，并且对于 Go 的垃圾回收算法（三色标记法）在递归根对象寻找可达对象的过程中不友好

---

### map

#### map 的扩容机制？

分为了翻倍扩容、等量扩容。还有确定了要扩容后，使用的是渐进式扩容去避免性能抖动。 	

扩容的触发条件有两个，状态装载因子超过 6.5（现在的桶装在的元素超过 80 %），也就是元素太多了，或者溢出桶太多（逻辑是判断现在桶的总数是否超过 map 结构体中的设置值，如果超过说明太多溢出桶），也就是太多元素被删除，元素非常稀疏。 前者会使用翻倍扩容，会申请现有翻倍的空间。当有读操作时仍会访问旧桶，当有插入或者删除操作的时候会将旧桶分流到两个新桶。后者会使用等倍扩容，重新申请一块和现有大小相同的新桶，也是使用渐进式扩容在插入或者删除操作中进行。

#### map 的存储是有序的吗？

​	存储结构上由于在扩容的时候会将 key 随机分流到另外两个桶，这导致了 key  的相对位置会发生改变，所以 key 是无序的。 遍历上来说，每次遍历是取一个随机数，随机从一个桶开始遍历。所以每次遍历出来的结果都是不一样的。额外一点是，当未发生扩容前，key 的相对位置是确定的。

#### map 是线程安全的吗？

不是的，当赋值和删除时是置写操作位。当置了之后有别的协程用任何操作进行来时否都会报错。如果想要 map 线程安全，解决方案一般是用 **sync.map** 或者 **互斥锁+map**

#### map 有缩容机制吗？

go 的 map 没有缩容的机制。map 内部的存储结构是基于拉链法的，里面的元素如果被大批量的删除后，会触发等量扩容。等量扩容时会申请原有大小一样的内存块，渐进式的扩容过去，让原有的 map 中因为很多元素被删除后导致元素排序稀疏的情况经过 rehash 后会排序会变得紧密，减少溢出桶的使用。

---

### sync

#### sync.map 为什么是线程安全的

因为原有的 map 会在赋值和删除的置写标志，置了后别的协程来做任何操作都会报错。所以引出了 sync.map 解决多协程问题。

**sync.map 使用了读写分离来去保证线程安全的**，sync.map 的数据结构分为读 map、写 map、还有互斥锁以及一个记录穿透次数的值。具体实现是每个协程来读取时都会先读取读部分的 kv，没有则去读写部分的 kv（操作写部分时都会上锁）。当穿透到写部分的次数大于写部分的长度时就会将写部分同步到读部分并且把写部分清空。所以多协程下一般都会先打到无锁的读部分，这能保证读取性能

#### sync.mutex 作用

sync.mutex 是一把互斥锁，**具体作用是锁住限定区域的代码逻辑**，这段区域只能被一个协程占用。具体实现原理是，当一个协程去获取锁时（获取锁是 CAS 看锁的状态位），当获取不到会自选一定次数后加入到队列去休眠，当锁被释放时，正在自旋的协程 + 休眠中的任意一个协程会才能会被唤醒的会去抢锁，这是正常模式。还有一种模式是饥饿模式，由于被唤醒的协程有很大几率是抢不到正在自旋的协程的，所以当有协程超过 1 毫秒获取不到锁时将会进入饥饿模式。进入后会根据上面提到的队列中按照先进先出的模式依次获取锁，新来的协程直接进入队列中等待。当队列中已经清空或者队列中头个协程等待时间小于 1 毫秒后退化为正常模式。

#### sync.RWmutex 作用

sync.RWmutex 是读写锁，用于解决 reader / wirter 问题（保证一个写协程和其他所有协程互斥的同步问题）。也就是可以读锁可以被多个协程拥有，但是只能一个协程拥有写锁。读写操作互斥、写写操作互斥。当有协程获取写锁时，会阻塞所有新来获取读锁的所有协程，并且会等所有正在拥有读锁的协程释放后才能获取到

#### sync.singleflight 作用

sync.signleflight 能将对同一个资源访问 的多个请求合并为一个请求。常见的应用场景比如防缓冲击穿。具体的实现是使用了 map 对同一资源访问的请求进行去重，使用互斥锁让当个协程进入临界区后进行资源访问，其他线程阻塞等待资源访问完成后，共同拿到访问资源的结果并返回。

---

### context 有什么作用

1. 传递上下文。使用 context 传递业务参数是很不推荐的，但是比较常用的用来传递整个链路的 trace id 来作为链路追踪 		
2. 协程间同步信息。使用 context 后能在多个协程组成的协程树传递取消信号（通过 Cancel，超时计数器调用 Cancel 等）

#### goroutine

#### 进程、线程和协程的区别

进程是应用程序的实体，分配**操作系统资源的最小单位**，拥有自己的内存空间以及堆栈。 	

线程是内核操作**系统调度CPU**的基本单位，在进程的内存空间及堆栈上进行执行运行。 	

协程指的是用户态线程，由用户的应用程序进行调度。

#### 协程的好处

1. 切换上下文代价小，协程切换时不用进行系统调用，走内核态的指令。 	
2. 没有多线程的竞争资源锁问题，多线程竞争资源还会锁内存走系统调用，而协程如果竞争资源直接在当前线程上的进行判断就可以了 
3. 内存占用小，只占用 2K，线程占用 2M

### GMP 模型中的 GMP 指的是什么

1. G 协程 
2. M 线程 
3. P 调度器 	
4. 其中 M 可能会自旋，也有可能会休眠，GC 会把一些休眠的线程销毁。 

#### GMP 模型中有什么组件

除开 GMP ，还有 P 的 G 本地队列， G 的全局队列，P 列表（MAXPROCS 决定），M 列表（最大限定 1W，runtime/debug 可以设置） 

#### GMP 模型中为什么需要 P

假设没有 P 会发生什么事情，（没有 P 本地队列，没有 P 全局队列） 	

1. 出现资源竞争，由于没有 P 的本地以及全局队列的多级缓存，所以 G 都会放在一起，多个 M 去获取时会出现资源竞争 	
2. 协程切换资源消耗大，由于没有 P ，也没有 g0 去负责切换协程堆栈，相当于协程堆栈以及一些运行现场全部都在内核态去维护 		
3. 系统调用阻塞时切换成本高，M 会经常被阻塞和解阻塞切换内核态和用户态（类似于进程间切换），消耗大 	

引入了 P 相当于解决了上面的大部分问题，甚至引入了新的特性去榨干 CPU 的性能 		

1. 引入本地队列和全局队列做多级缓存，获 取 G 时都会从本地队列获取，没有竞争，就算去全局队列获取也比较少的几率出现大量 P 去获取，降低了资源竞争的概率 	
2. 切换协程堆栈效率提高，使用了 g0 的协程负责去管理协程切换的堆栈以及保护现场的工作，进入内核态去切换的时候少了很多切换指令以及寄存器的使用，甚至引入了 g0 去负责做垃圾回收部分工作的职能 	
3. 系统调用的曲线救国方案，当 G 和 M 发生了系统调用时，P 会解绑 M ，带着本地队列的 P 去找空闲的 M 或者新创建的 M 去继续剩下的工作 还引入了「工作窃取」的功能，让基于和 M 绑定的 P 更加灵活的让每个 M 都能够最大限度的运行 task，榨干 CPU 

#### P 调度器的设计策略

1. work stealing 机制：当 P 本地队列无运行 G 时，会去其他线程绑定的 P 窃取 G ，若其他 P 本地队列也没有时会去 G 全局队列进行窃取 	
2. hand off 机制：当 G 因为系统调用阻塞时，P 会和 M 解绑，将 G 和 M 绑定，P 会和空闲的线程进行绑定
3. 主动让出机制：当 G 占用了 CPU 超过 10MS 会主动让出（sysmon 轮询） 





## mysql基础


### 1. 数据库的三范式是什么？

- 第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。
- 第二范式：要求实体的属性完全依赖于主关键字。所谓完全 依赖是指不能存在仅依赖主关键字一部分的属性。
- 第三范式：任何非主属性不依赖于其它非主属性。

### 2. MySQL 支持哪些存储引擎?

MySQL 支持多种存储引擎,比如 InnoDB,MyISAM,Memory,Archive 等等.在大多数的情况下,直接选择使用 InnoDB 引擎都是最合适的,InnoDB 也是 MySQL 的默认存储引擎。

MyISAM 和 InnoDB 的区别有哪些：

- InnoDB 支持事务，MyISAM 不支持
- InnoDB 支持外键，而 MyISAM 不支持
- InnoDB 是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。
- Innodb 不支持全文索引，而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；
- InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。
- MyISAM 采用表级锁(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

### 3. 超键、候选键、主键、外键分别是什么？

- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
- 候选键：是最小超键，即没有冗余元素的超键。
- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
- 外键：在一个表中存在的另一个表的主键称此表的外键。

### 4. SQL 约束有哪几种？

- NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
- UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
- PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
- FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
- CHECK: 用于控制字段的值范围。

### 5. MySQL 中的 varchar 和 char 有什么区别？

char 是一个定长字段,假如申请了`char(10)`的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.

在检索效率上来讲,char > varchar,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.例如存储用户 MD5 加密后的密码,则应该使用 char。

### 6. MySQL中 in 和 exists 区别

MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。

如果查询的两个表大小相当，那么用in和exists差别不大。
如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。
not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。

### 7. drop、delete与truncate的区别

三者都表示删除，但是三者有一些差别：

![image-20210822203927822](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637246866/image-20210822203927822.png)

### 8. 什么是存储过程？有哪些优缺点？

存储过程是一些预编译的 SQL 语句。

1、更加直白的理解：存储过程可以说是一个记录集，它是由一些 T-SQL 语句组成的代码块，这些 T-SQL 语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。

2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量 T_SQL 语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全

但是,在互联网[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java 开发手册》中禁止使用存储过程,我个人的理解是,在互联网[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)中,迭代太快,[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)的生命周期也比较短,人员流动相比于传统的[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好。

### 9. MySQL 执行查询的过程

1. [客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)通过 TCP 连接发送连接请求到 MySQL 连接器，连接器会对该请求进行权限验证及连接资源分配
2. 查缓存。（当判断缓存是否命中时，MySQL 不会进行解析查询语句，而是直接使用 SQL 语句和[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)发送过来的其他原始信息。所以，任何字符上的不同，例如空格、注解等都会导致缓存的不命中。）
3. 语法分析（SQL 语法是否写错了）。 如何把语句给到预处理器，检查数据表和数据列是否存在，解析别名看是否存在歧义。
4. 优化。是否使用索引，生成执行计划。
5. 交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给[客户端](https://www.nowcoder.com/jump/super-jump/word?word=客户端)。

![img](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637246616/4102b7d60fa20a0caabb127ecbb4d2f3.jpeg)

更新语句执行会复杂一点。需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。

### 索引

#### 1. 索引是什么？

索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

索引是一种数据结构。数据库索引，是数据库管理系统中一个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。

MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了。

#### 2. 索引有哪些优缺点？

**索引的优点**

- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

**索引的缺点**

- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；
- 空间方面：索引需要占物理空间。

#### 3. MySQL有哪几种索引类型？

1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。这里所描述的是索引存储时保存的形式，

2、从应用层次来分：普通索引，唯一索引，复合索引。

- 普通索引：即一个索引只包含单个列，一个表可以有多个单列索引
- 唯一索引：索引列的值必须唯一，但允许有空值
- 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B-Tree索引(技术上来说是B+Tree)和数据行。
- 非聚簇索引： 不是聚簇索引，就是非聚簇索引

3、根据中数据的物理顺序与键值的逻辑（索引）顺序关系： 聚集索引，非聚集索引。

#### 4. 说一说索引的底层实现？

**Hash索引**

基于[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。

> 图片来源：https://www.javazhiyin.com/40232.html

![img](https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752261/image-20210411215012443.png)

**B-Tree索引**（MySQL使用B+Tree）

B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。

![img](https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752112/image-20210411215023820.png)

**B+Tree索引**

是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

B+tree性质：

- n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。
- 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
- 所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。
- B+ 树中，数据对象的插入和删除仅在叶节点上进行。
- B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。

![img](https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752195/image-20210411215044332.png)

#### 5. 为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)，[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)？

B-tree： 从两个方面来回答

- B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B(B-)树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对`IO读写次数就降低`了。
- 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在`区间查询`的情况，所以通常B+树用于数据库索引。

Hash：

- 虽然可以快速定位，但是没有顺序，IO复杂度高；
- 基于Hash表实现，只有Memory存储引擎显式支持哈希索引 ；
- 适合**等值查询**，如=、in()、<=>，不支持范围查询 ；
- 因为不是按照索引值顺序存储的，就不能像B+Tree索引一样利用索引完成排序 ；
- Hash索引在查询等值时非常快 ；
- 因为Hash索引始终索引的**所有列的全部内容**，所以不支持部分索引列的匹配查找 ；
- 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 。

[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)： 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。

[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)： 树的高度随着数据量增加而增加，IO代价高。

#### 6. 讲一讲聚簇索引与非聚簇索引？

在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。

而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引、二级索引。

聚簇索引与非聚簇索引的区别：

- 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）
- 对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为**回表**。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。
- 通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可
- **注意**：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。

#### 7. 非聚簇索引一定会回表查询吗？

不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为"覆盖索引"。

举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行`select score from student where score > 90`的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。

#### 8. 联合索引是什么？为什么需要**注意**联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:

MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)为: 先按照name[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，如果name相同，则按照age[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，如果age的值也相等，则按照school进行[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该**注意**索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

#### 9. 讲一讲MySQL的最左前缀原则?

最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。
mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

#### 10. 讲一讲前缀索引？

因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要**注意**，order by不支持前缀索引 。

流程是：

先计算完整列的选择性 :`select count(distinct col_1)/count(1) from table_1`

再计算不同前缀长度的选择性 :`select count(distinct left(col_1,4))/count(1) from table_1`

找到最优长度之后，创建前缀索引 :`create index idx_front on table_1 (col_1(4))`

#### 11. 了解索引下推吗？

MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。

- 有了索引下推优化，可以在**减少回表次数**
- 在InnoDB中只针对二级索引有效

官方文档中给的例子和解释如下：

在 people_table中有一个二级索引(zipcode，lastname，address)，查询是SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;

- 如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断数据是否符合条件
- 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’ and address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。

#### 12. 怎么查看MySQL语句有没有用到索引？

通过explain，如以下例子：

```
EXPLAIN SELECT * FROM employees.titles WHERE emp_no='10001' AND title='Senior Engineer' AND from_date='1986-06-26';
```
|  id  | select_type | table  | partitions | type  | possible_keys |   key   | key_len |        ref        | filtered | rows | Extra |
| :--: | :---------: | :----: | :--------: | :---: | :-----------: | :-----: | :-----: | :---------------: | :------: | :--: | :---: |
|  1   |   SIMPLE    | titles |    null    | const |    PRIMARY    | PRIMARY |   59    | const,const,const |    10    |  1   |       |

- id：在⼀个⼤的查询语句中每个**SELECT**关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id = (select id from s1 where name = 'egon1');第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。

- select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。

- table：每个查询对应的表名 。

- type：`type` 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 `type` 字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等。如const(主键索引或者唯一二级索引进行等值匹配的情况下),ref(普通的⼆级索引列与常量进⾏等值匹配),index(扫描全表索引的覆盖索引) 。

  通常来说, 不同的 type 类型的性能关系如下:
  `ALL < index < range ~ index_merge < ref < eq_ref < const < system`
  `ALL` 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.
  而 `index` 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.

- possible_key：查询中可能用到的索引*(可以把用不到的删掉，降低优化器的优化时间)* 。

- key：此字段是 MySQL 在当前查询时所真正使用到的索引。

- filtered：查询器预测满足下一次查询条件的百分比 。

- rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.
  这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。

- extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。

#### 13. 为什么官方建议使用自增长主键作为索引？

结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。

插入连续的数据：

> 图片来自：https://www.javazhiyin.com/40232.html

![img](https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752160/java10-1562726251.gif)

插入非连续的数据：

![img](https://uploadfiles.nowcoder.com/files/20210413/540390845_1618325752674/java8-1562726251.gif)

#### 14. 如何创建索引？

创建索引有三种方式。

1、 在执行CREATE TABLE时创建索引

```
CREATE` `TABLE` `user_index2 (``  ``id ``INT` `auto_increment ``PRIMARY` `KEY``,``  ``first_name ``VARCHAR` `(16),``  ``last_name ``VARCHAR` `(16),``  ``id_card ``VARCHAR` `(18),``  ``information text,``  ``KEY` `name` `(first_name, last_name),``  ``FULLTEXT ``KEY` `(information),``  ``UNIQUE` `KEY` `(id_card)``);
```
2、 使用ALTER TABLE命令去增加索引。

```
ALTER` `TABLE` `table_name ``ADD` `INDEX` `index_name (column_list);
```
ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。

其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。

索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。
3、 使用CREATE INDEX命令创建。

```
CREATE` `INDEX` `index_name ``ON` `table_name (column_list);
```
#### 15. 创建索引时需要**注意**什么？

- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
- 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。

#### 16. 建索引的原则有哪些？

1、最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2、=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3、尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4、索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5、尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

#### 17. 使用索引查询一定能提高查询的性能吗？

通常通过索引查询数据比全表扫描要快。但是我们也必须**注意**到它的代价。

索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的I* NSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:

- 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%。
- 基于非唯一性索引的检索。

#### 18. 什么情况下不走索引（索引失效）？

##### 1、使用!= 或者 <> 导致索引失效

##### 2、类型不一致导致的索引失效

##### 3、函数导致的索引失效

如：

```
SELECT * FROM `user` WHERE DATE(create_time) = ``'2020-09-03'``;
```
如果使用函数在索引列，这是不走索引的。

##### 4、运算符导致的索引失效

```
SELECT * FROM `user` WHERE age - ``1` `= ``20``;
```
如果你对列进行了（+，-，*，/，!）, 那么都将不会走索引。

##### 5、OR引起的索引失效

```
SELECT * FROM `user` WHERE `name` = ``'张三'` `OR height = ``'175'``;
```
OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。

##### 6、模糊搜索导致的索引失效

```
SELECT * FROM `user` WHERE `name` LIKE ``'%冰'``;
```
当`%`放在匹配字段前是不走索引的，放在后面才会走索引。

##### 7、NOT IN、NOT EXISTS导致索引失效

### 事务

#### 1. 什么是数据库事务？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。

事务最经典也经常被拿出来说例子就是转账了。

假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

#### 2. 介绍一下事务具有的四个特征

事务就是一组原子性的操作，这些操作要么全部发生，要么全部不发生。事务把数据库从一种一致性状态转换成另一种一致性状态。

- 原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
- 一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
- 隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的//操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
- 持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

#### 3. 说一下MySQL 的四种隔离级别

- Read Uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

- Read Committed（读取提交内容）

这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓 的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。

- Repeatable Read（可重读）

这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。

- Serializable（可串行化）

通过强制事务[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

![image-20210822180308501](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637246843/image-20210822180308501.png)

MySQL 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是READ-COMMITTED(读取提交内容):，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。

InnoDB 存储引擎在 分布式事务 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。

#### 4. 什么是脏读？幻读？不可重复读？

1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据

2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。

3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。

#### 5. 事务的实现原理

事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。

每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。

#### 6. MySQL事务日志介绍下？

innodb 事务日志包括 redo log 和 undo log。

undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方。

事务日志的目的：实例或者介质失败，事务日志文件就能派上用场。

##### redo log

redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。

![image-20210822181340692](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637246892/image-20210822181340692.png)

##### undo log

undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。

![image-20210822181416382](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637246935/image-20210822181416382.png)

#### 7. 什么是MySQL的 binlog？

MySQL的 binlog 是记录所有数据库表结构变更（例如 CREATE、ALTER TABLE）以及表数据修改（INSERT、UPDATE、DELETE）的二进制日志。binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。

MySQL binlog 以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。binlog 的主要目的是复制和恢复。

binlog 有三种格式，各有优缺点：

- **statement：** 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。
- **row：** 基于行的模式，记录的是行的变化，很安全。但是 binlog 会比其他两种模式大很多，在一些大表中清除大量数据时在 binlog 中会生成很多条语句，可能导致从库延迟变大。
- **mixed：** 混合模式，根据语句来选用是 statement 还是 row 模式。

#### **8. 在事务中可以混合使用存储引擎吗？**

尽量不要在同一个事务中使用多种存储引擎，MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表）,在正常提交的情况下不会有什么问题。

但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。

#### 9. MySQL中是如何实现事务隔离的?

读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。

MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。

详细原理看这篇文章：https://haicoder.net/note/MySQL-interview/MySQL-interview-MySQL-trans-level.html

#### 10. 什么是 MVCC？

MVCC， 即多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

#### 11. MVCC 的实现原理

对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：

- ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。
- 事务 ID：记录最后一次修改该记录的事务 ID。
- 回滚指针：指向这条记录的上一个版本。

我们拿上面的例子，对应解释下 MVCC 的实现原理，如下图：

![img](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637246952/modb_95751916-225c-11eb-b0bb-5254001c05fe.png)

如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b=666 where a=1 时，大致步骤如下：

- 数据库会先对满足 a=1 的行加排他锁；
- 然后将原记录复制到 undo 表空间中；
- 修改 b 字段的值为 666，修改事务 ID 为 2；
- 并通过隐藏的回滚指针指向 undo log 中的历史记录；
- 事务提交，释放前面对满足 a=1 的行所加的排他锁。

在前面实验的第 6 步中，session2 查询的结果是 session1 修改之前的记录，这个记录就是**来自 undolog** 中。

因此可以总结出 MVCC 实现的原理大致是：

InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。

MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。

### 锁

#### 1. 为什么要加锁?

当多个用户并发地存取数据时，在[数据库](https://cloud.tencent.com/solution/database?from=10680)中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。

保证多用户环境下保证数据库完整性和一致性。

#### 2. 按照锁的粒度分数据库锁有哪些？

在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

行级锁

- 行级锁是[MySQL](https://cloud.tencent.com/product/cdb?from=10680)中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。
- 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

表级锁

- 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。
- 开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

页级锁

- 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁
- 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

**MyISAM和InnoDB存储引擎使用的锁：**

- MyISAM采用表级锁(table-level locking)。
- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁

#### 3. 从锁的类别上分MySQL都有哪些锁呢？

从锁的类别上来讲，有共享锁和排他锁。

- 共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
- 排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。

锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。

他们的加锁开销从大到小，并发能力也是从大到小。

#### 4. 数据库的乐观锁和悲观锁是什么？怎么实现的？

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)实现。

**两种锁的使用场景**

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

#### 5. InnoDB引擎的行锁是怎么实现的？

InnoDB是基于索引来完成行锁

例: select * from tab_with_index where id = 1 for update;

for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起

#### 6. 什么是死锁？怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；

3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁

#### 7. 隔离级别与锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

#### 8. 优化锁方面的意见？

- 使用较低的隔离级别
- 设计索引，尽量使用索引去访问数据，加锁更加精确，从而减少锁冲突
- 选择合理的事务大小，给记录显示加锁时，最好一次性请求足够级别的锁。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁，修改时在申请排他锁，这样会导致死锁
- 不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。
- 尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响
- 不要申请超过实际需要的锁级别
- 数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别
- 对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。

### 分库分表

#### 1. 为什么要分库分表？

**分表**

比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。

分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

**分库**

分库就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。

这就是所谓的分库分表。

![img](https://uploadfiles.nowcoder.com/images/20190919/56_1568900435177_29C080A5413E925FE3B3CCB4048AB99B)

#### 2. 用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？

这个其实就是看看你了解哪些分库分表的中间件，各个中间件的优缺点是啥？然后你用过哪些分库分表的中间件。

比较常见的包括：

- cobar
- TDDL
- atlas
- sharding-jdbc
- mycat

##### cobar

阿里 b2b 团队开发和开源的，属于 proxy 层方案。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。

##### TDDL

淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。

##### atlas

360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。

##### sharding-jdbc

当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也**可以选择的方案**。

##### mycat

基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。

#### 3. 如何对数据库如何进行垂直拆分或水平拆分的？

**水平拆分**的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发，还有就是用多个库的存储容量来进行扩容。

![img](https://uploadfiles.nowcoder.com/images/20190919/56_1568900435177_29C080A5413E925FE3B3CCB4048AB99B)

**垂直拆分**的意思，就是**把一个有很多字段的表给拆分成多个表**，**或者是多个库上去**。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会**将较少的访问频率很高的字段放到一个表里去**，然后**将较多的访问频率很低的字段放到另外一个表里去**。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

![img](https://uploadfiles.nowcoder.com/images/20190919/56_1568900435177_29C080A5413E925FE3B3CCB4048AB99B)

两种**分库分表的方式**：

- 一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如**时间范围**来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。
- 或者是按照某个字段hash一下均匀分散，这个较为常用。

range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。

hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表

### 读写分离、主从同步（复制）

#### 1. 什么是MySQL主从同步？

主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。

因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。

#### 2. MySQL主从同步的目的？为什么要做主从同步？

1. 通过增加从服务器来提高数据库的性能，在主服务器上执行写入和更新，在从服务器上向外提供读功能，可以动态地调整从服务器的数量，从而调整整个数据库的性能。
2. 提高数据安全-因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份而不破坏主服务器相应数据
3. 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能
4. 数据备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好的解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全

#### 3. 如何实现MySQL的读写分离？

其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。

#### 4. MySQL主从复制流程和原理？

基本原理流程，是3个线程以及之间的关联

主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；

从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；

从：sql执行线程——执行relay log中的语句；

**复制过程如下**：

![img](https://uploadfiles.nowcoder.com/images/20190919/56_1568900435177_29C080A5413E925FE3B3CCB4048AB99B)

Binary log：主数据库的二进制日志

Relay log：从服务器的中继日志

第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。

第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。

第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。

#### 5. MySQL主从同步延时问题如何解决？

MySQL 实际上在有两个同步机制，一个是半同步复制，用来 解决主库数据丢失问题；一个是并行复制，用来 解决主从同步延时问题。

- 半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。
- 并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

### MySQL优化

#### 1. 如何定位及优化SQL语句的性能问题？

对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，对于查询语句，最重要的优化方式就是使用索引。

而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。
![image-20210822204026552](https://uploadfiles.nowcoder.com/files/20210822/540390845_1629637247270/image-20210822204026552.png)

#### 2. 大表数据查询，怎么优化

- 优化shema、sql语句+索引；
- 第二加缓存，memcached, [redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)；
- 主从复制，读写分离；
- 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；
- 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；

#### 3. 超大分页怎么处理?

数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于`select * from table where age > 20 limit 1000000`,10 这种查询其实也是有可以优化的余地的. 这条语句需要 load1000000 数据然后基本上全部丢弃,只取 10 条当然比较慢. 当时我们可以修改为`select * from table where id in (select id from table where age > 20 limit 1000000,10)`.这样虽然也 load 了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快。

解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)等k-V数据库中,直接返回即可.

在[阿里巴巴](https://www.nowcoder.com/jump/super-jump/word?word=阿里巴巴)《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.

> 【推荐】利用延迟关联或者子查询优化超多分页场景。
>
> 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。
>
> 正例：先快速定位需要获取的id段，然后再关联：
>
> SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

#### 4. 统计过慢查询吗？对慢查询都怎么优化过？

在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。

慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？

所以优化也是针对这三个方向来的，

- 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。
- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。
- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。

#### 5. 如何优化查询过程中的数据访问

- 访问数据太多导致查询性能下降
- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
- 确认MySQL服务器是否在分析大量不必要的数据行
- 查询不需要的数据。解决办法：使用limit解决
- 多表关联返回全部列。解决办法：指定列名
- 总是返回全部列。解决办法：避免使用SELECT *
- 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
- 是否在扫描额外的记录。解决办法：
  使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
  使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
- 改变数据库和表的结构，修改数据表范式
- 重写SQL语句，让优化器可以以更优的方式执行查询。

#### 6. 如何优化关联查询

- 确定ON或者USING子句中是否有索引。
- 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。

#### 7. 数据库结构优化

一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。

需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

1. **将字段很多的表分解成多个表**

对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。

因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

1. **增加中间表**

对于需要经常联合查询的表，可以建立中间表以提高查询效率。

通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。

1. **增加冗余字段**

设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。

表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。

**注意**：

冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。

#### 8. MySQL数据库cpu飙升到500%的话他怎么处理？

当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 MySQLd 占用导致的，如果不是，找出占用高的进程，并进行相关处理。

如果是 MySQLd 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。

一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。

也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

#### 9. 大表怎么优化？

类似的问题：某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

- 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；
- 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
- 缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑；
- 通过分库分表的方式进行优化，主要有垂直分表和水平分表。

## Redis

### 应用场景

1. 缓存
2. 共享Session
3. 消息队列系统
4. 分布式锁

### 单线程的Redis为什么快

1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 合理高效的数据结构
4. 采用了非阻塞I/O多路复用机制（有一个文件描述符同时监听多个文件描述符是否有数据到来）

### Redis 的数据结构及使用场景

1. String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。
2. Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。
3. List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。
4. Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
5. Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。

### Redis 的数据过期策略

Redis 中数据过期策略采用定期删除+惰性删除策略
* 定期删除策略：Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。
* 惰性删除策略：在获取 key 时，先判断 key 是否过期，如果过期则删除。这种方式存在一个缺点：如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。
* 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。淘汰策略分为：
    1. 当内存不足以容纳新写入数据时，新写入操作会报错。（Redis 默认策略）
    2. 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。（LRU推荐使用）
    3. 当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。
    4. 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。这种情况一般是把 Redis 既当缓存，又做持久化存储的时候才用。
    5. 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。
    6. 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。

### Redis的set和setnx

Redis中setnx不支持设置过期时间，做分布式锁时要想避免某一客户端中断导致死锁，需设置lock过期时间，在高并发时 setnx与 expire 不能实现原子操作，如果要用，得在程序代码上显示的加锁。使用SET代替SETNX ，相当于SETNX+EXPIRE实现了原子性，不必担心SETNX成功，EXPIRE失败的问题。

### Redis的LRU具体实现：

传统的LRU是使用栈的形式，每次都将最新使用的移入栈顶，但是用栈的形式会导致执行select *的时候大量非热点数据占领头部数据，所以需要改进。Redis每次按key获取一个值的时候，都会更新value中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的keylru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的值然后将其淘汰。

### Redis如何发现热点key

1. 凭借经验，进行预估：例如提前知道了某个活动的开启，那么就将此Key作为热点Key。
2. 服务端收集：在操作redis之前，加入一行代码进行数据统计。
3. 抓包进行评估：Redis使用TCP协议与客户端进行通信，通信协议采用的是RESP，所以自己写程序监听端口也能进行拦截包进行解析。
4. 在proxy层，对每一个 redis 请求进行收集上报。
5. Redis自带命令查询：Redis4.0.4版本提供了redis-cli –hotkeys就能找出热点Key。（如果要用Redis自带命令查询时，要**注意**需要先把内存逐出策略设置为allkeys-lfu或者volatile-lfu，否则会返回错误。进入Redis中使用config set maxmemory-policy allkeys-lfu即可。）

### Redis的热点key解决方案

1. 服务端缓存：即将热点数据缓存至服务端的内存中.(利用Redis自带的消息通知机制来保证Redis和服务端热点Key的数据一致性，对于热点Key客户端建立一个监听，当热点Key有更新操作的时候，服务端也随之更新。)
2. 备份热点Key：即将热点Key+随机数，随机分配至Redis其他节点中。这样访问热点key的时候就不会全部命中到一台机器上了。

### 如何解决 Redis 缓存雪崩问题

1. 使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉
2. 缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效
3. 限流降级策略：有一定的备案，比如个性推荐服务不可用了，换成热点数据推荐服务

### 如何解决 Redis 缓存穿透问题

1. 在接口做校验
2. 存null值（缓存击穿加锁,或设置不过期）
3. 布隆过滤器拦截： 将所有可能的查询key 先映射到布隆过滤器中，查询时先判断key是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。布隆过滤器将值进行多次哈希bit存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。

### Redis的持久化机制

Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：

1. RDB：快照形式是直接把内存中的数据保存到一个dump的文件中，定时保存，保存策略。当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。
2. AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合。

使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。
缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。
Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。

### Redis的事务

1. Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。
2. Redis事务没有隔离级别的概念，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。
3. Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。

### Redis事务相关命令

1. watch key1 key2 ... : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断（类似乐观锁）
2. multi : 标记一个事务块的开始（queued）
3. exec : 执行所有事务块的命令（一旦执行exec后，之前加的监控锁都会被取消掉）
4. discard : 取消事务，放弃事务块中的所有命令
5. unwatch : 取消watch对所有key的监控

### Redis和 memcached 的区别

1. 存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性。
2. 数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，，而redis支持五种数据类型。
3. 用底层模型不同：它们之间底层实现方式以及与客户端之间通信的应用协议不一样。redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4. value的大小：redis可以达到1GB，而memcache只有1MB。

### Redis的几种集群模式

1. 主从复制
2. 哨兵模式
3. cluster模式

### Redis的哨兵模式

哨兵是一个分布式系统,在主从复制的基础上你可以在一个架构中运行多个哨兵进程,这些进程使用流言协议来接收关于Master是否下线的信息,并使用投票协议来决定是否执行自动故障迁移,以及选择哪个Slave作为新的Master。

每个哨兵会向其它哨兵、master、slave定时发送消息,以确认对方是否活着,如果发现对方在指定时间(可配置)内未回应,则暂时认为对方已挂(所谓的”主观认为宕机”)。

若“哨兵群“中的多数sentinel,都报告某一master没响应,系统才认为该master"彻底死亡"(即:客观上的真正down机),通过一定的vote算法,从剩下的slave节点中,选一台提升为master,然后自动修改相关配置。

### Redis的rehash

Redis的rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的，redis会维护维持一个索引计数器变量rehashidx来表示rehash的进度。

这种渐进式的 rehash 避免了集中式rehash带来的庞大计算量和内存操作，但是需要**注意**的是redis在进行rehash的时候，正常的访问请求可能需要做多要访问两次hashtable（ht[0]， ht[1]），例如键值被rehash到新ht1，则需要先访问ht0，如果ht0中找不到，则去ht1中找。

### Redis的hash表被扩展的条件

1. 哈希表中保存的key数量超过了哈希表的大小.
2. Redis服务器目前没有在执行BGSAVE命令（rdb）或BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.
3. Redis服务器目前在执行BGSAVE命令（rdb）或BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.(负载因子=哈希表已保存节点数量 / 哈希表大小，当哈希表的负载因子小于0.1时，对哈希表执行收缩操作。)

### Redis并发竞争key的解决方案

1. 分布式锁+时间戳
2. 利用消息队列

### Redis与Mysql双写一致性方案

先更新数据库，再删缓存。数据库的读操作的速度远快于写操作的，所以脏数据很难出现。可以对异步延时删除策略，保证读请求完成以后，再进行删除操作。

### Redis的管道pipeline

对于单线程阻塞式的Redis，Pipeline可以满足批量的操作，把多个命令连续的发送给Redis Server，然后一一解析响应结果。Pipelining可以提高批量处理性能，提升的原因主要是TCP连接中减少了“交互往返”的时间。pipeline 底层是通过把所有的操作封装成流，redis有定义自己的出入输出流。在 sync() 方法执行操作，每次请求放在队列里面，解析响应包。


## 消息队列

### 为什么需要消息队列

解耦，异步处理，削峰/限流

### Kafka的文件存储机制

Kafka中消息是以topic进行分类的，生产者通过topic向Kafka broker发送消息，消费者通过topic读取数据。然而topic在物理层面又能以partition为分组，一个topic可以分成若干个partition。partition还可以细分为segment，一个partition物理上由多个segment组成，segment文件由两部分组成，分别为“.index”文件和“.log”文件，分别表示为segment索引文件和数据文件。这两个文件的命令规则为：partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。

### Kafka 如何保证可靠性

如果我们要往 Kafka 对应的主题发送消息，我们需要通过 Producer 完成。前面我们讲过 Kafka 主题对应了多个分区，每个分区下面又对应了多个副本；为了让用户设置数据可靠性， Kafka 在 Producer 里面提供了消息确认机制。也就是说我们可以通过配置来决定消息发送到对应分区的几个副本才算消息发送成功。可以在定义 Producer 时通过 acks 参数指定。这个参数支持以下三种值：
* acks = 0：意味着如果生产者能够通过网络把消息发送出去，那么就认为消息已成功写入 Kafka 。在这种情况下还是有可能发生错误，比如发送的对象无能被序列化或者网卡发生故障，但如果是分区离线或整个集群长时间不可用，那就不会收到任何错误。在 acks=0 模式下的运行速度是非常快的（这就是为什么很多基准测试都是基于这个模式），你可以得到惊人的吞吐量和带宽利用率，不过如果选择了这种模式， 一定会丢失一些消息。
* acks = 1：意味若 Leader 在收到消息并把它写入到分区数据文件（不一定同步到磁盘上）时会返回确认或错误响应。在这个模式下，如果发生正常的 Leader 选举，生产者会在选举时收到一个 LeaderNotAvailableException 异常，如果生产者能恰当地处理这个错误，它会重试发送悄息，最终消息会安全到达新的 Leader 那里。不过在这个模式下仍然有可能丢失数据，比如消息已经成功写入 Leader，但在消息被复制到 follower 副本之前 Leader发生崩溃。
* acks = all（这个和 request.required.acks = -1 含义一样）：意味着 Leader 在返回确认或错误响应之前，会等待所有同步副本都收到悄息。如果和min.insync.replicas 参数结合起来，就可以决定在返回确认前至少有多少个副本能够收到悄息，生产者会一直重试直到消息被成功提交。不过这也是最慢的做法，因为生产者在继续发送其他消息之前需要等待所有副本都收到当前的消息。

### Kafka消息是采用Pull模式，还是Push模式

Kafka最初考虑的问题是，customer应该从brokes拉取消息还是brokers将消息推送到consumer，也就是pull还push。在这方面，Kafka遵循了一种大部分消息系统共同的传统的设计：producer将消息推送到broker，consumer从broker拉取消息。push模式下，当broker推送的速率远大于consumer消费的速率时，consumer恐怕就要崩溃了。最终Kafka还是选取了传统的pull模式。Pull模式的另外一个好处是consumer可以自主决定是否批量的从broker拉取数据。Pull有个缺点是，如果broker没有可供消费的消息，将导致consumer不断在循环中轮询，直到新消息到t达。为了避免这点，Kafka有个参数可以让consumer阻塞知道新消息到达。

### Kafka是如何实现高吞吐率的

1. 顺序读写：kafka的消息是不断追加到文件中的，这个特性使kafka可以充分利用磁盘的顺序读写性能
2. 零拷贝：跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存的直接映射，数据不再复制到“用户态缓冲区”
3. 文件分段：kafka的队列topic被分为了多个区partition，每个partition又分为多个段segment，所以一个队列中的消息实际上是保存在N多个片段文件中
4. 批量发送：Kafka允许进行批量发送消息，先将消息缓存在内存中，然后一次请求批量发送出去
5. 数据压缩：Kafka还支持对消息集合进行压缩，Producer可以通过GZIP或Snappy格式对消息集合进行压缩

### Kafka判断一个节点还活着的两个条件

1. 节点必须可以维护和 ZooKeeper 的连接，Zookeeper 通过心跳机制检查每个节点的连接
2. 如果节点是个 follower,他必须能及时的同步 leader 的写操作，延时不能太久

## Dubbo

### Dubbo的容错机制

1. 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数
2. 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
3. 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
4. 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
5. 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
6. 广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息

### Dubbo注册中心挂了还可以继续通信么

可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。

### Dubbo提供的线程池

1. fixed：固定大小线程池，启动时建立线程，不关闭，一直持有。 
2. cached：缓存线程池，空闲一分钟自动删除，需要时重建。 
3. limited：可伸缩线程池，但池中的线程数只会增长不会收缩。(为避免收缩时突然来了大流量引起的性能问题)。

### Dubbo框架设计结构

1. 服务接口层：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。
2. 配置层：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。
3. 服务代理层：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。
4. 服务注册层：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。
5. 集群层：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。
6. 监控层：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。
7. 远程调用层：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。
8. 信息交换层：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。
9. 网络传输层：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。
10. 数据序列化层：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。

## linux

### linux 基础
#### 1. 什么是Linux

Linux是一套免费使用和自由传播的类似Unix操作系统，一般的WEB项目都是部署都是放在Linux 操作系统上面。 Linux是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系 统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了 Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。



#### 2. Windows和Linux的区别

- Windows是微软开发的操作系统，民用操作系统，可用于娱乐、影音、上网。 Windows操作系统 具有强大的日志记录系统和强大的桌面应用。好处是它可以帮我们实现非常多绚丽多彩的效果，可 以非常方便去进行娱乐、影音、上网。
- Linux的应用相对单纯很多，没有什么绚丽多彩的效果，因此Linux的性能是非常出色的，可以完 全针对机器的配置有针对性的优化，
- 简单来说Windows适合普通用户进行娱乐办公使用，Linux适合软件开发部署

#### 3. Unix和Linux有什么区别？

- Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至 有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区 别。

1. 开源性 Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的 传统商业软件，使用需要付费授权使用。
2. 跨平台性 Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能 较弱，大多需与硬件配套使用。 
3. 可视化界面 Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。 
4. 硬件环境 Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度 较大。
5. 用户群体 Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高 的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。 相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作 系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源 免费的特性，更容易普及使用！

#### 4. 什么是 Linux 内核？

Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根 据需要执行软件。

1. 系统内存管理

2. 应用程序管理

3. 硬件设备管理

4. 文件系统管理

   

#### 5. Linux的基本组件是什么？ 

就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和GUI，系统实用程序 和应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费 下载。



#### 6. Linux 的体系结构 

从大的方面讲，Linux 体系结构可以分为两块：



![](https://gitee.com/nateshao/images/raw/master/img/20220105104041.png)

- 用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。 
- 内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、 平台架构相关的代码(Architecture-Dependent Kernel Code) 。

##### 为什么 Linux 体系结构要分为用户空间和内核空间的原因？

1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。

2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。

用户空间和内核空间是程序执行的两种不同的状态，我们可以通过两种方式完成用户空间到内核空 间的转移： 

- 系统调用； 
- 硬件中断。

#### 7. BASH和DOS之间的基本区别是什么？

BASH和DOS控制台之间的主要区别在于3个方面：

- BASH命令区分大小写，而DOS命令则不区分; 
  - 在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔 符，\是目录分隔符 

- DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没 有遵循这样的惯例。

#### 8. Linux 开机启动过程？

1、主机加电自检，加载 BIOS 硬件信息。

2、读取 MBR 的引导文件(GRUB、LILO)。 

3、引导 Linux 内核。 

4、运行第一个进程 init (进程号永远为 1 )。 

5、进入相应的运行级别。 

6、运行终端，输入用户名和密码。

#### 9. Linux系统缺省的运行级别？

- 关机。 
- 单机用户模式。 
- 字符界面的多用户模式(不支持网络)。 
- 字符界面的多用户模式。 
- 未分配使用。 
- 图形界面的多用户模式。 
- 重启。

#### 10. Linux 使用的进程间通信方式？

1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。 

2、信号(signal) 。 

3、消息队列。 

4、共享内存。 

5、信号量。 

6、套接字(socket) 。

#### 11. Linux 有哪些系统日志文件？

比较重要的是 /var/log/messages 日志文件。

> 该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。 另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。

#### 12. Linux系统安装多个桌面环境有帮助吗？

通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环 境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一 个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。

#### 13. 什么是交换空间？

交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来 容纳正在执行的所有程序时，就会发生这种情况。

#### 14. 什么是root帐户

root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为 每个帐户分配不同的权限。每次安装Linux时都是默认帐户。

#### 15. 什么是LILO？

LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运 行。

#### 16. 什么是BASH？

BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易 使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。

#### 17. 什么是CLI？

- 命令行界面（英语：command-line interface，缩写]：CLI）是在图形用户界面得到普及之前使 用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以 执行。也有人称之为字符用户界面（CUI）。

- 通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面 的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节 约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速 度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。

#### 18. 什么是GUI？

- 图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显 示的计算机操作用户界面。

- 图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的 图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文 本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。

#### 20. GNU项目的重要性是什么？

这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修 改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。

### 磁盘、目录、文件

#### 21. 简单 Linux 文件系统？

在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出 设备、普通文件或是目录都被看作是一个文件。

- 也就是说在 Linux 系统中有一个重要的概念：一切都是文件。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是 文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就 可以用读写文件的方式实现对硬件的访问。

- Linux 支持 5 种文件类型，如下图所示：

#### 22. Linux 的目录结构是怎样的？

Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：

![](https://gitee.com/nateshao/images/raw/master/img/20220105160919.png)

**常见目录说明**

![](https://gitee.com/nateshao/images/raw/master/img/20220105161045.png)

#### 23. 什么是 inode ？

> 一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix/Linux 文件系统和硬 盘储存的基础。

- 理解inode，要从文件储存说起。 
- 文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于 0.5KB）。 
- 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇 区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单 位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。
-  文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的 创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名 为"索引节点"。 
- 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。

#### 24. 什么是硬链接和软链接？

**硬链接**：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针， 指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接 数就加 1 。

不足： 

1. 不可以在不同文件系统的文件间建立链接； 
2. 只有超级用户才可以为目录创建硬链接。

**软链接**：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符 号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件 进行链接。

不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录 中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移； 还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。

#### 25. RAID 是什么?

RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个 相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大 的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统 只会把它当做一个硬盘。 RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应 用中，可以依据自己的实际需求选择不同的 RAID 方案。

当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、 SSD 云盘酱紫的概念。

#### 26. 一台 Linux 系统初始化环境后需要做一些什么安全工作？

1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。

> 修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。

2、服务器使用密钥登陆，禁止密码登陆。 

3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。 

4、装 fail2ban 这种防止 SSH 暴力破击的软件。 

5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要) 也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。 

6、修改历史命令记录的条数为 10 条。 

7、只允许有需要的服务器可以访问外网，其它全部禁止。 

8、做好软件层面的防护。 

1. 设置 nginx_waf 模块防止 SQL 注入。 
2. 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。

#### 27. 什么叫 CC 攻击？什么叫 DDOS 攻击？

- CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资 源消耗殆尽。 
- DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击 平台，来对一个或多个目标发动 DDOS 攻击。

> 攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。

怎么预防 CC 攻击和 DDOS 攻击？ 

- 防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。 

  > 流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般 是买服务，毕竟攻击不会是持续长时间。

#### 28. 什么是网站数据库注入？

- 由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法 性进行判断。 
- 应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想 得知的数据，这就是所谓的 SQL 注入。 
- SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如 果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。

#### 29. Shell 脚本是什么？

一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个 命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工 作任务。

#### 30.如何选择 Linux 操作系统版本?

一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。

- 安全性要求较高，则选择 Debian 或者 FreeBSD 。
-  需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。 
- 想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布 版本。 
- 【重点】根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现 在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束。
-  CentOS 7 系列，也慢慢使用的会比较多了。

#### 31. 如何规划一台 Linux 主机，步骤是怎样？

1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。 

> 不同的用途，机器的配置会有所不同。 

2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。 

3、需要优化系统的哪些参数，需要创建哪些用户等等的。

#### 32. 请问当用户反馈网站访问慢，你会如何处理？

有哪些方面的因素会导致网站网站访问慢？

**1、服务器出口带宽不够用** 

- 本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口 带宽就小，访问速度自然就会慢。 
- 跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是 长城宽带或联通，这也可能导致带宽的缩减。

**2、服务器负载过大，导致响应不过来** 

可以从两个方面入手分析：

- 分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。
- 如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分 析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访 问等。

**3、数据库瓶颈**

- 如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。 
- 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。

**4、网站开发代码没有优化好** 

- 例如 SQL 语句没有优化，导致数据库读写相当耗时。

#### 针对网站访问慢，怎么去排查？

1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看 看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。 

> 不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。

2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片 加载慢，还是某些数据加载慢。 

3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主 机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。 

4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看 看是不是某条 SQL 语句查询慢，导致网站访问慢。

**怎么去解决？**

1、如果是出口带宽问题，那么久申请加大出口带宽。 

2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。 

3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主 从，一台 MySQL 服务器负责写，其他几台从数据库负责读。 

4、申请购买 CDN 服务，加载用户的访问。 

5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同 一个服务。

#### 33. Linux 性能调优都有哪几种方法？

1、Disabling daemons (关闭 daemons)。 

2、Shutting down the GUI (关闭 GUI)。 

3、Changing kernel parameters (改变内核参数)。 

4、Kernel parameters (内核参数)。 

5、Tuning the processor subsystem (处理器子系统调优)。 

6、Tuning the memory subsystem (内存子系统调优)。 

7、Tuning the file system (文件系统子系统调优)。 

8、Tuning the network subsystem（网络子系统调优)。

### 34. 基本命令

cd （change directory：英文释义是改变目录）切换目录

```shell
cd ../ ;跳到上级目录
cd /opt ;不管现在到那直接跳到指定的opt文件夹中
cd ~ ;切换当前用户的家目录。root用户的家目录就是root目录。
```
pwd （print working directory：显示当前工作目录的绝对路径）

```shell
pwd
显示当前的绝对路径
```
ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）

```shell
ls -a ;显示所有文件夹,隐藏文件也显示出来
ls -R ;连同子目录一起列出来
```
ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间, 是否可读写等信息）

```shell
ll -a ;显示所有文件,隐藏文件也显示出来
ll -R ;连同子目录内容一起列出来
ll -h ;友好展示详情信息,可以看大小
ll -al ;即能显示隐藏文件又能显示详细列表。
```
touch （touch：创建文件）创建文件 

```shell
touch test.txt ;创建test.txt文件
touch /opt/java/test.java ;在指定目录创建test.java文件
```
mkdir （mkdir：创建目录） 创建目录 

```shell
mkdir 文件夹名称 ;在此目录创建文件夹
mkdir /opt/java/jdk ;在指定目录创建文件夹
```
cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内 容）（不能快速定位到最后一页）

```shell
cat lj.log ;快捷查看文件命令
Ctrl + c ;暂停显示文件
Ctrl + d ;退出查看文件命令
```
more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）

```shell
回车：向下n行，需要定义，默认为1行。
空格键：向下滚动一屏或Ctrl+F
B：返回上一层或Ctrl+B
q：退出more
```
less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）

```shell
less -m 显示类似于more命令的百分比。
less -N 显示每行的行号。(大写的N)
两参数一起使用如：less -mN 文件名，如此可分页并显示行号。
空格键：前下一页或page down。
回车：向下一行。
b：后退一页 或 page up。
q：退出。
d：前进半页。
u：后退半页
```
tail（尾巴） 查看文件命令（看最后多少行）

```shell
tail -10 ;文件名 看最后10行
```
cp（copy单词缩写，复制功能） 

```shell
cp /opt/java/java.log /opt/logs/ ;把java.log 复制到/opt/logs/下
cp /opt/java/java.log /opt/logs/aaa.log ;把java.log 复制到/opt/logs/下并且改名为
aaa.log
cp -r /opt/java /opt/logs ;把文件夹及内容复制到logs文件中
```
mv（move单词缩写，移动功能，该文件名称功能） 

```shell
mv /opt/java/java.log /opt/mysql/ ;移动文件到mysql目录下
mv java.log mysql.log ;把java.log改名为mysql.log
```
rm（remove：移除的意思）删除文件，或文件夹

```shell
-f或--force 强制删除文件或目录。删除文件不包括文件夹的文件
-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。
-rf 强制删除文件夹及内容
rm 文件名 ;安全删除命令 （yes删除 no取消）
rm -rf 强制删除文件夹及内容
rm -rf * 删除当前目录下的所有内容。
rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。
```
find （find：找到的意思）查找指定文件或目录

```shell
* 表示0~多个任意字符。
find -name 文件名;按照指定名称查找在当前目录下查找文件
find / -name 文件名按照指定名称全局查找文件
find -name '*文件名' ;任意前缀加上文件名在当前目录下查找文件
find / -name '*文件名*' ;全局进行模糊查询带文件名的文件
```
vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操 作） vim （VI IMproved：改进版视觉）改进版文本编辑器 （不管是文件查看还是文件编辑 按 Shift + 上或 者下可以上下移动查看视角）

```shell
输入”vim 文件名” 打开文件，刚刚时是”一般模式”。
一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退
出）等。
插入模式：可以编辑文件内容。
底行模式：可以进行强制退出操作,不保存 :q!
可以进行保存并退出操作 :wq
按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。
在编辑模式下按”Esc” 即可到一般模式
在一般模式下按”:”，冒号进入底行模式。
在一般模式下的快捷键
dd ;删除一整行
X ;向前删除 等同于windowns系统中的删除键
x ;向后删除和大写x相反方向
Ctrl + f ;向后看一页
Ctrl + b ;向前看一页
u ;撤销上一步操作
/word ;向下查找word关键字 输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过
n的方向相反）
?log ;向上查找log关键字 输入:n查找上一个,N查找下一个
:1,90s/redis/Redis/g ;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1
代表其实行,n2代表结尾行,g是必须要的
:0 ;光标移动到第一行
:$ ;光标移动到最后一行
:300 ;光标移动到300行,输入多少数字移动到多少行
:w ;保存
:w! ;强制保存
:q ;退出
:q! ;强制退出
5dd ;删除后面5行,打一个参数为自己填写
5x ;删除此光标后面5个字符
d1G ;删除此光标之前的所有
d0 ;从光标当前位置删除到此行的第一个位置
yy ;复制
p ;在光标的下面进行粘贴
P ;在光标的上门进行粘贴
```
管道命令（把多个命令组合起来使用）

```shell
管道命令的语法：命令1 | 命令2 | 命令3。
```
grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过

```shell
单独使用：
grep String test.java ；在test.java文件中查找String的位置，返回整行
一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）
ps aux|grep java ；查找带java关键字的进程
ll |grep java ；查找带java关键字的文件夹及文件
```
yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）

```shell
#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉
文件
#等待下载完了就可以输入：
rz 从win系统中选择文件上传到Linux系统中
sz 文件名 选择Linux系统的文件复制到win系统中
```
tar （解压 压缩 命令）

```shell
常用的组合命令：
-z 是否需要用gzip压缩。
-c 建立一个压缩文件的参数指令(create) –压缩
-x 解开一个压缩文件的参数指令(extract) –解压
-v 压缩的过程中显示文件(verbose)
-f 使用档名，在f之后要立即接档中(file)
常用解压参数组合：zxvf
常用压缩参数组合：zcvf
解压命令：
tar -zxvf redis-3.2.8.tar.gz ；解压到当前文件夹
tar -zxvf redis-3.2.8.tar.gz -C /opt/java/ ；解压到指定目录
压缩命令：（**注意** 语法有点反了，我反正每次都搞反）
tar -zcvf redis-3.2.8.tar.gz redis-3.2.8/ ;语法 tar -zcvf 压缩后的名称 要压缩的
文件
tar -zcvf 压缩后的文件（可指定目录） 要压缩的文件（可指定目录）
```
ps （process status：进程状态，类似于windows的任务管理器）

```shell
常用组合：ps -ef 标准的格式查看系统进程
ps -aux BSD格式查看系统进程
ps -aux|grep redis BSD格式查看进程名称带有redis的系统进程（常用技巧）
//显示进程的一些属性,需要了解（ps aux）
USER //用户名
PID //进程ID号,用来杀死进程的
%CPU //进程占用的CPU的百分比
%MEM //占用内存的的百分比
VSZ //该进程使用的虚拟內存量（KB）
RSS //该进程占用的固定內存量（KB）
STAT //进程的状态
START //该进程被触发启动时间
TIME //该进程实际使用CPU运行的时间
```
clear 清屏命令。（强迫症患者使用）

```shell
kill 命令用来中止一个进程。（要配合ps命令使用，配合pid关闭进程）
（ps类似于打开任务管理器，kill类似于关闭进程）
kill -5 进程的PID ;推荐,和平关闭进程
kill -9 PID ;不推荐,强制杀死进程

```
ifconfig命令 

```shell
用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。（一般是
用来查看的，很少更改）
如果此命令输入无效，先输入yum -y install net-tools
ifconfig
```

ping （用于检测与目标的连通性）语法：ping ip地址 

```shell
测试：
1、在Windows操作系统中cmdipconfig，查看本机IP地址：
2、再到LInux系统中输入 ping ip地址
（公司电脑，我就不暴露Ip了,没图片 自己去试）
按Ctrl + C 可以停止测
```

free 命令 （显示系统内存）

```shell
#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。
-b 以Byte显示内存使用情况
-k 以kb为单位显示内存使用情况
-m 以mb为单位显示内存使用情况
-g 以gb为单位显示内存使用情况
-s<间隔秒数> 持续显示内存
-t 显示内存使用
```
top 命令

```shell
#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等
-c 显示完整的进程命令
-s 保密模式
-p <进程号> 指定进程显示
-n <次数>循环显示
```
netstat 命令

```shell
#Linux netstat命令用于显示网络状态。
#利用netstat指令可让你得知整个Linux系统的网络情况。
#语法：
netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]
```
file （可查看文件类型）

file 文件名

重启linux 

```shell
Linux centos 重启命令：reboot
```
关机linux 

```shell
Linux centos 关机命令：halt
```
同步时间命令 

```shell
ntpdate ntp1.aliyun.com
```
更改为北京时间命令 

```shell
rm -rf /etc/localtime
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```
查看时间命令： 

```shell
date
```

### 进程
1. **进程**
   进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销(栈、寄器、虚拟内存、文件句柄等)比较大，但相对比较稳定安全。
2. **线程**
   线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
3. **协程**
   协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

#### 1.进程和线程的区别?

一个程序至少有一个进程，一个进程至少有一个线程

- **从系统调度上看**：进程是资源管理的基本单位，线程是程序执行的基本单位。
- **从上下文切换上看**：线程上下文切换比进程上下文切换要快得多。
- **从系统开销上看**：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

#### 2.协程与线程的区别?

- 一个线程可以有多个协程，一个进程也可以有多个协程。线程和进程都是同步机制，而协程是异步机制。

- **协程是由程序自身控制**，没有线程切换的开销，执行效率非常高

- 协程**不需要多线程的锁机制**：**在协程中控制共享资源不加锁**，只需要判断状态就好了，所以执行效率比多线程高很多。

- 线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

- 协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。

  

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220328113326.jpeg)

#### 并发与并行的区别是什么？

你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。

你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。

你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

并发的关键是你有处理多个任务的能力，不一定要同时。

并行的关键是你有同时处理多个任务的能力。

所以我认为它们最关键的点就是：**是否是『同时』**。

#### 4.进程与线程的切换流程?

进程切换分两步:

1. 切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。
2. 切换内核栈和硬件上下文。

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。
因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

#### 12.进程调度策略有哪几种? 

> 先来先服务，短作业优先，最短剩余时间优先，时间片轮转，优先级调度。

- **先来先服务**：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一 直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/o密集型进程也不利，因为这种进程每次进行I/o操作之后又得重新排队。
- 短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于-直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
- 最短剩余时间优先：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一.个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
- 时间片轮转：将所有就绪进程按FCFS的原则排成一一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系:因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。
- 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 进程有哪些状态?

进程一共有5种状态，分别是新建、就绪、运行、阻塞、终止。

#### 什么是用户态和内核态?

用户态和系统态是操作系统的两种运行状态:

- 用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的CPU不允许独占，也就是说CPU能够被其他程序获取。
- 内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的CPU可以从一个程序切换到另外一个程序，并且占用CPU不会发生抢占情况。

将操作系统的运行状态分为用户态和内核态，主要是为了对访问能力进行限制，防止随意进行一些比较危险的操作导致系统的崩溃，比如设置时钟、内存清理，这些都需要在内核态下完成。

### 讲一讲IO多路复用?

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合:

- 当客户处理多个描述字时(一般是交互式输入和网络套接口)，必须使用I/O复用。.
- 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
- 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
- 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
- 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。
- 与多进程和多线程技术相比，IO多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

---

**IO多路复用模型指的是：使用单个进程同时处理多个网络连接IO，他的原理就是select、poll、epoll不断轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。该模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。**

下面举一个例子，模拟一个tcp服务器处理30个客户socket。

假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择:

1. **(select)**第一种选择：**按顺序逐个检查**，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。

2. **(poll)**第二种选择：你**创建30个分身**，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。

3. **(select)**第三种选择，你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 

这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用**非阻塞模式**。

这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是**事件驱动**，所谓的reactor模式。

#### select、poll 和epoll之间的区别?
1. **select：时间复杂度O(n)**
   select仅仅知道有I/O事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数据或者写入数据的流，并对其进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。
2. **poll：时间复杂度O(n)**
   poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。
3. **epoll： 时间复杂度O(1)**
   epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的I/O事件通知我们。所以说epoll实际上是事件驱动(每个事件关联上fd)的。

select，poll，epoll都是IO多路复用的机制。l/O多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，就通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O,因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步l/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

### 软链接和硬链接有什么区别?

- 软链接可以理解成快捷方式，也清楚知道原文件在哪里。它和Windows下的快捷方式的作用是一样的，删除源文件，快捷方式也就无法使用了。

- 硬链接可以看成一个备份，但并没有增加空间，因为文件就一个，这种可以防止源文件删除后不能使用问题；同时也有局限性，不能对目录和跨文件系统使用。

语法格式(ln)区别：

　　硬链接：ln 源文件 链接名

　　软链接：ln -s 源文件 链接名

　　**注意**：链接的源文件路径要写绝对路径，否则会报错。

### 中断的处理过程?

1. 保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。
2. 开中断：以便执行中断时能响应较高级别的中断请求。
3. 中断处理
4. 关中断：保证恢复现场时不被新中断打扰
5. 恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。

---
### 1.1 Linux里如何查看一个想知道的进程？

**查看进程运行状态的指令**：ps命令。“**ps -aux | grep PID**”，用来查看某PID进程状态

>ps使用示例  //显示当前所有进程   ps -A   //与grep联用查找某进程   ps -aux | grep apache    //查看进程运行状态、查看内存使用情况的指令均可使用top指令。 top

### 1.2 Linux里如何查看带有关键字的日志文件？

1. **cat 路径/文件名 | grep 关键词**

```shell
# 返回test.log中包含http的所有行 cat test.log | grep "http"
```
1. **grep -i 关键词 路径/文件名** （与方法一效果相同，不同写法而已）

```shell
# 返回test.log中包含http的所有行(-i忽略大小写） grep -i "http" ./test.log 
```

### 1.3 说说你对grep命令的了解？

grep 命令。强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。

grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

### 1.4 Linux修改主机名的命令是什么？

1. 如果只需要临时更改主机名，可以使用hostname命令。

   ```shell
   sudo hostname <new-hostname> # 例如: sudo hostname myDebian #myDebian为修改名
   ```
2. 如果想永久改变主机名，可以使用hostnamectl命令

   ```shell
   sudo hostnamectl set-hostname myDebian #myDebian为修改名
   ```
### 1.5 Linux开机自动执行命令如何实现？

1. **方法 #1 - 使用 cron 任务**

   除了常用格式（分 / 时 / 日 / 月 / 周）外，cron 调度器还支持 @reboot 指令。这个指令后面的参数是脚本（启动时要执行的那个脚本）的绝对路径。

   然而，这种方法需要**注意**两点：

   a)  cron 守护进程必须处于运行状态（通常情况下都会运行），同时

   b) 脚本或 crontab 文件必须包含需要的环境变量。

2. **方法 #2 - 使用 /etc/rc.d/rc.local**

   这个方法对于 systemd-based 发行版 Linux 同样有效。不过，使用这个方法，需要授予 /etc/rc.d/rc.local 文件执行权限:

   ```shell
   # chmod +x /etc/rc.d/rc.local
   ```
   然后在这个文件底部添加脚本。

### 1.6 Linux查看内存的命令是什么？

**查看内存使用情况的指令**：**free命令**。“**free -m**”，命令查看内存使用情况。

查看进程运行状态、查看内存使用情况的指令均可使用**top指令**。

1. **free命令**

   Linux free命令用于**显示内存状态**。

   free指令会显示内存的使用情况，**包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。**

   参数如下:

   ```shell
   -b 以Byte为单位显示内存使用情况。
   -k 以KB为单位显示内存使用情况。 
   -m 以MB为单位显示内存使用情况。 
   -h 以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。
   单位有:         
   B = bytes         K = kilos         M = megas         G = gigas         T = teras -o 不显示缓冲区调节列。 -s<间隔秒数> 持续观察内存使用状况。 -t 显示内存总和列。 -V 显示版本信息。
   ```
   实例:显示内存使用情况

   ```shell
   # free //显示内存使用信息
   total used free shared buffers cached
   Mem: 254772 184568 70204 0 5692 89892
   -/+ buffers/cache: 88984 165788
   Swap: 524280 65116 459164
   ```
2. top命令

**top**命令。**显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等**

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220328215436.png)

**前五行是当前系统情况整体的统计信息区。**

1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下:

   00:12:54 — 当前系统时间

   up ？days, 4:49 — 系统已经运行了？天4小时49分钟（在这期间系统没有重启过）

   21users — 当前有1个用户登录系统

   load average: 0.06, 0.02, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

2. 第二行，Tasks — 任务（进程），具体信息说明如下:

   系统现在共有256个进程，其中处于运行中的有1个，177个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

3. 第三行，cpu状态信息，具体属性说明如下:

   0.2%us — 用户空间占用CPU的百分比。

   0.2% sy — 内核空间占用CPU的百分比。

   0.0% ni — 改变过优先级的进程占用CPU的百分比

   99.5% id — 空闲CPU百分比

   0.0% wa — IO等待占用CPU的百分比

   0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比

   0.0% si — 软中断（Software Interrupts）占用CPU的百分比

4. 第四行，内存状态，具体信息如下:

   2017552 total — 物理内存总量

   720188 used — 使用中的内存总量

   197916 free — 空闲内存总量

   1099448 cached — 缓存的总量

5. 第五行，swap交换分区信息，具体信息说明如下:

   998396 total — 交换区总量

   989936 free — 空闲交换区总量

   8460 used — 使用的交换区总量

   1044136 cached — 缓冲的交换区总量

### 1.7 free命令有哪些选项？

Linux free命令用于**显示内存状态**。

free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。

参数如下:

```shell
-b 　以Byte为单位显示内存使用情况。
-k 　以KB为单位显示内存使用情况。
-m 　以MB为单位显示内存使用情况。
-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有:
        B = bytes
        K = kilos
        M = megas
        G = gigas
        T = teras
-o 　不显示缓冲区调节列。
-s<间隔秒数> 　持续观察内存使用状况。
-t 　显示内存总和列。
-V 　显示版本信息。
```
**答案解析**

实例：显示内存使用情况

```shell
# free //显示内存使用信息
total used free shared buffers cached
Mem: 254772 184568 70204 0 5692 89892
-/+ buffers/cache: 88984 165788
Swap: 524280 65116 459164
```

### 1.8 Linux中压缩文件的命令是什么？

Linux中压缩文件与解压文件的命令有：**tar命令、gz命令、bz2命令、compress命令、zip命令、unzip命令**。

**答案解析**

1. **tar 命令详解**

   Linux tar（英文全拼：tape archive ）命令用于备份文件。

   tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

   ```shell
   //命令格式:
   tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F <Script文件>][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]
       
   //常用参数:
   //必要参数有如下:
   -A 新增压缩文件到已存在的压缩
   -c 建立新的压缩文件
   -d 记录文件的差别
   -r 添加文件到已经压缩的文件
   -u 添加改变了和现有的文件到已经存在的压缩文件
   -x 从压缩的文件中提取文件
   -t 显示压缩文件的内容
   -z 支持gzip解压文件
   -j 支持bzip2解压文件
   -Z 支持compress解压文件
   -v 显示操作过程
   -l 文件系统边界设置
   -k 保留原有文件不覆盖
   -m 保留文件不被覆盖
   -W 确认压缩文件的正确性
       
   //实例
   //1.压缩
   tar -cf hhh.tar hhh       //打包 hhh 文件为 hhh.tar
   tar -jcf hhh.tar.bz2 hhh  //压缩打包 hhh 文件为 hhh.tar.bz2
   tar -czf hhh.tar.gz hhh   //压缩 hhh 文件为 hhh.tar.gz
   tar -tzvf test.tar.gz     //列出压缩文件内容
       
   //2.解压文件  
   tar -tzvf test.tar.gz 
   ```
2. **gz命令详解**

   Linux gzip命令用于压缩文件。

   gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。

   ```shell
   //命令格式:
   gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]
       
   //常用参数:
   -a或--ascii 　使用ASCII文字模式。
   -c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。
   -d或--decompress或----uncompress 　解开压缩文件。
   -f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
   -h或--help 　在线帮助。
   -l或--list 　列出压缩文件的相关信息。
   -L或--license 　显示版本与版权信息。
   -n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。
   -N或--name 　压缩文件时，保存原来的文件名称及时间戳记。
   -q或--quiet 　不显示警告信息。
   -r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
   -S<压缩字尾字符串>或----suffix<压缩字尾字符串> 　更改压缩字尾字符串。
   -t或--test 　测试压缩文件是否正确无误。
   -v或--verbose 　显示指令执行过程。
   -V或--version 　显示版本信息。
   -<压缩效率> 　压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。
   --best 　此参数的效果和指定"-9"参数相同。
   --fast 　此参数的效果和指定"-1"参数相同。
       
   //实例
   //1.压缩
   gzip *            //压缩目录下的所有文件
       
   //2.解压文件  
   gzip -dv *        //解压文件，并列出详细信息   
   ```
3. **bz2命令详解**

   bzip2(选项)（参数）:用于创建和管理.bz2格式的压缩包。

   ```shell
   //命令格式:
   bzip2 源文件       //压缩不保留源文件
   bzip2 -k 源文件    //压缩保留源文件
   //**注意** bzip2 命令不能解压目录
   
   //常用参数:
   -c 将压缩与解压缩的结果送到标准输出
   -d 执行解压缩
   -f 在压缩或解压缩时，若输出文件与现有文件名相同，预设不会覆盖现有文件；使用该选项，可覆盖文件
   -k 在压缩或解压缩后，会删除原是文件；若要保留原是文件，使用该选项
   -v 压缩或解压缩文件时，显示详细的信息
   -z 强制执行压缩
       
   //实例
   //1.压缩
   bzip2 源文件       //压缩不保留源文件
   bzip2 -k 源文件    //压缩保留源文件
       
   //2.解压文件  
   bzip2 -d 源文件   //解压缩 -k 保留压缩文件
   bunzip2  源文件   //解压缩 -k 保留压缩文件      
   ```
4. **compress命令详解**

   Linux compress命令是一个相当古老的 unix 档案压缩指令，压缩后的档案会加上一个 .Z 延伸档名以区别未压缩的档案，压缩后的档案可以以 uncompress 解压。若要将数个档案压成一个压缩档，必须先将档案 tar 起来再压缩。由于 gzip 可以产生更理想的压缩比例，一般人多已改用 gzip 为档案压缩工具。

   ```shell
   //命令格式:
   compress [-dfvcV] [-b maxbits] [file ...]
    
   //常用参数:    
   -c 输出结果至标准输出设备（一般指荧幕）
   -f 强迫写入档案，若目的档已经存在，则会被覆盖 (force)
   -v 将程序执行的讯息印在荧幕上 (verbose)
   -b 设定共同字串数的上限，以位元计算，可以设定的值为 9 至 16 bits 。由于值越大，能使用的共同字串就 越多，压缩比例就越大，所以一般使用预设值 16 bits (bits)
   -d 将压缩档解压缩
   -V 列出版本讯息    
       
   //实例
   //1.压缩
   compress -f source.dat   //将 source.dat 压缩成 source.dat.Z ，若 source.dat.Z 已经存在，内容则会被压缩档覆盖。    
       
   //2.解压文件  
   compress -d source.dat   //将 source.dat.Z 解压成 source.dat ，若档案已经存在，使用者按 y 以确定覆盖档案，若使用 -df 程序则会自动覆盖档案。 
   ```
5. **zip 命令详解**

   ```shell
   //命令格式:
   zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]
       
   //常用参数:
   -m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。
   -o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。
   -q 不显示指令执行过程。
   -r 递归处理，将指定目录下的所有文件和子目录一并处理。
   -x<范本样式> 压缩时排除符合条件的文件。
       
   //实例:
   //将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：
   zip -q -r html.zip /home/html
       
   //如果在我们在 /home/html 目录下，可以执行以下命令:
   zip -q -r html.zip *
       
   //从压缩文件 cp.zip 中删除文件 a.c
   zip -dv cp.zip a.c
   ```
6. **unzip 命令详解**

   Linux unzip命令用于解压缩zip文件

   unzip为.zip压缩文件的解压缩程序。

   ```shell
   //命令格式:
   unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]
       
   //常用参数:    
   -c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。
   -f 更新现有的文件。
   -l 显示压缩文件内所包含的文件。
   -p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。
   -t 检查压缩文件是否正确。
   -u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。
   -v 执行是时显示详细的信息。
   -z 仅显示压缩文件的备注文字。
   -a 对文本文件进行必要的字符转换。
   -b 不要对文本文件进行字符转换。
   -C 压缩文件中的文件名称区分大小写。
   -j 不处理压缩文件中原有的目录路径。
   -L 将压缩文件中的全部文件名改为小写。
   -M 将输出结果送到more程序处理。
   -n 解压缩时不要覆盖原有的文件。
   -o 不必先询问用户，unzip执行后覆盖原有文件。
   -P<密码> 使用zip的密码选项。
   -q 执行时不显示任何信息。
   -s 将文件名中的空白字符转换为底线字符。
   -V 保留VMS的文件版本信息。
   -X 解压缩时同时回存文件原来的UID/GID。
   [.zip文件] 指定.zip压缩文件。
   [文件] 指定要处理.zip压缩文件中的哪些文件。
   -d<目录> 指定文件解压缩后所要存储的目录。
   -x<文件> 指定不要处理.zip压缩文件中的哪些文件。
   -Z unzip -Z等于执行zipinfo指令。
       
   //实例
   unzip text.zip   //将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。    
   unzip -n text.zip -d /tmp  //查看压缩文件目录，但不解压。
   ```
### 1.9 Linux查询连接数的命令是什么？

**参考回答**

1. **netstat**

2. ```shell
   //示例
   查看Web服务器（Nginx Apache）的并发请求数及其TCP连接状态:
   netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
   
   解释:
   返回结果示例: 
   LAST_ACK 5   (正在等待处理的请求数) 
   SYN_RECV 30 
   ESTABLISHED 1597 (正常数据传输状态) 
   FIN_WAIT1 51 
   FIN_WAIT2 504 
   TIME_WAIT 1057 (处理完毕，等待超时结束的请求数) 
    
   状态:描述 
   CLOSED：无连接是活动的或正在进行 
   LISTEN：服务器在等待进入呼叫 
   SYN_RECV：一个连接请求已经到达，等待确认 
   SYN_SENT：应用已经开始，打开一个连接 
   ESTABLISHED：正常数据传输状态 
   FIN_WAIT1：应用说它已经完成 
   FIN_WAIT2：另一边已同意释放 
   ITMED_WAIT：等待所有分组死掉 
   CLOSING：两边同时尝试关闭 
   TIME_WAIT：另一边已初始化一个释放 
   LAST_ACK：等待所有分组死掉
   ```
**答案解析**

无。

### 1.10 Linux中top命令有哪些参数？

**参考回答**

**top**命令。显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等

**参数**:

```shell
-d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 
-p 通过指定监控进程ID来仅仅监控某个进程的状态。 
-q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 
-S 指定累计模式 
-s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 
-i 使top不显示任何闲置或者僵死进程。 
-c 显示整个命令行而不只是显示命令名 
```
**答案解析**

![img](https://cdn.jsdelivr.net/gh/nateshao/images/20220328215712.png)

**前五行是当前系统情况整体的统计信息区。**

1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下:

   00:12:54 — 当前系统时间

   up ？days, 4:49 — 系统已经运行了？天4小时49分钟（在这期间系统没有重启过）

   21users — 当前有1个用户登录系统

   load average: 0.06, 0.02, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

2. 第二行，Tasks — 任务（进程），具体信息说明如下:

   系统现在共有256个进程，其中处于运行中的有1个，177个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

3. 第三行，cpu状态信息，具体属性说明如下:

   ```shell
   0.2%us — 用户空间占用CPU的百分比。
   
   0.2% sy — 内核空间占用CPU的百分比。
   
   0.0% ni — 改变过优先级的进程占用CPU的百分比
   
   99.5% id — 空闲CPU百分比
   
   0.0% wa — IO等待占用CPU的百分比
   
   0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
   
   0.0% si — 软中断（Software Interrupts）占用CPU的百分比
   ```
4. 第四行，内存状态，具体信息如下:

   2017552 total — 物理内存总量

   720188 used — 使用中的内存总量

   197916 free — 空闲内存总量

   1099448 cached — 缓存的总量

5. 第五行，swap交换分区信息，具体信息说明如下:

   998396 total — 交换区总量

   989936 free — 空闲交换区总量

   8460 used — 使用的交换区总量

   1044136 cached — 缓冲的交换区总量

### 1.11 Linux中，如何通过端口查进程，如何通过进程查端口？

**参考回答**

1. **linux下通过进程名查看其占用端口**: （1）先查看进程pid

   ```shell
   ps -ef | grep 进程名
   ```
   （2）通过pid查看占用端口

   ```shell
   netstat -nap | grep 进程pid
   ```
2. **linux通过端口查看进程**:

   ```shell
   netstat -nap | grep 端口号
   ```
### 1.12 请你说说ping命令？

**参考回答**

Linux ping命令用于检测主机。

**执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。**

**答案解析**

语法:

```shell
ping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]
```
参数说明:

```shell
-d 使用Socket的SO_DEBUG功能。
-c<完成次数> 设置完成要求回应的次数。
-f 极限检测。
-i<间隔秒数> 指定收发信息的间隔时间。
-I<网络界面> 使用指定的网络接口送出数据包。
-l<前置载入> 设置在送出要求信息之前，先行发出的数据包。
-n 只输出数值。
-p<范本样式> 设置填满数据包的范本样式。
-q 不显示指令执行过程，开头和结尾的相关信息除外。
-r 忽略普通的Routing Table，直接将数据包送到远端主机上。
-R 记录路由过程。
-s<数据包大小> 设置数据包的大小。
-t<存活数值> 设置存活数值TTL的大小。
-v 详细显示指令的执行过程。
```
实例:

```shell
检测是否与主机连通

# ping www.w3cschool.cc //ping主机
PING aries.m.alikunlun.com (114.80.174.110) 56(84) bytes of data.
64 bytes from 114.80.174.110: icmp_seq=1 ttl=64 time=0.025 ms
64 bytes from 114.80.174.110: icmp_seq=2 ttl=64 time=0.036 ms
64 bytes from 114.80.174.110: icmp_seq=3 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=4 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=5 ttl=64 time=0.028 ms
64 bytes from 114.80.174.110: icmp_seq=6 ttl=64 time=0.028 ms
64 bytes from 114.80.174.110: icmp_seq=7 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=8 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=9 ttl=64 time=0.036 ms
64 bytes from 114.80.174.110: icmp_seq=10 ttl=64 time=0.041 ms

--- aries.m.alikunlun.com ping statistics ---
10 packets transmitted, 30 received, 0% packet loss, time 29246ms
rtt min/avg/max/mdev = 0.021/0.035/0.078/0.011 ms

//需要手动终止Ctrl+C
指定接收包的次数

# ping -c 2 www.w3cschool.cc
PING aries.m.alikunlun.com (114.80.174.120) 56(84) bytes of data.
64 bytes from 114.80.174.120: icmp_seq=1 ttl=54 time=6.18 ms
64 bytes from 114.80.174.120: icmp_seq=2 ttl=54 time=15.4 ms

--- aries.m.alikunlun.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1016ms
rtt min/avg/max/mdev = 6.185/10.824/15.464/4.640 ms

//收到两次包后，自动退出
多参数使用

# ping -i 3 -s 1024 -t 255 g.cn //ping主机
PING g.cn (203.208.37.104) 1024(1052) bytes of data.
1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=0 ttl=243 time=62.5 ms
1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=1 ttl=243 time=63.9 ms
1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=2 ttl=243 time=61.9 ms

--- g.cn ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 6001ms
rtt min/avg/max/mdev = 61.959/62.843/63.984/0.894 ms, pipe 2
[root@linux ~]# 

//-i 3 发送周期为 3秒 -s 设置发送包的大小 -t 设置TTL值为 255
```

### 1.13 什么是协程？

**参考回答**

**协程**：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

**答案解析**

1. **线程与协程的区别:**

   （1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

   （2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

   （3）一个线程可以有多个协程。

2. **协程的优势:**

   （1）**协程调用跟切换比线程效率高**:协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。

   （2）**协程占用内存少**:执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。

   （3）**切换开销更少**:协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

### 1.14 为什么协程比线程切换的开销小？

**参考回答**

1. 协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的**切换非常快**，切换开销比线程更小。

2. 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。**避免了加锁解锁的开销。**


## 计网

### 1. OSI与TCP/IP 模型

OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408144411.jpeg)

七层网络体系结构各层的主要功能：

- 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统`DNS`， 支持万维网应用的`HTTP`协议，支持电子邮件的`SMTP`协议等。
- 表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。
- 会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。
- 运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议: 
  - `TCP`：提供面向连接的、可靠的数据传输服务;
  - `UDP`：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。
- 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括`IP`协议。
- 数据链路层：数据链路层通常简称为链路层。将网络层传下来的`IP`数据包组装成帧，并再相邻节点的链路上传送帧。
- 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。

### 2. 常见网络服务分层

应用层：`HTTP`、`DNS`、`FTP`、`SMTP`

传输层：`TCP `、`UDP`

网络层：`IP`、`ICMP `、路由器、防火墙

数据链路层：网卡、网桥、交换机

物理层：中继器、集线器

### 3. TCP三次握手

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327215643.png)

**三次握手过程：**

1. 客户端——发送带有`SYN`标志的数据包——服务端 **一次握手** 客户端进入`syn_sent`状态

2. 服务端——发送带有`SYN/ACK`标志的数据包——客户端  **二次握手** 服务端进入`syn_rcvd`

3. 客户端——发送带有`ACK`标志的数据包——服务端 **三次握手** 连接就进入`Established`状态

**为什么三次：**  主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力。

**为什么两次不行？**

1. 防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源。

2. **两次握手只能保证单向连接是畅通的。**（为了实现可靠数据传输， `TCP `协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。三次握手的过程即是通信双方 相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）。

### 4. 四次挥手过程：

1. 客户端——发送带有`FIN`标志的数据包——服务端，关闭与服务端的连接 ，客户端进入`FIN-WAIT-1`状态
2. 服务端收到这个 `FIN`，它发回⼀个 `ACK`，确认序号为收到的序号加`1`，服务端就进入了`CLOSE-WAIT`状态
3. 服务端——发送⼀个`FIN`数据包——客户端，关闭与客户端的连接，客户端就进入`FIN-WAIT-2`状态
4. 客户端收到这个 `FIN`，发回 `ACK `报⽂确认，并将确认序号设置为收到序号加`1`，客户端进入`TIME-WAIT`状态

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327215652.png)

**为什么四次：**因为需要确保客户端与服务端的数据能够完成传输。

**CLOSE-WAIT：** 这种状态的含义其实是表示在**等待关闭**。

**TIME-WAIT：** 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接。

### 5. 为什么连接的时候是三次握手，关闭的时候却是四次握手?

服务器在收到客户端的`FIN`报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回`ACK`报文段。

接下来可能会继续发送数据，在数据发送完后，服务器会向客户端发送`FIN`报文，表示数据已经发送完毕，请求关闭连接。服务器的`ACK`和`FIN`一般都会分开发送，从而导致多了一次，因此一共需要四次挥手。

### 6. 如何查看TIME-WAIT状态的链接数量？

```shell
netstat -an | grep TIME_WAIT | wc -l  //查看连接数等待time_wait状态连接数
```
### 7. 为什么会TIME-WAIT过多？解决方法是怎样的？

**可能原因：**高并发短连接的`TCP`服务器上，当服务器处理完请求后立刻按照主动正常关闭连接

**解决：**负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接

### 8. 半连接，洪泛攻击问题以及如何解决（syn_cookie）

在三次握手的过程中，服务器为了响应一个受到的`SYN`报文段，会分配并初始化连接变量和缓存，然后服务器发送一个`SYN/ACK`报文段进行响应，并等待客户端的`ACK`报文段。如果客户不发送`ACK`来完成该三次握手的第三步，最终(通常在一分多钟之后)服务器将终止该半开连接并回收资源。这种`TCP`连接管理协议的特性就会有这样一个漏洞，攻击者发送大量的`TCP SYN`报文段，而不完成第三次握手的步骤。随着这种`SYN`报文段的不断到来，服务器不断为这些半开连接分配资源，从而导致服务器连接资源被消耗殆尽。这种攻击就是`SYN`泛供攻击。

为了应对这种攻击，现在有一种**有效的防御系统，称为SYN cookie**。SYN cookie的工作方式如下：

1. 当服务器接收到一个`SYN`报文段时，它并不知道该报文段是来自一个合法的用户，还是这种SYN洪泛攻击的一部分。因为服务器不会为该报文段生成一个半开的连接。相反，服务器生成一个初始`TCP`序列号，该序列号是SYN报文段的源IP地址和目的IP地址，源端口号和目的端口号以及仅有服务器知道的秘密数的复杂函数(散列函数)。这种精心制作的初始序列号称为为“cookie”。服务器则发送具有这种特殊初始序号的`SYN/ACK`报文分组。服务器并不记忆该cookie或任何对应于SYN的其他状态信息。
2. 如果该客户是合法的，则它将返回一个`ACK`报文段。当服务器收到该`ACK`报文段，需要验证该ACK是与前面发送的某个`SYN`相对应。由于服务器并不维护有关`SYN`报文段的记忆，所以服务器通过使用`SYN/ACK`报文段中的源和目的IP地址与端口号以及秘密数运行相同的散列函数。如果这个函数的结果(cookie值)加1和在客户的ACK报文段中的确认值相同的话，那么服务器就会认为该`ACK`对应于较早的`SYN`报文段，因此它是合法的。服务器则会生成一个套接字的全开连接。
3. 另一方面，如果客户没有返回一个`ACK`报文段，说明之前的`SYN`报文段是洪泛攻击的一部分，但是它并没有对服务器产生危害，因为服务器没有为它分配任何资源。

### 9. 为什么客户端的TIME-WAIT状态必须等待2MSL ?

主要有两个原因:

1. **为了保证客户端发送的最后一个ACK报文段能够达到服务器。**
   这个`ACK`报文段可能丢失，因而使处在`LAST-ACK`状态的服务器收不到确认。服务器会超时重传`FIN+ACK`报文段，客户端就能在2MSL时间内收到这个重传的`FIN+ACK`报文段，接着客户端重传一次确认，重启计时器。最好，客户端和服务器都正常进入到`CLOSED`状态。如果客户端在`TIME-WAIT`状态不等待一段时间，而是再发送完`ACK`报文后立即释放连接，那么就无法收到服务器重传的`FIN+ACK`报文段，因而也不会再发送一次确认报文。这样，服务器就无法按照正常步骤进入`CLOSED`状态。
2. **防止已失效的连接请求报文段出现在本连接中。**
   客户端在发送完最后一个`ACK`确认报文段后，再经过时间`2MSL`，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 10. 4g切换wifi会发生什么

当移动设备的网络从`4G`切换到`WiFi`时，意味着IP地址变化了，那么必须要断开连接，然后重新连接，而建立连接的过程包含TCP三次握手和TLS四次挥手的时延，以及TCP慢启动的减速过程，给用户的感觉就是突然网络卡顿了一下，所以说，迁移的成本是很高的。

**http3是怎么解决连接迁移**

`HTTP3`中`QUIC`协议没有用四元组的方式来"绑定”连接，而是通过连接ID来标记通信的两个端点，客户端和服务器可以各自选择一组ID来标记自己，因此即使移动设备的网络变化后，导致IP地址变化了，只要仍保有上下文信息(比如连接ID、TLS 密钥等)，就可以"无缝"地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

### 11. TCP与UDP区别及场景

| 类型 | 特点                       | 性能                   | 应用过场景       | 首部字节 |
| ---- | -------------------------- | ---------------------- | ---------------- | -------- |
| TCP  | 面向连接、可靠、字节流     | 传输效率慢、所需资源多 | 文件、邮件传输   | 20-60    |
| UDP  | 无连接、不可靠、数据报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8个字节  |

**基于TCP的协议：**`HTTP`、`FTP`、`SMTP`

**基于UDP的协议：** `RIP`、`DNS`、`SNMP`

### 12. TCP滑动窗口，拥塞控制

**TCP通过：**应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输。

**拥塞控制目的：**为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载。

**拥塞控制过程：**TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。

### 13. TCP粘包原因和解决方法

**TCP粘包是指**：发送方发送的若干包数据到接收方接收时粘成一包

**发送方原因：**

TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：

收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题

**接收方原因：**

TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

- **传输层的UDP协议不会发生粘包或者拆包问题**

  `UDP`是基于报文发送的，在`UDP`首部采用了16bit来指示`UDP`数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

- **传输层的TCP协议会发生粘包或者拆包问题**

  原因有以下两点：

  1. `TCP`是基于字节流的，虽然应用层和传输层之间的数据交互是大小不等的数据块，但是`TCP`把这些数据块仅仅看成一连串无结构的字节流，没有边界；
  2. 在`TCP`的首部没有表示数据长度的字段，基于上面两点，在使用`TCP`传输数据时，才有粘包或者拆包现象发生的可能。

**解决粘包问题：**解决问题的关键在于如何给每个数据包添加边界信息

最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：

- 发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- 包尾加上\r\n标记。`FTP`协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
- 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。

### 14. TCP、UDP报文格式

**TCP报文格式：**

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408101002.png)



**源端口号和目的端口号**：

用于寻找发端和收端应用进程。这两个值加上`IP`首部源端IP地址和目的端`IP`地址唯一确定一个`TCP`连接。

**序号字段：**

序号用来标识从`TCP`发端向`TCP`收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 `TCP`用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。

当建立一个新的连接时，`SYN`标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为`SYN`标志消耗了一个序号

**确认序号**：

既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有`ACK`标志为 1时确认序号字段才有效。发送`ACK`无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。

**首都长度**：

首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此TCP最多有6 0字节的首部。然而，没有任选字段，正常的长度是 20字节。

**标志字段**：在`TCP`首部中有 6个标志比特，它们中的多个可同时被设置为1。

- `URG`紧急指针（u rgent pointer）有效
- `ACK`确认序号有效。
- `PSH`接收方应该尽快将这个报文段交给应用层。
- `RST`重建连接。
- `SYN`同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。
- `FIN`发端完成发送任务。

**窗口大小**：

`TCP`的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。

**检验和：**

检验和覆盖了整个的 `TCP`报文段：`TCP`首部和`TCP`数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

**紧急指针**：

只有当`URG`标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。`TCP`的紧急方式是发送端向另一端发送紧急数据的一种方式。

**选项**：

最常见的可选字段是最长报文大小，又称为 `MSS `(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 `SYN`标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

**UDP报文格式：**

![图片](https://mmbiz.qpic.cn/mmbiz_png/DWQ5ap0dyHP9wH6dWPia9Lna1rITnndXj1mOPAbjgvicRWDqAwosyhn44R5plROezpLBF3c3Q0ZsTokN8IpOiaNAQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**端口号**：

用来表示发送和接受进程。由于 `IP`层已经把I P数据报分配给`TCP`或 `UDP`（根据I P首部中协议字段值），因此`TCP`端口号由`TCP`来查看，而 `UDP`端口号由 `UDP`来查看。`TCP`端口号与 `UDP`端口号是相互独立的。

**长度**：

 `UDP`长度字段指的是 `UDP`首部和 `UDP`数据的字节长度。该字段的最小值为 8字节（发送一份0字节的 `UDP`数据报是 O K）。

**检验和**：

 `UDP`检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现 `UDP`首部和数据在发送端到接收端之间发生的任何改动。

**IP报文格式：**普通的IP首部长为20个字节，除非含有可选项字段。

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327215715.webp)

**4位版本**：目前协议版本号是4，因此IP有时也称作IPV4.

**4位首部长度**：

首部长度指的是首部占`32bit`字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。

**服务类型（TOS）**：

服务类型字段包括一个`3bit`的优先权字段（现在已经被忽略），`4bit`的TOS子字段和1bit未用位必须置0。`4bit`的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。

**总长度**：

总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长`16bit`，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。

**标识字段**：

标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。

**生存时间**：

TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 `ICMP `报文通知源主机。

**首部检验和**：

首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。`ICMP`、`IGMP`、`UDP`和`TCP`在它们各自的首部中均含有同时覆盖首部和数据检验和码。

**以太网报文格式：**

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327215724.webp)

**目的地址和源地址：** 是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。

**数据：**

以太网帧中的数据长度规定最小46 字节，最大1500 字节，`ARP `和`RARP `数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（`MTU`），不同的网络类型有不同的`MTU`，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的`MTU`了，则需要对数据包进行分片fragmentation）。`ifconfig `命令的输出中也有“MTU:1500”。**注意**，`MTU`个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。

### 15. TCP协议如何保证可靠传输机制？

**TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。**

- **检验和：**通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃`TCP`段，重新发送。
- **序列号/确认应答：**
  序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。
  `TCP`传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送`ACK`报文,这个`ACK`报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
- **超时重传：**超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。
- **滑动窗口：**滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。
- **拥塞控制：**在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证`TCP`可靠性的同时，提高性能。
- **流量控制：**如果主机A一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与`TCP`协议报头中的窗口大小有关。

### 16. TCP的滑动窗口?

在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。`TCP`协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。
为了避免这种情况，`TCP`引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327223444.png)

从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。

滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。

可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前`TCP`发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。

### 17. 详细讲一下拥塞控制? 为何要进行拥塞控制？

A在给B传输数据, A却没有收到B反馈的`TCP`,A就认为B发送的数据包丢失了..进而会重新传输这个丢失的数据包。然而实际情况有可能此时有太多主机正在使用信道资源，导致**网络拥塞**了。重传数据浪费了资源，所以要进行拥塞控制。发送发不知道一次发多少数据合适，所以设置一个拥塞窗口。

**TCP拥塞控制原理是通过：慢启动、拥塞避免、快重传、快启动** 

发送方维持一个叫做拥塞窗口cwnd (congestion window)的状态变量。当cwndssthresh时， 改用拥塞避免算法。

- **慢开始:** 不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。
- **拥塞避免:** 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。
- **快重传: **我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定:发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
- **快恢复: **主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半(为了预防网络发生拥塞)，但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。

### 18. TCP拥塞控制4种算法

- **基于丢包的拥塞控制**：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如`Reno`、`Cubic`等。
- **基于时延的拥塞控制**：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如`Vegas`、`FastTCP`等。
- **基于链路容量的拥塞控制**：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如`BBR`。
- **基于学习的拥塞控制**：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如`Remy`。

### HTTP协议

#### 1. HTTP协议1.0  1.1  2.0

**HTTP1.0：**服务器处理完成后立即断开`TCP`连接（**无连接**），服务器不跟踪每个客户端也不记录过去的请求（**无状态**）

**HTTP1.1：** `KeepAlived` **长连接**避免了连接建立和释放的开销；通过`Content-Length`来判断当前请求数据是否已经全部接受（**有状态**）

**HTTP2.0：**引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以**并行**的传输数据。

---

**无状态的好坏** 

- **无状态的好处**，因为服务器不会去记忆 `HTTP `的状态，所以不需要额外的资源来记录状态信息，这能减 轻服务器的负担，能够把更多的 `CPU `和内存用来对外提供服务。 
- **无状态的坏处**，既然服务器没有记忆能力，这样每操作一次，都要验证信息。例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

解决无状态的问题，解法方案有很多种，其中比较简单的方式用 `Cookie `和`Session`技术。

#### 2. HTTP1.0和HTTP1.1的主要区别如下：

1. **缓存处理**：1.1添加更多的缓存控制策略（如：`Entity tag`，`If-Match`）
2. **网络连接的优化**：1.1支持断点续传
3. **错误状态码的增多**：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
4. **Host头处理**：支持`Host`头域，不在以`IP`为请求方标志
5. **长连接**：减少了建立和关闭连接的消耗和延迟。

#### 3. HTTP1.1和HTTP2.0的主要区别：

1. **新的传输格式**：2.0使用二进制格式，1.0依然使用基于文本格式
2. **多路复用**：连接共享，不同的`request`可以使用同一个连接传输（最后根据每个`request`上的id号组合成正常的请求）
3. **header压缩**：由于1.X中`header`带有大量的信息，并且得重复传输，2.0使用`encoder`来减少需要传输的`hearder`大小
4. **服务端推送**：同`google`的`SPDUY`（1.0的一种升级）一样

#### 4. HTTP和 HTTPS的区别：

1. 最重要的区别就是**安全性**，`HTTP `明文传输，不对数据进行加密安全性较差。`HTTPS `(HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好。
2. **证书**：使用 `HTTPS `协议需要申请 `CA `证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：`Symantec`、`Comodo ` 、`DigiCert `和 `GlobalSign `等。
3. **响应速度**：`HTTP `页面响应速度比 `HTTPS `快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。
4. **加密**：`HTTP`协议运行在`TCP`（三次握手）之上，所有传输的内容都是明文，`HTTPS`运行在`SSL/TLS`之上，`SSL/TLS`运行在`TCP`之上，所有传输的内容都经过加密的。
5. **端口不同**：`HTTPS `和 `HTTP `使用的是完全不同的连接方式，用的端口也不一样，前者是 `443`，后者是 `80`。

| HTTP                             | HTTPS                                  |
| -------------------------------- | -------------------------------------- |
| 默认端口80                       | 默认端口443                            |
| 明文传输、数据未加密、安全性较差 | 传输协议ssl加密、安全性较好            |
| 响应速度快，消耗资源少           | 响应速度慢、消耗资源多，需要用到CA证书 |

#### 5. HTTPS 的缺点：

1. 在相同网络环境中，`HTTPS `相比 `HTTP `无论是响应时间还是耗电量都有大幅度上升。
2. `HTTPS `的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。
3. 在现有的证书机制下，中间人攻击依然有可能发生。
4. `HTTPS `需要更多的服务器资源，也会导致成本的升高。

#### 6. HTTPS链接建立的过程：

1. 首先客户端先给服务器发送一个请求
2. 服务器发送一个`SSL`证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥
3. 客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密
4. 服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端
5. 随后客户端和服务端就使用对称密钥进行信息传输

---

![HTTPS 加密、解密、验证及数据传输过程](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327225658.png)

加密流程按图中的序号分为:

1. 客户端请求`HTTPS`网址，然后连接到`server`的443端口(`HTTPS`默认端口，类似于`HTTP`的80端口)。
2. 采用`HTTPS`协议的服务器必须要有一套数字`CA `(Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带-一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一一个随机码`KEY`,并使用公钥A将其加密。
5. 客户端把加密后的随机码`KEY`发送给服务器，作为后面对称加密的密钥。
6. 服务器在收到随机码`KEY`之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
7. 服务器使用密钥(随机码`KEY`)对数据进行对称加密并发送给客户端，客户端使用相同的密钥(随机码`KEY`)解密数据。
8. 双方使用对称加密愉快地传输所有数据。

#### 7. HTTP常见响应状态码

`100`：Continue 一一 继续。客户端应继续其请求。

`200`：OK 一一 请求成功。一 般用于GET与POST请求。

`301`：Moved Permanently 一一 永久重定向。

`302`：Found 一一 暂时重定向。

`400`：Bad Request 一一 客户端请求的语法错误，服务器无法理解。请求没有包含host头

`403`：Forbideen 一一 服务器理解请求客户端的请求，但是拒绝执行此请求。禁止客户访问该资源

`404`：Not Found 一一 服务器无法根据客户端的请求找到资源（网页）。资源未找到

`500`：Internal Server Error 一一 服务器内部错误，无法完成请求。

`502`：Bad Gateway 一一 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。

#### 8. 状态码301和302的区别是什么?

`301`为永久重定向，`302`为临时重定向

**共同点**: `301`和`302`状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取(用户看到的效果就是他输入的地址A瞬间变成了另一个地址B)。

**不同点**: `301`表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址;`302`表示旧地址A的资源还在(仍然可以访问)，这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO中`302`好于`301`。

补充，重定向原因:

1. 网站调整(如改变网页目录结构);
2. 网页被移到一个新地址;
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

#### 9. 对称加密算法与非对称加密算法的区别

**对称加密算法：**

双方持有相同的密钥，且加密速度快，典型对称加密算法：`DES`、`AES`

**非对称加密算法：**

密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：`AES`、`DSA`

#### 10. HTTP请求方法：

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 像特定资源发送请求，查询数据，并返回实体                     |
| POST    | 向指定资源提交数据进行处理，可能会导致新的资源建立、已有的资源修改 |
| PUT     | 向服务器上传新的内容                                         |
| HEAD    | 类似GET请求，返回的响应式中没有具体内容，用于获取报头        |
| DELETE  | 请求服务器删除指定标识的资源                                 |
| OPTIONS | 可以原来向服务器发送请求来测试服务器的功能性                 |
| TRACE   | 回显服务器收到的请求，用于测试和诊断                         |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器       |

#### 11. Get和Post请求区别

|          | GET                                                        | POST                                                  |
| -------- | ---------------------------------------------------------- | ----------------------------------------------------- |
| HTTP规范 | GET用于信息获取                                            | 修改服务器上的资源的请求                              |
| 可见性   | 数据在URL中对所有人可见                                    | 数据不会显示在URL中                                   |
| 安全性   | 与post相比，get的安全性较差，因为所发送的数据是URL的一部分 | 安全，因为参数不会被保存在浏览器历史或web服务器日志中 |
| 数据长度 | 受限制，最长2kb                                            | 无限制                                                |
| 编码类型 | application/x-www-form-urlencoded                          | multipart/form-data                                   |
| 缓存     | 能被缓存                                                   | 不能被缓存                                            |

#### 12. GET 和 POST 方法都是安全和幂等的吗？

先说明下安全和幂等的概念： 

- 在 `DSA`协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。

`POST `因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据 就会创建多个资源，所以**不是幂等**的。

#### 13. 重定向和转发区别

**转发是服务器行为,重定向是客户端行为**

**重定向：redirect：**

地址栏发生变化

重定向可以访问其他站点（服务器）的资源

重定向是两次请求。不能使用request对象来共享数据

**转发：forward：**

转发地址栏路径不变

转发只能访问当前服务器下的资源

转发是一次请求，可以使用`request`对象共享数据

#### 14. Cookie和Session区别

**Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式**，但两者有所区别：

`Cookie `数据保存在客户端(浏览器端)，`Session `数据保存在服务器端。

`cookie`不是很安全，别人可以分析存放在本地的`Cookie`并进行欺骗,考虑到安全应当使用session。

`Cookie `⼀般⽤来保存⽤户信息，`Session `的主要作⽤就是通过服务端记录⽤户的状态

#### 15. 浏览器输入URL过程

**过程：**`DNS`解析、`TCP`连接、发送`HTTP`请求、服务器处理请求并返回`HTTP`报文、浏览器渲染、结束

1. 域名解析(域名www.baidu.com变为IP地址)。
   浏览器搜索自己的`DNS`缓存(维护一张域名与IP的对应表);
   1. 若没有，则搜索操作系统的`DNS`缓存(维护一张域名与IP的对应表) ;
   2. 若没有，则搜索操作系统的hosts文件(维护一张域名与IP的对应表)。
   3. 若都没有，则找TCP/IP参数中设置的首选dns服务器，即本地`DNS`服务器(递归查询)，本地域名服务器查询自己的`DNS`缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。
2. 发起`TCP`的三次握手，建立`TCP`连接。浏览器会以一个随机端口(1024-65535) 向服务端的web程序80端口发起`TCP`的连接。
3. 建立`TCP`连接后发起HTTP请求。
4. 服务器响应`HTTP`请求，客户端得到`html`代码。服务器web应用程序收到`HTTP`请求后，就开始处理请求，处理之后就返回给浏览器`html`文件。
5. 浏览器解析`html`代码，并请求`html`中的资源。
6. 浏览器对页面进行渲染，并呈现给用户。

---

如何查看 TCP 的连接状态？ **TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。**

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220401215515.png)

#### 16. DNS协议是TCP还是UDP?

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220330211131.png)

- `DNS`占用53号端口，同时使用`TCP`和`UDP`协议。那么`DNS`在什么情况下使用这两种协议？

  **DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。**

  - **DNS区域传输的时候使用TCP协议：**
    - 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用`TCP`而不是`UDP`，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
    - `TCP`是一种可靠连接，保证了数据的准确性。
  - **域名解析时使用UDP协议：**
    - 客户端向`DNS`服务器查询域名，一般返回的内容都不超过512字节，用`UDP`传输即可。不用经过`TCP`三次握手，这样`DNS`服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向`DNS`服务器查询的时候使用`TCP`，但事实上，很多`DNS`服务器进行配置的时候，仅支持`UDP`查询包。
  
  ![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408101037.png)
  
  ![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408101042.png)

#### 17. ARP协议如何找到对应IP地址和mac的映射的

简单地说，`ARP` 是借助 `ARP`  请求与 `ARP`  响应两种类型的包确定 `MAC` 地址的。

- 主机会通过广播发送 `ARP`  请求，这个包中包含了想要知道的  `MAC` 地址的主机 IP 地址。
- 当同个链路中的所有设备收到 `ARP`  请求时，会去拆开 `ARP`  请求包里的内容，如果 `ARP`  请求包中 的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 `ARP`  响应包返回 给主机。 

操作系统通常会把第一次通过 `ARP`  获取的  `MAC` 地址缓存起来，以便下次直接从缓存中找到对应 IP 地 址的  `MAC` 地址。不过， `MAC` 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220401224806.png)

#### 18. RARP 协议你知道是什么吗？

ARP 协议是已知 IP 地址求  `MAC` 地址，那 `RARP` 协议正好相反，它是已知  `MAC`地址求 IP 地址。例如 将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。 

通常这需要架设一台 `RARP` 服务器，在这个服务器上注册设备的  `MAC` 地址及其 IP 地址。然后再将 这个设备接入到网络，接着：

- 该设备会发送一条「我的  `MAC` 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。 
- `RARP` 服务器接到这个消息后返回「 `MAC`地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个 设备。

最后，设备就根据从 `RARP` 服务器所收到的应答信息设置自己的 IP 地址

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220401224906.png)



#### 19. 什么是DDos攻击?

`DDos`全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下:

1. 客户端向服务端发送请求链接数据包。
2. 服务端向客户端发送确认数据包。
3. 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

`DDos`则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。

`DDos`攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于`DDos`攻击，预防方法有:

- 减少SYN timeout时间。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。
- 限制同时打开的SYN半连接数目。

#### 20. 什么是XSS攻击?

XSS也称cross-sitescripting,跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有< script>标签的代码，导致恶意代码的执行。

预防措施有: 

- 前端：过滤。
- 后端：转义，比如go自带的处理器就具有转义功能。

#### 21. SQL注入是什么，如何避免SQL注入?
`SQL`注入就是在用户输入的字符串中加入`SQL`语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的`SQL`语句就会被数据库服务器误认为是正常的`SQL`语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

`SQL`注入的原理主要有以下4点：

1. 恶意拼接查询
2. 利用注释执行非法命令
3. 传入非法参数
4. 添加额外条件

避免`SQL`注入的一些方法：

1. 参数校验：在一些不该有特殊字符的参数中提前进行特殊字符校验即可。
2. 限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。
3. 提供参数化查询接口，不要直接使用原生`SQL`。
3. **SQL预编译**

​	在知道了`SQL`注入的原理之后，我们同样也了解到`MySQL`有预编译的功能，指的是在服务器启动时，`MySQL` Client把`SQL`语句的模板（变量采用占位符进行占位）发送给`MySQL`服务器，`MySQL`服务器对`SQL`语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给`MySQL`服务器，直接进行执行，节省了`SQL`查询时间，以及`MySQL`服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。

​	具体是怎样防止`SQL`注入的呢？实际上当将绑定的参数传到`MySQL`服务器，`MySQL`服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的JDBC就有预编译功能，不仅提升性能，而且防止`SQL`注入。

#### 22. 网络编程socket，客户端和服务端通信过程，分别调用了哪些函数，作用是什么

- 服务器端程序：
  1. 创建一个`socket`，用函数`socket()`
  2. 绑定IP地址、端口等信息到`socket`上，用函数`bind()`
  3. 设置允许的最大连接数，用函数`listen()`
  4. 接收客户端上来的连接，用函数`accept()`
  5. 收发数据，用函数`send()`和`recv()`，或者`read()`和`write()`
  6. 关闭网络连接

- 客户端程序：
  1. 创建一个`socket`，用函数`socket()`
  2. 设置要连接的对方的IP地址和端口等属性
  3. 连接服务器，用函数`connect()`
  4. 收发数据，用函数`send()`和`recv()`，或`read()`和`write()`
  5. 关闭网络连接

#### 23. 负载均衡算法有哪些?

nginx负载均衡的三种方式主要是**轮询模式、weight权重模式、ip_hash**。

当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。

1. **轮询模式（默认）**
   每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
   适合服务器配置相当，无状态且短平快的服务使用。也适用于图片服务器集群和纯静态页面服务器集群。

2. **weight权重模式**
   这种方式比较灵活，当后端服务器性能存在差异的时候，通过配置权重，可以让服务器的性能得到充分发挥，有效利用资源。weight和访问比率成正比，用于后端服务器性能不均的情况。权重越高，在被访问的概率越大

3. **ip_hash**
   上述weight权重模式方式存在一个问题，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。

   可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。每个请求按访问IP的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题。

---

**涉及到的linux命令**

- 查端口netstat -tunlp | grep 端口号
- 查进程 ps -aux | grep 进程号
- 查cpu top命令
- 查内存 free



### 什么是网络编程

- 网络编程的本质是多台计算机之间的数据交换。数据传递本身没有多大的难度，不就是把一个设备 中的数据发送给其他设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于请 求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络 编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连 接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应 连接，则需要一直启动。
- 例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。 连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一 些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是QQ、微信这类软件了。

#### 网络编程中两个主要的问题

1. 一个是如何准确的定位网络上一台或多台主机， 
2. 另一个就是找到主机后如何可靠高效的进行数据传输。

- 在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定 Internet上的一台主机。 
- 而TCP层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主 要对象，一般不需要关心IP层是如何处理数据的。
- 目前较为流行的网络编程模型是客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户 提出请求并予以响应。客户则在需要服务时向服务器提 出申请。服务器一般作为守护进程始终运 行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服 务端口，使后来的客户也 能及时得到服务。

### 网络协议是什么

在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格 式、是否需要发送一个应答信息。这些规则被称为网络协议。

#### 为什么要对网络协议分层

- 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 
- 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 
- 易于实现和维护。 
- 促进标准化工作。分开后，每层功能可以相对简单地被描述

![](https://gitee.com/nateshao/images/raw/master/img/20220104194210.png)

![](https://gitee.com/nateshao/images/raw/master/img/20220104194216.png)

TCP/IP参考模型 

TCP/IP四层协议（数据链路层、网络层、传输层、应用层）

1. **应用层** 应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网 络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。 
2.  **传输层** 建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数 据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细 节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定 的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。
3. **网络层** 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适 的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一 层就是我们经常说的IP协议层。IP协议是Internet的基础。 
4. **数据链路层** 通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现 这些规程或协议的 硬件 和软件加到物理线路，这样就构成了数据链路，

### TCP / UDP

#### 什么是TCP/IP和UDP

- TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成 对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢 失，没有重复，并且按顺序到达
- UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可 靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的 地，到达目的地的时间以及内容的正确性都是不能被保证的。

#### TCP与UDP区别：

- TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连 接传输的数据不会丢失，没有重复，并且按顺序到达； 
- UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；
-  TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；
-  UDP通信类似于学校广播，靠着广播播报直接进行通信。 TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
-  TCP是面向字节流的，UDP是面向报文的；
-  面向字节流是指发送数据时以字节为单位，一个数据 包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
-  TCP首部开销（20字节）比UDP首部开销（8字节）要大 UDP 的主机不需要维持复杂的连接状态表

#### TCP和UDP的应用场景

对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，实时直播，即使出现传输错误 也可以容忍；

其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情 况

#### 形容一下TCP和UDP

- TCP通信可看作打电话：

李三(拨了个号码)：喂，是王五吗？ 王五：哎，您谁啊？ 李三：我是李三，我想给你说点事儿， 你现在方便吗？ 王五：哦，我现在方便，你说吧。 甲：那我说了啊？ 乙：你说吧。 (连接建立 了，接下来就是说正事了…)

- UDP通信可看为学校里的广播：

 播音室：喂喂喂！全体操场集合

#### 运行在TCP 或UDP的应用层协议分析

- 运行在TCP协议上的协议：
  - HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
  - HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
  - FTP（File Transfer Protocol，文件传输协议），用于文件传输。
  - POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 
  - SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。 
  - TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网 络。 
  - SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

- 运行在UDP协议上的协议：
  - BOOTP（Boot Protocol，启动协议），应用于无盘设备。 
  - NTP（Network Time Protocol，网络时间协议），用于网络同步。 
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

- 运行在TCP和UDP协议上：
  - DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。 
  - ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议 上）。 
  - SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的 收集和网络管理。 
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 
  - ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。

#### 什么是ARP协议 (Address Resolution Protocol)？

- **ARP协议完成了IP地址与物理地址的映射。每一个主机都设有一个 ARP 高速缓存，里面有所在的 局域网上**的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机 时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这 个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包（在发送自己的 ARP 请求 时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主 机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一 个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再 进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。
- 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的 某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 剩下的工作就由下一个网络来做。

#### 从输入址到获得页面的过程?

**过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、**结束**

1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系 统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进 行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网 址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务 器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； 
2.  浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； 
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应 的视图返回给浏览器； 
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并 向服务器请求这些资源； 
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

### TCP的三次握手

####  什么是TCP的三次握手

在网络数据传输中，传输层协议TCP是要建立连接的可靠传输，TCP建立连接的过程，我们称为三 次握手。

![](https://gitee.com/nateshao/images/raw/master/img/20220104222206.png)



1. 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状 态； 
2. 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK 置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列 号，发送给客户端；进入SYN_RCVD状态； 
3. 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将 自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入 ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入 ESTABLISHED状态；完成三次握手，连接建立。

#### 用现实理解三次握手的具体细节

- 三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收机能正 常。

1. 第一次握手：客户什么都不能确认；服务器确认了对方发送正常 
2. 第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接 收正常，对方发送正常 
3. 第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发 送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。

#### 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什 么）？

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接 收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

####  如果第二次挥手时服务器的ACK没有送达客户端，会怎样？

客户端没有收到ACK确认，会重新发送FIN请求。

####  客户端TIME_WAIT状态的意义是什么？

第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的 ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就 会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。 MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的 最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则 结束TCP连接。

### Socket

#### 什么是Socket

- 网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编 程界面，一个Socket由一个IP地址和一个端口号唯一确定。
-  但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。 socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立 起连接将不会主动断掉的，但是有时候网络波动还是有可能的 
- Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，

#### socket属于网络的那个层面

![](https://gitee.com/nateshao/images/raw/master/img/20220104225037.png)

- Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简 单的接口就是全部，让Socket去组织数据，以符合指定的协议。

#### Socket通讯的过程

- 基于TCP：服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器 (connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务 器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次 交互结束。

- 基于UDP：UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不 太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出 更大的优势。我客户端只需要发送，服务端能不能接收的到我不管

#### TCP协议Socket代码示例：

先运行服务端，在运行客户端 ，

1. 服务端：

```java
package com.test.io;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
//TCP协议Socket使用BIO进行通行：服务端
public class BIOServer {
// 在main线程中执行下面这些代码
public static void main(String[] args) {
//1单线程服务
ServerSocket server = null;
Socket socket = null;
InputStream in = null;
OutputStream out = null;
try {
server = new ServerSocket(8000);
System.out.println("服务端启动成功，监听端口为8000，等待客户端连接...");
while (true){
socket = server.accept(); //等待客户端连接
System.out.println("客户连接成功，客户信息为：" +
socket.getRemoteSocketAddress());
in = socket.getInputStream();
byte[] buffer = new byte[1024];
int len = 0;
//读取客户端的数据
while ((len = in.read(buffer)) > 0) {
System.out.println(new String(buffer, 0, len));
}
//向客户端写数据
out = socket.getOutputStream();
out.write("hello!".getBytes());
}
} catch (IOException e) {
e.printStackTrace();
}
}
}
```
1. 客户端：

```java
package com.test.io;
import java.io.IOException;
import java.io.OutputStream;
import java.net.Socket;
import java.util.Scanner;
//TCP协议Socket：客户端
public class Client01 {
public static void main(String[] args) throws IOException {
//创建套接字对象socket并封装ip与port
Socket socket = new Socket("127.0.0.1", 8000);
//根据创建的socket对象获得一个输出流
OutputStream outputStream = socket.getOutputStream();
//控制台输入以IO的形式发送到服务器
System.out.println("TCP连接成功 \n请输入：");
while(true){
byte[] car = new Scanner(System.in).nextLine().getBytes();
outputStream.write(car);
System.out.println("TCP协议的Socket发送成功");
//刷新缓冲区
outputStream.flush();
}
}
}
```
先运行服务端，在运行客户端 。测试结果发送成功：
#### 5 UDP协议Socket代码示例：
先运行服务端，在运行客户端

1. 服务端：

```java
//UDP协议Socket：服务端
public class Server1 {
public static void main(String[] args) {
try {
//DatagramSocket代表声明一个UDP协议的Socket
DatagramSocket socket = new DatagramSocket(8888);
//byte数组用于数据存储。
byte[] car = new byte[1024];
//DatagramPacket 类用来表示数据报包DatagramPacket
DatagramPacket packet = new DatagramPacket(car, car.length);
// //创建DatagramPacket的receive()方法来进行数据的接收,等待接收一个socket请
求后才执行后续操作；
System.out.println("等待UDP协议传输数据");
socket.receive(packet);
//packet.getLength返回将要发送或者接收的数据的长度。

int length = packet.getLength();
System.out.println("啥东西来了：" + new String(car, 0, length));
socket.close();
System.out.println("UDP协议Socket接受成功");
} catch (IOException e) {
e.printStackTrace();
}
}
}
```
1. 客户端：

  ```java
  //UDP协议Socket：客户端
  public class Client1 {
  public static void main(String[] args) {
  try {
  //DatagramSocket代表声明一个UDP协议的Socket
  DatagramSocket socket = new DatagramSocket(2468);
  //字符串存储人Byte数组
  byte[] car = "UDP协议的Socket请求，有可能失败哟".getBytes();
  //InetSocketAddress类主要作用是封装端口
  InetSocketAddress address = new InetSocketAddress("127.0.0.1", 8888);
  //DatagramPacket 类用来表示数据报包DatagramPacket
  DatagramPacket packet = new DatagramPacket(car, car.length,
  address);
  //send() 方法发送数据包。
  socket.send(packet);
  System.out.println("UDP协议的Socket发送成功");
  socket.close();
  } catch (Exception e) {
  e.printStackTrace();
  }
  }
  }
  ```
  先运行服务端，在运行客户端 。测试结果成功发送成功：


#### 6 Socket的常用类

![](https://gitee.com/nateshao/images/raw/master/img/20220104230638.png)

### 3. HTTP 

#### 什么是Http协议？

- Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文 本数据的规范，格式简称为“超文本传输协议” 
- Http协议属于应用层，及用户访问的第一层就是http

![](https://gitee.com/nateshao/images/raw/master/img/20220104230750.png)

#### Socket和http的区别和应用场景

- Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉； 
- Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。 
- http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等 待下次连接 
- http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等

#### 什么是http的请求体？

- HTTP请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器那数据，先要表明我要什 么吧
-  HTTP请求体由：请求行 、请求头、请求数据组成的， 
- **注意**：GIT请求是没有请求体的

#### HTTPS工作原理

- 一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一 致、证书的公钥（RSA加密）等进行校验； 
- 二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密 （RSA加密）； 
- 三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名； 
- 四、发送给服务端，此时只有服务端（RSA私钥）能解密。 
- 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。

#### 一次完整的HTTP请求所经历几个步骤? 

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

1. 建立TCP连接 怎么建立连接的，看上面的三次捂手
2. Web浏览器向Web服务器发送请求行 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。 
3. Web浏览器发送请求头 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送 了一空白行来通知服务器，它已经结束了该头信息的发送。
4. Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议 的版本号和应答状态码。 
5. Web服务器发送应答头 类别 描述 1xx： 指示信息–表示请求已接收，正在处理 2xx： 成功–表示请求已被成功接收、理解、接受 3xx： 重定向–要完成请求必须进行更进一步的操作 4xx： 客户端错误–请求有语法错误或请求无法实现 5xx： 服务器端错误–服务器未能实现合法的请求 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及 被请求的文档。
6. Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它 就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

7. Web服务器关闭TCP连接

#### 常用HTTP状态码是怎么分类的，有哪些常见的状态码？

- HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误 等。 

- 状态码的类别：

1xx： 指示信息–表示请求已接收，正在处理 

2xx： 成功–表示请求已被成功接收、理解、接受 

3xx： 重定向–要完成请求必须进行更进一步的操作 

4xx： 客户端错误–请求有语法错误或请求无法实现 

5xx： 服务器端错误–服务器未能实现合法的请求

#### http版本的对比

- HTTP1.0版本的特性：
  - 早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。 
  - HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记 录过去的请求（无状态）。

- HTTP1.1版本新特性
  - 默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直 保持连接，可以发送多次HTTP请求 
  - 管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 
  - 断点续传原理
- HTTP2.0版本的特性
  - 二进制分帧（采用二进制格式的编码将其封装） 
  - 首部压缩（设置了专门的首部压缩设计的HPACK算法。） 
  - 流量控制（设置了接收某个数据流的多少字节一些流量控制） 
  - 多路复用（可以在共享TCP链接的基础上同时发送请求和响应） 
  - 请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能） 
  - 服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无 需客户端明确的请求。（重大更新））

#### 什么是对称加密与非对称加密

- 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问 题，即如何安全地将密钥发给对方； 
- 而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知 道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行 解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加 密比起来，非常的慢

#### cookie和session对于HTTP有什么用？

HTTP协议本身是无法判断用户身份。所以需要cookie或者session

#### 什么是cookie

cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信 息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器

#### 什么是session

- session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。 
- 服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向 服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出 会话中存储的信息，然后确定会话的身份信息。

#### cookie与session区别

1. cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高 
2. 单个cookie保存的数据不能超过4K，session无此限制 
3. session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应 当使用cookie。



## 面试问题
### 外包公司能不能去

外包合同和正式合同的区别:

1. 外包合同不是和本单位签订的。所以福利可能差一些。
2. 签的时间比较短，稳定性差。
3. 外包的优势，就业门槛低

适合转行，失业解决温饱问题的。

### 你如何看待加班？

1. 回答hr，你可以接受加班，表达一下你的意愿
2. 告诉hr你的工作效率非常高，可以避免不必要的加班。最后追问，公司加班的原因。

正确回答：

1. 如果出现加班，我首先会考虑是不是我的原因导致的，如果是的话，我会尽量加快提高工作效率，减少加班情况的发生。
2. 如果是项目比较急，加班，我也会接受加班的。
3. 但是我不是为了加班而加班，为了表现自己多努力工作而加班。我更希望提高自己的工作效率，合理安排自己的加班时间，这样可以协调工作和生活。
4. 如果公司有需要我是可以加班，但是呢，我会尽量在周一在周五之内完成自己的工作。周六日好好学习充电以备下周更高效的工作。
5. 追问hr：那么加班严重到什么程度，一般是为了什么而加班。



### 面试问题｜被录用后如何开展工作？

1. 我会按照领导的指示和需求，了解工作情况，其次的话，我会制作一个工作计划表，然后开展工作
2. 注重工作态度和学习能力

### 面试问题｜你从上份工作中学到了什么？

1. 学会开发的流程，这样一来，让我的工作更加工业化和职业化
2. 在工作上，我学会了如何从项目中分析问题和解决问题
3. 工作之外，我还会学习和充电

### 面试问题 ｜你希望通过这份工作获得什么？满分话术分享

对于我来说，我从事的工作还是比较适合我的，我从事的工作可以充分发挥我的专长，这样的话可以带给我一种满足感，同时，我希望这一份工作具有挑战性，这样的话可以促使我提升自己

### 面试问题 ｜谈谈你失败的一次经历？满分话术分享

hr的目的：想知道你遇到挫折之后你的承受能力有多强，你的学习能力有多强，收获了什么，下一次遇到什么问题，你应该如何去做

我：举例子：。。。。。

最后，我有时候认为失败比成功更重要，失败可以让我积累一定的经验和财富，这样的话，以后遇到同样的事情，我就不会再犯同样的错误了

### 面试问题 ｜你有没有参加其他公司面试？

hr的动机：

1. 判断求职者是否有明确的职业规划，而不是今天投这一行,明天找另外一行
2. 根据求职者面试情况，给求职者定薪资

话术：

1. 在投递简历之前，我已经对业内几家有口碑的公司进行了背调，并且结合我的职业规划进行筛选和投递，来您公司之前我已经去面试过其他家岗位，并且收到几家offer  。但是呢，从今天的面试来看，我觉得贵公司的企业文化及实力非常符合我的职业发展，并且我的工作履历和贵公司的岗位职责描述是相符的，所以我也真诚希望贵公司可以考虑我(不要说其他公司的细节，大忌)
2. 再面试之前我做了很多准备，并且通过这一次面试，我对贵公司有了一个了解和认识。觉得和我的求职意向还是满符合的。我希望贵公司可以给我一个机会，让我为贵公司做出一些贡献。贵公司是我参加面试这么多





### 薪资技巧

薪资：

1. 面试阶段不要提薪酬，等公司确定要你之后再谈；不要狮子大张口

2. 不要工资造假 

3. 谈钱不可耻，不卑不亢的提出薪资要求

4. 不要自爆（比如：重发展机会，不在乎工资）可以表达，本人很欣赏公司，也很开心能加入，对于薪酬也是一个重要的考虑纬度，然后与人资展开具体沟通（喷血，我都是这么说的![](https://i0.hdslb.com/bfs/emote/485a7e0c01c2d70707daae53bee4a9e2e31ef1ed.png@100w_100h.webp))

5. 不要过早亮出底牌，报出具体金额，应先给到方向性的回复，争取让对方先报数。

   - 比如：相较于现有的工资水平，有一定合理比例的涨幅，也想了解一下公司对我offer的看法；具体询问公司的工资构成。如果对方还是不说数字的话，报出去的工资要比底线高10-20%。
   - 能否先问一下公司的薪酬结构。比如基础薪资和绩效奖金的构成，绩效奖金的发放标准，公司有没有年终奖，项目奖金，公司有没有期权，五险一金的缴纳方式，公司有没有期权，公司上班时间，周末上班的计薪方式。
   - 一定要争取对方先报数。 比如hr和我们介绍公司的薪酬体系，你现在是什么样的想法呢。这时候你可以说：我希望总包上，相较于上一份工作一定有合理比例的涨幅，也想听听看公司给我目前聊下给我offer提议。这时候，有两种情况：
     - hr给你一个具体的数字。那你就给这个数字具体一个反馈，如果符合预期，就愉快的接受，如果不符合，就说，可能这距离距离我的预期还有一定的差距，看你能否给到xxx呢。or我这边的期望是不低于xxx
     - hr继续追问，你预计的涨幅是多少呢。你期望的薪资数字是怎么样的呢。这时候会回答，比自己底线高10%-20%的数字

   - 拿现有的去argue。
     - 说你上一份工作中拿到额外的奖励，升职加薪等
     - 说目前拿到的offer是多少，具体哪一个公司不说了。比如xxxx行业的公司给我offer是多少。
     - 说你工作上，经验上的优势。比如，这个岗位，你有非常成功的经验，能够快速上手；这个岗位所要求的技术栈，你已经非常熟练的运用了。

6. 说出自己的优势的论据

7. 我最近刚换工作，薪资方面还比较满意。
   分享几点我的经历：
   1、根据岗位对标信息，认为自己绝对有信心胜任此岗位的，绝不松口，绝不给对方压价的余地，如果对方使用话术提问一些比较难刻薄的问题，那么可以拒不作答或者反问，只要别吵起来，都没有问题，HR的职责是花小钱招大能，最终决定权一般都在用人单位手中不在HR手中。
   2、不要让HR知道你只面试了这一家或者圈子很小的几家公司，因为这几家公司有可能中高层互通有无，对你的信息和情况掌握得十分清楚，甚至直接电联你直属上司，非常非常被动。面试的时候HR掌握你的信息越多，越不利于你谈判。甚至可以用跨多个行业的应聘资历反过来给HR施加压力。
   3、面试过程中回答问题所表达的高度和视角要高于应聘岗位，给用人单位一种：“卧槽！这是个宝才！这下捡到鬼了！”这种感觉，HR一般还是要听用人单位的意见，如果用人单位说这个人一定要拿下，那么HR是压不住你的薪资的。
   4、不要给自己画条条框框，比如：看别人跳槽升1级比较多，升2级的寥寥无几。就抱着我肯定也只能升1级的想法，是完全没有道理的。只要招聘的岗位能给你实现想法的平台，能给你展现才华的舞台，就勇敢去追！有底气有信心就去搏一搏，便是失败了，也明了了自身的不足与差距在哪里。
   我面试过程中，升了两级，涨了一次工资，省了差不多3年时间：
   P1：HR找到我，问我有没有意向加入A+1岗位（我当前处于A岗位），我表示完全没有兴趣，没有谈的必要，于是他说那么A+2的岗位有没有兴趣，我表示吸引力一般般，但可以接受面试。
   P2：第一轮面试通过，面谈结果定岗A+3，薪资方便我表示低于底线X-4就不必谈了。于是第一轮薪资报价是X-2，进入第二轮面试（当对于目前年薪X，因为绩效优占比较大，所以跳槽有一定的下浮是正常的）
   P3：第二轮面试通过，面谈结果定岗A+3，并且表示薪资X-2已经是A+3岗位封顶水平。我表示没有谈的必要了，此offer的“岗位+薪资综合水平”对我完全没有吸引力。
   P4：HR上报审批意见，最终定岗A+4，薪资X+3+期权（处于A+4岗位中上水平）。

8. 关于不要给自己画条条框框这一点我举个例子，我室友和我是同岗位，他的薪资比我还高6个。可以讲，他跳槽之后，+2职级的情况下，没有哪家公司能给出他当前水平的薪资。他陷入了“不跳槽要命，跳槽就亏钱”的情境之中。他就是给自己画了一个“我跳槽只能升2级”的框框里，现在他新面试的岗位比原先高3级，对方公司明确表示，你这点薪资要求完全没有问题，属于该要钱的时候要少了的典型。
   还有就是涨薪幅度的问题，不要受到30%、50%这种统计数字的束缚，这些数字只能代表大多数或者平均数，不跨行涨300%的，跨行涨500%的这种人虽然少，但不是没有！

9. 我个人的想法是，一般来说选**offer钱多 事少 离家近** 至少占一个。但对于应届生，你是否能学到东西才是最重要的。这里的学到东西说的不是hr许诺给你的个人成长培训资源之类的，而是会不会为你以后的跳槽提高身价。职场无非就是个工作能力和人情世故，薪资福利该问问该谈谈，千万不要不好意思，不然折磨的只会是自己。





💡💡先说下楼主本人背景：双非硕士，无具体实习经验，但项目经验比较丰富，在校也有相关的获奖情况
💈12月1号当天收到补录通过的通知，然后前天就到了和HR谈薪的环节。（偷偷说个小秘密，原来校招生也是有谈薪的余地的）
·
这个环节可谓精彩，鹅厂的HR也真的是专业🎏
谈薪流程如下：
💎- HR：同学，你期望的薪资是多少呢？（第一个坑：千万别先说）

- 我：我已经通过您们的面试，相信贵司是一个珍惜人才的公司，已经有一个合理的薪酬给到我，您直接跟我说就好。（不入坑）
💎- HR：好的，同学你的整体面试还不错，我们这边给出了一个SP的评价，请问同学你这边还有其它公司的offer吗？（第二个坑：慎重说）
- 我：谢谢您们的认可，目前的话我是有几个offer在手的，但具体还没有确定接受哪个，还正在考虑中。（模糊回答）
💎- HR：那目前你这边已经接了哪些offer呢，以及对应的薪酬是如何的呢？（第三个坑：看情况砍价）
- 我：目前的话主要是字节、顺丰等头部企业，薪酬其实每一家都不一样，这个很难统一说。（继续打太极拳）
💎- HR：好的，那我们这边目前给你的薪酬为：18k * 16 + 4k * 12 + 2w签字费 + 6w 股票 （主动说出薪酬） 总包40W+，还有一些诸如此类的福利等等
- 我：明白，这个薪酬相对来说还是比较ok的，和其它几家公司也差不多，我会好好考虑一下（压住激动的心，先压一压）
💎- HR：同学你这边是还有其它的考虑吗？你可以说一说（似乎上钩了）
- 我：对，因为我同学也进了咱们公司，但他的薪酬似乎比我好一些。（的确存在，但我同学是算法岗）
💎- HR：哦，那你自己有没有目标的薪酬呢？（这时候还不能急）
- 我：哈哈，我当然希望能够高一些，我想的是，基础工资那里希望是19k，签字费有3w，这个是我的想法（明确说出自己的希望）
💎- HR：明白，这样，我跟部门经理先说一下你的情况，然后再回电你。
（过程15分钟挂机，心里比较忐忑）
·
再次回电
💎- HR：同学，我这边已经沟通过了，你这边提的这个要求我们可以满足，前提是你需要尽快办理三方。
- 我：好的，谢谢您！
·
至此，不到10分钟的谈话，薪酬从18k * 16 + 4k * 12 + 2w签字费 + 6w 股票 = 41.6W 变成了 19k * 16 + 4k * 12 + 3w签字费 + 6w 股票 = 44.2W 
💡💡也就是相当于我10分钟赚了2.6W💡💡
·
☎️回顾整体面试给我的感觉就是，没有实习经历的确是我的硬伤，但我的项目经历是我的亮点，扬长避短，而且在面试中一定是表现冷静、沉着，不断通过交流展示自己的优点。
·
🔋好了，至此，鹅厂的谈薪已经结束，也正在准备三方了。面试过程还有很多有趣的东西没来得及分享，如果想了解的可以私戳我哦。谢谢大家的喜欢，祝大家也有满意的offer！！🧧🧧

