---
title: "Facial_meridians"
date: 2022-06-21T10:58:56+08:00
lastmod:
tags: []
categories: []
slug:
draft: true
---

## 导学面试
面试的核心，对于应聘者，是想方设法让面试官认可自己对职位有用的那些优点

用真诚的态度，有效地表达自己的能力和价值，建立相互的信任和认可。

在“知彼篇”里，让应聘者明白面试官眼里的人才素质模型，这相当于面试的“考点大纲”；介绍公司整个招聘过程，带你了解面试中考查能力的一般方法，让你更容易理解面试官的意图。
在“知己篇”里，带你搞清楚什么是工作中决定个人发展的关键因素，进而明确自己该不该换工作；另一方面，明确自己的职业愿景和规划。准备一份详历，挖掘自己的能力、价值和亮点，并浓缩成一份受青睐的简历给面试官看。
在“问答篇”里，和你分析面试中常见的几类问题，包括如何解释清楚一个技术点，如何体现你在项目中的重要性等等，帮助你回答得更加精准到位。
在“贯通篇”里，重点分析几种能力：学习能力、精益能力、协作能力、管理和领导能力等等，这些能力都体现为解决问题的能力，目的是让你了解提高这些能力的关键因素，到详历中寻找合适的事例，全面精准地把你真实的能力水平展现给面试官。
在“综合篇”里，盘点面试官和应聘者的认知偏差，强调双向选择中，帮你明确该如何衡量新团队和新环境，如何处理和老东家的关系，以及从面试中学习，为长远的发展提供动力。

一个优秀的人，其职业发展的终极目标，是把自己变得更优秀。你，一定也曾经辉煌过，其实，你的内心从未停止过对优秀的追求。你可以看出来，我在这个专栏中所提到的理念和方法，并非某些面霸面经里讲的“粉饰性修复”，不是教你如何去“哄”“躲”“演”，我也根本不想做这事。“临时抱佛脚”地看这种面经，甚至连佛脚都不抱就去碰运气，是对面试的敷衍。

## 知己知彼
### 知彼
#### 公司想要什么样的人？

公司眼中的好员工：个人工作结果质量好，价值高、赋能别人做出成果

面试是建立信任的开端，信任形成得越快越牢固，越有利于合作，因此面试双方都应该在不违背诚信的原则下有效沟通，互相了解，形成互信。

![img](https://static001.geekbang.org/resource/image/21/52/21955ad163ebef124b5db877be37ea52.png?wh=587*603)

面试官希望，你库存的经验技能，与职位的要求匹配度越高越好，也就是所谓的“对口”。

关于潜力，面试官可以通过考察应聘者的学习、创新和精益能力来做判断。“学习”指的是从不会到会，掌握一项技能的过程；“创新”是针对特定场景创造新事物的技能；“精益”是把事情越做越好的技能。

如果你承认潜力，那么就说明你有成长型思维，有成长思维的人认为：技能是可以通过努力获得的，关键是要保持好奇心，平时爱思考、总结、尝试，愿意接受挑战，不怕错误和失败。因此，要在潜力上为自己的面试效果加分，你就需要注意如何在言谈及简历描述中体现这些特质。

最下层是“动机”，指的是做事情的内心目标、意愿和态度。很多事情我们不是没有能力做，而是被不想做、觉得困难等心理因素扯了后腿，这就是动机不足。因此，要想做成事儿，动机的作用非常重要。而且，“动机”决定着应聘者的潜力发挥、技能习得和经验形成，也就是说，动机决定着素质模型上面的三层。动机的表现是什么呢？日本著名的企业家稻盛和夫在《干法》一书中，按动机区分了三类员工：

自燃型，也就是自我驱动的员工，他们做事动机强烈，目标明确，明白任务的意义，甚至自己寻找有意义的事，满怀激情地投入，往往超出自己的工作范围，去推动进展，取得成果，然后又奔向下一个目标。“鸡血”满满有木有？
点燃型，这类员工需要一定的激励，需要他人帮助才能找到目标和意义，一旦“激活”就能像自燃型员工一样奋力工作。
阻燃型，这类员工当一天和尚撞一天钟，给多少钱，干多少活，按工作的最低标准和最后完成时间递交任务，跟同事合作差，不乐意分享，自我保护。

人格品质，比如诚实守信、认真负责、坚毅勇敢等。这些从底层决定我们的做事动机。

职业价值观，就是在工作中区分是非、明确轻重的观念。比如，有人喜欢轻松安稳的工作，有人喜欢冒险和竞争；有人喜欢照章办事，有人则喜欢灵活自主；有人追求个人利益，有人则喜欢分享和帮助他人。小提示：不同的企业文化，对员工的职业价值观要求也不同。面试官希望你的职业价值观和团队文化一致，即所谓的“味道”相投。大家有相同的信条，才可以合作共事。

职业性格，是长久的思维和行为习惯，受环境影响固化成的心态“定势”，比如内向、感性等。面试官希望性格多样，但要与职位性质相契合。举个例子，内向的人做销售恐怕不适合。（MBTI 是一个主流的职业性格模型，这里就不细讲了。）不过，一个团队包含多种职位，职业性格最好多样化，这样大家工作在一起才能碰撞出火花，进而互相补充，共同进步。

而对于校园招聘，因为学生普遍缺乏经验和技能，对其动机和潜力等基本素质的考查就成了重点。

素质模型中的经验、技能和潜能，不仅仅是面试前要总结准备的，而是要在决定换工作时，甚至在制定职业规划时，更甚至在工作的每一天都要积累、总结、提高的；动机方面，不是要你在面试中“见风使舵”，靠套路和粉饰去迎合和敷衍。

#### 面试过程
我们今天看一个比较典型的、完整的招聘全过程：从出现用人需求到需求被满足，大体会经历确定职位空缺、收集和筛选简历、面试、签 Offer、试用转正等阶段。


**确定职位空缺，提前预知工作的难度：**

- 填补空缺的职位，因为有前任的工作样板，工作细节清楚、职责明确，确定性高，老板对这个职位的期待也很明确，双方都可以清楚地评价人和工作的匹配度。而且，应聘者完全可以复用前任的经验轻松上手，但是因为有前任的对比，需要超越前任的表现才能获得好评。
- 新增的职位，工作难度和职责细节往往还不清晰，在团队中还没有和其他职位形成稳定的职责接口，甚至老板对这个职位的期待可能还说不清，新人做起工作来，需要很多的探索和磨合，较难上手。但是因为没有对比，你比较容易校正老板的期待，也容易获得好评。

小提示：搞清楚应聘职位是补坑，还是新增，有利于你进一步评估工作难度和胜任度。

招聘的员工从合同类型上看至少有三种：正式员工、外派员工、实习生。

正式员工是本公司的人，享有本公司的福利待遇，公司会关心你的发展机会和稳定性，使你更有归属感；这也是正式员工和外派员工的一个主要而且重要的区别。外派员工由外包公司派遣到本公司工作，不是本公司的人，自然不享受本公司的福利待遇，虽然工作内容和正式员工相仿，但是你的职业发展不由本公司负责，因而你的稳定性和归属感一定会受影响。目前外派模式的采用规模越来越小了。实习生，一般待遇要比正式员工低，但同时招聘门槛也低，是为没有实际工作经验的学生准备的，主要看潜力和工作态度。

出现招聘需求以后，一般由部门经理根据工作需要，确定职责和要求，然后向上级提交招聘申请（hiring ticket），审批下来之后，部门经理就可以发布职位说明（Job Description，简称 JD），着手面试了。不过，如果职位紧急，在拿到审批之前，部门经理就会开始四处找人面试，这样审批一到手，就可以马上发 Offer 了。

所以，这里要特别提示一点：小提示：如果招聘申请没有通过审批，或者审批被冻结，即使你得到了口头 Offer，也可能无法入职。只有签了正式 Offer 才算稳妥。

 **了解简历收集渠道和筛选过程，有的放矢**

内推、公司网站、社交平台、招聘网站、线下招聘会、猎头公司

投递简历，要采用尽量可靠的方式。这里其实有很多细节需要注意，我举几个真实的反例：简历邮件标题只有俩字：简历。（至少要写清应聘职位、姓名）
简历附件打开是乱码。 （请尽量用 PDF 格式，保证跨平台阅读的一致性）
简历邮件被自动归入垃圾邮件。（请用一些稍正式的个人邮箱地址投递简历）

小提示：投递简历之后，随时可能有公司电话预约面试或者做电话初筛。建议你做好心理准备，接到电话不要紧张，这是你第一次获得了与面试官交互的机会，应当尽最大可能展现自己的能力，给对方留下一个好印象。

我曾经打电话给一位在民企工作多年的应聘者，想了解一下他的英语水平。结果呢，他拒绝用英语沟通，理由是“怕说不好”。经过我一再鼓励，他终于说了几句，虽然不流利，但是也能表达清意思。虽然他最终没被录用，但并非折在英语上。**所以不要给自己设限，你认为的，并不一定面试官也这么认为。**


**面试，是谁决定了你的去留**

面试官可能来源于三类角色：HR、部门大牛、部门经理。HR 离部门业务较远，不熟悉职位的要求细节，因此会重点考查人才的基本面：动机（价值观、职业性格）和潜力，往往不会出现在考查其专业技能的面试中；而部门大牛最清楚工作细节，关注应聘者在这些细节上的经验和技能，也就是解决问题的能力；部门经理则要两方面兼顾，既要保证此人能胜任岗位（或者通过学习能够很快胜任），还要验证他的动机和潜力，确保他能认可公司文化，融入团队，保持稳定长远的发展。

所以，部门经理对自己的职位人选负责。在评价应聘者的面试表现时，他会听取 HR 和部门大牛的反馈，结合自己的体会，做出以下几种决定：录用。不录用：不适合本职位（不排除推荐给其他匹配的职位）。候选，留待与后面的人作比较：不是非常理想的人选，需要再看看后面有没有更合适的（如果时间允许的话）。再面试一次：没看清，拿不准。这往往是因为面试中应聘者没能充分表达自己的能力所致。

最终，高级经理可能做最后一轮面试，以便确定你确实是符合团队需要的人员。在这一轮对话中，你会得到更多关于公司和团队的信息，这时我建议你多问多了解，以便能够更好地判断这个职位是否满足你的预期，是否符合你的职业发展规划，甚至为你判断是否要加入这个公司提供信息支持。

**签 Offer，定薪水**

这个阶段不能闭口不提薪水，但是要太高了也会被认为不够“自知”。

那么谁决定给你多少薪水呢？是部门经理。部门经理，即要负责业务指标，又要关注员工激励和绩效考核，还要兼顾团队公平，而薪水是其中非常重要的影响因素，因此他要对此项负责，而 HR 负责提供公司级别的薪水标准范围，如果部门经理的薪水诉求超过了薪水范围，会被交给上一管理层审批。

**入职试用期，你还不能放松警惕**

假如你在试用期内的工作表现不能满足职位要求，公司在有证据证明的情况下，是可以辞退你的。当然，这段时间，公司也会尽力帮你增加新技能、熟悉新工作、融入新团队。你呢？需要尽快地承担起工作职责，用能力说话，持续建立和加强同团队的信任，推动个人和团队的发展。



#### 面试官的面试逻辑
经验、技能、潜力和动机

而面试官的目的，就是找到适合职位要求的候选人，而职位要求，最终体现在素质模型的四层当中。

所以，应聘者需要有意识地寻找机会，向面试官展示自己的能力，而不要仅以面试官的提问为纲。


考查能力的方法：观察、提问，并选择最有效的问题

![img](https://static001.geekbang.org/resource/image/31/cf/31b6be3cb98a05a35661e979cd8a1bcf.png?wh=966*635)

面试官的问题之间是有逻辑关系的，并非孤立和没来由的


### 知己

#### 该不该换工作
工作满意度指标：物质保障水平、精神满足水平、能力发展通道

#### 喜欢或擅长的工作，你该选哪一个

![img](https://static001.geekbang.org/resource/image/62/9f/627838bd9071852fd6e8f4d7e702f09f.png?wh=528*691)

![img](https://static001.geekbang.org/resource/image/bd/df/bd13e199f20b4f4f7edde3bab6d56ddf.png?wh=911*610)


#### 职业规划
职业规划的五个步骤：
构建心理愿景：确定你想要什么。
选择或调整能力方向： 比如具体选择哪种技术、哪种业务（行业）、什么领域的管理等等。
发展：你怎么一步一步发展这些能力？
选择或调整职业：有了这些能力素质资源之后，你要继续当前职业，还是要换个职业？
反馈：工作中获得的心理满意度，和心理愿景对比，反馈到能力、发展、职业的活动中，对其调整，或者调整心理愿景本身。

![img](https://static001.geekbang.org/resource/image/06/74/06a35d5459eca5724bd53bb9b9fafb74.png?wh=679*545)

我非常欣赏 IBM 一位超级大牛的名言：“要让职业发展追着你走，而不是你追着职业发展走。” 其含义是说，你如果能力不到位，只追求职位升级是徒劳的，所以你不能追着职业发展走；你要先提高自己的能力，然后在公平开放的公司文化中，自然就会有合适的职位和机会让你升级，这就是职业发展追着你走。


**程序员后来都去干啥了？**
有人跳到别的大厂发展成总监，有人去互联网创业做了 CEO，有人进了银行，有人改行做了餐饮，有人搞起自媒体成了大 V……

但是大多数人，都像我一样，还在程序的世界里摸爬滚打。以我们团队为例，十多年来，从十几个人，发展成 200 多人的全球跨职能团队。其中，我们的领队成了全球商务系统的总负责人，汽车制造专业的程序员成了资深架构师，测试出身的小姑娘成了业务大拿，还有更多的人，一直坚守在技术岗位上，成了所在领域的专家，推动着客户成功，带领着团队成长。

![img](https://static001.geekbang.org/resource/image/cc/1b/cc422898cc0c1493e75761c1bf35e61b.png?wh=594*618)

技术角色：关注技术和逻辑实现，可发展为“T”型人才，需要有对技术的钻研和敏感性。业务角色：关注用户和价值，有同理心。管理角色：关注过程质量，有条理。


**简历美化**

很多面试官都承认，如果看到一份中意的简历，会用“发现优点”的眼光在面试中对待这位应聘者；相反，如果看到一份差强人意的简历，会用“排除缺点”的眼光在面试中考查应聘者。简历给面试官造成的“第一印象”起着非常重要的作用。

![img](https://static001.geekbang.org/resource/image/cd/97/cd31612a4e3a2de3c229f101b79e5497.png?wh=913*469)

形式上，要简洁大方、重点突出，从视觉上，引导对方关注你最想表达的部分


内容不真实、内容不客观，掺杂主观臆断、页面太花哨、笔误、内容导致歧义或者误解、职业发展不衔接、换工作太频繁

**没什么亮点怎么办**
转换角度找价值：这是要回答“我为谁、解决了什么问题”。

量化结果找提高：“我在哪方面做了什么提高”。

复盘过程找创新：“我的做法有什么与众不同”。

回顾挑战找动机：我解决了什么挑战”。你对工作的热情，源于动机。把你的价值观和追求，融合到经历中，总结成亮点，也非常不错。

每个故事可以选择下面的结构来组织：开头，“有段经历，正好遇到了这个问题……”。（讲清问题背景）发展，“一般的做法是做不到的，因为……”。（讲问题的复杂性和挑战）高潮，“我一开始用到……后来……”。（讲解决方案的形成过程）结局，“成果是……”。（讲结果、影响、意义）




**面试紧张怎么办**
从生物学的角度来看，紧张是我们作为哺乳动物几百万年进化而来的一种本能。

在《高效演讲》里，彼得·迈尔斯提到过：人类大脑里有两个微小的、杏仁状的神经组织，叫“杏仁体”。作为最古老的大脑神经系统的组成部分，“杏仁体”仅有一项功能，不是助人思考，而是让人保持活跃。“杏仁体”从不休息，它们是人类早期预警系统的一部分。它们不断扫描危险事物，一旦判断为不利的情况，就向你的身体发出警告。

面试中陌生的环境、陌生的面试官、陌生的问题、挑战性的气氛、一时的语塞，或者不理想的回答，都会被认为不利的信号。此时杏仁体会启动自我保护模式，增强运动器官的能量供给，帮助你战斗或逃跑，而其他器官仅仅处于“基本维持”状态，负责思考和表达的大脑前额叶，也缺少了能量供给。那一刻，你的大脑一片空白，思维开始迟钝下来，你不得不处于“杏仁体劫持”状态，“停运”了思考器官。



面试其实和相亲差不多，面试看似权力在面试官，其实是双向选择。

求职者面试的紧张程度与其对职位的期待程度成正比，与其对自身的自信程度成反比。

面试前怎样缓解紧张？
调整期待


![img](https://static001.geekbang.org/resource/image/ba/7f/ba8df55f22171b2975d5a1a12a822d7f.png?wh=879*622)

提高能力：提高能力，包括两方面，一是通过面试的能力，二是职位要求的能力。


充分准备：减少面试主题和问答的不确定性、减少环境影响的不确定性、自己的状态保持最佳

如果你发现声音颤抖、忘词等情况，可以向面试官坦白地说，对不起，有些紧张，这样更能赢得面试官的理解和耐心。而且，有时候把紧张说出来了，就不太紧张了。

**时刻谨记，你的目的是向面试官尽可能真实地展示你的工作和思考，把他看重的那部分给出足够的细节，赢得认可。适度的紧张，反而有利于你保持思维活跃。**
面试只不过是一只开关，而能打开这个开关的，是你的能力


**面试小困惑**
社招、校招：一流学校毕业的学生，毕竟能大概率说明他曾经多年接受较高程度的思维训练和校风熏陶。

如果他的问题没有问透，你可以主动地探寻他想知道什么，“坦白”你的经验范围和能力级别；如果他有什么失礼的言辞举止，你需要保持礼貌和内心平和。

**面试官关注的，不是你用最糟的一面，做出来的东西有多好，而关注的是，你用最好的一面，做出来的东西有多糟。**所以，你在面试中表现出积极的一面，隐藏不积极的一面，不能叫不真诚，只要你工作时也保持你面试时的表现，就够了。

## 问答篇

### 自我介绍
首先，自我介绍是塑造第一印象的重要部分

其次，自我介绍是暖场

再次，自我介绍是你第一次有机会掌握话语的主动权


经历概括、经验和技能总结、表达风格和气场、简历内容之外的信息

### 怎样展示你在项目中的重要性

面试官的问题往往是这样开始问的：“看你做的项目不少，请介绍一个你认为最能表现你能力的项目吧。”“XX 项目看起来挺复杂的，能否详细介绍下复杂在哪里，你的贡献又是什么？”“XX 项目你做的时间很长，说说你都有哪些收获吧。”

应聘者的回答，常常有两个主要毛病。**做事浮于表面**：做的工作不少，都想提一下，没有详略，不能在某个价值点上讲出深度。这种表现会让面试官觉得，你仅仅在浅层或者在外围干活儿，而很少或者没有深入解决过核心的项目问题。**能力单薄**：细讲某一项目环节时，你只专注在项目问题的某一部分上，不能以完整的视角复盘解决方案，只具有任务级别的工作能力。比如，只清楚自己的模块实现，至于上下游过来的数据含义都不了解，也不知道自己写的代码是服务于什么业务问题。这会让面试官觉得，虽然你能编写代码，但没有协作意识，你很大程度上依赖别人完成分析调研，甚至连测试数据都要给你准备好，你才能完成任务级别的工作，这样表现出来的能力很单一。

首先，前提是你要全面深入地了解项目，尤其是你负责的部分。

……


### 被面试官问住了怎么办

完全不知道问的是什么、部分知道问的是什么、想不起来了


如果你实在没有办法了，我这里倒是真有一个“话术”（只作为救命用，不要轻易使用）：“您这个问题，我一时想不到答案。不过，我好奇的是，什么样的场景用到这项 XX 呢？” 这样，在面试官回答使用场景的时候，你就有更多时间和线索来思考答案了。



### 向面试官提问

面试官之所以让应聘者提问，一是表达对应聘者的尊重，显示平等的对话关系；二是通过你的关注点，了解你的需求和动机，进而判断当下的职位是否适合你；三是通过审视你提的问题，考查你的思考广度和深度，以及经验能力。

面试中，面试官让你主导对话的机会不多，第一次是自我介绍，第二次就是让你提问的环节。这是你获取信息和表现主动权的一次好机会，你可以借此：获取关于团队、职位或者项目的一手信息，这是你在网上或者从朋友同学那里拿不到的。这些信息对你判断当前职位的匹配度非常重要。表现自己的思考方式、认知水平和经验能力，以此提升面试效果，锦上添花。

应聘者的问题，最好是与职位相关的，并且是应聘者、面试官都关注的信息。


下面一组是可能让面试官产生不适的问题（减分问题）：**有关薪酬待遇的细节**。如果面试官没有主动开始这个话题，最好不要自己问起。因为现在还不到时候。我们在“26 | 怎么谈薪水比较好”一文中会详谈。**有关涨薪升职的条件**。同上。**我面试表现得怎么样**。这样提问说明你关心面试结果，但对面试官没有价值，除非他非常 nice，想指点你一二。**面试官您在这个团队里是什么角色**。这个问题听起来没有上下文，如果是讨好面试官，没有必要；如果觉得这位面试官可能是将来合作的同事，现在了解情况也为时尚早，入职以后会有人给你介绍的。

一般情况下，下面的问题是比较安全的：
有关团队的现状和发展前景，要解决的挑战和问题等

有关项目或产品的业务、价值、技术栈、流程工具等。

有关职位的工作对象、工作环境、方法工具等。

该职位的考核标准、职位期望：这类问题表明你能换位思考，从老板的角度去理解他的期望；同时也说明你是个注重实干的人，你希望了解职位的考核标准，以及所需要的各种能力；你也是个干劲十足的人，你做事结果导向，有目标感。你可以通过这个问题，确认这个职位的需求和自己的能力是否契合，以及你是否真正有意愿做这个工作。所以，在评判对方的回答时，需要重点关注老板对这个职位的期待和 KPI 的考核标准是否合理，你有没有能力达到这些标准，这些对你的成长是否有利。


如何让提问为面试加分：
尽量展示正向的态度和观点，适当表示负面的担忧和建议

问合适的人。你要区分面试官的角色，是 HR，还是技术负责人，还是团队负责人。不同的角色，承担的任务不同，对职位的理解也不同。如果是技术问题，就要问技术负责人；团队发展前景的问题，就要问团队负责人。

问题带着自己的洞见。比如，“对于全球团队来说，由于时区不同，往往加班沟通。您团队有这种情况么？讨教一下有没有好办法解决一下。”这个问题的确说出了跨时区团队的一个痛点，反映了提出者对全球团队的沟通有经验和思考，并且积极寻求解决方案。

问题面不要太宽泛，让人抓不住你的关注点


问题要简洁精准，不要有恭维或者冗余。


### 谈薪水

好 Offer 的条件，就成了对于大局不错的那个职位，尽量把薪水谈高点。这是应聘者谈薪水的原则。

理智的雇主，不会一味压低你的薪水，而是考虑公司的薪酬体系和市场水平，兼顾“成就感”“成长性”，给出符合应聘者价值（不是应聘者期待），带有激励作用的薪水。这是雇主定薪水的原则。


**薪水的构成**
我们来了解一下基本知识，即员工薪资的基本构成及其注意事项，主要分为四部分。
月薪和年薪。注意，不少公司的年薪大于 12 个月薪。

年终奖：取决于公司的业绩和你的绩效。某些互联网公司，给杰出员工发半年工资做年终奖，但有的员工却一点都拿不到，目的就是按绩效激励或淘汰员工，显示了强烈的竞争文化。

股票、期权。上市公司都有股票，中高级的职位，公司可能会按照你的级别相应地配股，并且员工购买公司股票会享受内部价。一些创业公司，因为没有太多的现金或者股票，为了激励员工，提出了期权的做法，一旦公司 IPO，期权变现，你很可能就财务自由了，这也是创业公司最吸引人的地方，但是风险也很高。

福利，条目比较多，各公司差异较大，包括社会保险（五险一金）、带薪年假、各种补贴（如交通费、餐补、通信补，甚至宿舍或者住房、租房补贴、买房贷款）等。注意，不要在面试中向面试官询问这些细碎的信息，可以在和 HR 谈 Offer 的时候询问。

以上部分，对于校园招聘的学生来说，基本是依靠面试结果定级，然后遵从公司统一的标准；对于社招，月薪是可以谈的；股票期权，是留给中高级职位的。



想发展为技术领导者的朋友，需要具备三方面的基本功：扎根技术，着眼业务，懂得管理。


## 贯通篇
怎样体现你的学习能力强？

我们进入“贯通篇”，主要讨论工作中几种重要的能力：
- 学习能力：你怎样把不会的事情做出来。
- 精益能力：你怎样把事情越做越好。
- 协作能力：你怎样配合大家一块把事情做好。
- 领导能力：你怎样带领大家互相配合把事情做好。解决问题的能力：更综合的能力，看你“成事”的能力有多大。

学习能力的表现：记、思、说、写、用

怎么体现你能把工作越做越好？

想不想精益、如何找到提高目标，以及如何提高。

一是精益的动机，这里最难的是允许别人说你不对，也就是成长型思维，你能做到“有则改之，无则加勉”。二是看你如何找到提高的点。我提到了四种方法：梳理产品问题、识别重复动作、识别等待、建立指标体系找到平庸点。三是看你如何做出提高，是通过打补丁，还是翻新？如何通过守破离的过程，引入新的方法？又是如何跃迁到“提高曲线”中的新阶梯的。

怎样体现你的协作能力强？

![img](https://static001.geekbang.org/resource/image/98/ac/98bcecf493f59ce371fa02ffb5dd18ac.png?wh=1440*1080)


怎么体现你的领导力？

领导的作用是：赋予团队目标和动力，指出更好的方向，以促成决策和推动进展。管理的作用是：使计划按照既定目标和流程执行。



我面试时，会用下面的问题来考查应聘者带人和影响人的能力：
- 你觉得培养或者指导别人时，哪方面最困难？
- 除了技能上给他们帮助，你还做过什么？
- 举个实例，你们团队在讨论中如何达成一致的？
- 你培养过别人的学习能力么？
- 如果我给你 Offer，你回去怎么做项目交接？（这个问题同时还在看其责任感。）


做事：前瞻、决策、推进和担当

T 型人才常被提及，结合到领导力上，在技术宽度和深度上有着不同的含义。宽度意味着你懂得多少技术，就是有多 “泛” ，这很大程度上决定了你能否带领团队着手解决问题；深度预示着你在哪些技术领域有所深耕，形成了自己独到的见解，也就是有多 “精” ，这决定了你能否带领团队把问题解决好。

技术最终是要解决业务问题的，所以好的技术领导者必须着眼业务。

技术领导者也要懂得如何调动资源、统筹规划，以及如何做分工协作等管理工作，这一是为了和管理人员紧密协作，二是很多技术工作可能需要自己主持，而远远不是一个人能简单完成的了。











解决问题的四个层次：只消除当前影响、彻底根除错误、变问题为机会，以及分享和教导他人。


## 综合篇

合同都签了，老板却不放你走，怎么办

新 Offer 谈妥了，甚至合同都签了，可是原来的老板却不放你走，这时候你该怎么办呢？

离职准备：降低关键性和不可替代性


**如何更好地体现你的能力？**


计算机编程，是一门技术活，那些把编程说成“搬砖”的人，很可能还没有为复杂的问题写出过高效的代码。一个好的程序员，应该有清晰的逻辑分析能力。我在面试时，除了考查应聘者的计算机基础（操作系统、编程语言、算法、网络等），还会检查他的逻辑能力：包括表达、思考。这有两种考查方法：一是看回答时的反应和思路，二是直接考查逻辑、算法或者智力题。

我在面试过程中其实不太在意对方回答的结果是否正确，而主要看他如何理解这个问题，采取了哪些有意义的尝试，在碰壁之后如何自我修正，逐渐接近合理的答案。这个过程，能反应出应聘者是否能锲而不舍地从多方面看问题，思考过程是否有条理、成体系，是否在用计算机思维思考问题。

说到计算机思维，我们来说一下如何培养计算机逻辑分析能力。还记得**离散数学**这门课吧？我认为，这门课奠定了计算机思维的基础。无论是计算机原理、编程算法，以及复杂业务逻辑实现，都离不开离散数学里讲的逻辑。我的感受是，它让我能够按计算机的思路去思考生活中的问题。

## 考官面对面

程序员择业时常碰到的几个疑惑：
外企 VS 民企

在我看来，对于大部人来说，先在大公司积累能力和视野，然后再跳到创业公司施展和锻炼，综合收益会可能会更高一些，这是我的建议。

走管理线 VS 走技术线
大多的事实证明，所谓的突出的工作能力，大多还是跟工作时间相关。

目前在中国，比如在工作 5~8 年以后，走纯技术线会比走纯管理线要来得更加稳健一些。

Cash 多 VS Option 多
一个企业，不可能因为一个人而去破坏整体的薪资架构，不可能因为招了一个人而导致最终走了一批人。




**我是如何面试程序员的？**

编程能力（必须），考查候选人能不能实际动手写程序，有没有基本的编程思维。
技术技能经验（必须），考查候选人之前参与过哪些实际项目，积累了哪些实际的技能经验。
软性能力（参考），考查候选人的沟通合作能力如何，心理成熟度如何，管理和领导力如何。


我们招聘程序员主要是来干活的（说白了就是写代码），不管你之前多么有经验、有资历，我一定要考查你的实际编程动手能力，同时也考查你的编程思维和代码质量。下面是我常用的两个面试题示例，一起来看一下。

问题 1：请写出求二叉树深度的算法（我会给出二叉树图例和节点的定义）。

这个问题表面上是看候选人对二叉树数据结构的掌握程度，实际上我考查的重点是递归思维。因为这个问题如果用递归算法解的话，5～6 行代码就可以解决，但是没有掌握递归思维的候选人一般会陷进去，要么搞半天也写不出来，要么花半天弄出一个很复杂的非递归算法。递归是一种很强大的编程武器，开发工作中一些看似非常复杂的技术问题（例如语言解析器、代码生成器等），都可以通过递归简单优雅地解决，而没有掌握递归的程序员则对此类问题常常束手无策。最后，不管候选人有没有解出这个问题，我都会仔细看看他写的代码，看看程序组织、变量命名，甚至标点符号等细节，这些不仅可以看出他的代码质量，同时可以看他是否细心认真（程序员的基本素质）。写程序如绣花，一针一线不容马虎。有些候选人能把算法思路讲出来，或者把伪代码写出来，但是实际代码写不好，说明他写实战代码的能力还是比较生疏。

问题 2：用一台普通电脑对一个 100G 的大文件（内部是字符串记录）进行排序，本题只需给出算法思路。

有些候选人数据结构掌握较好，上面第 1 题能够轻松过关，这个时候我会进一步用问题 2 来考查。问题 2 看上去规模很大，实际考查点也更多，但是核心考查的是分治思维（分而治之）：先将大问题分解为子问题，依次解决子问题，最后再合并子问题的解得到最终解。分治思维也很强大，能帮助我们解决很多表面上看起来很庞大的问题，例如一个中大规模系统的架构设计，甚至一个企业组织的架构设计都离不开分治思维。所以我用一个技术问题考查候选人是否具有分治思维，也就是看他是否具备解决大规模问题的思维基础。另外，这个问题同时也考查候选人对计算机组织（内外存）、文件操作、算法时空复杂度，以及各种排序算法（快排、归并等）的掌握程度，可以说是一举多得。


技术技能经验考查：

eg:
问题 3：介绍 Java 垃圾回收器的基本原理。

Java 语言最著名的特性就是自动垃圾回收（GC），很多生产上 Java 应用的问题（尤其是性能和内存问题），大都和 GC 有关。对于一个实战型的 Java 程序员来说，他在生产实践中一定会不止一次地遇到 GC 问题，所以对 GC 的理解程度，基本可以作为衡量一个 Java 程序员是否合格的门槛。按我的要求，他至少要把 Java 的分代垃圾回收机制讲清楚，否则差不多就可以判定“不合格”了。对于有些能讲清楚的候选人，我还会进一步延伸，让他解释什么是 GC Root，解释 Java 程序中有哪些可以作为 GC Root？甚至深入到如何直接操作堆外内存（offheap）的程度，进一步挖掘这个候选人的技术广度和深度。GC 的基本原理可以背诵，但是对于延伸的知识，如果没有拓展阅读或者实际动手实践过，你一般很难回答上来。




介绍 HashMap 的实现原理。

在我们日常编程的中，除了 List/Array 以外，用得最多的数据结构基本上就是 HashMap 了。另外，在大学时 HashMap 也是数据结构课程中必学的一种基础结构（课本中称为“散列表”）。因此，我基本上都会问 Java 的 HashMap 是如何实现的。按我的要求，候选人至少要把 HashMap 的内部数据结构实现和 get/put 算法给讲清楚，好一点的候选人要能把装载因子（load factor）和再哈希（rehashing）給讲清楚。这个问题可以考查三个点：

你是否真的在一线写代码，因为只要是写代码就一定绕不开 HashMap。对这么常用的数据结构，你是只停留在会用 API 的层面，还是说能够深入到内部算法实现？你在大学时有没有认真学习过数据结构，对这门核心计算机课程的态度如何？

对于能讲清楚 HashMap 基本实现的候选人，我还会进一步延伸，既可以向 Java 集合框架方向延伸，也可以向 Java 多线程方向延伸，其中涉及的内容很多，例如 HashTable、ConcurrentHashMap，甚至 TreeMap、ConcurrentSkipList 和 ThreadLocal 等。HashMap 的基本原理并不难，但是延伸的内容如果没有实际动手实践过，你一般很难回答上来。

除了 Core Java 之外，我也常常会问一些软件开发高级问题，例如和 Web 应用开发或者设计模式相关问题，下面同样给出两个例子。

问题 5：讲讲 Web 应用程序中的 Cookie 和 Session 是什么关系？

互联网应用大部分属于 Web 应用，开发人员或多或少会开发 Web 应用，而 Web 应用开发中一个很基本的问题是理解 Cookie 和 Session。有很多候选人简历中写精通 Web 开发，我就会问他们 Cookie 和 Session 是啥关系？实际上比较遗憾，真正能回答清楚的并不多。这个问题需要一些底层 HTTP 协议知识，理解 HTTP 是无状态协议，理解服务端和客户端会话存储机制。对于能回答清楚的，我会进一步扩展，Session 可以存储在哪些地方？客户端？服务器端？缓存？还有数据库？这些存储机制有何利弊？粘性会话（sticky session）是什么意思？如何实现粘性会话？分布式会话如何实现？诸如此类，全面考查候选人 Web 应用开发和分布式架构的实战经验。


问题 6：你在生产实践中使用过哪些设计模式，是什么场景下使用的？为什么使用？

随着一个工程师项目经验的积累，他会逐渐体会到软件设计中有很多模式性解决方案，也就是所谓的软件设计模式（Design Pattern）。

设计模式是软件研发行业几十年实践后提炼出来的一些通用的设计方案，是比数据结构更高一层的抽象，学习和应用设计模式可以帮助我们提升软件设计能力。我认为，工程师能力提升的一个标志，就是会开始注重设计模式的学习和积累，并且在实际项目中应用模式解决具体问题，以提升设计效率和质量。

因此，我在面试中一般也会询问设计模式相关的问题，比如问候选人在实际项目中应用过哪些设计模式（因为工厂和单例太常见，我一般会要求两者除外的答案）？什么场景下使用的？为什么要使用？对于有模式使用经验的候选人，我会要求横向比较几种相关模式，例如策略（strategy）和模板方法（template method）模式的差异，代理（proxy）和装饰（decorator）模式的差异等，进一步挖掘他对模式掌握的全面性。

总之，对这个问题的回答，可以看出侯选人项目经验是否充分，是否已经上升到模式性解决问题的高度。


问题 7：讲讲你最近开发的一个项目的业务背景和架构（或技术）。

这是一个开放性问题，考查目的并不在项目本身，而是看三点：

侯选人近期是否还在一线参与实际项目?侯选人的沟通表达能力，能否用简单的语言，给一个完全没有上下文的人，讲清楚自己开发（或者参与开发）的一个项目的业务背景和架构。该问题也是后面软性能力考查的重要参考。侯选人的技术热情，但凡有技术热情的侯选人，一讲到自己开发项目的架构或技术时，常常会两眼放光，滔滔不绝，充满激情。


软性能力考查:沟通能力考查 心理成熟度考查 管理能力考查 领导力考查


**知之为知之，不知为不知，面试过程中如果有的问题回答不上来，那就诚实讲不知道（或者自己没有相关经验”**

**整个面试重点考查侯选人的实战能力（说白了就是干活、产出的能力)，这个不太可能通过研究面试攻略搞突击来完成。**

**数据结构和算法、编程语言（Core Java）、编程思维（递归和分治）、Web 开发和软件设计模式等，是我考查程序员硬技能的重点，我想也是很多其他公司面试侯选人的重点。**

面试过程中，要注意面试官同时也在考查你的软性技能


面试经验谈之校招与社招:

### 校园招聘篇
每年的互联网公司技术类职位校园招聘，一般分为 3~4 个阶段。


第一阶段是实习转正式校招 Offer。在正常情况下，我们都会优先从当前实习的同学中挑选合适的人，直接发放正式校招 Offer。这个过程一般不再有面试环节，但可能会有述职和评审环节。在实习期导师的指导下，只要你的实习和述职表现符合预期，不出现重大失误，绝大概率是可以拿到正式 Offer 的。

第二类是提前批校招。顾名思义，提前批校招一般在每年正式校招开始前进行，多为暑期，时间区间是 7 月初到 8 月底。提前批校招一方面可以帮助公司更早锁定优秀的候选人，另一方面也可以帮助公司尽早判断今年的校招形势，及时调整招聘策略，同时还可以为秋季正式校招减轻招聘压力。

这部分候选人的简历一般靠师兄师姐内推，以及各业务部门在主要生源高校的 BBS 发布招聘帖等模式来收集。提前批校招的组织较为灵活，时间也并不固定，而且很多在暑期，所以需要候选人一方面提早联系师兄师姐内推，另外要多关注学校论坛等的招聘信息发布渠道。此外，如果收集的侯选人简历较少，校招公司会直接由目标职位所在部门的面试官自行组织面试；如果候选人简历较多，则会组织大规模集体面试，多为周末进行。

值得一提的是，提前批校招往往被很多业务团队重点关注。正式批校招是公司层面统一组织联合招聘并发放 Offer，并分配候选人给各业务部门。提前批校招，多为业务部门直接组织，所以主动性更强，而且简历多为内推和目标学校收集的方式，简历质量也往往较高。

对于候选人而言，不用因为自觉准备不足而轻易放弃提前批面试的机会，因为大多数候选人在正式校招前都没有多少面试经验，大家站在同一起跑线上。另外，一些岗位如果提前批招聘效果很好，那么在正式批校招中就不会设置很多 HC（招聘名额）了，**所以推荐大家尽可能优先参与各公司的提前批招聘。**

第三类就是正式批校招。大多数互联网公司的正式批校招为每年的 9 月上旬到 10 月下旬。秋招的职位多由公司 HR 统一安排，1 次笔试＋3 次面试，是百度的标准流程。这部分，相信你能获取到的信息非常多，我不过多赘述。

还有第四类，第二年春招。这个阶段一般适用于某些业务部门在秋招中没有招满的情况。每年都会有一些同学问我什么时候进行春招，但我只能说，如果把希望寄托于第二年春招，那就是在赌博碰运气。比如今年，互联网行业形势如此严峻，多数公司可能都不会安排大规模春招。所以，千万不要因为面试准备不充足或者“懒癌”犯了，押宝到第二年春招，面试准备还是越早越好。









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































自我介绍：面试官你好，我是来自哈工大深圳计算机系的23届本科生，学习成绩在








## 项目
身份认证与资源授权系统：

背景：服务自身的安全：为了保证服务的安全，需要禁止非法用户访问服务。这可以通过服务器层面和软件层面来解决。服务器层面可以通过物理隔离、网络隔离、防火墙等技术从底层保证服务的安全性，软件层面可以通过 HTTPS、用户认证等手段来加强服务的安全性。服务资源的安全：服务内有很多资源，为了避免非法访问，开发者要避免 UserA 访问到 UserB 的资源，也即需要对资源进行授权。通常，我们可以通过资源授权系统来对资源进行授权。

资源授权的流程：
1. 用户注册登陆
2. 用户创建密钥对secret
3. 用户创建授权策略
4. 请求 IAM 提供的授权接口，IAM 会根据用户的请求内容和授权策略来决定一个授权请求是否被允许。








## w

熟练掌握GO语言，了解map， struct， slice， channal，GMP模型调度器，gc垃圾回收等；
了解掌握gin，grom， grpc等框架使用；
熟悉计算机网络原理，了解TCP，UDP，HTTP，HTTPS等网络基础知识
熟悉使用MySQL数据库（InnoDB，MyISAM储存引擎）及数据库管理工具Navicat，熟悉InnnoDB储存引擎 的底层框架及MVCC多版本并发控制
了解Redis等非关系型数据库
掌握操作系统进程，虚拟内存，锁，调度算法，多核缓存一致性等概念
掌握IO复用并发模型，Linux系统命令及云服务器项目部署算法相关。
熟悉基础数据结构，掌握多种排序，动态规划，二叉树等算法
微服务相关：了解基础微服务架构，服务网格架构
团队相关：熟悉使用Git以及使用Github／Gitlab仓库进行协作开发

项目：
1. 抖音后端：gin 



1、重点介绍项目
2、如何学习go语言的
3、从搜索引擎输入数据到显示结果的流程
4、通过ip地址如何找到目标地址
5、进程线程区别
6、进程间通信方式 共享内存通信
7、https请求流程
7、http和tcp
8、主协程如何等待所有协程都完成
9、go中的uint无符号整型是否可以相减
10、go的数组和切片 如何更改对应值
11、map数据根据key进行排序
12、go的反射
13、如何定义接口返回类型
14、go的结构体能不能比较
15、GMP调度模型
16、linux常用命令
17、如何查看端口是否被占用
18、如何停止一个进程
19、查找文件中的特定字符
20、git命令 merge和rebase的区别


深信服实习一面：
写伪代码，实现增删改查

数据库索引

go GC，slice（包括场景题关于append的），map（场景题如下）：
```go
func demo(){
    var map = make(map[string]struct{})
    i := 0
    for i<100{
        if i%3==0{
            //执行查询操作
        }
        //执行插入操作
    }
} //记不太清了，代码差不多这样
```
问上述代码，会发生什么，应该考察扩容和新桶旧桶这一块的知识

go实现生产者消费者，开两个协程一个放随机数一个打印，还有额外特殊条件下两个协程都关闭。

docker 原理（终于有人问我了，面试官让我自由发挥，我就一口气稍微做了个总结，这里我的博客里有做总结:https://www.mrxuexi.com/archives/dockerhe-xin-ji-shu）；

gin 原理（讲了路由组、路由树，讲了一部分启动过程，如路由注册，少了一些，中间件实现也忘了补充了、了解还是不够）；

Redis 数据结构们（跳表、SDS 和 c string 的不同，ziplist、listpack 等）；

Mysql 数据库索引（索引有哪些、索引结构、索引失效情况乱搞）；

讲讲 B+ 树，以及和 B 树 的区别；

ACID是什么（A是怎么实现的）；

MySQL 日志；

TCP、UDP 连招（扩展到了 QUIC 协议，稍微讲了些）；

get 和 post 的区别；

讲讲 JWT；

HTTP code；

IO 多路复用；

进程、线程、协程；

goroutine 结构、map 结构和扩容等等、slice 结构和一些相关的问题；

gmp 调度（又是天花乱坠的说，一路补充到 channel 去了）；

应该还有些，忘记录音，记不太清了

算法：

感觉白刷了，目前为止运气不错，都是 EZ 题：

反转链表、合并有序数组；


深信服一面：
自我介绍、项目介绍；
docker 原理（终于有人问我了，面试官让我自由发挥，我就一口气稍微做了个总结，这里我的博客里有做总结）；
gin 原理（讲了路由组、路由树，讲了一部分启动过程，如路由注册，少了一些，中间件实现也忘了补充了、了解还是不够）；
Redis 数据结构们（跳表、SDS 和 c string 的不同，ziplist、listpack 等）；
Mysql 数据库索引（索引有哪些、索引结构、索引失效情况乱搞）；
讲讲 B+ 树，以及和 B 树 的区别；
ACID是什么（A是怎么实现的）；
MySQL 日志；
TCP、UDP 连招（扩展到了 QUIC 协议，稍微讲了些）；
get 和 post 的区别；
讲讲 JWT；
HTTP code；
IO 多路复用；
进程、线程、协程；
goroutine 结构、map 结构和扩容等等、slice 结构和一些相关的问题；
gmp 调度（又是天花乱坠的说，一路补充到 channel 去了）；
应该还有些，忘记录音，记不太清了
算法：
感觉白刷了，目前为止运气不错，都是 EZ 题：
反转链表、合并有序数组；
总结：
深信服面试官也很好，听我各种天花乱坠的发挥，其中例如 JWT 加密的部分讲错了，也会引导我说对，酷！
再次十分感谢面试官为我浪费时间！


深信服实习二面：
defer相关知识 的考察（读代码题）

树的子结构， leetcode 原题目，

Go 的 panic 和 recover 原理，panic 的是什么，；

panic 可以 被其他 recover 捕获吗；

map 的数据结构，及一些相关机制；

go map 线程安全吗；

说说线程安全的 map ，sync.map 和 cmap 的实现原理；

goroutine 的结构；

讲讲 gmp，分别讲讲 g m p（go 有什么特殊的办法防止 协程长期抢占一个 m）；

goroutine 的 开销小，为什么小；

channel 的结构，同步与异步，同步的实现原理；

Go 的 gc，三色标记、插入写屏障、删除写屏障、混合写屏障（场景复杂，还真不太好讲清楚，就做了个简单概括），提问这几个发展的区别，混合写屏障还有 STW 吗？

了解哪些锁；

流量控制、拥塞控制；滑动窗口有几个，讲讲接收端和发送端等等等等一系列追问，记不起来了；

https；

四次挥手；四次挥手为什么要 time_wait，为什么是2 MSL；

了解 websocket 吗？

tcp 和 http 分别在哪一层，讲讲 why http；

有些 rpc 的实现，使用的是私有协议，为什么不用 http？

二进制和基于文本协议的区别，他们底层不应该都是二进制吗？

操作系统的僵尸进程与孤儿进程；

僵尸进程过多会怎样；

Linux 的文件系统；

Linux 的内存管理；

Linux 的进程调度机制；

死锁、死锁的产生条件；

MySQL 的 隔离级别与实现机制；

mvvc，怎么实现；

MySQL 的锁怎么实现；

几个日志；

索引、结构、区别、为什么；

事务是怎么实现的；

框架和库的区别；

gin 框架讲讲；

了解哪些 Nosql（redis、mongodb，后者只是用过一下）；

docker 和 k8s；

pod deployment service 都讲讲；

为什么用 deployment 不用 pod；

保活机制；

orm 了解多少

## go
defer底层原理
每次defer在执行的时候，都将函数进行压栈处理，函数参数被拷贝下来。当外部函数退出的时候，defer按照原定义顺序依序执行，如果defer执行的函数为nil，那么最终调用函数会产生panic。
为什么defer要按照定义的顺序逆序执行？
因为有时候后面的defer执行需要前面的资源。
defer函数定义时，对外部变ᰁ的引⽤⽅式有两种 分别是函数参数以及作为闭包引⽤。 在作为函数参数的时候，在defer定义时就把值传递给defer，并被缓存起来。 如果是作为闭包引⽤，则会在defer真正调⽤的时候，根据整个上下⽂去确定当前的值。
defer后⾯的语句在执⾏的时候，函数调⽤的参数会被保存起来，也就是复制⼀份。 在真正执⾏的时候，实际上⽤到的是复制的变ᰁ，也就是说，如果这个变ᰁ是⼀个"值类型"，那他就和定义的时候是⼀致的，如果是⼀个"引⽤"，那么就可能和定义的时候的值不⼀致
defer配合recover
recover捕获异常程序在引发panic时不会崩溃退出。在引发panic时，panic会停掉当前正在执行的程序，但在此之前它会有序执行完当前goroutine的defer列表的语句。所以我们通常在defer⾥⾯挂⼀个recover，防⽌程序直接挂掉，类似于try...catch，但绝对不能像try...catch这样使 ⽤，因为panic的作⽤不是为了抓异常。recover函数只在defer的上下⽂中才有效，如果直接调⽤recover，会返回nil

接口interface
Go的接口使用非侵入方式，即删不删出接口层一样可以使用，代码可用性非常高，缺点：无法复用框架提供的代码和功能

goroutine与线程的区别
goroutine比线程更轻量级，goroutine与channel搭配使用可以轻松实现高并发不需要担心资源问题。
实现层面：
资源层面：线程栈大小一般为2MB左右，goroutine的栈内存可变初始化为2kb，最大可扩容1GB
调度层面：线程的调度由OS完成，goroutine调度由自身的调度器完成
goroutine与线程的联系
多个goroutine绑定在同一线程上，按照一定的调度算法执行。

goroutine的调度机制
MPG
M
M代表一个线程，所有goroutine的任务都会在M上执行
P（Processer）
代表一个处理器，每个M必须绑定一个P，P的个数是GOMAXPROCS，最大为256，在程序启动阶段，一般不去更改。
GOMAXPROCS的默认为电脑CPU核心数，单核CPU就只能设置为1，如果设置>1，在GOMAXPOCS函数中也会被修改为1。
M和P的个数不一样多，M≥P,每个P都会保存本地的G的队列，另外还有一个全局的G队列，G任务队列可以看作是线程池里的线程队列。
G（Goroutine）
代表一个goroutine对象，每次调用go的时候都会创建一个G对象。
goroutine的调度流程
创建一个goroutine对象，加入到本地或全局队列中
查找是否有空闲的P，没有就直接返回，有的话就调用系统API创建一个M
由刚刚创建的M找到G任务
G任务的执行顺序
先从本地找，再从全局找再从其他P找
所有G任务的执行是按照go关键字的顺序执行的
如果一个系统调用或者G任务执行时间太长就会一直占着整个线程，所以会有调度整个过程
goroutine是抢占式进行调度，一个goroutine最多执行10ms就会到下一个
Go垃圾回收算法（GC）
三色标记法
起初所有对象为白色
扫描根对象标记为灰色，放入处理队列
从队列中提取灰色对象，将其引用的对象标记为灰色，并自身标记为黑色
有专有的锁监视对象内存修改
完成所有上述过程后，对象只有黑色和白色，清除所有白色对象
GC中有写屏障，简单地说就是GC过程中新引入的内存只做标记不会回收。
辅助GC，在GC执行过程中，如果goroutine需要重新分配内存，那么这个goroutine会参与部分GC工作。
收起



## Mysql

### 事务的基本要素

1. 原子性：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行
2. 一致性：事务开始前和结束后，数据库的完整性约束没有被破坏。
3. 隔离性：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。
4. 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

### Mysql的存储引擎

1. InnoDB存储引擎：InnoDB存储引擎支持事务，其设计目标主要面向在线事务处理（OLTP）的应用。其特点是行锁设计，支持外键，并支持非锁定锁，即默认读取操作不会产生锁。从Mysql5.5.8版本开始，InnoDB存储引擎是默认的存储引擎。
2. MyISAM存储引擎：MyISAM存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些OLAP数据库应用。InnoDB的数据文件本身就是主索引文件，而MyISAM的主索引和数据是分开的。
3. NDB存储引擎：NDB存储引擎是一个集群存储引擎，其结构是share nothing的集群架构，能提供更高的可用性。NDB的特点是数据全部放在内存中（从MySQL 5.1版本开始，可以将非索引数据放在磁盘上），因此主键查找的速度极快，并且通过添加NDB数据存储节点可以线性地提高数据库性能，是高可用、高性能的集群系统。NDB存储引擎的连接操作是在MySQL数据库层完成的，而不是在存储引擎层完成的。这意味着，复杂的连接操作需要巨大的网络开销，因此查询速度很慢。如果解决了这个问题，NDB存储引擎的市场应该是非常巨大的。
4. Memory存储引擎：Memory存储引擎（之前称HEAP存储引擎）将表中的数据存放在内存中，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。虽然Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持TEXT和BLOB列类型。最重要的是，存储变长字段时是按照定常字段的方式进行的，因此会浪费内存。
5. Archive存储引擎：Archive存储引擎只支持INSERT和SELECT操作，从MySQL 5.1开始支持索引。Archive存储引擎使用zlib算法将数据行（row）进行压缩后存储，压缩比一般可达1∶10。正如其名字所示，Archive存储引擎非常适合存储归档数据，如日志信息。Archive存储引擎使用行锁来实现高并发的插入操作，但是其本身并不是事务安全的存储引擎，其设计目标主要是提供高速的插入和压缩功能。
6. Maria存储引擎：Maria存储引擎是新开发的引擎，设计目标主要是用来取代原有的MyISAM存储引擎，从而成为MySQL的默认存储引擎。它可以看做是MyISAM的后续版本。Maria存储引擎的特点是：支持缓存数据和索引文件，应用了行锁设计，提供了MVCC功能，支持事务和非事务安全的选项，以及更好的BLOB字符类型的处理性能。

### 事务的并发问题

1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
2. 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
3. 幻读：A事务读取了B事务已经提交的新增数据。**注意**和不可重复读的区别，这里是新增，不可重复读是更改（或删除）。select某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。

### MySQL事务隔离级别

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
|--------|----|-------|----|
| 读未提交   | 是  | 是     | 是  |
| 不可重复读  | 否  | 是     | 是  |
| 可重复读   | 否  | 否     | 是  |
| 串行化    | 否  | 否     | 否  |

### Mysql的逻辑结构

* 最上层的服务类似其他CS结构，比如连接处理，授权处理。
* 第二层是Mysql的服务层，包括SQL的解析分析优化，存储过程触发器视图等也在这一层实现。
* 最后一层是存储引擎的实现，类似于Java接口的实现，Mysql的执行器在执行SQL的时候只会关注API的调用，完全屏蔽了不同引擎实现间的差异。比如Select语句，先会判断当前用户是否拥有权限，其次到缓存（内存）查询是否有相应的结果集，如果没有再执行解析sql，检查SQL 语句语法是否正确，再优化生成执行计划，调用API执行。

### SQL执行顺序

SQL的执行顺序：from---where--group by---having---select---order by

### MVCC,redolog,undolog,binlog

* undoLog 也就是我们常说的回滚日志文件 主要用于事务中执行失败，进行回滚，以及MVCC中对于数据历史版本的查看。由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如"把id='B' 修改为id = 'B2' ，那么undo日志就会用来存放id ='B'的记录”。当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。它保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。
* redoLog 是重做日志文件是记录数据修改之后的值，用于持久化到磁盘中。redo log包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的。由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如“某个数据页上内容发生了哪些改动”。当一条数据需要更新时,InnoDB会先将数据更新，然后记录redoLog 在内存中，然后找个时间将redoLog的操作执行到磁盘上的文件上。不管是否提交成功我都记录，你要是回滚了，那我连回滚的修改也记录。它确保了事务的持久性。每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。为了得到更高的可靠性，用户可以设置多个的镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上，以此提高重做日志的高可用性。在日志组中每个重做日志文件的大小一致，并以循环写入的方式运行。InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，再当重做日志文件2也被写满时，会再切换到重做日志文件1中。
* MVCC多版本并发控制是MySQL中基于乐观锁理论实现隔离级别的方式，用于读已提交和可重复读取隔离级别的实现。在MySQL中，会在表中每一条数据后面添加两个字段：最近修改该行数据的事务ID，指向该行（undolog表中）回滚段的指针。Read View判断行的可见性，创建一个新事务时，copy一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

### binlog和redolog的区别

1. redolog是在InnoDB存储引擎层产生，而binlog是MySQL数据库的上层服务层产生的。
2. 两种日志记录的内容形式不同。MySQL的binlog是逻辑日志，其记录是对应的SQL语句，对应的事务。而innodb存储引擎层面的重做日志是物理日志，是关于每个页（Page）的更改的物理情况。
3. 两种日志与记录写入磁盘的时间点不同，binlog日志只在事务提交完成后进行一次写入。而innodb存储引擎的重做日志在事务进行中不断地被写入，并日志不是随事务提交的顺序进行写入的。
4. binlog不是循环使用，在写满或者重启之后，会生成新的binlog文件，redolog是循环使用。
5. binlog可以作为恢复数据使用，主从复制搭建，redolog作为异常宕机或者介质故障后的数据恢复使用。

### Mysql读写分离以及主从同步

1. 原理：主库将变更写binlog日志，然后从库连接到主库后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中，接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再执行一遍sql，这样就可以保证自己跟主库的数据一致。
2. 问题：这里有很重要一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行操作，在从库上会串行化执行，由于从库从主库拷贝日志以及串行化执行sql特点，在高并发情况下，从库数据一定比主库慢一点，是有延时的，所以经常出现，刚写入主库的数据可能读不到了，要过几十毫秒，甚至几百毫秒才能读取到。还有一个问题，如果突然主库宕机了，然后恰巧数据还没有同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。所以mysql实际上有两个机制，一个是半同步复制，用来解决主库数据丢失问题，一个是并行复制，用来解决主从同步延时问题。
3. 半同步复制：semi-sync复制，指的就是主库写入binlog日志后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库ack之后才会认为写完成。
4. 并发复制：指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这样库级别的并行。（将主库分库也可缓解延迟问题）
                                                                                                                                                  
### Next-Key Lock

InnoDB 采用 Next-Key Lock 解决幻读问题。在`insert into test(xid) values (1), (3), (5), (8), (11);`后，由于xid上是有索引的，该算法总是会去锁住索引记录。现在，该索引可能被锁住的范围如下：(-∞, 1], (1, 3], (3, 5], (5, 8], (8, 11], (11, +∞)。Session A（`select * from test where id = 8 for update`）执行后会锁住的范围：(5, 8], (8, 11]。除了锁住8所在的范围，还会锁住下一个范围，所谓Next-Key。

### InnoDB的关键特性

1. 插入缓冲：对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge（合并）操作，这时通常能将多个插入合并到一个操作中（因为在一个索引页中），这就大大提高了对于非聚集索引插入的性能。
2. 两次写：两次写带给InnoDB存储引擎的是数据页的可靠性，有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，如果这个页本身已经发生了损坏（物理到page页的物理日志成功页内逻辑日志失败），再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer，之后通过doublewrite buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，这就是doublewrite。
3. 自适应哈希索引：InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引。
4. 异步IO：为了提高磁盘操作性能，当前的数据库系统都采用异步IO（AIO）的方式来处理磁盘操作。AIO的另一个优势是可以进行IO Merge操作，也就是将多个IO合并为1个IO，这样可以提高IOPS的性能。
5. 刷新邻接页：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，故该工作机制在传统机械磁盘下有着显著的优势。

### Mysql如何保证一致性和持久性

MySQL为了保证ACID中的一致性和持久性，使用了WAL(Write-Ahead Logging,先写日志再写磁盘)。Redo log就是一种WAL的应用。当数据库忽然掉电，再重新启动时，MySQL可以通过Redo log还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新Redo log就足够了。

### InnoDB的行锁模式

* 共享锁(S)：用法lock in share mode，又称读锁，允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。
* 排他锁(X)：用法for update，又称写锁，允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。在没有索引的情况下，InnoDB只能使用表锁。

### 为什么选择B+树作为索引结构

* Hash索引：Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描
* 二叉查找树：解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表。
* 平衡二叉树：通过旋转解决了平衡的问题，但是旋转操作效率太低。
* 红黑树：通过舍弃严格的平衡和引入红黑节点，解决了	AVL旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO次数太多。
* B+树：在B树的基础上，将非叶节点改造为不存储数据纯索引节点，进一步降低了树的高度；此外将叶节点使用指针连接成链表，范围查询更加高效。

### B+树的叶子节点都可以存哪些东西

可能存储的是整行数据，也有可能是主键的值。B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引

### 覆盖索引

指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。

### 查询在什么时候不走（预期中的）索引

1. 模糊查询 %like
2. 索引列参与计算,使用了函数
3. 非最左前缀顺序
4. where单列索引对null判断 
5. where不等于
6. or操作有至少一个字段没有索引
7. 需要回表的查询结果集过大（超过配置的范围）

### 为什么Mysql数据库存储不建议使用NULL

1. NOT IN子查询在有NULL值的情况下返回永远为空结果，查询容易出错。
2. 索引问题，单列索引无法存储NULL值，where对null判断会不走索引。
3. 如果在两个字段进行拼接（CONCAT函数），首先要各字段进行非null判断，否则只要任意一个字段为空都会造成拼接的结果为null
4. 如果有 Null column 存在的情况下，count(Null column)需要格外**注意**，null 值不会参与统计。
5. Null列需要更多的存储空间：需要一个额外的字节作为判断是否为NULL的标志位

### explain命令概要

1. id:select选择标识符
2. select_type:表示查询的类型。
3. table:输出结果集的表
4. partitions:匹配的分区
5. type:表示表的连接类型
6. possible_keys:表示查询时，可能使用的索引
7. key:表示实际使用的索引
8. key_len:索引字段的长度
9. ref:列与索引的比较
10. rows:扫描出的行数(估算的行数)
11. filtered:按表条件过滤的行百分比
12. Extra:执行情况的描述和说明

### explain 中的 select_type（查询的类型）

1. SIMPLE(简单SELECT，不使用UNION或子查询等)
2. PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
3. UNION(UNION中的第二个或后面的SELECT语句)
4. DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
5. UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
6. SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
7. DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
8. DERIVED(派生表的SELECT, FROM子句的子查询)
9. UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

### explain 中的 type（表的连接类型）

1. system：最快，主键或唯一索引查找常量值，只有一条记录，很少能出现
2. const：PK或者unique上的等值查询
3. eq_ref：PK或者unique上的join查询，等值匹配，对于前表的每一行(row)，后表只有一行命中
4. ref：非唯一索引，等值匹配，可能有多行命中
5. range：索引上的范围扫描，例如：between/in
6. index：索引上的全集扫描，例如：InnoDB的count
7. ALL：最慢，全表扫描(full table scan)

### explain 中的 Extra（执行情况的描述和说明）

1. Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤
2. Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by
3. Using filesort：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”
4. Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该**注意**，根据查询的具体情况可能需要添加索引来改进能。
5. Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。
6. Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行
7. No tables used：Query语句中使用from dual 或不含任何from子句

### 数据库优化指南

1. 创建并使用正确的索引
2. 只返回需要的字段
3. 减少交互次数（批量提交）
4. 设置合理的Fetch Size（数据每次返回给客户端的条数）

## 操作系统

### 进程和线程

1. 进程是操作系统资源分配的最小单位，线程是CPU任务调度的最小单位。一个进程可以包含多个线程，所以进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
2. 不同进程间数据很难共享，同一进程下不同线程间数据很易共享。
3. 每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
4. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

### 多线程和单线程

线程不是越多越好，假如你的业务逻辑全部是计算型的（CPU密集型）,不涉及到IO，并且只有一个核心。那肯定一个线程最好，多一个线程就多一点线程切换的计算，CPU不能完完全全的把计算能力放在业务计算上面，线程越多就会造成CPU利用率（用在业务计算的时间/总的时间）下降。**但是在WEB场景下，业务并不是CPU密集型任务，而是IO密集型的任务，一个线程是不合适，如果一个线程在等待数据时，把CPU的计算能力交给其他线程，这样也能充分的利用CPU资源。**但是线程数量也要有个限度，一般线程数有一个公式：最佳启动线程数=[任务执行时间/(任务执行时间-IO等待时间)]*CPU内核数超过这个数量，CPU要进行多余的线程切换从而浪费计算能力，低于这个数量，CPU要进行IO等待从而造成计算能力不饱和。总之就是要尽可能的榨取CPU的计算能力。如果你的CPU处于饱和状态，并且没有多余的线程切换浪费，那么此时就是你服务的完美状态，如果再加大并发量，势必会造成性能上的下降。

### 进程的组成部分

进程由进程控制块（PCB）、程序段、数据段三部分组成。

### 进程的通信方式

1. 无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
2. FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
3. 消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
4. 信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
5. 共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。

### 进程间五种通信方式的比较

1. 管道：速度慢，容量有限，只有**父子进程能通讯。**
2. FIFO：任何进程间都能通讯，但速度慢。
3. 消息队列：**容量受到系统限制，且要**注意**第一次读的时候，要考虑上一次没有读完数据的问题。**
4. 信号量：不能传递复杂消息，只能用来同步。
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要**注意**读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。

### 内存管理有哪几种方式

1. 块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
2. 页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
3. 段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
4. 段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。

### 页面置换算法

1. 最佳置换算法OPT：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。
2. 先进先出置换算法FIFO：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。
3. 最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。
4. 时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。
5. 改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。
6. LFU最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。

### 操作系统中进程调度策略有哪几种

1. 先来先服务调度算法FCFS：队列实现，非抢占，先请求CPU的进程先分配到CPU，可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度，对于长作业比较有利.
2. 最短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行，平均等待时间最短，但难以知道下一个CPU区间长度；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱.
3. 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿.
4. 时间片轮转调度算法(可抢占的)：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

### 死锁的4个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用；
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。   

### 如何避免（预防）死锁

1. 破坏“请求和保持”条件：让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源。
2. 破坏“不可抢占”条件：允许进程进行抢占，方法一：如果去抢资源，被拒绝，就释放自己的资源。方法二：操作系统允许抢，只要你优先级大，可以抢到。
3. 破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出（指定获取锁的顺序，顺序加锁）。

## 计算机网路

### Get和Post区别

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。
2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。
3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。
4. Get执行效率却比Post方法好。Get是form提交的默认方法。
5. GET产生一个TCP数据包；POST产生两个TCP数据包。（非必然，客户端可灵活决定）

### Http请求的完全过程

1. 浏览器根据域名解析IP地址（DNS）,并查DNS缓存
2. 浏览器与WEB服务器建立一个TCP连接
3. 浏览器给WEB服务器发送一个HTTP请求（GET/POST）：一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。
4. 服务端响应HTTP响应报文，报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。
5. 浏览器解析渲染

### 计算机网络的五层模型

1. 应用层：为操作系统或网络应用程序提供访问网络服务的接口 ，通过应用进程间的交互完成特定网络应用。应用层定义的是应用进程间通信和交互的规则。（HTTP，FTP，SMTP，RPC）
2. 传输层：负责向两个主机中进程之间的通信提供通用数据服务。（TCP,UDP）
3. 网络层：负责对数据包进行路由选择和存储转发。（IP，ICMP(ping命令)）
4. 数据链路层：两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧（frame)。每一帧包括数据和必要的控制信息。
5. 物理层：物理层所传数据单位是比特（bit)。物理层要考虑用多大的电压代表1 或 0 ，以及接受方如何识别发送方所发送的比特。

### tcp和udp区别

1. TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接。
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4. 每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。
5. TCP首部开销20字节，UDP的首部开销小，只有8个字节。
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

### tcp和udp的优点

* TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。
* UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输。什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP。

### 三次握手

* 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
* 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；
* 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

### 为什么不能两次握手

TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

### 四次挥手

1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。**注意**此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些

### 为什么连接的时候是三次握手，关闭的时候却是四次握手

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

## 数据结构与算法

### 排序算法

1. 冒泡排序
2. 选择排序：选择排序与冒泡排序有点像，只不过选择排序每次都是在确定了最小数的下标之后再进行交换，大大减少了交换的次数
3. 插入排序：将一个记录插入到已排序的有序表中，从而得到一个新的，记录数增1的有序表
4. 快速排序：通过一趟排序将序列分成左右两部分，其中左半部分的的值均比右半部分的值小，然后再分别对左右部分的记录进行排序，直到整个序列有序。
```
int partition(int a[], int low, int high){
    int key = a[low];
    while( low < high ){
        while(low < high && a[high] >= key) high--;
        a[low] = a[high];
        while(low < high && a[low] <= key) low++;
        a[high] = a[low];
    }
    a[low] = key;
    return low;
}
void quick_sort(int a[], int low, int high){
    if(low >= high) return;
    int keypos = partition(a, low, high);
    quick_sort(a, low, keypos-1);
    quick_sort(a, keypos+1, high);
}
```
5. 堆排序：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。
```
public class Test {

    public void sort(int[] arr) {
        for (int i = arr.length / 2 - 1; i >= 0; i--) {
            adjustHeap(arr, i, arr.length);
        }
        for (int j = arr.length - 1; j > 0; j--) {
            swap(arr, 0, j);
            adjustHeap(arr, 0, j);
        }

    }

    public void adjustHeap(int[] arr, int i, int length) {
        int temp = arr[i];
        for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if (k + 1 < length && arr[k] < arr[k + 1]) {
                k++;
            }
            if (arr[k] > temp) {
                arr[i] = arr[k];
                i = k;
            } else {
                break;
            }
        }
        arr[i] = temp;
    }

    public void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};
        new Test().sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}
```
6. 希尔排序：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。
7. 归并排序：把有序表划分成元素个数尽量相等的两半，把两半元素分别排序，两个有序表合并成一个

## 其他

### 高并发系统的设计与实现

在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。

* 缓存：缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。
* 降级：服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。
* 限流：限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。

### 负载均衡算法：

1. 轮询
2. 加权轮询
3. 随机算法
4. 一致性Hash

### 常见的限流算法：

常见的限流算法有计数器、漏桶和令牌桶算法。漏桶算法在分布式环境中消息中间件或者Redis都是可选的方案。发放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。

### 秒杀并发情况下库存为负数问题

1. for update显示加锁
2. 把update语句写在前边，先把数量-1，之后select出库存如果>-1就commit,否则rollback。
```
update products set quantity = quantity-1 WHERE id=3;
select quantity from products WHERE id=3 for update;
```
3. update语句在更新的同时加上一个条件
```
quantity = select quantity from products WHERE id=3;
update products set quantity = ($quantity-1) WHERE id=3 and queantity = $quantity;
```







熟悉go，了解C，Python

熟悉常见设计模式如单例模式、工厂模式等

熟悉常用的数据结构(链表、栈、队列、二叉树等)，以及排序，查找，动态规划等算法

熟悉操作系统的进程通信、死锁、内存管理等知识

熟悉OSI五层网络模型，熟悉TCP/IP,UDP,HTTP/HTTPS,DNS等网络协议

熟练使用 MySQL，熟悉 MySQL 索引、事务、存储引擎、锁机制

了解Linux下vim开发环境

了解分布式系统，包括其特征，系统模型，进程间通信等

了解gin的基本原理

了解软件工程知识，比如敏捷开发等


项目描述：

大学入门项目，四人合作使用Java进行开发，最终完成的功能有手动、拍照记账，流水统计，以及一些辅助功能。

主要工作：

我负责实现对总收支、收入/支出分配、收支趋势和对比等层面的数据图表化。也就是实现流水统计功能。我从 LitePal 中读取流水数据，并利用一个开源的图表库 MPAndroidChart，实现了期望的数据图表化。

主要收获：

第一次做软件开发，也是第一次团队协作进行软件开发。我明白了团队合理分工协作以及规范设计开发的重要性。


项目描述：

使用c++和cocos2d-x游戏引擎开发的一款回合制游戏，它能够让玩家在一片地形多变的地图上，在初始的领土基础上进行扩张、殖民、训练军队、对其他玩家发起战争等操作。最后实现了一个简单的单机多人回合制战争策略游戏。

主要工作：

除了参与游戏功能设计之外，我主要负责游戏地图的UI设计以及自定义操作栈的实现。比如玩家回合当中的操作偶有失误需要撤销操作，便需要对操作进行压栈出栈。

主要收获：

第一次参与游戏开发，从设计到开发整个过程痛苦并快乐，收获了一定的P图技巧，巩固了对数据结构的理解与使用。


项目描述：
