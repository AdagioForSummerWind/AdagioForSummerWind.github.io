---
title: "计网"
date: 2022-11-03T23:45:02+08:00
lastmod: 2022-11-03
tags: [计网]
categories: [计网]
slug: 计网
draft: false
---

- [计网](#计网)
  - [Get和Post区别](#get和post区别)
  - [Http请求的完全过程](#http请求的完全过程)
  - [计算机网络的五层模型](#计算机网络的五层模型)
  - [TCP/IP 四层协议栈](#tcpip-四层协议栈)
  - [OSI七层：](#osi七层)
  - [tcp和udp区别](#tcp和udp区别)
  - [tcp和udp的优点](#tcp和udp的优点)
  - [三次握手](#三次握手)
  - [为什么不能两次握手](#为什么不能两次握手)
  - [四次挥手](#四次挥手)
  - [为什么连接的时候是三次握手，关闭的时候却是四次握手](#为什么连接的时候是三次握手关闭的时候却是四次握手)
  - [1. OSI与TCP/IP 模型](#1-osi与tcpip-模型)
  - [2. 常见网络服务分层](#2-常见网络服务分层)
  - [6. 如何查看TIME-WAIT状态的链接数量？](#6-如何查看time-wait状态的链接数量)
  - [7. 为什么会TIME-WAIT过多？解决方法是怎样的？](#7-为什么会time-wait过多解决方法是怎样的)
  - [大量 CLOSE_WAIT](#大量-close_wait)
  - [8. 半连接，洪泛攻击问题以及如何解决（syn_cookie）](#8-半连接洪泛攻击问题以及如何解决syn_cookie)
  - [9. 为什么客户端的TIME-WAIT状态必须等待2MSL ?](#9-为什么客户端的time-wait状态必须等待2msl-)
  - [10. 4g切换wifi会发生什么](#10-4g切换wifi会发生什么)
  - [11. TCP与UDP区别及场景](#11-tcp与udp区别及场景)
  - [12. TCP滑动窗口，拥塞控制](#12-tcp滑动窗口拥塞控制)
  - [13. TCP粘包原因和解决方法](#13-tcp粘包原因和解决方法)
  - [14. TCP、UDP报文格式](#14-tcpudp报文格式)
  - [15. TCP协议如何保证可靠传输机制？](#15-tcp协议如何保证可靠传输机制)
  - [16. TCP的滑动窗口?](#16-tcp的滑动窗口)
  - [17. 详细讲一下拥塞控制? 为何要进行拥塞控制？](#17-详细讲一下拥塞控制-为何要进行拥塞控制)
  - [18. TCP拥塞控制4种算法](#18-tcp拥塞控制4种算法)
  - [HTTP协议](#http协议)
    - [1. HTTP协议1.0  1.1  2.0](#1-http协议10--11--20)
    - [2. HTTP1.0和HTTP1.1的主要区别如下：](#2-http10和http11的主要区别如下)
    - [3. HTTP1.1和HTTP2.0的主要区别：](#3-http11和http20的主要区别)
    - [4. HTTP和 HTTPS的区别：](#4-http和-https的区别)
    - [5. HTTPS 的缺点：](#5-https-的缺点)
    - [6. HTTPS链接建立的过程：](#6-https链接建立的过程)
    - [7. HTTP常见响应状态码](#7-http常见响应状态码)
    - [8. 状态码301和302的区别是什么?](#8-状态码301和302的区别是什么)
    - [9. 对称加密算法与非对称加密算法的区别](#9-对称加密算法与非对称加密算法的区别)
    - [10. HTTP请求方法：](#10-http请求方法)
    - [11. Get和Post请求区别](#11-get和post请求区别)
    - [12. GET 和 POST 方法都是安全和幂等的吗？](#12-get-和-post-方法都是安全和幂等的吗)
    - [13. 重定向和转发区别](#13-重定向和转发区别)
    - [14. Cookie和Session区别](#14-cookie和session区别)
    - [15. 浏览器输入URL过程](#15-浏览器输入url过程)
    - [16. DNS协议是TCP还是UDP?](#16-dns协议是tcp还是udp)
    - [17. ARP协议如何找到对应IP地址和mac的映射的](#17-arp协议如何找到对应ip地址和mac的映射的)
    - [18. RARP 协议你知道是什么吗？](#18-rarp-协议你知道是什么吗)
    - [19. 什么是DDos攻击?](#19-什么是ddos攻击)
    - [20. 什么是XSS攻击?](#20-什么是xss攻击)
    - [21. SQL注入是什么，如何避免SQL注入?](#21-sql注入是什么如何避免sql注入)
    - [22. 网络编程socket，客户端和服务端通信过程，分别调用了哪些函数，作用是什么](#22-网络编程socket客户端和服务端通信过程分别调用了哪些函数作用是什么)
    - [23. 负载均衡算法有哪些?](#23-负载均衡算法有哪些)
  - [什么是网络编程](#什么是网络编程)
    - [网络编程中两个主要的问题](#网络编程中两个主要的问题)
  - [网络协议是什么](#网络协议是什么)
    - [为什么要对网络协议分层](#为什么要对网络协议分层)
  - [TCP / UDP](#tcp--udp)
    - [什么是TCP/IP和UDP](#什么是tcpip和udp)
    - [TCP与UDP区别：](#tcp与udp区别)
    - [TCP和UDP的应用场景](#tcp和udp的应用场景)
    - [形容一下TCP和UDP](#形容一下tcp和udp)
    - [运行在TCP 或UDP的应用层协议分析](#运行在tcp-或udp的应用层协议分析)
    - [什么是ARP协议 (Address Resolution Protocol)？](#什么是arp协议-address-resolution-protocol)
    - [从输入址到获得页面的过程?](#从输入址到获得页面的过程)
  - [Socket](#socket)
    - [什么是Socket](#什么是socket)
    - [socket属于网络的那个层面](#socket属于网络的那个层面)
    - [Socket通讯的过程](#socket通讯的过程)
    - [TCP协议Socket代码示例：](#tcp协议socket代码示例)
    - [6 Socket的常用类](#6-socket的常用类)
  - [3. HTTP](#3-http)
    - [什么是Http协议？](#什么是http协议)
    - [Socket和http的区别和应用场景](#socket和http的区别和应用场景)
    - [什么是http的请求体？](#什么是http的请求体)
    - [HTTPS工作原理](#https工作原理)
    - [一次完整的HTTP请求所经历几个步骤?](#一次完整的http请求所经历几个步骤)
    - [常用HTTP状态码是怎么分类的，有哪些常见的状态码？](#常用http状态码是怎么分类的有哪些常见的状态码)
    - [http版本的对比](#http版本的对比)
    - [什么是对称加密与非对称加密](#什么是对称加密与非对称加密)
    - [cookie和session对于HTTP有什么用？](#cookie和session对于http有什么用)
    - [什么是cookie](#什么是cookie)
    - [什么是session](#什么是session)
    - [cookie与session区别](#cookie与session区别)
- [参考](#参考)
##  计网

### Get和Post区别

1. Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。
2. Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。
3. Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。
4. Get执行效率却比Post方法好。Get是form提交的默认方法。
5. GET产生一个TCP数据包；POST产生两个TCP数据包。（非必然，客户端可灵活决定）

### Http请求的完全过程

1. 浏览器根据域名解析IP地址（DNS）,并查DNS缓存（域名解析的过程中会有多级的缓存，浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts）
2. 浏览器与WEB服务器建立一个TCP连接
3. 浏览器给WEB服务器发送一个HTTP请求（GET/POST）：一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。
4. 服务端响应HTTP响应报文，报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。
5. 浏览器解析渲染

### 计算机网络的五层模型

1. 应用层：为操作系统或网络应用程序提供访问网络服务的接口 ，通过应用进程间的交互完成特定网络应用。应用层定义的是应用进程间通信和交互的规则。（HTTP，FTP，SMTP，RPC）
2. 传输层：负责向两个主机中进程之间的通信提供通用数据服务。（TCP,UDP）
3. 网络层：负责对数据包进行路由选择和存储转发。（IP，ICMP(ping命令)）
4. 数据链路层：两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧（frame)。每一帧包括数据和必要的控制信息。
5. 物理层：物理层所传数据单位是比特（bit)。物理层要考虑用多大的电压代表1 或 0 ，以及接受方如何识别发送方所发送的比特。


### TCP/IP 四层协议栈
- TCP/IP 协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。
- **这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。协议的层级关系模型非常重要。**
- IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。
- 现在我们使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。看上去好像很多，但互联网的快速发展让地址的分配管理很快就“捉襟见肘”。所以，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，容量扩大了很多，有 2^128 个，在未来的几十年里应该是足够用了。
- TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。**“可靠”是指保证数据不丢失，“字节流”是指保证数据完整**，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。
- 因此，HTTP协议运行在TCP/IP之上。

### OSI七层：
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层


七层网络体系结构各层的主要功能：

- 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统`DNS`， 支持万维网应用的`HTTP`协议，支持电子邮件的`SMTP`协议等。
- 表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。
- 会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。
- 运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议: 
  - `TCP`：提供面向连接的、可靠的数据传输服务;
  - `UDP`：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。
- 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括`IP`协议。
- 数据链路层：数据链路层通常简称为链路层。将网络层传下来的`IP`数据包组装成帧，并再相邻节点的链路上传送帧。
- 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。
### tcp和udp区别

1. TCP面向连接，UDP是无连接的，即发送数据之前不需要建立连接。
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
4. 每一条TCP连接只能是点到点的，UDP支持一对一，一对多，多对一和多对多的交互通信。
5. TCP首部开销20字节，UDP的首部开销小，只有8个字节。
6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。

### tcp和udp的优点

* TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。
* UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击…… UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 基于上面的优缺点，那么： 什么时候应该使用TCP： 当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 在日常生活中，常见使用TCP协议的应用如下： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输。什么时候应该使用UDP： 当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 比如，日常生活中，常见使用UDP协议的应用如下： QQ语音 QQ视频 TFTP。

### 三次握手
TCP连接的不是主机、IP地址、应用进程。而是socket(IP+端口号)

- 连接前，CLOSED状态
* 第一次握手：建立连接时，客户端发送一个报文段（seq=x, SYN=1的报文段）到服务器，并进入SYN_SENT状态，等待服务器确认；
* 第二次握手：服务器收到这个报文段后，如果同意建立连接的话就回复一个报文段（seq=y, ack=x+1，SYN=1, ACK=1），此时服务器进入SYN_RECV状态；
* 第三次握手：客户端收到服务器的这个报文段后，向服务器发送确认报文段(seq=x+1，ack=y+1，ACK=1），此包发送完毕，客户端进入ESTABLISHED状态，服务器收到后也进入ESTABLISH状态。完成三次握手。
* 服务器更易受到SYN泛洪攻击


**为什么三次：**  主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力。

**为什么两次不行？**

1. 防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源。

2. **两次握手只能保证单向连接是畅通的。**（为了实现可靠数据传输， `TCP `协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。三次握手的过程即是通信双方 相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）。

### 为什么不能两次握手

TCP是一个双向通信协议，通信双方都有能力发送信息，并接收响应。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

### 四次挥手

1. 客户端进程发出连接释放报文段，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文段，发出确认报文段，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。此时客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ACK=1, ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。**注意**此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命，也就是一个报文段来回时间）的时间后，客户端撤销相应的TCB(传输控制块)后，才进入CLOSED状态。如果在此过程中，服务端在规定时间内未收到确认报文段，会重复发送FIN报文段给客户端。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些


**为什么四次：**因为需要确保客户端与服务端的数据能够完成传输。

**CLOSE-WAIT：** 这种状态的含义其实是表示在**等待关闭**。

**TIME-WAIT：** 为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接。(为什么要有 TIME_WAIT 状态？因为客户端最后向服务器发送的确认 ACK 是有可能丢失的，当出现超时，服务端会再次发送 FIN 报文段，如果客户端已经关闭了就收不到了。)
### 为什么连接的时候是三次握手，关闭的时候却是四次握手

由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。所以简单地说两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。
而建立连接时服务器可以把ACK报文段和SYN报文段（ACK报文段起确认作用，即确认客户端的连接建立请求；SYN报文段起同步作用）放在一起发送，所以是3次。


### 1. OSI与TCP/IP 模型

OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408144411.jpeg)

七层网络体系结构各层的主要功能：

- 应用层：为应用程序提供交互服务。在互联网中的应用层协议很多，如域名系统`DNS`， 支持万维网应用的`HTTP`协议，支持电子邮件的`SMTP`协议等。
- 表示层：主要负责数据格式的转换，如加密解密、转换翻译、压缩解压缩等。
- 会话层：负责在网络中的两节点之间建立、维持和终止通信，如服务器验证用户登录便是由会话层完成的。
- 运输层：有时也译为传输层，向主机进程提供通用的数据传输服务。该层主要有以下两种协议: 
  - `TCP`：提供面向连接的、可靠的数据传输服务;
  - `UDP`：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性。
- 网络层：选择合适的路由和交换结点，确保数据及时传送。主要包括`IP`协议。
- 数据链路层：数据链路层通常简称为链路层。将网络层传下来的`IP`数据包组装成帧，并再相邻节点的链路上传送帧。
- 物理层：实现相邻节点间比特流的透明传输，尽可能屏蔽传输介质和通信手段的差异。

### 2. 常见网络服务分层

应用层：`HTTP`、`DNS`、`FTP`、`SMTP`

传输层：`TCP `、`UDP`

网络层：`IP`、`ICMP `、路由器、防火墙

数据链路层：网卡、网桥、交换机

物理层：中继器、集线器



### 6. 如何查看TIME-WAIT状态的链接数量？

```shell
netstat -an | grep TIME_WAIT | wc -l  //查看连接数等待time_wait状态连接数
```
### 7. 为什么会TIME-WAIT过多？解决方法是怎样的？

**可能原因：**高并发短连接的`TCP`服务器上，当服务器处理完请求后立刻按照主动正常关闭连接

**解决：**负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接

### 大量 CLOSE_WAIT
大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。
### 8. 半连接，洪泛攻击问题以及如何解决（syn_cookie）

在三次握手的过程中，服务器为了响应一个受到的`SYN`报文段，会分配并初始化连接变量和缓存，然后服务器发送一个`SYN/ACK`报文段进行响应，并等待客户端的`ACK`报文段。如果客户不发送`ACK`来完成该三次握手的第三步，最终(通常在一分多钟之后)服务器将终止该半开连接并回收资源。这种`TCP`连接管理协议的特性就会有这样一个漏洞，攻击者发送大量的`TCP SYN`报文段，而不完成第三次握手的步骤。随着这种`SYN`报文段的不断到来，服务器不断为这些半开连接分配资源，从而导致服务器连接资源被消耗殆尽。这种攻击就是`SYN`泛供攻击。

为了应对这种攻击，现在有一种**有效的防御系统，称为SYN cookie**。SYN cookie的工作方式如下：

1. 当服务器接收到一个`SYN`报文段时，它并不知道该报文段是来自一个合法的用户，还是这种SYN洪泛攻击的一部分。因为服务器不会为该报文段生成一个半开的连接。相反，服务器生成一个初始`TCP`序列号，该序列号是SYN报文段的源IP地址和目的IP地址，源端口号和目的端口号以及仅有服务器知道的秘密数的复杂函数(散列函数)。这种精心制作的初始序列号称为为“cookie”。服务器则发送具有这种特殊初始序号的`SYN/ACK`报文分组。服务器并不记忆该cookie或任何对应于SYN的其他状态信息。
2. 如果该客户是合法的，则它将返回一个`ACK`报文段。当服务器收到该`ACK`报文段，需要验证该ACK是与前面发送的某个`SYN`相对应。由于服务器并不维护有关`SYN`报文段的记忆，所以服务器通过使用`SYN/ACK`报文段中的源和目的IP地址与端口号以及秘密数运行相同的散列函数。如果这个函数的结果(cookie值)加1和在客户的ACK报文段中的确认值相同的话，那么服务器就会认为该`ACK`对应于较早的`SYN`报文段，因此它是合法的。服务器则会生成一个套接字的全开连接。
3. 另一方面，如果客户没有返回一个`ACK`报文段，说明之前的`SYN`报文段是洪泛攻击的一部分，但是它并没有对服务器产生危害，因为服务器没有为它分配任何资源。

### 9. 为什么客户端的TIME-WAIT状态必须等待2MSL ?

主要有两个原因:

1. **为了保证客户端发送的最后一个ACK报文段能够达到服务器。**
   这个`ACK`报文段可能丢失，因而使处在`LAST-ACK`状态的服务器收不到确认。服务器会超时重传`FIN+ACK`报文段，客户端就能在2MSL时间内收到这个重传的`FIN+ACK`报文段，接着客户端重传一次确认，重启计时器。最好，客户端和服务器都正常进入到`CLOSED`状态。如果客户端在`TIME-WAIT`状态不等待一段时间，而是再发送完`ACK`报文后立即释放连接，那么就无法收到服务器重传的`FIN+ACK`报文段，因而也不会再发送一次确认报文。这样，服务器就无法按照正常步骤进入`CLOSED`状态。
2. **防止已失效的连接请求报文段出现在本连接中。**
   客户端在发送完最后一个`ACK`确认报文段后，再经过时间`2MSL`，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 10. 4g切换wifi会发生什么

当移动设备的网络从`4G`切换到`WiFi`时，意味着IP地址变化了，那么必须要断开连接，然后重新连接，而建立连接的过程包含TCP三次握手和TLS四次挥手的时延，以及TCP慢启动的减速过程，给用户的感觉就是突然网络卡顿了一下，所以说，迁移的成本是很高的。

**http3是怎么解决连接迁移**

`HTTP3`中`QUIC`协议没有用四元组的方式来"绑定”连接，而是通过连接ID来标记通信的两个端点，客户端和服务器可以各自选择一组ID来标记自己，因此即使移动设备的网络变化后，导致IP地址变化了，只要仍保有上下文信息(比如连接ID、TLS 密钥等)，就可以"无缝"地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

### 11. TCP与UDP区别及场景

| 类型 | 特点                       | 性能                   | 应用过场景       | 首部字节 |
| ---- | -------------------------- | ---------------------- | ---------------- | -------- |
| TCP  | 面向连接、可靠、字节流     | 传输效率慢、所需资源多 | 文件、邮件传输   | 20-60    |
| UDP  | 无连接、不可靠、数据报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8个字节  |

**基于TCP的协议：**`HTTP`、`FTP`、`SMTP`

**基于UDP的协议：** `RIP`、`DNS`、`SNMP`

### 12. TCP滑动窗口，拥塞控制

**TCP通过：**应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输。

**拥塞控制目的：**为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载。

**拥塞控制过程：**TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。

### 13. TCP粘包原因和解决方法

**TCP粘包是指**：发送方发送的若干包数据到接收方接收时粘成一包

**发送方原因：**

TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：

收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题

**接收方原因：**

TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

- **传输层的UDP协议不会发生粘包或者拆包问题**

  `UDP`是基于报文发送的，在`UDP`首部采用了16bit来指示`UDP`数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

- **传输层的TCP协议会发生粘包或者拆包问题**

  原因有以下两点：

  1. `TCP`是基于字节流的，虽然应用层和传输层之间的数据交互是大小不等的数据块，但是`TCP`把这些数据块仅仅看成一连串无结构的字节流，没有边界；
  2. 在`TCP`的首部没有表示数据长度的字段，基于上面两点，在使用`TCP`传输数据时，才有粘包或者拆包现象发生的可能。

**解决粘包问题：**解决问题的关键在于如何给每个数据包添加边界信息

最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：

- 发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
- 包尾加上\r\n标记。`FTP`协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
- 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。

### 14. TCP、UDP报文格式

**TCP报文格式：**

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408101002.png)



**源端口号和目的端口号**：

用于寻找发端和收端应用进程。这两个值加上`IP`首部源端IP地址和目的端`IP`地址唯一确定一个`TCP`连接。

**序号字段：**

序号用来标识从`TCP`发端向`TCP`收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 `TCP`用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。

当建立一个新的连接时，`SYN`标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为`SYN`标志消耗了一个序号

**确认序号**：

既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有`ACK`标志为 1时确认序号字段才有效。发送`ACK`无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。

**首都长度**：

首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此TCP最多有6 0字节的首部。然而，没有任选字段，正常的长度是 20字节。

**标志字段**：在`TCP`首部中有 6个标志比特，它们中的多个可同时被设置为1。

- `URG`紧急指针（u rgent pointer）有效
- `ACK`确认序号有效。
- `PSH`接收方应该尽快将这个报文段交给应用层。
- `RST`重建连接。
- `SYN`同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。
- `FIN`发端完成发送任务。

**窗口大小**：

`TCP`的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。

**检验和：**

检验和覆盖了整个的 `TCP`报文段：`TCP`首部和`TCP`数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

**紧急指针**：

只有当`URG`标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。`TCP`的紧急方式是发送端向另一端发送紧急数据的一种方式。

**选项**：

最常见的可选字段是最长报文大小，又称为 `MSS `(Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 `SYN`标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

**UDP报文格式：**

![图片](https://mmbiz.qpic.cn/mmbiz_png/DWQ5ap0dyHP9wH6dWPia9Lna1rITnndXj1mOPAbjgvicRWDqAwosyhn44R5plROezpLBF3c3Q0ZsTokN8IpOiaNAQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**端口号**：

用来表示发送和接受进程。由于 `IP`层已经把I P数据报分配给`TCP`或 `UDP`（根据I P首部中协议字段值），因此`TCP`端口号由`TCP`来查看，而 `UDP`端口号由 `UDP`来查看。`TCP`端口号与 `UDP`端口号是相互独立的。

**长度**：

 `UDP`长度字段指的是 `UDP`首部和 `UDP`数据的字节长度。该字段的最小值为 8字节（发送一份0字节的 `UDP`数据报是 O K）。

**检验和**：

 `UDP`检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现 `UDP`首部和数据在发送端到接收端之间发生的任何改动。

**IP报文格式：**普通的IP首部长为20个字节，除非含有可选项字段。

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327215715.webp)

**4位版本**：目前协议版本号是4，因此IP有时也称作IPV4.

**4位首部长度**：

首部长度指的是首部占`32bit`字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。

**服务类型（TOS）**：

服务类型字段包括一个`3bit`的优先权字段（现在已经被忽略），`4bit`的TOS子字段和1bit未用位必须置0。`4bit`的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。

**总长度**：

总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长`16bit`，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。

**标识字段**：

标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。

**生存时间**：

TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 `ICMP `报文通知源主机。

**首部检验和**：

首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。`ICMP`、`IGMP`、`UDP`和`TCP`在它们各自的首部中均含有同时覆盖首部和数据检验和码。

**以太网报文格式：**

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327215724.webp)

**目的地址和源地址：** 是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。

**数据：**

以太网帧中的数据长度规定最小46 字节，最大1500 字节，`ARP `和`RARP `数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（`MTU`），不同的网络类型有不同的`MTU`，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的`MTU`了，则需要对数据包进行分片fragmentation）。`ifconfig `命令的输出中也有“MTU:1500”。**注意**，`MTU`个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。

### 15. TCP协议如何保证可靠传输机制？

**TCP主要提供了检验和、序列号/确认应答、超时重传、滑动窗口、拥塞控制和流量控制等方法实现了可靠性传输。**

- **检验和：**通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃`TCP`段，重新发送。
- **序列号/确认应答：**
  序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。
  `TCP`传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送`ACK`报文,这个`ACK`报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
- **超时重传：**超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。
- **滑动窗口：**滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。
- **拥塞控制：**在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证`TCP`可靠性的同时，提高性能。
- **流量控制：**如果主机A一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与`TCP`协议报头中的窗口大小有关。

### 16. TCP的滑动窗口?

在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。`TCP`协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。
为了避免这种情况，`TCP`引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327223444.png)

从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。

滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。

可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前`TCP`发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。

### 17. 详细讲一下拥塞控制? 为何要进行拥塞控制？

A在给B传输数据, A却没有收到B反馈的`TCP`,A就认为B发送的数据包丢失了..进而会重新传输这个丢失的数据包。然而实际情况有可能此时有太多主机正在使用信道资源，导致**网络拥塞**了。重传数据浪费了资源，所以要进行拥塞控制。发送发不知道一次发多少数据合适，所以设置一个拥塞窗口。

**TCP拥塞控制原理是通过：慢启动、拥塞避免、快重传、快启动** 

发送方维持一个叫做拥塞窗口cwnd (congestion window)的状态变量。当cwndssthresh时， 改用拥塞避免算法。

- **慢开始:** 不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。
- **拥塞避免:** 拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。
- **快重传: **我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。快重传规定:发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
- **快恢复: **主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半(为了预防网络发生拥塞)，但接下来并不执行慢开始算法，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。

### 18. TCP拥塞控制4种算法

- **基于丢包的拥塞控制**：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如`Reno`、`Cubic`等。
- **基于时延的拥塞控制**：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如`Vegas`、`FastTCP`等。
- **基于链路容量的拥塞控制**：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如`BBR`。
- **基于学习的拥塞控制**：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如`Remy`。

### HTTP协议

#### 1. HTTP协议1.0  1.1  2.0

**HTTP1.0：**服务器处理完成后立即断开`TCP`连接（**无连接**），服务器不跟踪每个客户端也不记录过去的请求（**无状态**）

**HTTP1.1：** `KeepAlived` **长连接**避免了连接建立和释放的开销；通过`Content-Length`来判断当前请求数据是否已经全部接受（**有状态**）

**HTTP2.0：**引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以**并行**的传输数据。

---

**无状态的好坏** 

- **无状态的好处**，因为服务器不会去记忆 `HTTP `的状态，所以不需要额外的资源来记录状态信息，这能减 轻服务器的负担，能够把更多的 `CPU `和内存用来对外提供服务。 
- **无状态的坏处**，既然服务器没有记忆能力，这样每操作一次，都要验证信息。例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。

解决无状态的问题，解法方案有很多种，其中比较简单的方式用 `Cookie `和`Session`技术。

#### 2. HTTP1.0和HTTP1.1的主要区别如下：

1. **缓存处理**：1.1添加更多的缓存控制策略（如：`Entity tag`，`If-Match`）
2. **网络连接的优化**：1.1支持断点续传
3. **错误状态码的增多**：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
4. **Host头处理**：支持`Host`头域，不在以`IP`为请求方标志
5. **长连接**：减少了建立和关闭连接的消耗和延迟。

#### 3. HTTP1.1和HTTP2.0的主要区别：

1. **新的传输格式**：2.0使用二进制格式，1.0依然使用基于文本格式
2. **多路复用**：连接共享，不同的`request`可以使用同一个连接传输（最后根据每个`request`上的id号组合成正常的请求）
3. **header压缩**：由于1.X中`header`带有大量的信息，并且得重复传输，2.0使用`encoder`来减少需要传输的`hearder`大小
4. **服务端推送**：同`google`的`SPDUY`（1.0的一种升级）一样

#### 4. HTTP和 HTTPS的区别：

1. 最重要的区别就是**安全性**，`HTTP `明文传输，不对数据进行加密安全性较差。`HTTPS `(HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好。
2. **证书**：使用 `HTTPS `协议需要申请 `CA `证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：`Symantec`、`Comodo ` 、`DigiCert `和 `GlobalSign `等。
3. **响应速度**：`HTTP `页面响应速度比 `HTTPS `快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。
4. **加密**：`HTTP`协议运行在`TCP`（三次握手）之上，所有传输的内容都是明文，`HTTPS`运行在`SSL/TLS`之上，`SSL/TLS`运行在`TCP`之上，所有传输的内容都经过加密的。
5. **端口不同**：`HTTPS `和 `HTTP `使用的是完全不同的连接方式，用的端口也不一样，前者是 `443`，后者是 `80`。

| HTTP                             | HTTPS                                  |
| -------------------------------- | -------------------------------------- |
| 默认端口80                       | 默认端口443                            |
| 明文传输、数据未加密、安全性较差 | 传输协议ssl加密、安全性较好            |
| 响应速度快，消耗资源少           | 响应速度慢、消耗资源多，需要用到CA证书 |

#### 5. HTTPS 的缺点：

1. 在相同网络环境中，`HTTPS `相比 `HTTP `无论是响应时间还是耗电量都有大幅度上升。
2. `HTTPS `的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。
3. 在现有的证书机制下，中间人攻击依然有可能发生。
4. `HTTPS `需要更多的服务器资源，也会导致成本的升高。

#### 6. HTTPS链接建立的过程：

1. 首先客户端先给服务器发送一个请求
2. 服务器发送一个`SSL`证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥
3. 客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密
4. 服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端
5. 随后客户端和服务端就使用对称密钥进行信息传输

---

![HTTPS 加密、解密、验证及数据传输过程](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220327225658.png)

加密流程按图中的序号分为:

1. 客户端请求`HTTPS`网址，然后连接到`server`的443端口(`HTTPS`默认端口，类似于`HTTP`的80端口)。
2. 采用`HTTPS`协议的服务器必须要有一套数字`CA `(Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带-一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。
3. 服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。
4. 客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一一个随机码`KEY`,并使用公钥A将其加密。
5. 客户端把加密后的随机码`KEY`发送给服务器，作为后面对称加密的密钥。
6. 服务器在收到随机码`KEY`之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。
7. 服务器使用密钥(随机码`KEY`)对数据进行对称加密并发送给客户端，客户端使用相同的密钥(随机码`KEY`)解密数据。
8. 双方使用对称加密愉快地传输所有数据。

#### 7. HTTP常见响应状态码

`100`：Continue 一一 继续。客户端应继续其请求。

`200`：OK 一一 请求成功。一 般用于GET与POST请求。

`301`：Moved Permanently 一一 永久重定向。

`302`：Found 一一 暂时重定向。

`400`：Bad Request 一一 客户端请求的语法错误，服务器无法理解。请求没有包含host头

`403`：Forbideen 一一 服务器理解请求客户端的请求，但是拒绝执行此请求。禁止客户访问该资源

`404`：Not Found 一一 服务器无法根据客户端的请求找到资源（网页）。资源未找到

`500`：Internal Server Error 一一 服务器内部错误，无法完成请求。

`502`：Bad Gateway 一一 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。

#### 8. 状态码301和302的区别是什么?

`301`为永久重定向，`302`为临时重定向

**共同点**: `301`和`302`状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取(用户看到的效果就是他输入的地址A瞬间变成了另一个地址B)。

**不同点**: `301`表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址;`302`表示旧地址A的资源还在(仍然可以访问)，这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO中`302`好于`301`。

补充，重定向原因:

1. 网站调整(如改变网页目录结构);
2. 网页被移到一个新地址;
3. 网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

#### 9. 对称加密算法与非对称加密算法的区别

**对称加密算法：**

双方持有相同的密钥，且加密速度快，典型对称加密算法：`DES`、`AES`

**非对称加密算法：**

密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：`AES`、`DSA`

#### 10. HTTP请求方法：

| 方法    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| GET     | 像特定资源发送请求，查询数据，并返回实体                     |
| POST    | 向指定资源提交数据进行处理，可能会导致新的资源建立、已有的资源修改 |
| PUT     | 向服务器上传新的内容                                         |
| HEAD    | 类似GET请求，返回的响应式中没有具体内容，用于获取报头        |
| DELETE  | 请求服务器删除指定标识的资源                                 |
| OPTIONS | 可以原来向服务器发送请求来测试服务器的功能性                 |
| TRACE   | 回显服务器收到的请求，用于测试和诊断                         |
| CONNECT | HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器       |

#### 11. Get和Post请求区别

|          | GET                                                        | POST                                                  |
| -------- | ---------------------------------------------------------- | ----------------------------------------------------- |
| HTTP规范 | GET用于信息获取                                            | 修改服务器上的资源的请求                              |
| 可见性   | 数据在URL中对所有人可见                                    | 数据不会显示在URL中                                   |
| 安全性   | 与post相比，get的安全性较差，因为所发送的数据是URL的一部分 | 安全，因为参数不会被保存在浏览器历史或web服务器日志中 |
| 数据长度 | 受限制，最长2kb                                            | 无限制                                                |
| 编码类型 | application/x-www-form-urlencoded                          | multipart/form-data                                   |
| 缓存     | 能被缓存                                                   | 不能被缓存                                            |

#### 12. GET 和 POST 方法都是安全和幂等的吗？

先说明下安全和幂等的概念： 

- 在 `DSA`协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。 
- 所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。

那么很明显 **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据 都是安全的，且每次的结果都是相同的。

`POST `因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据 就会创建多个资源，所以**不是幂等**的。

#### 13. 重定向和转发区别

**转发是服务器行为,重定向是客户端行为**

**重定向：redirect：**

地址栏发生变化

重定向可以访问其他站点（服务器）的资源

重定向是两次请求。不能使用request对象来共享数据

**转发：forward：**

转发地址栏路径不变

转发只能访问当前服务器下的资源

转发是一次请求，可以使用`request`对象共享数据

#### 14. Cookie和Session区别

**Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式**，但两者有所区别：

`Cookie `数据保存在客户端(浏览器端)，`Session `数据保存在服务器端。

`cookie`不是很安全，别人可以分析存放在本地的`Cookie`并进行欺骗,考虑到安全应当使用session。

`Cookie `⼀般⽤来保存⽤户信息，`Session `的主要作⽤就是通过服务端记录⽤户的状态

#### 15. 浏览器输入URL过程

**过程：**`DNS`解析、`TCP`连接、发送`HTTP`请求、服务器处理请求并返回`HTTP`报文、浏览器渲染、结束

1. 域名解析(域名www.baidu.com变为IP地址)。
   浏览器搜索自己的`DNS`缓存(维护一张域名与IP的对应表);
   1. 若没有，则搜索操作系统的`DNS`缓存(维护一张域名与IP的对应表) ;
   2. 若没有，则搜索操作系统的hosts文件(维护一张域名与IP的对应表)。
   3. 若都没有，则找TCP/IP参数中设置的首选dns服务器，即本地`DNS`服务器(递归查询)，本地域名服务器查询自己的`DNS`缓存，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。
2. 发起`TCP`的三次握手，建立`TCP`连接。浏览器会以一个随机端口(1024-65535) 向服务端的web程序80端口发起`TCP`的连接。
3. 建立`TCP`连接后发起HTTP请求。
4. 服务器响应`HTTP`请求，客户端得到`html`代码。服务器web应用程序收到`HTTP`请求后，就开始处理请求，处理之后就返回给浏览器`html`文件。
5. 浏览器解析`html`代码，并请求`html`中的资源。
6. 浏览器对页面进行渲染，并呈现给用户。

---

如何查看 TCP 的连接状态？ **TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。**

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220401215515.png)

#### 16. DNS协议是TCP还是UDP?

![](HTTPS://cdn.jsdelivr.net/gh/nateshao/images/20220330211131.png)

- `DNS`占用53号端口，同时使用`TCP`和`UDP`协议。那么`DNS`在什么情况下使用这两种协议？

  **DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。**

  - **DNS区域传输的时候使用TCP协议：**
    - 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用`TCP`而不是`UDP`，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
    - `TCP`是一种可靠连接，保证了数据的准确性。
  - **域名解析时使用UDP协议：**
    - 客户端向`DNS`服务器查询域名，一般返回的内容都不超过512字节，用`UDP`传输即可。不用经过`TCP`三次握手，这样`DNS`服务器负载更低，响应更快。虽然从理论上说，客户端也可以指定向`DNS`服务器查询的时候使用`TCP`，但事实上，很多`DNS`服务器进行配置的时候，仅支持`UDP`查询包。
  
  ![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408101037.png)
  
  ![](https://cdn.jsdelivr.net/gh/nateshao/images/20220408101042.png)

#### 17. ARP协议如何找到对应IP地址和mac的映射的

简单地说，`ARP` 是借助 `ARP`  请求与 `ARP`  响应两种类型的包确定 `MAC` 地址的。

- 主机会通过广播发送 `ARP`  请求，这个包中包含了想要知道的  `MAC` 地址的主机 IP 地址。
- 当同个链路中的所有设备收到 `ARP`  请求时，会去拆开 `ARP`  请求包里的内容，如果 `ARP`  请求包中 的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 `ARP`  响应包返回 给主机。 

操作系统通常会把第一次通过 `ARP`  获取的  `MAC` 地址缓存起来，以便下次直接从缓存中找到对应 IP 地 址的  `MAC` 地址。不过， `MAC` 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220401224806.png)

#### 18. RARP 协议你知道是什么吗？

ARP 协议是已知 IP 地址求  `MAC` 地址，那 `RARP` 协议正好相反，它是已知  `MAC`地址求 IP 地址。例如 将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。 

通常这需要架设一台 `RARP` 服务器，在这个服务器上注册设备的  `MAC` 地址及其 IP 地址。然后再将 这个设备接入到网络，接着：

- 该设备会发送一条「我的  `MAC` 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。 
- `RARP` 服务器接到这个消息后返回「 `MAC`地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个 设备。

最后，设备就根据从 `RARP` 服务器所收到的应答信息设置自己的 IP 地址

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220401224906.png)



#### 19. 什么是DDos攻击?

`DDos`全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下:

1. 客户端向服务端发送请求链接数据包。
2. 服务端向客户端发送确认数据包。
3. 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

`DDos`则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。

`DDos`攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于`DDos`攻击，预防方法有:

- 减少SYN timeout时间。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。
- 限制同时打开的SYN半连接数目。

#### 20. 什么是XSS攻击?

XSS也称cross-sitescripting,跨站脚本。这种攻击是由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入带有< script>标签的代码，导致恶意代码的执行。

预防措施有: 

- 前端：过滤。
- 后端：转义，比如go自带的处理器就具有转义功能。

#### 21. SQL注入是什么，如何避免SQL注入?
`SQL`注入就是在用户输入的字符串中加入`SQL`语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的`SQL`语句就会被数据库服务器误认为是正常的`SQL`语句而运行，攻击者就可以执行计划外的命令或访问未被授权的数据。

`SQL`注入的原理主要有以下4点：

1. 恶意拼接查询
2. 利用注释执行非法命令
3. 传入非法参数
4. 添加额外条件

避免`SQL`注入的一些方法：

1. 参数校验：在一些不该有特殊字符的参数中提前进行特殊字符校验即可。
2. 限制数据库权限，给用户提供仅仅能够满足其工作的最低权限。
3. 提供参数化查询接口，不要直接使用原生`SQL`。
3. **SQL预编译**

​	在知道了`SQL`注入的原理之后，我们同样也了解到`MySQL`有预编译的功能，指的是在服务器启动时，`MySQL` Client把`SQL`语句的模板（变量采用占位符进行占位）发送给`MySQL`服务器，`MySQL`服务器对`SQL`语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给`MySQL`服务器，直接进行执行，节省了`SQL`查询时间，以及`MySQL`服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。

​	具体是怎样防止`SQL`注入的呢？实际上当将绑定的参数传到`MySQL`服务器，`MySQL`服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的JDBC就有预编译功能，不仅提升性能，而且防止`SQL`注入。

#### 22. 网络编程socket，客户端和服务端通信过程，分别调用了哪些函数，作用是什么

- 服务器端程序：
  1. 创建一个`socket`，用函数`socket()`
  2. 绑定IP地址、端口等信息到`socket`上，用函数`bind()`
  3. 设置允许的最大连接数，用函数`listen()`
  4. 接收客户端上来的连接，用函数`accept()`
  5. 收发数据，用函数`send()`和`recv()`，或者`read()`和`write()`
  6. 关闭网络连接

- 客户端程序：
  1. 创建一个`socket`，用函数`socket()`
  2. 设置要连接的对方的IP地址和端口等属性
  3. 连接服务器，用函数`connect()`
  4. 收发数据，用函数`send()`和`recv()`，或`read()`和`write()`
  5. 关闭网络连接

#### 23. 负载均衡算法有哪些?

nginx负载均衡的三种方式主要是**轮询模式、weight权重模式、ip_hash**。

当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。

1. **轮询模式（默认）**
   每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
   适合服务器配置相当，无状态且短平快的服务使用。也适用于图片服务器集群和纯静态页面服务器集群。

2. **weight权重模式**
   这种方式比较灵活，当后端服务器性能存在差异的时候，通过配置权重，可以让服务器的性能得到充分发挥，有效利用资源。weight和访问比率成正比，用于后端服务器性能不均的情况。权重越高，在被访问的概率越大

3. **ip_hash**
   上述weight权重模式方式存在一个问题，在负载均衡系统中，假如用户在某台服务器上登录了，那么该用户第二次请求的时候，因为我们是负载均衡系统，每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的。

   可以采用ip_hash指令解决这个问题，如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器。每个请求按访问IP的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session不能跨服务器的问题。

---

**涉及到的linux命令**

- 查端口netstat -tunlp | grep 端口号
- 查进程 ps -aux | grep 进程号
- 查cpu top命令
- 查内存 free



### 什么是网络编程

- 网络编程的本质是多台计算机之间的数据交换。数据传递本身没有多大的难度，不就是把一个设备 中的数据发送给其他设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于请 求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络 编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连 接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应 连接，则需要一直启动。
- 例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。 连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一 些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是QQ、微信这类软件了。

#### 网络编程中两个主要的问题

1. 一个是如何准确的定位网络上一台或多台主机， 
2. 另一个就是找到主机后如何可靠高效的进行数据传输。

- 在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定 Internet上的一台主机。 
- 而TCP层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主 要对象，一般不需要关心IP层是如何处理数据的。
- 目前较为流行的网络编程模型是客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户 提出请求并予以响应。客户则在需要服务时向服务器提 出申请。服务器一般作为守护进程始终运 行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服 务端口，使后来的客户也 能及时得到服务。

### 网络协议是什么

在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格 式、是否需要发送一个应答信息。这些规则被称为网络协议。

#### 为什么要对网络协议分层

- 简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。 
- 灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。 
- 易于实现和维护。 
- 促进标准化工作。分开后，每层功能可以相对简单地被描述

![](https://gitee.com/nateshao/images/raw/master/img/20220104194210.png)

![](https://gitee.com/nateshao/images/raw/master/img/20220104194216.png)

TCP/IP参考模型 

TCP/IP四层协议（数据链路层、网络层、传输层、应用层）

1. **应用层** 应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网 络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。 
2.  **传输层** 建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数 据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细 节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定 的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。
3. **网络层** 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适 的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一 层就是我们经常说的IP协议层。IP协议是Internet的基础。 
4. **数据链路层** 通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现 这些规程或协议的 硬件 和软件加到物理线路，这样就构成了数据链路，

### TCP / UDP

#### 什么是TCP/IP和UDP

- TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成 对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢 失，没有重复，并且按顺序到达
- UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可 靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的 地，到达目的地的时间以及内容的正确性都是不能被保证的。

#### TCP与UDP区别：

- TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连 接传输的数据不会丢失，没有重复，并且按顺序到达； 
- UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；
-  TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；
-  UDP通信类似于学校广播，靠着广播播报直接进行通信。 TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；
-  TCP是面向字节流的，UDP是面向报文的；
-  面向字节流是指发送数据时以字节为单位，一个数据 包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。
-  TCP首部开销（20字节）比UDP首部开销（8字节）要大 UDP 的主机不需要维持复杂的连接状态表

#### TCP和UDP的应用场景

对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，实时直播，即使出现传输错误 也可以容忍；

其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情 况

#### 形容一下TCP和UDP

- TCP通信可看作打电话：

李三(拨了个号码)：喂，是王五吗？ 王五：哎，您谁啊？ 李三：我是李三，我想给你说点事儿， 你现在方便吗？ 王五：哦，我现在方便，你说吧。 甲：那我说了啊？ 乙：你说吧。 (连接建立 了，接下来就是说正事了…)

- UDP通信可看为学校里的广播：

 播音室：喂喂喂！全体操场集合

#### 运行在TCP 或UDP的应用层协议分析

- 运行在TCP协议上的协议：
  - HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
  - HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
  - FTP（File Transfer Protocol，文件传输协议），用于文件传输。
  - POP3（Post Office Protocol, version 3，邮局协议），收邮件用。 
  - SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。 
  - TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网 络。 
  - SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

- 运行在UDP协议上的协议：
  - BOOTP（Boot Protocol，启动协议），应用于无盘设备。 
  - NTP（Network Time Protocol，网络时间协议），用于网络同步。 
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

- 运行在TCP和UDP协议上：
  - DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。 
  - ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议 上）。 
  - SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的 收集和网络管理。 
  - DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。 
  - ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。

#### 什么是ARP协议 (Address Resolution Protocol)？

- **ARP协议完成了IP地址与物理地址的映射。每一个主机都设有一个 ARP 高速缓存，里面有所在的 局域网上**的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机 时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这 个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包（在发送自己的 ARP 请求 时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主 机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一 个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再 进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。
- 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的 某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。 剩下的工作就由下一个网络来做。

#### 从输入址到获得页面的过程?

**过程：**DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、**结束**

1. 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系 统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进 行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网 址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务 器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； 
2.  浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； 
3. TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应 的视图返回给浏览器； 
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并 向服务器请求这些资源； 
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。


### Socket

#### 什么是Socket

- 网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编 程界面，一个Socket由一个IP地址和一个端口号唯一确定。
-  但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。 socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立 起连接将不会主动断掉的，但是有时候网络波动还是有可能的 
- Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，

#### socket属于网络的那个层面

![](https://gitee.com/nateshao/images/raw/master/img/20220104225037.png)

- Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个外观模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简 单的接口就是全部，让Socket去组织数据，以符合指定的协议。

#### Socket通讯的过程

- 基于TCP：服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用 accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器 (connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务 器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次 交互结束。

- 基于UDP：UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不 太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出 更大的优势。我客户端只需要发送，服务端能不能接收的到我不管

#### TCP协议Socket代码示例：

先运行服务端，在运行客户端 ，

1. 服务端：

```go
package server

import (
	"fmt"
	"net"
	"strings"
	"time"
)

type server struct {
	// 网络协议类型
	networkType string
	// ip地址 + 端口
	ipAddress string
}

// NewServer 通过此函数可以得到一个 server 结构体
func NewServer(ipAddress string) server {
	if ipAddress == "" {
		ipAddress = "127.0.0.1:8088"
	}
	return server{
		// 默认值 -- 方便开发
		networkType: "tcp",
		ipAddress:   ipAddress,
	}
}

// StartServer 启动服务端的方法
func (s server) StartServer() {

	// 1. 表示使用的网络协议：tcp
	// 2. 对本机进行监听 ip为 xxx.xxx.xxx.xxx + 端口为 xxx
	listener, err := net.Listen(s.networkType, s.ipAddress)
	if err != nil {
		panic(fmt.Sprintf("服务器启动失败, err = %v \n", err))
	}

	fmt.Printf("服务器端启动成功, %v , time: %v \n", listener.Addr().String(), nowTime())

	// 服务器不断的接收客户端的信息
	for {
		conn, err := listener.Accept()
		// 客户端的信息
		remoteAddr := conn.RemoteAddr()
		if err != nil {
			fmt.Printf("客户端[%v]: %v 链接服务器端出现异常, err = %v \n", nowTime(), remoteAddr.String(), err)
			// 跳过此客户端链接不在往下执行
			continue
		}
		fmt.Printf("客户端[%v]: %v 链接服务器端成功 \n", nowTime(), remoteAddr.String())
		// 处理客户端的消息..
		// 有多个客户端链接，就有多少个协程
		go process(conn)
	}
}

// 获取当前运行的时间
func nowTime() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

// 用于处理客户端消息的函数
func process(conn net.Conn) {
	// 客户端断开链接后要及时关闭
	defer conn.Close()
	connRemoteAddr := conn.RemoteAddr().String()
	// 循环读取客户端的消息
	for {
		// 创建一个1024长度的 byte 切片用于存储客户端的消息
		bytes := make([]byte, 1024)
		// 等待客户端通过 conn 发送消息
		// 如果客户端一直没有发送，那么此协程就阻塞在这里
		readLen, err := conn.Read(bytes)
		if err != nil {
			errStr := err.Error()
			contains := strings.Contains(errStr, "An existing connection was forcibly closed by the remote host")
			if contains || errStr == "EOF" {
				fmt.Printf("客户端[%v]: %v 断开链接\n", nowTime(), connRemoteAddr)
				return
			} else {
				fmt.Printf("服务器读取客户端[%v]: %v 消息出现异常, err = %v \n", nowTime(), connRemoteAddr, err)
				return
			}
		}
		// 服务器端显示客户端的消息
		// bytes[:readLen] ==> 只打印有效的数据长度
		fmt.Printf("server[%v]-客户端[%v]说: %v\n", nowTime(), connRemoteAddr, string(bytes[:readLen]))
	}
}
```
1. 客户端：

```go
package client

import (
	"fmt"
	"net"
	"time"
)

type client struct {
	// 网络协议类型
	networkType string
	// ip地址 + 端口
	ipAddress string
	// 当前的链接
	conn net.Conn
}

// NewClient 通过此函数可以得到一个 client 结构体
func NewClient(ipAddress string) client {
	return client{
		networkType: "tcp",
		ipAddress:   ipAddress,
	}
}

// 获取当前运行的时间
func nowTime() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

// StartClient 客户端启动方法
func (c *client) StartClient() {
	conn, err := net.Dial(c.networkType, c.ipAddress)
	if err != nil {
		fmt.Printf("链接服务器端: %v ,time = %v ,出现异常 err = %v\n", c.ipAddress, nowTime(), err)
		return
	}
	fmt.Printf("[%v]链接服务器端:[%v]成功\n", nowTime(), conn.RemoteAddr().String())
	c.conn = conn
}

// SendMessage 发送消息
func (c *client) SendMessage(msg string) {
	writeLen, err := c.conn.Write([]byte(msg))
	if err != nil {
		fmt.Printf("[%v]客户端发送消息至服务器失败, err = %v\n", nowTime(), err)
		return
	}
	fmt.Printf("[%v]客户发送长度为[%d]-[%v]消息成功\n", nowTime(), writeLen, msg)
}
```
先运行服务端，在运行客户端 。测试结果发送成功

#### 6 Socket的常用类

![](https://gitee.com/nateshao/images/raw/master/img/20220104230638.png)

### 3. HTTP 

#### 什么是Http协议？

- Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文 本数据的规范，格式简称为“超文本传输协议” 
- Http协议属于应用层，及用户访问的第一层就是http

![](https://gitee.com/nateshao/images/raw/master/img/20220104230750.png)

#### Socket和http的区别和应用场景

- Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉； 
- Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。 
- http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等 待下次连接 
- http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等

#### 什么是http的请求体？

- HTTP请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器那数据，先要表明我要什 么吧
-  HTTP请求体由：请求行 、请求头、请求数据组成的， 
- **注意**：GIT请求是没有请求体的

#### HTTPS工作原理

- 一、首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一 致、证书的公钥（RSA加密）等进行校验； 
- 二、客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密 （RSA加密）； 
- 三、消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名； 
- 四、发送给服务端，此时只有服务端（RSA私钥）能解密。 
- 五、解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。

#### 一次完整的HTTP请求所经历几个步骤? 

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

1. 建立TCP连接 怎么建立连接的，看上面的三次捂手
2. Web浏览器向Web服务器发送请求行 一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。 
3. Web浏览器发送请求头 浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送 了一空白行来通知服务器，它已经结束了该头信息的发送。
4. Web服务器应答 客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议 的版本号和应答状态码。 
5. Web服务器发送应答头 类别 描述 1xx： 指示信息–表示请求已接收，正在处理 2xx： 成功–表示请求已被成功接收、理解、接受 3xx： 重定向–要完成请求必须进行更进一步的操作 4xx： 客户端错误–请求有语法错误或请求无法实现 5xx： 服务器端错误–服务器未能实现合法的请求 正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及 被请求的文档。
6. Web服务器向浏览器发送数据 Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它 就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

7. Web服务器关闭TCP连接

#### 常用HTTP状态码是怎么分类的，有哪些常见的状态码？

- HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误 等。 

- 状态码的类别：

1xx： 指示信息–表示请求已接收，正在处理 

2xx： 成功–表示请求已被成功接收、理解、接受 

3xx： 重定向–要完成请求必须进行更进一步的操作 

4xx： 客户端错误–请求有语法错误或请求无法实现 

5xx： 服务器端错误–服务器未能实现合法的请求

#### http版本的对比

- HTTP1.0版本的特性：
  - 早先1.0的HTTP版本，是一种无状态、无连接的应用层协议。 
  - HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记 录过去的请求（无状态）。

- HTTP1.1版本新特性
  - 默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直 保持连接，可以发送多次HTTP请求 
  - 管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 
  - 断点续传原理
- HTTP2.0版本的特性
  - 二进制分帧（采用二进制格式的编码将其封装） 
  - 首部压缩（设置了专门的首部压缩设计的HPACK算法。） 
  - 流量控制（设置了接收某个数据流的多少字节一些流量控制） 
  - 多路复用（可以在共享TCP链接的基础上同时发送请求和响应） 
  - 请求优先级（可以通过优化这些帧的交错和传输顺序进一步优化性能） 
  - 服务器推送（就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资 源无 需客户端明确的请求。（重大更新））

#### 什么是对称加密与非对称加密

- 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问 题，即如何安全地将密钥发给对方； 
- 而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知 道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行 解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加 密比起来，非常的慢

#### cookie和session对于HTTP有什么用？

HTTP协议本身是无法判断用户身份。所以需要cookie或者session

#### 什么是cookie

cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信 息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器

#### 什么是session

- session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。 
- 服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向 服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出 会话中存储的信息，然后确定会话的身份信息。

#### cookie与session区别

1. cookie数据存放在客户端上，安全性较差，session数据放在服务器上，安全性相对更高 
2. 单个cookie保存的数据不能超过4K，session无此限制 
3. session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应 当使用cookie。





## 参考
https://baijiahao.baidu.com/s?id=1693383134922615393&wfr=spider&for=pc