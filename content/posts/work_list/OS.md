---
title: "OS"
date: 2022-11-03T23:45:02+08:00
lastmod: 2022-11-03
tags: [OS]
categories: [OS]
slug: OS
draft: false
---

> 熟悉操作系统内存管理、进程线程、死锁等知识

- [操作系统](#操作系统)
  - [进程和线程](#进程和线程)
  - [2、协程与线程的区别？](#2协程与线程的区别)
  - [3、并发和并行有什么区别？](#3并发和并行有什么区别)
  - [4、进程与线程的切换流程？](#4进程与线程的切换流程)
  - [5、为什么虚拟地址空间切换会比较耗时？](#5为什么虚拟地址空间切换会比较耗时)
  - [多线程和单线程](#多线程和单线程)
  - [进程的组成部分](#进程的组成部分)
  - [进程的通信方式](#进程的通信方式)
  - [进程间五种通信方式的比较](#进程间五种通信方式的比较)
  - [7、进程间同步的方式有哪些？](#7进程间同步的方式有哪些)
  - [8、线程同步的方式有哪些？](#8线程同步的方式有哪些)
  - [9、线程的分类？](#9线程的分类)
  - [10、什么是临界区，如何解决冲突？](#10什么是临界区如何解决冲突)
  - [11、什么是死锁？死锁产生的条件？](#11什么是死锁死锁产生的条件)
  - [12、进程调度策略有哪几种？](#12进程调度策略有哪几种)
  - [13、进程有哪些状态？](#13进程有哪些状态)
  - [14、什么是分页？](#14什么是分页)
  - [15、什么是分段？](#15什么是分段)
  - [16、分页和分段有什区别？](#16分页和分段有什区别)
  - [17、什么是交换空间？](#17什么是交换空间)
  - [内存管理有哪几种方式](#内存管理有哪几种方式)
  - [页面置换算法](#页面置换算法)
  - [18、什么是缓冲区溢出？有什么危害？](#18什么是缓冲区溢出有什么危害)
  - [19、什么是虚拟内存？](#19什么是虚拟内存)
  - [21、硬链接和软链接有什么区别？](#21硬链接和软链接有什么区别)
  - [22、中断的处理过程?](#22中断的处理过程)
  - [23、中断和轮询有什么区别？](#23中断和轮询有什么区别)
  - [操作系统中进程调度策略有哪几种](#操作系统中进程调度策略有哪几种)
  - [死锁的4个必要条件](#死锁的4个必要条件)
  - [如何避免（预防）死锁](#如何避免预防死锁)
- [linux](#linux)
- [linux](#linux-1)
  - [linux 基础](#linux-基础)
    - [1. 什么是Linux](#1-什么是linux)
    - [2. Windows和Linux的区别](#2-windows和linux的区别)
    - [3. Unix和Linux有什么区别？](#3-unix和linux有什么区别)
    - [4. 什么是 Linux 内核？](#4-什么是-linux-内核)
    - [5. Linux的基本组件是什么？](#5-linux的基本组件是什么)
    - [6. Linux 的体系结构](#6-linux-的体系结构)
      - [为什么 Linux 体系结构要分为用户空间和内核空间的原因？](#为什么-linux-体系结构要分为用户空间和内核空间的原因)
    - [7. BASH和DOS之间的基本区别是什么？](#7-bash和dos之间的基本区别是什么)
    - [8. Linux 开机启动过程？](#8-linux-开机启动过程)
    - [9. Linux系统缺省的运行级别？](#9-linux系统缺省的运行级别)
    - [10. Linux 使用的进程间通信方式？](#10-linux-使用的进程间通信方式)
    - [11. Linux 有哪些系统日志文件？](#11-linux-有哪些系统日志文件)
    - [12. Linux系统安装多个桌面环境有帮助吗？](#12-linux系统安装多个桌面环境有帮助吗)
    - [13. 什么是交换空间？](#13-什么是交换空间)
    - [14. 什么是root帐户](#14-什么是root帐户)
    - [15. 什么是LILO？](#15-什么是lilo)
    - [16. 什么是BASH？](#16-什么是bash)
    - [17. 什么是CLI？](#17-什么是cli)
    - [18. 什么是GUI？](#18-什么是gui)
    - [20. GNU项目的重要性是什么？](#20-gnu项目的重要性是什么)
  - [磁盘、目录、文件](#磁盘目录文件)
    - [21. 简单 Linux 文件系统？](#21-简单-linux-文件系统)
    - [22. Linux 的目录结构是怎样的？](#22-linux-的目录结构是怎样的)
    - [23. 什么是 inode ？](#23-什么是-inode-)
    - [24. 什么是硬链接和软链接？](#24-什么是硬链接和软链接)
    - [25. RAID 是什么?](#25-raid-是什么)
    - [26. 一台 Linux 系统初始化环境后需要做一些什么安全工作？](#26-一台-linux-系统初始化环境后需要做一些什么安全工作)
    - [27. 什么叫 CC 攻击？什么叫 DDOS 攻击？](#27-什么叫-cc-攻击什么叫-ddos-攻击)
    - [28. 什么是网站数据库注入？](#28-什么是网站数据库注入)
    - [29. Shell 脚本是什么？](#29-shell-脚本是什么)
    - [30.如何选择 Linux 操作系统版本?](#30如何选择-linux-操作系统版本)
    - [31. 如何规划一台 Linux 主机，步骤是怎样？](#31-如何规划一台-linux-主机步骤是怎样)
    - [32. 请问当用户反馈网站访问慢，你会如何处理？](#32-请问当用户反馈网站访问慢你会如何处理)
    - [针对网站访问慢，怎么去排查？](#针对网站访问慢怎么去排查)
    - [33. Linux 性能调优都有哪几种方法？](#33-linux-性能调优都有哪几种方法)
  - [34. 基本命令](#34-基本命令)
  - [进程](#进程)
    - [1.进程和线程的区别?](#1进程和线程的区别)
    - [2.协程与线程的区别?](#2协程与线程的区别-1)
    - [并发与并行的区别是什么？](#并发与并行的区别是什么)
    - [4.进程与线程的切换流程?](#4进程与线程的切换流程-1)
    - [12.进程调度策略有哪几种?](#12进程调度策略有哪几种-1)
    - [进程有哪些状态?](#进程有哪些状态)
    - [什么是用户态和内核态?](#什么是用户态和内核态)
  - [讲一讲IO多路复用?](#讲一讲io多路复用)
    - [select、poll 和epoll之间的区别?](#selectpoll-和epoll之间的区别)
  - [软链接和硬链接有什么区别?](#软链接和硬链接有什么区别)
  - [中断的处理过程?](#中断的处理过程)
  - [1.1 Linux里如何查看一个想知道的进程？](#11-linux里如何查看一个想知道的进程)
  - [1.2 Linux里如何查看带有关键字的日志文件？](#12-linux里如何查看带有关键字的日志文件)
  - [1.3 说说你对grep命令的了解？](#13-说说你对grep命令的了解)
  - [1.4 Linux修改主机名的命令是什么？](#14-linux修改主机名的命令是什么)
  - [1.5 Linux开机自动执行命令如何实现？](#15-linux开机自动执行命令如何实现)
  - [1.6 Linux查看内存的命令是什么？](#16-linux查看内存的命令是什么)
  - [1.7 free命令有哪些选项？](#17-free命令有哪些选项)
  - [1.8 Linux中压缩文件的命令是什么？](#18-linux中压缩文件的命令是什么)
  - [1.9 Linux查询连接数的命令是什么？](#19-linux查询连接数的命令是什么)
  - [1.11 Linux中，如何通过端口查进程，如何通过进程查端口？](#111-linux中如何通过端口查进程如何通过进程查端口)
  - [1.12 请你说说ping命令？](#112-请你说说ping命令)
  - [1.13 什么是协程？](#113-什么是协程)
  - [1.14 为什么协程比线程切换的开销小？](#114-为什么协程比线程切换的开销小)
##  操作系统

### 进程和线程

1. 进程是操作系统资源分配的最小单位，线程是CPU任务调度的最小单位。一个进程可以包含多个线程，所以进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。
2. 不同进程间数据很难共享，同一进程下不同线程间数据很易共享。
3. 每个进程都有独立的代码和数据空间，进程要比线程消耗更多的计算机资源。线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
4. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉。
5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

### 2、协程与线程的区别？
- 线程和进程都是同步机制，而协程是异步机制。
- 线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
- 一个线程可以有多个协程，一个进程也可以有多个协程。
- 协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的 CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。
- 协程能保留上一次调用时的状态。
### 3、并发和并行有什么区别？
并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程 A 和 B，A 运行一个时间片之后，切换到 B，B 运行一个时间片之后又切换到 A。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。


### 4、进程与线程的切换流程？
进程切换分两步：
1. 切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。
2. 切换内核栈和硬件上下文。

对于 linux 来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1 步是不需要做的，第 2 步是进程和线程切换都要做的。因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

### 5、为什么虚拟地址空间切换会比较耗时？
进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 Cache 来缓存常用的地址映射，这样可以加速页表查找，这个 Cache 就是 TLB（translation Lookaside Buffer，TLB 本质上就是一个 Cache，是用来加速页表查找的）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后 TLB 就失效了，Cache 失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。


### 多线程和单线程

线程不是越多越好，假如你的业务逻辑全部是计算型的（CPU密集型）,不涉及到IO，并且只有一个核心。那肯定一个线程最好，多一个线程就多一点线程切换的计算，CPU不能完完全全的把计算能力放在业务计算上面，线程越多就会造成CPU利用率（用在业务计算的时间/总的时间）下降。**但是在WEB场景下，业务并不是CPU密集型任务，而是IO密集型的任务，一个线程是不合适，如果一个线程在等待数据时，把CPU的计算能力交给其他线程，这样也能充分的利用CPU资源。**但是线程数量也要有个限度，一般线程数有一个公式：最佳启动线程数=[任务执行时间/(任务执行时间-IO等待时间)]*CPU内核数超过这个数量，CPU要进行多余的线程切换从而浪费计算能力，低于这个数量，CPU要进行IO等待从而造成计算能力不饱和。总之就是要尽可能的榨取CPU的计算能力。如果你的CPU处于饱和状态，并且没有多余的线程切换浪费，那么此时就是你服务的完美状态，如果再加大并发量，势必会造成性能上的下降。

### 进程的组成部分

进程由进程控制块（PCB）、程序段、数据段三部分组成。

### 进程的通信方式

1. 无名管道：半双工的，即数据只能在一个方向上流动，只能用于具有亲缘关系的进程之间的通信，可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write 等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。
2. FIFO命名管道：FIFO是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同，FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。
3. 消息队列：消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
4. 信号量：信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
5. 共享内存：共享内存指两个或多个进程共享一个给定的存储区，一般配合信号量使用。

管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。

信号：信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

Linux 系统中常用信号：
1. SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。
2. SIGINT：程序终止信号。程序运行过程中，按 Ctrl+C 键将产生该信号。
3. SIGQUIT：程序退出信号。程序运行过程中，按 Ctrl+\\键将产生该信号。
4. SIGBUS 和 SIGSEGV：进程访问非法地址。
5. SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。
6. SIGKILL：用户终止进程执行信号。shell 下执行 kill -9 发送该信号。
7. SIGTERM：结束进程信号。shell 下执行 kill 进程 pid 发送该信号。
8. SIGALRM：定时器信号。
9. SIGCLD：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。

信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

消息队列：消息队列是消息的链接表，包括 Posix 消息队列和 System V 消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。

共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。


Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。


优缺点：
- 管道：速度慢，容量有限；
- Socket：任何进程间都能通讯，但速度慢；
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；
- 信号量：不能传递复杂消息，只能用来同步；
- 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。
### 进程间五种通信方式的比较

1. 管道：速度慢，容量有限，只有**父子进程能通讯。**
2. FIFO：任何进程间都能通讯，但速度慢。
3. 消息队列：**容量受到系统限制，且要**注意**第一次读的时候，要考虑上一次没有读完数据的问题。**
4. 信号量：不能传递复杂消息，只能用来同步。
5. 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要**注意**读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。


### 7、进程间同步的方式有哪些？
临界区：
- 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
- 优点：保证在某一时刻只有一个线程能访问数据的简便办法。
- 缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。

互斥量：
- 为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。
- 优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。
- 缺点： 
   - 互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。
   - 通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。

信号量：
- 为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1 就是互斥量了。
- 优点：适用于对 Socket（套接字）程序中线程的同步。
- 缺点:
   - 信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；
   - 信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；
   - 核心操作 P-V 分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。

事件：
- 用来通知线程有一些事件已发生，从而启动后继任务的开始。
- 优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。


### 8、线程同步的方式有哪些？
- 临界区：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操作共享资源的目的。
- 事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。
- 互斥量：互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。
- 信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。

区别：
- 互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。
- 互斥量，信号量，事件都可以被跨越进程使用来进行同步数据操作。

### 9、线程的分类？
从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）内核级线程：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。比如英特尔 i5-8250U 是 4 核 8 线程，这里的线程就是内核级线程用户级线程：它仅存在于用户级中，这种线程是不依赖于操作系统核心的。应用进程利用线程库来完成其创建和管理，速度比较快，操作系统内核无法感知用户级线程的存在。
### 10、什么是临界区，如何解决冲突？
每个进程中访问临界资源的那段程序称为临界区，一次仅允许一个进程使用的资源称为临界资源。

解决冲突的办法：
- 如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；
- 进入临界区的进程要在有限时间内退出。
- 如果进程不能进入自己的临界区，则应让出 CPU，避免进程出现“忙等”现象。

### 11、什么是死锁？死锁产生的条件？
什么是死锁：
- 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个必要条件：（有一个条件不成立，则不会产生死锁）
- 互斥条件：一个资源一次只能被一个进程使用
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
- 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
- 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

如何处理死锁问题：
- 忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。
- 检测死锁并且恢复。
- 仔细地对资源进行动态分配，以避免死锁。
- 通过破除死锁四个必要条件之一，来防止死锁产生。


### 12、进程调度策略有哪几种？
- 先来先服务：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对 I/O 密集型进程也不利，因为这种进程每次进行 I/O 操作之后又得重新排队。
- 短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
- 最短剩余时间优先：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

- 时间片轮转：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
   - 时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。

- 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级

### 13、进程有哪些状态？
进程一共有 5 种状态，分别是创建、就绪、运行（执行）、终止、阻塞。
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20221118231122.png)
- 运行状态就是进程正在 CPU 上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
- 就绪状态就是说进程已处于准备运行的状态，即进程获得了除 CPU 之外的一切所需资源，一旦得到 CPU 即可运行。
- 阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待 I/O 完成。即使 CPU 空闲，该进程也不能运行。

- 运行态→阻塞态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。
- 阻塞态→就绪态：则是等待的条件已满足，只需分配到处理器后就能运行。
- 运行态→就绪态：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。
- 就绪态→运行态：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。

### 14、什么是分页？
把内存空间划分为大小相等且固定的块，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。

访问分页系统中内存数据需要两次的内存访问 (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20221118231207.png)

### 15、什么是分段？
分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。分段内存管理当中，地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从 0 开始编址的。

由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20221118231239.png)

### 16、分页和分段有什区别？
- 分页对程序员是透明的，但是分段需要程序员显式划分每个段。
- 分页的地址空间是一维地址空间，分段是二维的。
- 页的大小不可变，段的大小可以动态改变。
- 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

### 17、什么是交换空间？
操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为页(page)。当内存资源不足时，Linux 把某些页的内容转移至硬盘上的一块空间上，以释放内存空间。硬盘上的那块空间叫做交换空间(swap space),而这一过程被称为交换(swapping)。物理内存和交换空间的总容量就是虚拟内存的可用容量。

用途：
- 物理内存不足时一些不常用的页可以被交换出去，腾给系统。
- 程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。

### 内存管理有哪几种方式

1. 块式管理：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
2. 页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
3. 段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
4. 段页式管理：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。

### 页面置换算法
在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

1. 最佳置换算法OPT：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。
2. 先进先出置换算法FIFO：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。
3. 最近最久未使用算法LRU：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方可以采用寄存器或者栈的方式实现)。
4. 时钟算法clock(也被称为是最近未使用算法NRU)：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。
5. 改进型Clock算法：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改为1的页面。
6. LFU最少使用算法LFU：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。

### 18、什么是缓冲区溢出？有什么危害？
缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。

危害有以下两点：
- 程序崩溃，导致拒绝额服务
- 跳转并且执行一段恶意代码

造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。

### 19、什么是虚拟内存？
虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。

### 21、硬链接和软链接有什么区别？
⚫ 硬链接就是在目录下创建一个条目，记录着文件名与 inode 编号，这个inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。
⚫ 符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接。

### 22、中断的处理过程?
⚫ 保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。
⚫ 开中断：以便执行中断时能响应较高级别的中断请求。
⚫ 中断处理
⚫ 关中断：保证恢复现场时不被新中断打扰
⚫ 恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。

### 23、中断和轮询有什么区别？
⚫ 轮询：CPU 对特定设备轮流询问。中断：通过特定事件ᨀ醒 CPU。
⚫ 轮询：效率低等待时间长，CPU 利用率不高。中断：容易遗漏问题，CPU 利用率不高。

### 操作系统中进程调度策略有哪几种

1. 先来先服务调度算法FCFS：队列实现，非抢占，先请求CPU的进程先分配到CPU，可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度，对于长作业比较有利.
2. 最短作业优先调度算法SJF：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行，平均等待时间最短，但难以知道下一个CPU区间长度；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱.
3. 优先级调度算法(可以是抢占的，也可以是非抢占的)：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿.
4. 时间片轮转调度算法(可抢占的)：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

### 死锁的4个必要条件

1. 互斥条件：一个资源每次只能被一个线程使用；
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；
3. 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。   

### 如何避免（预防）死锁

1. 破坏“请求和保持”条件：让进程在申请资源时，一次性申请所有需要用到的资源，不要一次一次来申请，当申请的资源有一些没空，那就让线程等待。不过这个方法比较浪费资源，进程可能经常处于饥饿状态。还有一种方法是，要求进程在申请资源前，要释放自己拥有的资源。
2. 破坏“不可抢占”条件：允许进程进行抢占，方法一：如果去抢资源，被拒绝，就释放自己的资源。方法二：操作系统允许抢，只要你优先级大，可以抢到。
3. 破坏“循环等待”条件：将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序提出（指定获取锁的顺序，顺序加锁）。


## linux

##  linux

### linux 基础
#### 1. 什么是Linux

Linux是一套免费使用和自由传播的类似Unix操作系统，一般的WEB项目都是部署都是放在Linux 操作系统上面。 Linux是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系 统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了 Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。



#### 2. Windows和Linux的区别

- Windows是微软开发的操作系统，民用操作系统，可用于娱乐、影音、上网。 Windows操作系统 具有强大的日志记录系统和强大的桌面应用。好处是它可以帮我们实现非常多绚丽多彩的效果，可 以非常方便去进行娱乐、影音、上网。
- Linux的应用相对单纯很多，没有什么绚丽多彩的效果，因此Linux的性能是非常出色的，可以完 全针对机器的配置有针对性的优化，
- 简单来说Windows适合普通用户进行娱乐办公使用，Linux适合软件开发部署

#### 3. Unix和Linux有什么区别？

- Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至 有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区 别。

1. 开源性 Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的 传统商业软件，使用需要付费授权使用。
2. 跨平台性 Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能 较弱，大多需与硬件配套使用。 
3. 可视化界面 Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。 
4. 硬件环境 Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度 较大。
5. 用户群体 Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高 的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。 相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作 系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源 免费的特性，更容易普及使用！

#### 4. 什么是 Linux 内核？

Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根 据需要执行软件。

1. 系统内存管理

2. 应用程序管理

3. 硬件设备管理

4. 文件系统管理

   

#### 5. Linux的基本组件是什么？ 

就像任何其他典型的操作系统一样，Linux拥有所有这些组件：内核，shell和GUI，系统实用程序 和应用程序。Linux比其他操作系统更具优势的是每个方面都附带其他功能，所有代码都可以免费 下载。



#### 6. Linux 的体系结构 

从大的方面讲，Linux 体系结构可以分为两块：



![](https://gitee.com/nateshao/images/raw/master/img/20220105104041.png)

- 用户空间(User Space) ：用户空间又包括用户的应用程序(User Applications)、C 库(C Library) 。 
- 内核空间(Kernel Space) ：内核空间又包括系统调用接口(System Call Interface)、内核(Kernel)、 平台架构相关的代码(Architecture-Dependent Kernel Code) 。

##### 为什么 Linux 体系结构要分为用户空间和内核空间的原因？

1、现代 CPU 实现了不同的工作模式，不同模式下 CPU 可以执行的指令和访问的寄存器不同。

2、Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了两部分。

用户空间和内核空间是程序执行的两种不同的状态，我们可以通过两种方式完成用户空间到内核空 间的转移： 

- 系统调用； 
- 硬件中断。

#### 7. BASH和DOS之间的基本区别是什么？

BASH和DOS控制台之间的主要区别在于3个方面：

- BASH命令区分大小写，而DOS命令则不区分; 
  - 在BASH下，/ character是目录分隔符，\作为转义字符。在DOS下，/用作命令参数分隔 符，\是目录分隔符 

- DOS遵循命名文件中的约定，即8个字符的文件名后跟一个点，扩展名为3个字符。BASH没 有遵循这样的惯例。

#### 8. Linux 开机启动过程？

1、主机加电自检，加载 BIOS 硬件信息。

2、读取 MBR 的引导文件(GRUB、LILO)。 

3、引导 Linux 内核。 

4、运行第一个进程 init (进程号永远为 1 )。 

5、进入相应的运行级别。 

6、运行终端，输入用户名和密码。

#### 9. Linux系统缺省的运行级别？

- 关机。 
- 单机用户模式。 
- 字符界面的多用户模式(不支持网络)。 
- 字符界面的多用户模式。 
- 未分配使用。 
- 图形界面的多用户模式。 
- 重启。

#### 10. Linux 使用的进程间通信方式？

1、管道(pipe)、流管道(s_pipe)、有名管道(FIFO)。 

2、信号(signal) 。 

3、消息队列。 

4、共享内存。 

5、信号量。 

6、套接字(socket) 。

#### 11. Linux 有哪些系统日志文件？

比较重要的是 /var/log/messages 日志文件。

> 该日志文件是许多进程日志文件的汇总，从该文件可以看出任何入侵企图或成功的入侵。 另外，如果胖友的系统里有 ELK 日志集中收集，它也会被收集进去。

#### 12. Linux系统安装多个桌面环境有帮助吗？

通常，一个桌面环境，如KDE或Gnome，足以在没有问题的情况下运行。尽管系统允许从一个环 境切换到另一个环境，但这对用户来说都是优先考虑的问题。有些程序在一个环境中工作而在另一 个环境中无法工作，因此它也可以被视为选择使用哪个环境的一个因素。

#### 13. 什么是交换空间？

交换空间是Linux使用的一定空间，用于临时保存一些并发运行的程序。当RAM没有足够的内存来 容纳正在执行的所有程序时，就会发生这种情况。

#### 14. 什么是root帐户

root帐户就像一个系统管理员帐户，允许你完全控制系统。你可以在此处创建和维护用户帐户，为 每个帐户分配不同的权限。每次安装Linux时都是默认帐户。

#### 15. 什么是LILO？

LILO是Linux的引导加载程序。它主要用于将Linux操作系统加载到主内存中，以便它可以开始运 行。

#### 16. 什么是BASH？

BASH是Bourne Again SHell的缩写。它由Steve Bourne编写，作为原始Bourne Shell（由/ bin / sh表示）的替代品。它结合了原始版本的Bourne Shell的所有功能，以及其他功能，使其更容易 使用。从那以后，它已被改编为运行Linux的大多数系统的默认shell。

#### 17. 什么是CLI？

- 命令行界面（英语：command-line interface，缩写]：CLI）是在图形用户界面得到普及之前使 用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以 执行。也有人称之为字符用户界面（CUI）。

- 通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面 的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节 约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速 度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。

#### 18. 什么是GUI？

- 图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显 示的计算机操作用户界面。

- 图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的 图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文 本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。

#### 20. GNU项目的重要性是什么？

这种所谓的自由软件运动具有多种优势，例如可以自由地运行程序以及根据你的需要自由学习和修 改程序。它还允许你将软件副本重新分发给其他人，以及自由改进软件并将其发布给公众。

### 磁盘、目录、文件

#### 21. 简单 Linux 文件系统？

在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出 设备、普通文件或是目录都被看作是一个文件。

- 也就是说在 Linux 系统中有一个重要的概念：一切都是文件。其实这是 Unix 哲学的一个体现，而 Linux 是重写 Unix 而来，所以这个概念也就传承了下来。在 Unix 系统中，把一切资源都看作是 文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就 可以用读写文件的方式实现对硬件的访问。

- Linux 支持 5 种文件类型，如下图所示：

#### 22. Linux 的目录结构是怎样的？

Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：

![](https://gitee.com/nateshao/images/raw/master/img/20220105160919.png)

**常见目录说明**

![](https://gitee.com/nateshao/images/raw/master/img/20220105161045.png)

#### 23. 什么是 inode ？

> 一般来说，面试不会问 inode 。但是 inode 是一个重要概念，是理解 Unix/Linux 文件系统和硬 盘储存的基础。

- 理解inode，要从文件储存说起。 
- 文件储存在硬盘上，硬盘的最小存储单位叫做"扇区"（Sector）。每个扇区储存512字节（相当于 0.5KB）。 
- 操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇 区，即一次性读取一个"块"（block）。这种由多个扇区组成的"块"，是文件存取的最小单 位。"块"的大小，最常见的是4KB，即连续八个 sector组成一个 block。
-  文件数据都储存在"块"中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的 创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名 为"索引节点"。 
- 每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。

#### 24. 什么是硬链接和软链接？

**硬链接**：由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针， 指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接 数就加 1 。

不足： 

1. 不可以在不同文件系统的文件间建立链接； 
2. 只有超级用户才可以为目录创建硬链接。

**软链接**：软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符 号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件 进行链接。

不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录 中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移； 还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。

#### 25. RAID 是什么?

RAID 全称为独立磁盘冗余阵列(Redundant Array of Independent Disks)，基本思想就是把多个 相对便宜的硬盘组合起来，成为一个硬盘阵列组，使性能达到甚至超过一个价格昂贵、 容量巨大 的硬盘。RAID 通常被用在服务器电脑上，使用完全相同的硬盘组成一个逻辑扇区，因此操作系统 只会把它当做一个硬盘。 RAID 分为不同的等级，各个不同的等级均在数据可靠性及读写性能上做了不同的权衡。在实际应 用中，可以依据自己的实际需求选择不同的 RAID 方案。

当然，因为很多公司都使用云服务，大家很难接触到 RAID 这个概念，更多的可能是普通云盘、 SSD 云盘酱紫的概念。

#### 26. 一台 Linux 系统初始化环境后需要做一些什么安全工作？

1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。

> 修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。

2、服务器使用密钥登陆，禁止密码登陆。 

3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。 

4、装 fail2ban 这种防止 SSH 暴力破击的软件。 

5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要) 也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。 

6、修改历史命令记录的条数为 10 条。 

7、只允许有需要的服务器可以访问外网，其它全部禁止。 

8、做好软件层面的防护。 

1. 设置 nginx_waf 模块防止 SQL 注入。 
2. 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。

#### 27. 什么叫 CC 攻击？什么叫 DDOS 攻击？

- CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资 源消耗殆尽。 
- DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击 平台，来对一个或多个目标发动 DDOS 攻击。

> 攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。

怎么预防 CC 攻击和 DDOS 攻击？ 

- 防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。 

  > 流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般 是买服务，毕竟攻击不会是持续长时间。

#### 28. 什么是网站数据库注入？

- 由于程序员的水平及经验参差不齐，大部分程序员在编写代码的时候，没有对用户输入数据的合法 性进行判断。 
- 应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想 得知的数据，这就是所谓的 SQL 注入。 
- SQL注入，是从正常的 WWW 端口访问，而且表面看起来跟一般的 Web 页面访问没什么区别，如 果管理员没查看日志的习惯，可能被入侵很长时间都不会发觉。

#### 29. Shell 脚本是什么？

一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个 命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工 作任务。

#### 30.如何选择 Linux 操作系统版本?

一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。

- 安全性要求较高，则选择 Debian 或者 FreeBSD 。
-  需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。 
- 想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布 版本。 
- 【重点】根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现 在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束。
-  CentOS 7 系列，也慢慢使用的会比较多了。

#### 31. 如何规划一台 Linux 主机，步骤是怎样？

1、确定机器是做什么用的，比如是做 WEB 、DB、还是游戏服务器。 

> 不同的用途，机器的配置会有所不同。 

2、确定好之后，就要定系统需要怎么安装，默认安装哪些系统、分区怎么做。 

3、需要优化系统的哪些参数，需要创建哪些用户等等的。

#### 32. 请问当用户反馈网站访问慢，你会如何处理？

有哪些方面的因素会导致网站网站访问慢？

**1、服务器出口带宽不够用** 

- 本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口 带宽就小，访问速度自然就会慢。 
- 跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是 长城宽带或联通，这也可能导致带宽的缩减。

**2、服务器负载过大，导致响应不过来** 

可以从两个方面入手分析：

- 分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。
- 如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分 析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访 问等。

**3、数据库瓶颈**

- 如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。 
- 如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。

**4、网站开发代码没有优化好** 

- 例如 SQL 语句没有优化，导致数据库读写相当耗时。

#### 针对网站访问慢，怎么去排查？

1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看 看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。 

> 不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。

2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片 加载慢，还是某些数据加载慢。 

3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主 机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。 

4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看 看是不是某条 SQL 语句查询慢，导致网站访问慢。

**怎么去解决？**

1、如果是出口带宽问题，那么久申请加大出口带宽。 

2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。 

3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主 从，一台 MySQL 服务器负责写，其他几台从数据库负责读。 

4、申请购买 CDN 服务，加载用户的访问。 

5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同 一个服务。

#### 33. Linux 性能调优都有哪几种方法？

1、Disabling daemons (关闭 daemons)。 

2、Shutting down the GUI (关闭 GUI)。 

3、Changing kernel parameters (改变内核参数)。 

4、Kernel parameters (内核参数)。 

5、Tuning the processor subsystem (处理器子系统调优)。 

6、Tuning the memory subsystem (内存子系统调优)。 

7、Tuning the file system (文件系统子系统调优)。 

8、Tuning the network subsystem（网络子系统调优)。

### 34. 基本命令

cd （change directory：英文释义是改变目录）切换目录

```shell
cd ../ ;跳到上级目录
cd /opt ;不管现在到那直接跳到指定的opt文件夹中
cd ~ ;切换当前用户的家目录。root用户的家目录就是root目录。
```
pwd （print working directory：显示当前工作目录的绝对路径）

```shell
pwd
显示当前的绝对路径
```
ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名）

```shell
ls -a ;显示所有文件夹,隐藏文件也显示出来
ls -R ;连同子目录一起列出来
```
ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间, 是否可读写等信息）

```shell
ll -a ;显示所有文件,隐藏文件也显示出来
ll -R ;连同子目录内容一起列出来
ll -h ;友好展示详情信息,可以看大小
ll -al ;即能显示隐藏文件又能显示详细列表。
```
touch （touch：创建文件）创建文件 

```shell
touch test.txt ;创建test.txt文件
touch /opt/java/test.java ;在指定目录创建test.java文件
```
mkdir （mkdir：创建目录） 创建目录 

```shell
mkdir 文件夹名称 ;在此目录创建文件夹
mkdir /opt/java/jdk ;在指定目录创建文件夹
```
cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内 容）（不能快速定位到最后一页）

```shell
cat lj.log ;快捷查看文件命令
Ctrl + c ;暂停显示文件
Ctrl + d ;退出查看文件命令
```
more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页）

```shell
回车：向下n行，需要定义，默认为1行。
空格键：向下滚动一屏或Ctrl+F
B：返回上一层或Ctrl+B
q：退出more
```
less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页）

```shell
less -m 显示类似于more命令的百分比。
less -N 显示每行的行号。(大写的N)
两参数一起使用如：less -mN 文件名，如此可分页并显示行号。
空格键：前下一页或page down。
回车：向下一行。
b：后退一页 或 page up。
q：退出。
d：前进半页。
u：后退半页
```
tail（尾巴） 查看文件命令（看最后多少行）

```shell
tail -10 ;文件名 看最后10行
```
cp（copy单词缩写，复制功能） 

```shell
cp /opt/java/java.log /opt/logs/ ;把java.log 复制到/opt/logs/下
cp /opt/java/java.log /opt/logs/aaa.log ;把java.log 复制到/opt/logs/下并且改名为
aaa.log
cp -r /opt/java /opt/logs ;把文件夹及内容复制到logs文件中
```
mv（move单词缩写，移动功能，该文件名称功能） 

```shell
mv /opt/java/java.log /opt/mysql/ ;移动文件到mysql目录下
mv java.log mysql.log ;把java.log改名为mysql.log
```
rm（remove：移除的意思）删除文件，或文件夹

```shell
-f或--force 强制删除文件或目录。删除文件不包括文件夹的文件
-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。
-rf 强制删除文件夹及内容
rm 文件名 ;安全删除命令 （yes删除 no取消）
rm -rf 强制删除文件夹及内容
rm -rf * 删除当前目录下的所有内容。
rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。
```
find （find：找到的意思）查找指定文件或目录

```shell
* 表示0~多个任意字符。
find -name 文件名;按照指定名称查找在当前目录下查找文件
find / -name 文件名按照指定名称全局查找文件
find -name '*文件名' ;任意前缀加上文件名在当前目录下查找文件
find / -name '*文件名*' ;全局进行模糊查询带文件名的文件
```
vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操 作） vim （VI IMproved：改进版视觉）改进版文本编辑器 （不管是文件查看还是文件编辑 按 Shift + 上或 者下可以上下移动查看视角）

```shell
输入”vim 文件名” 打开文件，刚刚时是”一般模式”。
一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退
出）等。
插入模式：可以编辑文件内容。
底行模式：可以进行强制退出操作,不保存 :q!
可以进行保存并退出操作 :wq
按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。
在编辑模式下按”Esc” 即可到一般模式
在一般模式下按”:”，冒号进入底行模式。
在一般模式下的快捷键
dd ;删除一整行
X ;向前删除 等同于windowns系统中的删除键
x ;向后删除和大写x相反方向
Ctrl + f ;向后看一页
Ctrl + b ;向前看一页
u ;撤销上一步操作
/word ;向下查找word关键字 输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过
n的方向相反）
?log ;向上查找log关键字 输入:n查找上一个,N查找下一个
:1,90s/redis/Redis/g ;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1
代表其实行,n2代表结尾行,g是必须要的
:0 ;光标移动到第一行
:$ ;光标移动到最后一行
:300 ;光标移动到300行,输入多少数字移动到多少行
:w ;保存
:w! ;强制保存
:q ;退出
:q! ;强制退出
5dd ;删除后面5行,打一个参数为自己填写
5x ;删除此光标后面5个字符
d1G ;删除此光标之前的所有
d0 ;从光标当前位置删除到此行的第一个位置
yy ;复制
p ;在光标的下面进行粘贴
P ;在光标的上门进行粘贴
```
管道命令（把多个命令组合起来使用）

```shell
管道命令的语法：命令1 | 命令2 | 命令3。
```
grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过

```shell
单独使用：
grep String test.java ；在test.java文件中查找String的位置，返回整行
一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用）
ps aux|grep java ；查找带java关键字的进程
ll |grep java ；查找带java关键字的文件夹及文件
```
yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件）

```shell
#（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉
文件
#等待下载完了就可以输入：
rz 从win系统中选择文件上传到Linux系统中
sz 文件名 选择Linux系统的文件复制到win系统中
```
tar （解压 压缩 命令）

```shell
常用的组合命令：
-z 是否需要用gzip压缩。
-c 建立一个压缩文件的参数指令(create) –压缩
-x 解开一个压缩文件的参数指令(extract) –解压
-v 压缩的过程中显示文件(verbose)
-f 使用档名，在f之后要立即接档中(file)
常用解压参数组合：zxvf
常用压缩参数组合：zcvf
解压命令：
tar -zxvf redis-3.2.8.tar.gz ；解压到当前文件夹
tar -zxvf redis-3.2.8.tar.gz -C /opt/java/ ；解压到指定目录
压缩命令：（**注意** 语法有点反了，我反正每次都搞反）
tar -zcvf redis-3.2.8.tar.gz redis-3.2.8/ ;语法 tar -zcvf 压缩后的名称 要压缩的
文件
tar -zcvf 压缩后的文件（可指定目录） 要压缩的文件（可指定目录）
```
ps （process status：进程状态，类似于windows的任务管理器）

```shell
常用组合：ps -ef 标准的格式查看系统进程
ps -aux BSD格式查看系统进程
ps -aux|grep redis BSD格式查看进程名称带有redis的系统进程（常用技巧）
//显示进程的一些属性,需要了解（ps aux）
USER //用户名
PID //进程ID号,用来杀死进程的
%CPU //进程占用的CPU的百分比
%MEM //占用内存的的百分比
VSZ //该进程使用的虚拟內存量（KB）
RSS //该进程占用的固定內存量（KB）
STAT //进程的状态
START //该进程被触发启动时间
TIME //该进程实际使用CPU运行的时间
```
clear 清屏命令。（强迫症患者使用）

```shell
kill 命令用来中止一个进程。（要配合ps命令使用，配合pid关闭进程）
（ps类似于打开任务管理器，kill类似于关闭进程）
kill -5 进程的PID ;推荐,和平关闭进程
kill -9 PID ;不推荐,强制杀死进程

```
ifconfig命令 

```shell
用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。（一般是
用来查看的，很少更改）
如果此命令输入无效，先输入yum -y install net-tools
ifconfig
```

ping （用于检测与目标的连通性）语法：ping ip地址 

```shell
测试：
1、在Windows操作系统中cmdipconfig，查看本机IP地址：
2、再到LInux系统中输入 ping ip地址
（公司电脑，我就不暴露Ip了,没图片 自己去试）
按Ctrl + C 可以停止测
```

free 命令 （显示系统内存）

```shell
#显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。
-b 以Byte显示内存使用情况
-k 以kb为单位显示内存使用情况
-m 以mb为单位显示内存使用情况
-g 以gb为单位显示内存使用情况
-s<间隔秒数> 持续显示内存
-t 显示内存使用
```
top 命令

```shell
#显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等
-c 显示完整的进程命令
-s 保密模式
-p <进程号> 指定进程显示
-n <次数>循环显示
```
netstat 命令

```shell
#Linux netstat命令用于显示网络状态。
#利用netstat指令可让你得知整个Linux系统的网络情况。
#语法：
netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]
```
file （可查看文件类型）

file 文件名

重启linux 

```shell
Linux centos 重启命令：reboot
```
关机linux 

```shell
Linux centos 关机命令：halt
```
同步时间命令 

```shell
ntpdate ntp1.aliyun.com
```
更改为北京时间命令 

```shell
rm -rf /etc/localtime
ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
```
查看时间命令： 

```shell
date
```

### 进程
1. **进程**
   进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销(栈、寄器、虚拟内存、文件句柄等)比较大，但相对比较稳定安全。
2. **线程**
   线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。
3. **协程**
   协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

#### 1.进程和线程的区别?

一个程序至少有一个进程，一个进程至少有一个线程

- **从系统调度上看**：进程是资源管理的基本单位，线程是程序执行的基本单位。
- **从上下文切换上看**：线程上下文切换比进程上下文切换要快得多。
- **从系统开销上看**：创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。

#### 2.协程与线程的区别?

- 一个线程可以有多个协程，一个进程也可以有多个协程。线程和进程都是同步机制，而协程是异步机制。

- **协程是由程序自身控制**，没有线程切换的开销，执行效率非常高

- 协程**不需要多线程的锁机制**：**在协程中控制共享资源不加锁**，只需要判断状态就好了，所以执行效率比多线程高很多。

- 线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

- 协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。

  

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220328113326.jpeg)

#### 并发与并行的区别是什么？

你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。

你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。

你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

并发的关键是你有处理多个任务的能力，不一定要同时。

并行的关键是你有同时处理多个任务的能力。

所以我认为它们最关键的点就是：**是否是『同时』**。

#### 4.进程与线程的切换流程?

进程切换分两步:

1. 切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。
2. 切换内核栈和硬件上下文。

对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。
因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

#### 12.进程调度策略有哪几种? 

> 先来先服务，短作业优先，最短剩余时间优先，时间片轮转，优先级调度。

- **先来先服务**：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一 直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I/o密集型进程也不利，因为这种进程每次进行I/o操作之后又得重新排队。
- 短作业优先：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于-直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
- 最短剩余时间优先：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一.个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。
- 时间片轮转：将所有就绪进程按FCFS的原则排成一一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把CPU时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系:因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。
- 优先级调度：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 进程有哪些状态?

进程一共有5种状态，分别是新建、就绪、运行、阻塞、终止。

#### 什么是用户态和内核态?

用户态和系统态是操作系统的两种运行状态:

- 用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的CPU不允许独占，也就是说CPU能够被其他程序获取。
- 内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的CPU可以从一个程序切换到另外一个程序，并且占用CPU不会发生抢占情况。

将操作系统的运行状态分为用户态和内核态，主要是为了对访问能力进行限制，防止随意进行一些比较危险的操作导致系统的崩溃，比如设置时钟、内存清理，这些都需要在内核态下完成。

### 讲一讲IO多路复用?

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合:

- 当客户处理多个描述字时(一般是交互式输入和网络套接口)，必须使用I/O复用。.
- 当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。
- 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。
- 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。
- 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。
- 与多进程和多线程技术相比，IO多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

---

**IO多路复用模型指的是：使用单个线程同时处理多个网络连接IO，他的原理就是select、poll、epoll不断轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。该模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。**

下面举一个例子，模拟一个tcp服务器处理30个客户socket。

假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择:

1. **(select)**第一种选择：**按顺序逐个检查**，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡住，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。

2. **(poll)**第二种选择：你**创建30个分身**，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。

3. **(select)**第三种选择，你**站在讲台上等，谁解答完谁举手**。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 

这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用**非阻塞模式**。

这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是**事件驱动**，所谓的reactor模式。

#### select、poll 和epoll之间的区别?
1. **select：时间复杂度O(n)**
   select仅仅知道有I/O事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数据或者写入数据的流，并对其进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。
2. **poll：时间复杂度O(n)**
   poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，但是它没有最大连接数的限制，原因是它是基于链表来存储的。
3. **epoll： 时间复杂度O(1)**
   epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的I/O事件通知我们。所以说epoll实际上是事件驱动(每个事件关联上fd)的。

select，poll，epoll都是IO多路复用的机制。l/O多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪(一般是读就绪或者写就绪)，就通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O,因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步l/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

### 软链接和硬链接有什么区别?

- 软链接可以理解成快捷方式，也清楚知道原文件在哪里。它和Windows下的快捷方式的作用是一样的，删除源文件，快捷方式也就无法使用了。

- 硬链接可以看成一个备份，但并没有增加空间，因为文件就一个，这种可以防止源文件删除后不能使用问题；同时也有局限性，不能对目录和跨文件系统使用。

语法格式(ln)区别：

　　硬链接：ln 源文件 链接名

　　软链接：ln -s 源文件 链接名

　　**注意**：链接的源文件路径要写绝对路径，否则会报错。

### 中断的处理过程?

1. 保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。
2. 开中断：以便执行中断时能响应较高级别的中断请求。
3. 中断处理
4. 关中断：保证恢复现场时不被新中断打扰
5. 恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。

---
### 1.1 Linux里如何查看一个想知道的进程？

**查看进程运行状态的指令**：ps命令。“**ps -aux | grep PID**”，用来查看某PID进程状态

>ps使用示例  //显示当前所有进程   ps -A   //与grep联用查找某进程   ps -aux | grep apache    //查看进程运行状态、查看内存使用情况的指令均可使用top指令。 top

### 1.2 Linux里如何查看带有关键字的日志文件？

1. **cat 路径/文件名 | grep 关键词**

```shell
## 返回test.log中包含http的所有行 cat test.log | grep "http"
```
1. **grep -i 关键词 路径/文件名** （与方法一效果相同，不同写法而已）

```shell
## 返回test.log中包含http的所有行(-i忽略大小写） grep -i "http" ./test.log 
```

### 1.3 说说你对grep命令的了解？

grep 命令。强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。

grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

### 1.4 Linux修改主机名的命令是什么？

1. 如果只需要临时更改主机名，可以使用hostname命令。

   ```shell
   sudo hostname <new-hostname> # 例如: sudo hostname myDebian #myDebian为修改名
   ```
2. 如果想永久改变主机名，可以使用hostnamectl命令

   ```shell
   sudo hostnamectl set-hostname myDebian #myDebian为修改名
   ```
### 1.5 Linux开机自动执行命令如何实现？

1. **方法 #1 - 使用 cron 任务**

   除了常用格式（分 / 时 / 日 / 月 / 周）外，cron 调度器还支持 @reboot 指令。这个指令后面的参数是脚本（启动时要执行的那个脚本）的绝对路径。

   然而，这种方法需要**注意**两点：

   a)  cron 守护进程必须处于运行状态（通常情况下都会运行），同时

   b) 脚本或 crontab 文件必须包含需要的环境变量。

2. **方法 #2 - 使用 /etc/rc.d/rc.local**

   这个方法对于 systemd-based 发行版 Linux 同样有效。不过，使用这个方法，需要授予 /etc/rc.d/rc.local 文件执行权限:

   ```shell
   # chmod +x /etc/rc.d/rc.local
   ```
   然后在这个文件底部添加脚本。

### 1.6 Linux查看内存的命令是什么？

**查看内存使用情况的指令**：**free命令**。“**free -m**”，命令查看内存使用情况。

查看进程运行状态、查看内存使用情况的指令均可使用**top指令**。

1. **free命令**

   Linux free命令用于**显示内存状态**。

   free指令会显示内存的使用情况，**包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。**

   参数如下:

   ```shell
   -b 以Byte为单位显示内存使用情况。
   -k 以KB为单位显示内存使用情况。 
   -m 以MB为单位显示内存使用情况。 
   -h 以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。
   单位有:         
   B = bytes         K = kilos         M = megas         G = gigas         T = teras -o 不显示缓冲区调节列。 -s<间隔秒数> 持续观察内存使用状况。 -t 显示内存总和列。 -V 显示版本信息。
   ```
   实例:显示内存使用情况

   ```shell
   # free //显示内存使用信息
   total used free shared buffers cached
   Mem: 254772 184568 70204 0 5692 89892
   -/+ buffers/cache: 88984 165788
   Swap: 524280 65116 459164
   ```
2. top命令

**top**命令。**显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等**

![](https://cdn.jsdelivr.net/gh/nateshao/images/20220328215436.png)

**前五行是当前系统情况整体的统计信息区。**

1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下:

   00:12:54 — 当前系统时间

   up ？days, 4:49 — 系统已经运行了？天4小时49分钟（在这期间系统没有重启过）

   21users — 当前有1个用户登录系统

   load average: 0.06, 0.02, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

2. 第二行，Tasks — 任务（进程），具体信息说明如下:

   系统现在共有256个进程，其中处于运行中的有1个，177个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

3. 第三行，cpu状态信息，具体属性说明如下:

   0.2%us — 用户空间占用CPU的百分比。

   0.2% sy — 内核空间占用CPU的百分比。

   0.0% ni — 改变过优先级的进程占用CPU的百分比

   99.5% id — 空闲CPU百分比

   0.0% wa — IO等待占用CPU的百分比

   0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比

   0.0% si — 软中断（Software Interrupts）占用CPU的百分比

4. 第四行，内存状态，具体信息如下:

   2017552 total — 物理内存总量

   720188 used — 使用中的内存总量

   197916 free — 空闲内存总量

   1099448 cached — 缓存的总量

5. 第五行，swap交换分区信息，具体信息说明如下:

   998396 total — 交换区总量

   989936 free — 空闲交换区总量

   8460 used — 使用的交换区总量

   1044136 cached — 缓冲的交换区总量

### 1.7 free命令有哪些选项？

Linux free命令用于**显示内存状态**。

free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。

参数如下:

```shell
-b 　以Byte为单位显示内存使用情况。
-k 　以KB为单位显示内存使用情况。
-m 　以MB为单位显示内存使用情况。
-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有:
        B = bytes
        K = kilos
        M = megas
        G = gigas
        T = teras
-o 　不显示缓冲区调节列。
-s<间隔秒数> 　持续观察内存使用状况。
-t 　显示内存总和列。
-V 　显示版本信息。
```
**答案解析**

实例：显示内存使用情况

```shell
## free //显示内存使用信息
total used free shared buffers cached
Mem: 254772 184568 70204 0 5692 89892
-/+ buffers/cache: 88984 165788
Swap: 524280 65116 459164
```

### 1.8 Linux中压缩文件的命令是什么？

Linux中压缩文件与解压文件的命令有：**tar命令、gz命令、bz2命令、compress命令、zip命令、unzip命令**。

**答案解析**

1. **tar 命令详解**

   Linux tar（英文全拼：tape archive ）命令用于备份文件。

   tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

   ```shell
   //命令格式:
   tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F <Script文件>][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]
       
   //常用参数:
   //必要参数有如下:
   -A 新增压缩文件到已存在的压缩
   -c 建立新的压缩文件
   -d 记录文件的差别
   -r 添加文件到已经压缩的文件
   -u 添加改变了和现有的文件到已经存在的压缩文件
   -x 从压缩的文件中提取文件
   -t 显示压缩文件的内容
   -z 支持gzip解压文件
   -j 支持bzip2解压文件
   -Z 支持compress解压文件
   -v 显示操作过程
   -l 文件系统边界设置
   -k 保留原有文件不覆盖
   -m 保留文件不被覆盖
   -W 确认压缩文件的正确性
       
   //实例
   //1.压缩
   tar -cf hhh.tar hhh       //打包 hhh 文件为 hhh.tar
   tar -jcf hhh.tar.bz2 hhh  //压缩打包 hhh 文件为 hhh.tar.bz2
   tar -czf hhh.tar.gz hhh   //压缩 hhh 文件为 hhh.tar.gz
   tar -tzvf test.tar.gz     //列出压缩文件内容
       
   //2.解压文件  
   tar -tzvf test.tar.gz 
   ```
2. **gz命令详解**

   Linux gzip命令用于压缩文件。

   gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。

   ```shell
   //命令格式:
   gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]
       
   //常用参数:
   -a或--ascii 　使用ASCII文字模式。
   -c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。
   -d或--decompress或----uncompress 　解开压缩文件。
   -f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
   -h或--help 　在线帮助。
   -l或--list 　列出压缩文件的相关信息。
   -L或--license 　显示版本与版权信息。
   -n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。
   -N或--name 　压缩文件时，保存原来的文件名称及时间戳记。
   -q或--quiet 　不显示警告信息。
   -r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
   -S<压缩字尾字符串>或----suffix<压缩字尾字符串> 　更改压缩字尾字符串。
   -t或--test 　测试压缩文件是否正确无误。
   -v或--verbose 　显示指令执行过程。
   -V或--version 　显示版本信息。
   -<压缩效率> 　压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。
   --best 　此参数的效果和指定"-9"参数相同。
   --fast 　此参数的效果和指定"-1"参数相同。
       
   //实例
   //1.压缩
   gzip *            //压缩目录下的所有文件
       
   //2.解压文件  
   gzip -dv *        //解压文件，并列出详细信息   
   ```
3. **bz2命令详解**

   bzip2(选项)（参数）:用于创建和管理.bz2格式的压缩包。

   ```shell
   //命令格式:
   bzip2 源文件       //压缩不保留源文件
   bzip2 -k 源文件    //压缩保留源文件
   //**注意** bzip2 命令不能解压目录
   
   //常用参数:
   -c 将压缩与解压缩的结果送到标准输出
   -d 执行解压缩
   -f 在压缩或解压缩时，若输出文件与现有文件名相同，预设不会覆盖现有文件；使用该选项，可覆盖文件
   -k 在压缩或解压缩后，会删除原是文件；若要保留原是文件，使用该选项
   -v 压缩或解压缩文件时，显示详细的信息
   -z 强制执行压缩
       
   //实例
   //1.压缩
   bzip2 源文件       //压缩不保留源文件
   bzip2 -k 源文件    //压缩保留源文件
       
   //2.解压文件  
   bzip2 -d 源文件   //解压缩 -k 保留压缩文件
   bunzip2  源文件   //解压缩 -k 保留压缩文件      
   ```
4. **compress命令详解**

   Linux compress命令是一个相当古老的 unix 档案压缩指令，压缩后的档案会加上一个 .Z 延伸档名以区别未压缩的档案，压缩后的档案可以以 uncompress 解压。若要将数个档案压成一个压缩档，必须先将档案 tar 起来再压缩。由于 gzip 可以产生更理想的压缩比例，一般人多已改用 gzip 为档案压缩工具。

   ```shell
   //命令格式:
   compress [-dfvcV] [-b maxbits] [file ...]
    
   //常用参数:    
   -c 输出结果至标准输出设备（一般指荧幕）
   -f 强迫写入档案，若目的档已经存在，则会被覆盖 (force)
   -v 将程序执行的讯息印在荧幕上 (verbose)
   -b 设定共同字串数的上限，以位元计算，可以设定的值为 9 至 16 bits 。由于值越大，能使用的共同字串就 越多，压缩比例就越大，所以一般使用预设值 16 bits (bits)
   -d 将压缩档解压缩
   -V 列出版本讯息    
       
   //实例
   //1.压缩
   compress -f source.dat   //将 source.dat 压缩成 source.dat.Z ，若 source.dat.Z 已经存在，内容则会被压缩档覆盖。    
       
   //2.解压文件  
   compress -d source.dat   //将 source.dat.Z 解压成 source.dat ，若档案已经存在，使用者按 y 以确定覆盖档案，若使用 -df 程序则会自动覆盖档案。 
   ```
5. **zip 命令详解**

   ```shell
   //命令格式:
   zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]
       
   //常用参数:
   -m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。
   -o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。
   -q 不显示指令执行过程。
   -r 递归处理，将指定目录下的所有文件和子目录一并处理。
   -x<范本样式> 压缩时排除符合条件的文件。
       
   //实例:
   //将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：
   zip -q -r html.zip /home/html
       
   //如果在我们在 /home/html 目录下，可以执行以下命令:
   zip -q -r html.zip *
       
   //从压缩文件 cp.zip 中删除文件 a.c
   zip -dv cp.zip a.c
   ```
6. **unzip 命令详解**

   Linux unzip命令用于解压缩zip文件

   unzip为.zip压缩文件的解压缩程序。

   ```shell
   //命令格式:
   unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]
       
   //常用参数:    
   -c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。
   -f 更新现有的文件。
   -l 显示压缩文件内所包含的文件。
   -p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。
   -t 检查压缩文件是否正确。
   -u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。
   -v 执行是时显示详细的信息。
   -z 仅显示压缩文件的备注文字。
   -a 对文本文件进行必要的字符转换。
   -b 不要对文本文件进行字符转换。
   -C 压缩文件中的文件名称区分大小写。
   -j 不处理压缩文件中原有的目录路径。
   -L 将压缩文件中的全部文件名改为小写。
   -M 将输出结果送到more程序处理。
   -n 解压缩时不要覆盖原有的文件。
   -o 不必先询问用户，unzip执行后覆盖原有文件。
   -P<密码> 使用zip的密码选项。
   -q 执行时不显示任何信息。
   -s 将文件名中的空白字符转换为底线字符。
   -V 保留VMS的文件版本信息。
   -X 解压缩时同时回存文件原来的UID/GID。
   [.zip文件] 指定.zip压缩文件。
   [文件] 指定要处理.zip压缩文件中的哪些文件。
   -d<目录> 指定文件解压缩后所要存储的目录。
   -x<文件> 指定不要处理.zip压缩文件中的哪些文件。
   -Z unzip -Z等于执行zipinfo指令。
       
   //实例
   unzip text.zip   //将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。    
   unzip -n text.zip -d /tmp  //查看压缩文件目录，但不解压。
   ```
### 1.9 Linux查询连接数的命令是什么？

**参考回答**

1. **netstat**

2. ```shell
   //示例
   查看Web服务器（Nginx Apache）的并发请求数及其TCP连接状态:
   netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
   
   解释:
   返回结果示例: 
   LAST_ACK 5   (正在等待处理的请求数) 
   SYN_RECV 30 
   ESTABLISHED 1597 (正常数据传输状态) 
   FIN_WAIT1 51 
   FIN_WAIT2 504 
   TIME_WAIT 1057 (处理完毕，等待超时结束的请求数) 
    
   状态:描述 
   CLOSED：无连接是活动的或正在进行 
   LISTEN：服务器在等待进入呼叫 
   SYN_RECV：一个连接请求已经到达，等待确认 
   SYN_SENT：应用已经开始，打开一个连接 
   ESTABLISHED：正常数据传输状态 
   FIN_WAIT1：应用说它已经完成 
   FIN_WAIT2：另一边已同意释放 
   ITMED_WAIT：等待所有分组死掉 
   CLOSING：两边同时尝试关闭 
   TIME_WAIT：另一边已初始化一个释放 
   LAST_ACK：等待所有分组死掉
   ```
**答案解析**

无。

### 1.10 Linux中top命令有哪些参数？

**参考回答**

**top**命令。显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等

**参数**:

```shell
-d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 
-p 通过指定监控进程ID来仅仅监控某个进程的状态。 
-q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 
-S 指定累计模式 
-s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 
-i 使top不显示任何闲置或者僵死进程。 
-c 显示整个命令行而不只是显示命令名 
```
**答案解析**

![img](https://cdn.jsdelivr.net/gh/nateshao/images/20220328215712.png)

**前五行是当前系统情况整体的统计信息区。**

1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下:

   00:12:54 — 当前系统时间

   up ？days, 4:49 — 系统已经运行了？天4小时49分钟（在这期间系统没有重启过）

   21users — 当前有1个用户登录系统

   load average: 0.06, 0.02, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

2. 第二行，Tasks — 任务（进程），具体信息说明如下:

   系统现在共有256个进程，其中处于运行中的有1个，177个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

3. 第三行，cpu状态信息，具体属性说明如下:

   ```shell
   0.2%us — 用户空间占用CPU的百分比。
   
   0.2% sy — 内核空间占用CPU的百分比。
   
   0.0% ni — 改变过优先级的进程占用CPU的百分比
   
   99.5% id — 空闲CPU百分比
   
   0.0% wa — IO等待占用CPU的百分比
   
   0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
   
   0.0% si — 软中断（Software Interrupts）占用CPU的百分比
   ```
4. 第四行，内存状态，具体信息如下:

   2017552 total — 物理内存总量

   720188 used — 使用中的内存总量

   197916 free — 空闲内存总量

   1099448 cached — 缓存的总量

5. 第五行，swap交换分区信息，具体信息说明如下:

   998396 total — 交换区总量

   989936 free — 空闲交换区总量

   8460 used — 使用的交换区总量

   1044136 cached — 缓冲的交换区总量

### 1.11 Linux中，如何通过端口查进程，如何通过进程查端口？

**参考回答**

1. **linux下通过进程名查看其占用端口**: （1）先查看进程pid

   ```shell
   ps -ef | grep 进程名
   ```
   （2）通过pid查看占用端口

   ```shell
   netstat -nap | grep 进程pid
   ```
2. **linux通过端口查看进程**:

   ```shell
   netstat -nap | grep 端口号
   ```
### 1.12 请你说说ping命令？

**参考回答**

Linux ping命令用于检测主机。

**执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。**

**答案解析**

语法:

```shell
ping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]
```
参数说明:

```shell
-d 使用Socket的SO_DEBUG功能。
-c<完成次数> 设置完成要求回应的次数。
-f 极限检测。
-i<间隔秒数> 指定收发信息的间隔时间。
-I<网络界面> 使用指定的网络接口送出数据包。
-l<前置载入> 设置在送出要求信息之前，先行发出的数据包。
-n 只输出数值。
-p<范本样式> 设置填满数据包的范本样式。
-q 不显示指令执行过程，开头和结尾的相关信息除外。
-r 忽略普通的Routing Table，直接将数据包送到远端主机上。
-R 记录路由过程。
-s<数据包大小> 设置数据包的大小。
-t<存活数值> 设置存活数值TTL的大小。
-v 详细显示指令的执行过程。
```
实例:

```shell
检测是否与主机连通

## ping www.w3cschool.cc //ping主机
PING aries.m.alikunlun.com (114.80.174.110) 56(84) bytes of data.
64 bytes from 114.80.174.110: icmp_seq=1 ttl=64 time=0.025 ms
64 bytes from 114.80.174.110: icmp_seq=2 ttl=64 time=0.036 ms
64 bytes from 114.80.174.110: icmp_seq=3 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=4 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=5 ttl=64 time=0.028 ms
64 bytes from 114.80.174.110: icmp_seq=6 ttl=64 time=0.028 ms
64 bytes from 114.80.174.110: icmp_seq=7 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=8 ttl=64 time=0.034 ms
64 bytes from 114.80.174.110: icmp_seq=9 ttl=64 time=0.036 ms
64 bytes from 114.80.174.110: icmp_seq=10 ttl=64 time=0.041 ms

--- aries.m.alikunlun.com ping statistics ---
10 packets transmitted, 30 received, 0% packet loss, time 29246ms
rtt min/avg/max/mdev = 0.021/0.035/0.078/0.011 ms

//需要手动终止Ctrl+C
指定接收包的次数

## ping -c 2 www.w3cschool.cc
PING aries.m.alikunlun.com (114.80.174.120) 56(84) bytes of data.
64 bytes from 114.80.174.120: icmp_seq=1 ttl=54 time=6.18 ms
64 bytes from 114.80.174.120: icmp_seq=2 ttl=54 time=15.4 ms

--- aries.m.alikunlun.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1016ms
rtt min/avg/max/mdev = 6.185/10.824/15.464/4.640 ms

//收到两次包后，自动退出
多参数使用

## ping -i 3 -s 1024 -t 255 g.cn //ping主机
PING g.cn (203.208.37.104) 1024(1052) bytes of data.
1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=0 ttl=243 time=62.5 ms
1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=1 ttl=243 time=63.9 ms
1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=2 ttl=243 time=61.9 ms

--- g.cn ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 6001ms
rtt min/avg/max/mdev = 61.959/62.843/63.984/0.894 ms, pipe 2
[root@linux ~]# 

//-i 3 发送周期为 3秒 -s 设置发送包的大小 -t 设置TTL值为 255
```

### 1.13 什么是协程？

**参考回答**

**协程**：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

**答案解析**

1. **线程与协程的区别:**

   （1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

   （2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

   （3）一个线程可以有多个协程。

2. **协程的优势:**

   （1）**协程调用跟切换比线程效率高**:协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。

   （2）**协程占用内存少**:执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。

   （3）**切换开销更少**:协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

### 1.14 为什么协程比线程切换的开销小？

**参考回答**

1. 协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的**切换非常快**，切换开销比线程更小。

2. 协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。**避免了加锁解锁的开销。**

