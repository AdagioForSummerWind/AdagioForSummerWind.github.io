---
title: "隐私信息检索"
date: 2022-05-13T09:33:30+08:00
lastmod: 2022-05-14
tags: [papers]
categories: [Software design B]
slug: One Server for the Price of Two:Simple and Fast Single-Server Private Information Retrieval
draft: true
---

> One Server for the Price of Two:Simple and Fast Single-Server Private Information Retrieval
> https://eprint.iacr.org/2022/949.pdf


# 两台服务器的价格：简单快速的单服务器隐私信息检索


## 摘要
我们提出了 SimplePIR，这是迄今为止已知的最快的私人信息检索 (PIR) 方案。 SimplePIR 是一种单服务器 PIR 方案，其安全性在错误学习假设下成立。为了回答客户端的 PIR 查询，SimplePIR 服务器对每个数据库字节执行一次 32 位乘法和一次 32 位加法。 SimplePIR 实现了 6.5 GB/s/核心服务器吞吐量，比最快的两台服务器 PIR 方案（需要非共谋服务器）快 7%。 SimplePIR 的通信成本比较大：要查询 1 GB 的数据库，客户端必须下载 124 MB 的关于数据库内容的“提示”；此后，客户端可以进行无限数量的查询，每个查询需要 242 KB 的通信。我们提出了第二种单服务器方案，DoublePIR，它将提示缩小到 16 MB，代价是每次查询通信稍高 (345 KB) 和吞吐量稍低 (5.2 GB/s/core)。最后，我们将我们的 PIR 方案以及用于近似集合成员的新数据结构应用于证书透明度中的私人审计问题。我们实现了比 Google Chrome 当前方法更严格的隐私概念，但通信开销却是适度的​​ 13 倍。

## 1 介绍

在私人信息检索 (PIR) 协议 [26, 53] 中，数据库服务器保存一组 𝑁 记录。 客户端想要从服务器获取记录 𝑖 ∈ {1, · · · , 𝑁}，而不向服务器透露它想要的索引 𝑖。 PIR 可应用于私有数据库搜索 [75, 81]、元数据隐藏消息 [9, 10]、私有媒体消费 [48]、凭据泄露报告 [4,57,80,82] 和私有阻止列表查找 [52] 的系统 ，等等。



现代 PIR 方案几乎不需要通信：使用单个数据库服务器，并且在适度的密码学假设下 [20,44,70]，获取数据库记录所需的总通信量仅随记录数量 𝑁 呈多对数增长。 不幸的是，PIR 方案的计算成本很高：服务器必须触及数据库的每一位才能回答甚至单个客户端查询 [12]，否则 PIR 方案会泄漏有关客户端不感兴趣的数据库记录的信息。（最近，已经有许多 PIR 方案对数据库进行预处理以实现数据库大小的运行时亚线性，但所有已知的方法要么需要特定于客户端的预处理 [29,30,52,77,85]，要么需要不切实际的大型服务器存储 [12, 16, 21]。）因此，对 PIR 方案性能的硬性限制是 PIR 服务器从内存中读取数据库的速度——在我们的机器上大约为 12.8 GB/s/core。



在标准设置下，客户端仅与单个数据库服务器通信，现有 PIR 方案的性能远未达到这个理论极限：我们测量到最快的单服务器 PIR 方案的吞吐量达到 259 MB/s/core ，或最大可能[66]的 2% ，在百字节记录的数据库中。 当数据库记录长达数百 KB 时，可以将性能提高到 1.3 GB/s/core，尽管该参数设置与许多 PIR 应用程序无关，包括我们对证书透明度的应用程序。


当客户端可以与多个非共谋数据库服务器通信时[26]，存在更快的 PIR 方案。 在两台服务器的设置中，基于分布式点功能的方案 [15, 45] 可以实现 5.4 GB/s/core 吞吐量，或最大可能的 42%。 在这里，两个服务器必须回答每个查询，这将每个核心的吞吐量减半。 不幸的是，这些两台服务器方案部署起来很麻烦，因为它们依赖于多个协调但独立的基础设施提供商。 此外，它们的安全性很脆弱，因为它源于非共谋假设而不是密码学难度。 因此，现有的 PIR 方案要么在单服务器设置中性能不佳，要么在多服务器设置中具有不良的信任假设。


在本文中，我们提出了两种新的单服务器 PIR 方案； 我们更快的方案实现了任何现有 PIR 协议（包括多服务器协议）的最高服务器吞吐量。 我们的方案在 10 亿个短行的数据库上具有几百 KB 的适度每次查询通信，并且它们的安全性基于 Regev 的错误学习假设 [76]。 此外，我们的方案解释起来相对简单，实现起来也很容易：两个方案的完整实现总共需要大约 1200 行 Go 代码，加上 80 行 C 代码，并且不使用外部库。


更具体地说，我们的第一个方案 SimplePIR 实现了 6.5 GB/s/core 的服务器吞吐量，尽管它需要客户端在进行查询之前下载关于数据库内容的相对较大的“提示”。 在大小为 𝑁 的数据库上，提示的大小约为 1024√ 𝑁 字节。 提示不是特定于客户端的，并且客户端可以在许多查询中重用提示，因此每个查询的摊销通信成本可以很小。 我们的第二个方案 DoublePIR 实现了 5.2 GB/s/核心的稍低的服务器吞吐量，但对于单字节记录的数据库，将提示缩小到大约 16 MB——与数据库中的记录数无关。

我们的技术。 我们现在总结我们的结果背后的技术思想。

### Recap: Single-server PIR


我们的出发点是 Kushilevitz 和 Ostrovsky [53] 的单服务器 PIR 构建。 在他们的方案中，PIR 服务器将 𝑁 记录数据库表示为维度为 √ 𝑁 × √ 𝑁 的矩阵 D。 为了获取行𝑖和列𝑗中的数据库记录，客户端向服务器发送维度-√𝑁向量的加密𝐸（q），除了索引𝑗中的“1”之外，它在任何地方都为零。 如果加密方案是线性同态的，服务器可以在加密下计算矩阵-向量积D·𝐸(q)=𝐸(D·q)并将结果返回给客户端。 客户端解密以恢复 D·q，根据需要，它是数据库的第 𝑗 列。 总通信量增长为 √ 𝑁。

SimplePIR 来自带预处理的线性同态加密。

此处 PIR 服务器的吞吐量受限于它计算明文矩阵 D 与加密向量 𝐸(q) 的乘积的速度。我们在 SimplePIR（第 4 节）中的观察结果是，使用 Regev 的基于错误学习的加密方案 [76]，服务器可以提前执行绝大多数计算矩阵向量积 D·𝐸(q) 的工作——在客户端甚至进行查询之前。服务器的预处理只依赖于数据库 D 和 Regev 加密方案的公共参数，因此服务器可以在来自许多独立客户端的许多查询中重用此预处理工作。在这个预处理步骤之后，为了回答客户端的查询，服务器只需要在 𝑁 字节的数据库上计算大约 𝑁 32 位整数乘法和加法。唯一的问题是客户端必须在此预处理步骤之后下载有关数据库内容的“提示”——提示占 SimplePIR 中通信成本的大部分。


### DoublePIR from one recursive step. 
……

### 申请证书透明度

最后，我们在证书透明度中应用签名证书时间戳(SCT)审计的背景下评估我们的PIR方案。


在这个审计应用程序中，服务器持有一组字符串𝑆，并且客户端（Web 浏览器）想要测试表示 SCT 的特定字符串 𝜎 是否出现在集合 𝑆 中，同时对服务器隐藏 𝜎。 （字符串 𝜎 揭示了有关客户访问过哪些网站的信息。）Google Chrome 目前建议使用为 𝑘 = 1000 [33] 提供 𝑘-匿名的解决方案来实施此审计步骤。



在此过程中，我们构建了一个新的数据结构（第 6 节），以使用 PIR 更有效地解决这种类型的私有集合成员问题，此时可以接受恒定的误报率（如在我们的应用程序中）。 在此设置中，标准 Bloom 过滤器 [14] 和基于 PIR 通过关键字 [25] 的方法要求客户端在 𝜆𝑁 位的数据库上执行 PIR（如果集合 𝑆 的大小为 𝑁 并且 𝜆 ≈ 128 是一个安全参数）。 相比之下，我们的数据结构只需要在 8𝑁 位上执行 PIR——在我们的应用程序中提供大约 16 倍的加速。


Google 当前的 SCT 审计解决方案提供了 𝑘- 匿名性而非完整的加密隐私，它要求客户端平均每个 TLS 连接通信 240 B。 我们的解决方案提供加密隐私，每个 TLS 连接平均需要 1.5 KB 和 0.004 核心秒的服务器计算，以及每周 16 MB 的客户端下载和 400 KB 的客户端存储来维护提示。



### 不足


我们新的 PIR 计划有两个主要缺点。 首先，我们的客户端必须下载一个“提示：”数据库大小为千兆字节，提示为数十兆字节。 如果客户端只进行一次查询，则此提示下载将主导整个通信。 其次，我们方案的在线通信在具有短条目的数据库上约为数百 KB，比之前的一些工作大 10 倍。 在具有较大条目的数据库上，这种差距进一步扩大。 尽管如此，我们相信 SimplePIR 和 DoublePIR 代表了 PIR 设计领域中一个令人兴奋的新点：大量的计算节省，以及概念上简单的设计和小型的独立代码库，但代价是适度的通信和存储开销。


总之，我们的贡献是：
- 两个新的高吞吐量单服务器私有信息检索协议（第 4 节和第 5 节），
- 使用 PIR（第 6 节）的私有集成员资格的新数据结构及其在证书透明度中的私有审计中的应用（第 7 节），以及
- 使用新的开源实现对这些方案进行评估（第 8 节）。


## 2 Related work and comparison

Chor、Goldreich、Kushilevitz 和苏丹 [26] 在多服务器设置中引入了 PIR，Kushilevitz 和 Ostrovsky [53] 首次构建了单服务器 PIR。 他们的方案使用线性同态加密方案，将ℓ位明文扩展为ℓ·𝐹位密文。 我们称𝐹为加密方案的扩展因子。 然后，在 N 位和任何维度参数的数据库上 𝑑 ∈ {1, 2, 3, . . . }，他们的 PIR 结构大致有通信 $𝑁^{1/𝑑}𝐹^{𝑑−1}$ 。 服务器在回答客户端查询的过程中必须执行大致$𝑁𝐹^{𝑑−1}$ 同态操作。

Damgård-Jurik [32] 密码系统具有扩展因子 𝐹 ≈ 1，它产生了非常有效的通信 PIR 方案 [60]。 从一系列密码学假设 [20, 23, 36] 可以构建具有相似通信效率的 PIR。 然而，这些方案在计算上都是昂贵的：对于数据库的每一位，服务器必须在安全参数中执行工作多项式。

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917110251.png)



表 1：PIR 方案在数据库大小 𝑁 和安全参数 𝑛 上的比较。 我们机器的内存带宽是12.8 GB/s/core； 由于这些方案中的每一个都必须从内存中读取整个数据库，因此它们的吞吐量不能高于这个上限。 XOR 是指对数据库执行 XOR 线性扫描的基准（参见第 8.1 节）。 开销列指示每个数据库位的服务器计算是否最多是 𝑛 中的多对数。 吞吐量列给出了我们针对任何数据库大小和记录大小测量的最大吞吐量。 我们用于这些数字的数据库大小在附录 A 中。吞吐量由核心数量标准化，即，对于 2 台服务器 PIR 方案（DPF PIR 和 XOR）除以 2。 ★没有可用的开源实现。 这是 MulPIR 论文 [8] 中报告的吞吐量。 ♥这是 SealPIR [9] 报告的 XPIR 吞吐量。



基于格的 PIR。

为了降低这种计算成本，最近的 PIR 方案使用基于环学习错误问题（“环 LWE”）[63] 的加密方案来实例化 Kushilevitz-Ostrovsky 结构。 在这些方案中，对于数据库的每一位，服务器在安全参数中执行多项式工作，而不是多项式。 然而，这些计算上的节省是以更大的扩展因子 (𝐹 ≈ 10) 为代价的，这增加了通信，因为维度参数 𝑑 不能太大。 例如，XPIR[5]取𝑑=2。另外，Kushilevitz-Ostrovsky方案中的客户端必须上传𝑁1/𝑑密文，每个环-LWE密文的大小至少为数千字节。 这会带来很大的绝对通信成本（例如，对于数百 MB 的数据库，每次查询数十 MB）。


SealPIR [9] 表明客户端可以在上传之前以 XPIR 样式的方案压缩密文。 然后服务器可以使用同态操作扩展这些密文。 （FastPIR [6] 使用类似的想法来压缩响应。）这种优化将通信成本降低了几个数量级，尽管它需要服务器存储一些每个客户端的信息（“密钥切换提示”）——本质上，加密 客户端的秘密解密密钥——大小为兆字节，客户端在进行任何查询之前必须上传到服务器。



MulPIR [8]、OnionPIR [67] 和 Spiral [66] 还使用全同态加密 [42] 以进一步降低通信成本。 例如，在 Spiral [66] 中，成本大致增长为 𝑁 1/𝑑𝐹，其中 𝐹 项的指数现在是 1 而不是 𝑑 − 1。基于 Gentry 和 Halevi [43] 的想法，Spiral 展示了如何 在保持高吞吐量的同时降低通信成本：在短记录数据库上高达 259 MB/s。 （当数据库记录较长时，Spiral 不使用 SealPIR 查询压缩技术，并以增加通信为代价获得高达 1,314 MB/s 的吞吐量。）

简单的错误学习。

我们的 PIR 方案基于标准的错误学习 (LWE) 问题，而不是环变体。 标准基于 LWE 的加密方案 Regev 加密 [76] 的扩展因子大致为 𝐹 = 𝑛 ≈ 1024，其中 𝑛 是格安全参数。 这种大的扩展因子意味着将 Regev 加密直接应用于 Kushilevitz-Ostrovsky PIR 方案在通信和计算方面将是灾难性的。 我们的创新是表明服务器可以提前完成大部分工作，并在多个客户端上重用它。

除了我们的方案基于较弱的加密假设（即普通 LWE 而不是环 LWE）这一事实之外，这种策略还产生了多种好处：

1. 我们基于 LWE 的方案易于实现：它们不需要多项式算术或快速傅立叶变换。
2. 我们的方案不需要服务器存储任何额外的每个客户端状态。 相比之下，许多基于 Ring LWE [8, 9, 66, 67] 的方案依赖于需要服务器为每个客户端存储一个“按键切换提示”的优化。
3. 我们的方案更快。 我们避免了与密文压缩和扩展相关的成本。 另外，由于我们只需要我们的加密方案是线性的（不是完全的）同态的，我们可以使用更小更有效的格参数。


我们的方案的缺点是它们具有较大的通信成本，特别是当客户端只进行一次查询（因此客户端无法将离线下载成本分摊到多个查询中）或数据库记录很长时。

预处理和 PIR。 
我们的 PIR 方案中的服务器执行一些独立于客户端的预处理。 先前的工作使用服务器端预处理（一次性 [12,16,21] 或每个客户端 [29,30,52,77,85]）来构建 PIR，其中服务器在线工作在数据库大小中是次线性的。 先前的工作还证明了使用预处理方案 [12,29,30,74] 对任何此类 PIR 的性能都有很强的下限。 相比之下，在这项工作中，我们使用预处理来构建 PIR，其中摊销的每个查询服务器工作仍然是线性的，但它实际上是有效的。

PIR 的硬件加速。 
最近的工作使用硬件加速提高了单服务器 [58] 和多服务器 [49] PIR 的吞吐量。 这种方法是对我们的补充，因为它可以进一步加快我们的新 PIR 协议。

隐私和证书透明度。 Lueks 和 Goldberg [62] 以及 Kales、Omolola 和 Ramacher [51] 建议使用多服务器 PIR 来审计证书透明度。 我们在单服务器设置中工作，其中客户端与单独的审计服务器（例如，谷歌，在 Chrome 的应用程序中）进行通信。 此外，我们引入了一种新的集合成员数据结构来降低审计成本（第 6 节）。 我们将在第 7.2 节讨论现有的审计方法。

## 3 Background and definitions

符号。 对于概率分布 𝜒，我们使用 𝑥 ←R 𝜒 来表示 𝑥 是来自 𝜒 的均匀随机样本。 对于有限集 𝑆，我们使用 𝑥 ←R 𝑆 表示从 𝑆 均匀随机抽样 𝑥。 我们用 N 表示自然数，用 Z𝑝 表示模 𝑝 的整数。 所有对数均以二为底。 对于 𝑛 ∈ N，我们让 [𝑛] 表示集合 {1, . . . ，𝑛}。 在整个过程中，我们假设像 √ 𝑁 这样的值是完整的，只要这样做基本上不失一般性。 算法被建模为 RAM 程序，它们的运行时间是根据执行的 RAM 指令的数量来衡量的。 我们将符号 MB 和 MiB 以及 GB 和 GiB 用作同义词

### 3.1 Learning with errors (LWE)


我们的 PIR 方案的安全性依赖于错误学习假设的决策版本 [76]。 该假设由 LWE 秘密的维度 𝑛 ∈ N、样本数量 𝑚 ∈ N、整数模 𝑞 ≥ 2 以及 Z 上的误差分布 𝜒 参数化。LWE 假设随后断言对于矩阵 $A ←^R Z^{𝑚×𝑛}_𝑞$ 、秘密 $s ←^R Z^𝑛_𝑞$ 、误差向量 $e ←^R 𝜒^𝑚$ 和随机向量 $r ←^R Z^𝑚_𝑞$ ，以下分布在计算上无法区分：

$$
\{(\mathbf{A}, \mathbf{A s}+\mathbf{e})\} \stackrel{c}{\approx}\{(\mathbf{A}, \mathbf{r})\}
$$

更具体地说，如果所有在时间 𝑇 上运行的对手在区分两个分布时最多具有优势 在 4.2 节中，我们给出了 LWE 参数的具体值。

密钥 Regev 加密。 
Regev [76] 给出了在 LWE 假设下安全的密钥加密方案。使用 LWE 参数（𝑛，𝑞，𝜒）和明文模数𝑝，Regev 密钥是向量 s ←R Z 𝑛 𝑞。 消息 𝜇 ∈ Z𝑝 的 Regev 加密是

$$
(\mathbf{a}, c)=\left(\mathbf{a}, \mathbf{a}^{\top} \mathbf{s}+e+\lfloor q / p\rfloor \cdot \mu\right) \in \mathbb{Z}_q^n \times \mathbb{Z}_q
$$


对于𝑒←R𝜒。 要解密密文，任何知道秘密 s 的人都可以计算 𝑐 -a ⊺ s mod 𝑞 并将结果四舍五入到最接近的 ⌊𝑞/𝑝⌋ 倍数。 只要从误差分布𝜒中采样的误差的绝对值小于 1 2 · ⌊𝑞/𝑝⌋，解密就会成功。 如果解密错误的概率最多为 𝛿（超过加密算法的随机性），我们说 Regev 参数的设置支持正确性错误 𝛿。 Regev 加密是加法同态的，因为给定两个密文 (a1, 𝑐1) 和 (a2, 𝑐2)，它们的和 (a1 +a2, 𝑐1 +𝑐2) 解密为明文的总和，前提是误差仍然足够小。

### 3.2 Private information retrieval with hints


我们现在给出我们构建的 PIR 方案类型的语法和安全定义。 我们的 PIR 形式与标准的单服务器 PIR 方案非常相似 [26, 53]。 主要区别在于我们允许 PIR 服务器提前预处理数据库并输出两个“提示”：一个是服务器存储在本地的，另一个是服务器发送给每个客户端的。 这种预处理允许 PIR 服务器将其大部分计算工作推入离线阶段，该阶段发生在客户端进行查询之前。 在我们的构造中，这两个提示都很小——它们的大小在数据库大小中是次线性的。 此外，所有客户端都使用相同的提示，并且客户端可以针对无限数量的 PIR 查询重复使用相同的提示。

备注 3.1（处理数据库更新）。 由于带有预处理的 PIR 方案对数据库执行一些预计算，因此如果数据库内容发生变化，服务器本质上需要重复其中的一些工作。 相关工作研究了如何以黑盒 [52] 和特定于协议的 [64] 方式最小化此类数据库更新所产生的计算和通信量。 我们在附录 C.3 和 E.3 中讨论了如何处理我们的方案中的更新。

一个带有预处理的 PIR 方案 [12]，在明文空间 D 和数据库大小 𝑁 ∈ Z 上，由四个例程组成，它们都将安全参数作为隐式输入：


Setup(db) → (hint𝑠, hint𝑐). Given a database db ∈ D𝑁 ,
output preprocessed hints for the server and the client.

Query(𝑖) → (st, qu). Given an index 𝑖 ∈ [𝑁], output a secret
client state st and a database query qu.

Answer(db, hint𝑠, qu) → ans. Given the database db, a server
hint hint𝑠, and a client query qu, output an answer ans.

Recover(st, hint𝑐, ans) → 𝑑. Given a secret client state st, a
client hint hint𝑐, and a query answer ans, output a database
record 𝑑 ∈ D.

正确性。 当客户端和服务器忠实地执行 PIR 协议时，客户端应该在隐式正确性参数中以几乎可以忽略不计的概率恢复其所需的数据库记录。 正式地说，如果在数据库大小 𝑁 ∈ N 上，对于所有数据库 db = (𝑑1, ..., 𝑑𝑁 ) ∈ D𝑁 和所有索引 𝑖 ∈ [𝑁]，则 PIR 方案具有正确性错误 𝛿，以下概率 至少为 1 - 𝛿：
<!-- 
$$
\operatorname{Pr}\left[\begin{array}{rl}
\left(\text { hint }_s, \text { hint }_c\right) & \leftarrow \operatorname{Setup}(\mathrm{db}) \\
(\mathrm{st}, \mathrm{qu}) & \leftarrow \operatorname{Query}(i) \\
\text { ans } & \leftarrow \operatorname{Answer}\left(\mathrm{db}, \text { hint }_s, \mathrm{qu}\right) \\
\ d_i = \hat{d}_i: \quad & \leftarrow \operatorname{Recover}\left(\text { st, }_i \text { hint }_c, \text { ans }\right)
\end{array}\right]
$$


$$
d_i=\hat{d}_i
$$ -->
![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917112812.png)

为了使 PIR 方案不平凡，总的客户端到服务器通信应该小于数据库的位长。 也就是说，它必须持有 |hint𝑐 | + |曲| + |答案| ≪ |分贝|。

安全。 客户端的查询不应显示有关其所需数据库记录的任何信息。 也就是说，我们说 PIR 方案是 (𝑇, 𝜖)-安全的，如果，对于所有在时间上运行的攻击者 A 最多为 𝑇，数据库大小为 𝑁 ∈ N，并且对于所有 𝑖，𝑗 ∈ [𝑁]，

$$
\begin{aligned}
&\mid \operatorname{Pr}\left[\mathcal{A}\left(1^N, \mathrm{qu}\right)=1:(\text { st, qu }) \leftarrow \operatorname{Query}(i)\right] \\
&-\operatorname{Pr}\left[\mathcal{A}\left(1^N, \mathrm{qu}\right)=1:(\text { st }, \mathrm{qu}) \leftarrow \operatorname{Query}(j)\right] \mid \leq \epsilon .
\end{aligned}
$$

备注 3.2（无状态客户端）。 我们的 PIR 方案中的客户端在查询中不持有任何秘密状态。 相比之下，在 SealPIR [9] 和相关方案中，客户端使用持久的长期加密秘密构建其查询。 我们在附录 B 中表明，在某些情况下，恶意 PIR 服务器可以对这些方案执行状态恢复攻击，从而破坏过去和未来查询的客户端隐私。 我们的无国籍方案不易受到此类攻击。


## 4 SimplePIR


在本节中，我们将介绍我们的第一个 PIR 方案 SimplePIR。 就每个内核每秒的吞吐量而言，SimplePIR 是迄今为止已知最快的 PIR 方案，即使与双服务器 PIR 方案相比也是如此（表 1）。 特别地，我们证明了以下定理：



非正式定理 4.1。 在数据库大小 𝑁 上，让 𝑝 ∈ N 是一个合适的明文模数，用于使用 LWE 参数 (𝑛, 𝑞, 𝜒) 的密钥 Regev 加密，实现 √ 𝑁 LWE 样本的 (𝑇, 𝜖)-安全性并支持 √ 𝑁 同态加法 有正确性错误𝛿（参见第 4.2 节）。 然后，对于随机 LWE 矩阵 $A ∈ Z^{√𝑁×𝑛}_𝑞$ ，SimplePIR 是一个 (𝑇 − 𝑂( √ 𝑁), 2𝜖)-安全 PIR 方案，数据库大小为 𝑁，在明文空间 Z𝑝 上，正确性错误为 𝛿。

我们在图 2 中给出了 SimplePIR 的正式描述，并在附录 C 中证明了它的安全性和正确性。

备注 4.1（SimplePIR 的具体成本）。 使用非正式定理 4.1 的参数，我们在 Z𝑞 上的操作（即整数加法和乘法）方面给出了 SimplePIR 的具体成本，没有隐藏常数。 在一次性公共预处理阶段，SimplePIR 需要：



构造：SimplePIR。 构造的参数是数据库大小𝑁、LWE 参数（𝑛、𝑞、𝜒）、明文模数𝑝 ≪ 𝑞 和 LWE 矩阵 A ∈ Z √ 𝑁×𝑛 𝑞（在实践中使用哈希函数采样）。 数据库由 Z𝑝 中的 𝑁 值组成，我们将其表示为 Z √ 𝑁× √ 𝑁 𝑝 中的矩阵。 定义标量 Δ := ⌊𝑞/𝑝⌋ ∈ Z。


Setup(db ∈ Z √ 𝑁× √ 𝑁 𝑝 ) → (hint𝑠, hint𝑐). • Return (hint𝑠, hint𝑐) ← (⊥, db · A ∈ Z √ 𝑁×𝑛 𝑞 ). Query(𝑖 ∈ [𝑁]) → (st, qu). • Write 𝑖 as a pair (𝑖row, 𝑖col) ∈ [√ 𝑁] 2 . • Sample s ←R Z 𝑛 𝑞 and e ←R 𝜒 √ 𝑁 . • Compute qu ← (As + e + Δ · u𝑖col) ∈ Z √ 𝑁 𝑞 , where u𝑖col is the vector of all zeros with a single ‘1’ at index 𝑖col. • Return (st, qu) ← ( (𝑖row,s), qu). Answer(db ∈ Z √ 𝑁× √ 𝑁 𝑝 , hint𝑠, qu ∈ Z √ 𝑁 𝑞 ) → ans. • Return ans ← db · qu ∈ Z √ 𝑁 𝑞 . Recover(st, hint𝑐 ∈ Z √ 𝑁×𝑛 𝑞 , ans ∈ Z √ 𝑁 𝑞 ) → 𝑑. • Parse (𝑖row ∈ [√ 𝑁],s ∈ Z 𝑛 𝑞 ) ← st. • Compute 𝑑ˆ ← (ans[𝑖row] − hint𝑐 [𝑖row, :] · s) ∈ Z𝑞, where ans[𝑖row] denotes component 𝑖row of ans and hint𝑐 [𝑖row, :] denotes row 𝑖row of hint𝑐. • Return 𝑑 ← RoundΔ(𝑑ˆ)/Δ ∈ Z𝑝, which is 𝑑ˆrounded to the nearest multiple of Δ and then divided by Δ.

设置（db ∈ Z √ 𝑁× √ 𝑁 𝑝 ）→（提示𝑠，提示𝑐）。 • 返回 (hint𝑠, hint𝑐) ← (⊥, db · A ∈ Z √ 𝑁×𝑛 𝑞 )。查询(𝑖 ∈ [𝑁]) → (st, qu)。 • 将𝑖写成一对(𝑖row, 𝑖col) ∈ [√ 𝑁] 2 。 • 样本 s ←R Z 𝑛 𝑞 和 e ←R 𝜒 √ 𝑁 。 • 计算 qu ← (As + e + Δ · u𝑖col) ∈ Z √ 𝑁 𝑞 ，其中 u𝑖col 是在索引 𝑖col 处带有单个“1”的全零向量。 • 返回 (st, qu) ← ( (𝑖row,s), qu)。答案(db ∈ Z √ 𝑁× √ 𝑁 𝑝 , hint𝑠, qu ∈ Z √ 𝑁 𝑞 ) → ans. • 返回ans ← db · qu ∈ Z √ 𝑁 𝑞。恢复(st, hint𝑐 ∈ Z √ 𝑁×𝑛 𝑞 , ans ∈ Z √ 𝑁 𝑞 ) → 𝑑。 • Parse (𝑖row ∈ [√ 𝑁],s ∈ Z 𝑛 𝑞 ) ← st。 • 计算𝑑^ ← (ans[𝑖row] − hint𝑐 [𝑖row, :] · s) ∈ Z𝑞，其中 ans[𝑖row] 表示组件 𝑖 ans 行，hint𝑐 [𝑖row, :] 表示行𝑖行提示𝑐。 • 返回𝑑 ← RoundΔ(𝑑^)/Δ ∈ Z𝑝，它是 𝑑^四舍五入到最接近的 Δ 倍数，然后除以 Δ。

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917113409.png)





Figure 2: The SimplePIR protocol.


- 服务器在 Z𝑞 中执行 2𝑛𝑁 操作，以及 
- 客户端在 Z𝑞 中下载 𝑛 √ 𝑁 元素，我们的实现需要 𝑛 = 2 10 和 𝑞 = 2 32 来实现 128 位安全性以抵御最知名的攻击 [7] .

On each query, SimplePIR requires
• the client to upload √
𝑁 elements in Z𝑞,
• the server to perform 2𝑁 operations in Z𝑞, and
• the client to download √
𝑁 elements in Z𝑞.

在每个查询中，SimplePIR 要求 
- 客户端上传 Z𝑞 中的 √ 𝑁 元素， 
- 服务器在 Z𝑞 中执行 2𝑁 操作，以及 
- 客户端下载 Z𝑞 中的 √ 𝑁 元素。


### 4.1 技术思路

我们现在更详细地讨论 SimplePIR 构造。最简单的非平凡单服务器 PIR 方案 [22, 53, 60] 采用以下“平方根”方法：给定一个 𝑁 元素数据库，服务器将此数据库存储为 √ 𝑁-by- √ 𝑁 方阵.同时，希望查询数据库条目𝑖 ∈ [𝑁] 的客户端将索引 𝑖 分解为坐标对 (𝑖row, 𝑖col) ∈ $[√𝑁]^2$ 。然后，客户端在 $Z^{√𝑁}_2$ 中构建一个单位向量 $u_{𝑖_{col}}$（即，在索引 𝑖col 处具有单个“1”的全零向量），使用线性同态加密方案逐元素对其进行加密，并发送此加密向量到服务器。服务器计算数据库和查询向量之间的矩阵向量乘积并将其返回给客户端。最后，客户端解密服务器答案向量的元素 𝑖row——它正好对应于数据库行 𝑖row 和加密单位向量 u𝑖col 的内积，或者等效地，在 (𝑖row, 𝑖col) 处的加密数据库条目。在该方案中，服务器和客户端交换 2 √ 𝑁 密文元素，而服务器执行 𝑁 密文乘法和加法来回答每个 PIR 查询


首先呢，服务器把一个 𝑁 元素数据库存储为 √ 𝑁-by- √ 𝑁 的一个矩阵,预处理数据库并输出两个“提示”：一个是服务器存储在本地的，另一个是服务器发送给每个客户端的。
服务器。服务器


客户端将要查询的一个索引 i 分解为一个坐标对（$i_x,i_j$）,
然后客户端利用这个坐标构造一个单位向量，使用线性同态加密方案逐元素对其进行加密，并发送此加密向量到服务器。服务器计算数据库和查询向量之间的矩阵向量乘积并将其返回给客户端。最后，客户端解密服务器答案向量的元素——它正好对应于数据库行 𝑖row 和加密单位向量 u𝑖col 的内积。



![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917113750.png)

图 3：SimplePIR 中的服务器计算。 每个单元格代表一个 Z𝑞 元素，× 表示矩阵乘法。 服务器在一次性预处理阶段执行其大部分工作——即，将数据库 db 和矩阵 A 相乘。 此后，服务器可以通过轻量级在线阶段回答每个客户端的查询。


我们的出发点是使用 Regev 的基于 LWE 的加密方案 [76] 的密钥版本来实例化这种“平方根”方法。 让 (𝑛, 𝑞, 𝜒) 为 LWE 参数。 然后，向量 𝝁 ∈ Z 𝐿 𝑝 的 Regev 加密由一对矩阵和一个向量组成：

$$
\operatorname{Enc}(\boldsymbol{\mu})=(\mathbf{A}, \mathbf{c})=(\mathbf{A}, \mathbf{A s}+\mathbf{e}+\lfloor q / p\rfloor \cdot \boldsymbol{\mu})
$$


对于一些 LWE 矩阵 A ←R Z 𝐿×𝑛 𝑞 ，秘密 s ←R Z 𝑛 𝑞 和误差向量 e ←R 𝜒 𝐿


我们对 Regev 加密做了三个重要的观察：


首先，密文的很大一部分——即矩阵 A——与加密信息无关。 因此可以提前生成矩阵A。
其次，即使许多不同方使用相同的矩阵 A 来加密许多消息 [73]，Regev 加密仍然是安全的，前提是每个密文使用独立的秘密向量 s 和错误向量 e。
最后，我们可以在安全性损失可以忽略不计的情况下将 A 视为伪随机（而不是随机），从而允许我们用一个短随机种子简洁地表示 A。


在 SimplePIR 中，我们利用这三个观察结果如下。 考虑一个希望在 ($𝑖_{row}$, $𝑖_{col}$) 处检索数据库条目的客户。 在概念层面上，客户端对服务器的查询由 Enc($u_{𝑖_{col}}$) = (A, c) 组成——$Z^{√𝑁}_𝑝$ 中向量的 Regev 加密，它处处为零，但在索引 𝑖col 处为“1”。 然后，服务器将数据库表示为矩阵 D ∈ $Z^{√𝑁×√𝑁}_𝑝$，并计算并返回数据库与客户端加密查询的矩阵向量积，即 (D·A，D·c)。 根据服务器的回复，客户端可以根据需要使用标准 Regev 解密来恢复 $D·u_{𝑖_{col}}$ ∈ $Z^{√𝑁}_𝑝$，这正是数据库的第 $𝑖_{col}$ 列。

现在，我们进行以下修改：



我们让服务器在预处理阶段提前计算值 D·A。 此预处理步骤需要 Z𝑞 中的 2𝑛𝑁 操作，其中 𝑛 ≈ 2 10 是 LWE 秘密的维度，𝑁 是数据库大小。 然后，为了回答客户端的查询，服务器需要计算值 D·c，这只需要 Z𝑞 中的 2𝑁 操作。 因此，服务器工作的 𝑛/(𝑛 + 1) 部分（即 99.9%）可以提前发生——甚至在客户端决定要获取哪个数据库记录之前。


我们让所有客户使用相同的矩阵 A 来构建他们的查询。 然后，服务器必须只预计算一次 D·A。 服务器将这一一次性“提示”发送给所有客户端。 因此，服务器将计算和通信 D·A 的成本分摊给许多客户端和许多查询。


作为优化，我们使用伪随机性压缩 A。 在协议启动之前的初始化步骤中，服务器和客户端就用于生成 A 的公共随机种子达成一致。这节省了带宽和存储，因为服务器和客户端通信并仅存储一个小种子。


SimplePIR 结构的安全性几乎紧跟 Regev 加密 [76] 的安全性和重用矩阵 A [73]，而后者又遵循 LWE 的硬度。 SimplePIR 的正确性源于 Regev 的线性同态加密方案以及 Kushilevitz 和 Ostrovsky 的“平方根”PIR 模板的正确性。


### 4.2 参数选择


选择 LWE 参数（𝑛、𝑞、𝜒）和明文模数 𝑝 需要进行标准（尽管乏味）分析。 根据现代格子攻击成本估计[7]，我们选择我们的参数具有 128 位安全性。 特别是，我们设置秘密维度𝑛 = 2 10，使用模数𝑞 = 2 32（因为现代硬件本身支持使用此模数的操作），将误差分布𝜒设置为具有标准偏差𝜎 = 6.4的离散高斯分布，以及 允许正确性错误𝛿 = 2 −40。 我们在数据库大小𝑁和明文模数𝑝之间进行了以下权衡：

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917114446.png)

我们将在附录 C.1 中进一步讨论参数选择。

### 4.3 扩展

最后，我们扩展了我们的 SimplePIR 构造以满足实际部署场景的要求：

支持具有更大记录大小的数据库。 基本的 SimplePIR 方案（图 2）支持数据库，其中每条记录都是单个 Z𝑝 元素，或者，使用我们的参数设置大约为 8-10 位。 我们的主要应用程序（第 7 节）使用具有一位记录的数据库，尽管 PIR [6, 9, 10, 48, 66] 的其他应用程序使用更长的记录。


为了处理大型记录，我们观察到 SimplePIR 中的客户端可以一次检索数据库的整个列。 具体来说，在与服务器执行单个在线阶段以查询数据库元素（𝑖row，𝑖col）后，客户端可以运行Recover过程√𝑁次——[√𝑁]中的每一行一次——以重建整个数据库列𝑖col . 因此，为了支持大记录，我们将每个记录编码为明文空间 Z𝑝 中的多个元素，并将这些元素垂直堆叠在同一个数据库列中。 通过进行单个在线查询并重建相应的元素列，客户端可以恢复其选择的任何记录。


在 𝑁 记录的数据库中，每个 Z 𝑑 𝑝（其中 𝑑 ≤ 𝑁），具有 LWE 秘密维度 𝑛 和模数 𝑞，SimplePIR 具有：

- 一次性（提示）下载 Z𝑞 中的 𝑛 · √ 𝑑𝑁 元素， 
- 每次查询上传和下载 Z𝑞 中的 √ 𝑑𝑁 元素，以及 
- 每次查询服务器计算 2𝑑𝑁 Z𝑞 中的操作。


一次获取许多数据库记录（“Batch PIR”）。 在许多应用程序 [9, 10] 中，客户端希望立即从 PIR 服务器获取 𝑘 记录。 如果客户端在 𝑁 记录的数据库上运行我们的 PIR 协议 𝑘 次，则服务器总时间大约是 𝑘𝑁。 我们可以应用 Ishai 等人的“批量 PIR”技术。 [50] 允许客户端以服务器端成本获取 𝑘 记录 ≪ 𝑘𝑁，而无需增加提示大小。


这个想法是将𝑁记录的数据库随机划分为𝑘块，每个块都表示为一个维度矩阵（√𝑁/𝑘）×√𝑁。 为了获取一组属于不同块的𝑘数据库记录，客户端和服务器然后在每个数据库块上运行一次 SimplePIR。 提示大小（即离线客户端下载）保持为 𝑛 √ 𝑁 — 与单查询 SimplePIR 中一样。 客户端的通信成本是𝑘 · √ 𝑁—𝑘 倍于单次查询 SimplePIR（如果客户端按顺序获取所有 𝑘 记录，则与通信相同）。 服务器在 Z𝑞 中执行 𝑁 操作，就像在单查询 SimplePIR 中一样。

但是，多个客户所需的记录可能会落入同一个块中。 有两种方法可以处理这个问题：



- 如果客户端必须以压倒性的概率恢复所有 𝑘 记录，则客户端可以运行整个批处理 PIR 协议 𝜆 次以实现失败概率 2 −Ω(𝜆) [9, 50]。 
- 如果客户端只需要恢复一定比例的𝑘 数据库记录，那么客户端和服务器只运行一次此协议。 服务器端计算成本与单查询 SimplePIR 相同。

额外的改进。 我们在附录 C.3 中讨论了如何进一步提高 SimplePIR 的渐近效率。


### 4.4 快速线性同态加密Fast linearly homomorphic encryption

在附录 D 中，我们介绍了带有预处理的线性同态加密的概念。 这个新的原语抽象出了我们在 SimplePIR 中使用的 Regev 加密的关键属性。 我们期望这种新形式的线性同态加密有进一步的实际应用。


## 5 DoublePIR


## 6 Data structure for private approximate set membership6 私有近似集成员的数据结构



在本节中，我们为近似私有集成员问题介绍了一种新的数据结构。 在这个问题中，客户端持有私有字符串𝜎，服务器持有一组字符串𝑆，并且客户端想要测试𝜎是否包含在𝑆中，而不向服务器透露𝜎。 为了排除服务器将𝑆发送给客户端的简单解决方案，我们坚持|𝑆|中的次线性通信。 这个问题与私有集合交集[41]的问题在两个关键方面不同：服务器的集合𝑆不需要保持私有，客户端的输出位𝑏（指示是否𝜎 ∈𝑆）可能是近似的，即有 它有可能是不正确的。 展望未来，我们的数据结构将成为我们新的证书透明度审计计划的核心（第 7 节）。


在非常高的层次上，我们让服务器将其字符串集𝑆预处理成数据结构。 然后，持有私有字符串 𝜎 的客户端可以通过仅读取服务器数据结构的少数位来测试是否 𝜎 ∈ 𝑆。 客户端使用 PIR 从服务器获取这些位。 因此，此设置中的相关成本指标（表 4）是：


- 探头数量。 客户端必须读取服务器数据结构的多少位/符号？ 
- PIR 数据库大小。 客户端执行其私有 PIR 读取的数据结构的大小是多少？ 
- 稳健性错误（即误报率）。 对于对抗性选择的集合 𝑆 和字符串 𝜎，当 𝜎 ∉ 𝑆 时，客户端输出“𝜎 ∈ 𝑆”的概率是多少，仅取决于客户端随机性的选择。



备注 6.1（假阳性与假阴性）。 一些（但不是全部）应用程序可以容忍误报。 例如，密码泄露数据库查找 [57,72,80] 可能会容忍高达 2 −30 的误报率； 相比之下，安全浏览阻止列表查找 [47, 52] 需要加密可忽略的误报率，因为误报会导致合法网站被标记为恶意网站。 对于后一种情况，其他数据结构可能更合适。


### 6.1 Related approaches


标准的布隆过滤器 [14] 是解决这个问题的一个很好的解决方案，除了一个主要的问题：它们提供的健全性保证对于我们的目的来说太弱了。 特别是，标准 Bloom 过滤器的稳健性保证仅在被测试的字符串 𝜎 的选择独立于用于构造过滤器的随机性（即散列函数）时才成立。 在我们的对抗设置（第 7 节）中，数据结构（包括其散列函数）是公开的，并且攻击者可以选择字符串 𝜎，其方式取决于用于构造 Bloom 过滤器的散列函数 . 标准布隆过滤器在此设置中不能提供良好的可靠性，除非探测器的数量相对较大（表 4）。


为了解决这个问题，之前的工作已经构建了对抗性布隆过滤器 [27, 68]。 虽然这些数据结构提供了我们需要的对抗性稳健性，但它们不提供隐私。 特别是，它们要求客户端将其字符串 𝜎 发送到服务器； 然后，服务器对 𝜎 执行私有计算以确定探测。

相比之下，我们展示了服务器如何构建数据结构，以便客户端可以通过从比布隆过滤器或其他标准技术（安全 参数𝜆≈128）。 如果客户端使用 PIR 读取此位，则此方法是私有的。 缺点是我们的数据结构的健全性错误率是恒定的（即 1/2），而不是在 𝜆 中可以忽略不计。 然而，由于我们的应用程序（第 7 节）可以自然地容忍恒定的稳健性误差，因此这种权衡是有利可图的。


### 6.2 Syntax and properties语法和属性


我们为我们的近似私有集成员数据结构定义语法和安全属性。 数据结构由可能字符串的全域 U ⊆ {0, 1} ∗ 参数化，并由两个例程组成：

Setup(𝑆) → 𝐷. Take as input a set of strings 𝑆 ⊆ U and
output a data structure 𝐷 ∈ {0, 1}
𝑎×𝑏
, where 𝑎, 𝑏 ∈ N can
depend on |𝑆|. This algorithm is deterministic.
Query(𝜎) → (𝑖, 𝑗). Given a candidate string 𝜎 ∈ U, output an
index (𝑖, 𝑗) ∈ [𝑎] × [𝑏] in the data structure 𝐷 to probe. If
𝜎 ∈ 𝑆, it holds that 𝐷𝑖, 𝑗 = 1. This algorithm is randomized.

设置（𝑆）→𝐷。 将一组字符串 𝑆 ⊆ U 作为输入，并输出一个数据结构 𝐷 ∈ {0, 1} 𝑎×𝑏 ，其中𝑎，𝑏 ∈ N 可以依赖于 |𝑆|。 该算法是确定性的。 查询（𝜎）→（𝑖，𝑗）。 给定一个候选字符串𝜎 ∈ U，在数据结构 𝐷 中输出一个索引 (𝑖, 𝑗) ∈ [𝑎] × [𝑏] 进行探测。 如果𝜎 ∈ 𝑆，它认为𝐷𝑖，𝑗 = 1。这个算法是随机的。

Properties. For a set 𝑆 ⊆ U and string 𝜎 ∈ U, define

特性。 对于集合 𝑆 ⊆ U 和字符串 𝜎 ∈ U，定义

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917150547.png)

其中概率仅取自 Query 算法的随机性。

Completeness. An approximate membership test is complete
if, for all 𝑆 ⊆ U and 𝜎 ∈ 𝑆, Accept(𝑆, 𝜎) = 1.

完整性。 如果对于所有 𝑆 ⊆ U 和 𝜎 ∈ 𝑆，Accept(𝑆, 𝜎) = 1，则近似成员检验完成。

Soundness. An approximate membership test has soundness
error 𝜖 if, for all 𝑆 ⊆ U and 𝜎 ∉ 𝑆, Accept(𝑆, 𝜎) ≤ 𝜖.

健全。 如果对于所有 𝑆 ⊆ U 和 𝜎 ∉ 𝑆，Accept(𝑆, 𝜎) ≤ 𝜖，则近似成员检验具有稳健性错误 𝜖。


隐私。 如果 Query 算法探测的数据结构的行没有显示有关查询字符串 𝜎 的信息，则近似成员资格测试是私有的。 特别是，如果对于所有字符串 𝜎0, 𝜎1 ∈ U，行索引的以下分布相同，则我们说隐私成立：

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917150815.png)


在部署中，为了探测数据结构中行𝑖和列𝑗的元素，客户端以明文形式向服务器发送𝑖以及针对𝑗的 PIR 查询。 服务器在第 𝑖 行上执行 PIR 方案，并将 PIR 答案（以及，如果需要，该行的客户端提示）发送回客户端。 因此，通过上述隐私属性，服务器对𝜎一无所知。 与相关方法相比，仅对数据结构的一行（而不是整个数据结构）执行 PIR 将是我们 𝜆 倍性能改进的源泉。

### 6.3 Our approximate membership test

我们的构造由整数 𝑎、𝑘 ∈ N 和集合大小 𝑁 参数化。 然后，我们的数据结构将字符串集合 𝑆 映射到 𝑎-by-(𝑘𝑁) 位的矩阵中。 该结构使用加密散列函数𝐻1, 。 . . , 𝐻𝑎 : U → [𝑘𝑁]，我们将其建模为独立的随机预言机 [13]。

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917151010.png)
然后我们在附录 F 中证明以下命题：


提案 6.2。 近似的成员资格测试数据结构（Setup，Query），参数 𝑎 ≥ 2 (log(|U|) + 𝜆) 和 𝑘 ≥ 8，是完整的、私有的，并且有 1/2 的健全性错误。 在选择建模为独立随机预言机的哈希函数时，构造失败的概率为 2 -𝜆。 具体来说，在 |U| = 2 256，取 𝑘 = 8 和 𝑎 = 768 给出稳健性误差 1/2 和失败概率 2 -128。

## 7 Application: Auditing in Certificate Transparency 7 应用：证书透明度审计

我们现在解释如何使用我们的新 PIR 方案来解决在证书透明度部署中私下审核签名证书时间戳的问题 [54,55,65]。

### 7.1 Problem statement
背景：证书透明度


证书透明度的目标是将每个证书颁发机构颁发的每个公钥证书存储在一组可公开访问的日志中。 为此，证书颁发机构将他们颁发的证书提交给日志操作员，他们以签名证书时间戳 (SCT) 进行响应。 SCT 承诺在一定时间内将新证书包含在此运营商维护的日志中。



稍后，当 TLS 服务器向客户端发送公钥证书时，服务器会根据客户端的策略附加多个 SCT（例如，Google 和 Apple 都需要分别来自 Chrome 和 Safari 中三个不同日志操作符的 SCT） . 通过验证 SCT，客户端可以确保每个日志操作员都看到了新证书，并且 - 如果操作员是诚实的 - 最终会记录它。 然后，域运营商可以使用日志来检测证书颁发机构是否错误或恶意为其域颁发了证书


SCT auditing  SCT 审计


为了保持日志的真实性，系统中的某些方还必须验证日志操作员是否履行了他们发布的 SCT 中隐含的承诺。 特别是，如果客户端收到由日志操作员签署的某些证书 𝐶 的 SCT，则该方希望验证 𝐶 确实出现在该操作员的公共日志中。 这个过程是 SCT 审计。


客户必须参与 SCT 审计，因为他们是唯一“在野外”看到 SCT 的参与者。 但是，由于客户端看到的一组 SCT 揭示了有关客户端浏览历史的信息，客户端不应向日志操作员或任何其他实体透露它看到的 SCT。


谷歌最近提出的 SCT 审计建议 [33, 78] 涉及一名独立于客户的 SCT 审计员（由谷歌运营）。 在他们的模型中，审核员维护所有证书透明度日志中未过期证书的整套 SCT。 客户在实时网站上看到的每个 SCT 都应该出现在审核员的集合中。 为了确定 SCT 是否有效，客户端可以检查它（或者实际上，它的 SHA256 哈希）是否出现在审核员维护的有效 SCT 集中：

• 如果客户的 SCT 出现在审核员的集合中，则日志
发出 SCT 的服务器正确地履行了它的承诺。

• 如果没有，客户可以将有问题的 SCT 报告给审核员（即 Google）以进一步调查。

为了保护客户的隐私，客户不应直接向审计师透露其 SCT。 （同样，客户已经看到了 example.com 的 SCT 的事实表明客户已经访问了 example.com。）因此，用于 SCT 审计的隐私保护解决方案必须允许客户测试其 SCT 是否出现在 审计员的有效 SCT 集，而不向审计员透露其 SCT。 这是一个私有集合成员问题[80]。

总而言之，我们需要以下属性来保持，我们只是非正式地声明：

• 误报的正确性。 当一个诚实的客户持有字符串𝜎，独立于客户的秘密随机性选择，与持有字符串𝑆 = {𝜎1, 𝜎2, . . . }：

– 如果 𝜎 ∈ 𝑆，那么客户端总是输出“有效”，并且 – 如果 𝜎 ∉ 𝑆，那么客户端输出“无效”的概率至少为 1/2，超过了客户端随机性的选择。

• 客户的隐私。 当诚实的客户端与恶意审计服务器交互时，服务器不会了解客户端的私人输入字符串𝜎。

我们不需要正确性来抵御恶意审计服务器。 （如果审计服务器想要破坏正确性，它可以通过对其 SCT 集撒谎来轻松做到这一点。）


系统参数。 今天，网络上大约有 50 亿个活跃的 SCT [33]。 随着证书颁发机构颁发证书和证书到期 [2]，每天大约有 600 万个证书被添加或删除。 谷歌当前的 SCT 审计提议要求 Chrome 客户端随机抽样 0.1% 的与其 TLS 连接相关的 SCT，并且只审计所有 SCT [33] 中的一小部分。 以这种方式随机抽样将审计的摊销成本降低了 1000 倍，但也减少了单个审计客户捕获作弊日志的机会。 尽管如此，在许多审计客户中，这种随机 SCT 审计将很有可能捕获许多客户看到的无效 SCT。 （在 1000 个客户观察到无效的 SCT 后，会有一个期望对其进行审核。）


### 7.2 Existing approaches to SCT auditing

我们考虑了两个现有的 SCT 审计建议，可以单独使用或组合使用。


选择退出 SCT 审计。 谷歌浏览器当前的提议 [33] 让客户端向审计服务器显示其 SCT 哈希的前 20 位。 审计服务器在其集合中以该 20 位前缀开头的所有 ≈ 1000 个 SCT 进行回复。 这种方法实现起来很简单，但是对于 𝑘 = 1000 只实现了 𝑘-匿名； 即，谷歌的审计服务器获悉客户访问了一组 1000 个网站中的一个。


匿名代理。 客户端可以使用一个或多个代理服务器，例如在 Tor [34] 中，将其 SCT 匿名发送给审计员 [31]，审计员可以回复指示 SCT 是否出现在其集合中的位。 这种机制容易受到定时攻击，它会揭示客户 SCT 到审计服务器的整个分布，这可能允许审计师对特定客户进行去匿名化。 实际上，浏览器供应商可能不希望将这一安全关键任务外包给 Tor 网络。

### 7.3 Our approach

我们提出了一个新的 SCT 审计方案，它使用我们的 PIR 方案（第 4 和 5 节）以及我们新的近似集合成员数据结构（第 6 节）。 正如 Chrome 对 SCT 审计的提议 [33] 一样，我们希望在从客户端 TLS 连接中采样的一小部分 SCT 上运行该协议。 部署如下：


审计服务器：数据集构建。 SCT 审计服务器为所有 𝑁 活动 SCT 的所有 SHA256 哈希集合准备一个近似的集合成员数据结构。 该数据结构由𝑎 ≈ 768 个数组组成，每个数组长度为 8𝑁 位。 服务器在每个 𝑎 数组上运行我们的 PIR 方案的设置算法，以产生 𝑎 PIR 提示。


客户：提示下载。 客户端选择一个秘密随机值 𝑖 ∗ ←R [𝑎] 并从审计服务器下载 𝑖 ∗ -th 提示（在此过程中将 𝑖 ∗ 显示给服务器）。 为了测试特定的 SCT 哈希是否出现在服务器的集合中，客户端现在只需要从服务器持有的 𝑖 ∗ -th 数组中私下读取一个位。 恶意 TLS 服务器可以欺骗客户端以最多 𝜖 ≈ 1/2 的概率接受无效的 SCT。 （值 𝜖 是底层近似集合成员数据结构的参数。）如果客户端审核所有 TLS 连接的 𝑓 部分，则误报率为 (1 - 𝑓 ) + 𝑓 · 𝜖。 在我们的部署中，𝑓 = 1/500 和 𝜖 = 1/2，这产生了 1/1000 的整体假阴性率，与 Chrome 目前的提议 [33] 相匹配。



客户端和审计服务器：通过 PIR 进行 SCT 查找。 一旦客户端接收到它想要验证其有效性的 SCT，客户端就会对 SCT 进行哈希处理，计算客户端需要读取的服务器的 𝑖 ∗ -th 数组的位以验证 SCT 的有效性，并使用我们的 PIR 协议， 连同它的离线提示，阅读这一位。 审计服务器回答客户端关于 𝑖 ∗ -th 数组的 PIR 查询，客户端重建该位。

### 7.4 我们如何处理数据库更新

客户端持有一个取决于审计服务器数据库内容的 PIR “提示”。 每当活动 SCT 集发生变化时——随着证书颁发机构颁发新证书和证书到期而不断发生——审计服务器必须更新其数据库状态。 如果没有额外的工程，客户端将不得不从审计服务器下载新的提示。 由于提示相对较大（我们的参数设置为数十兆字节），我们希望客户端只需很少下载提示。


我们的方法是让客户端只定期下载一个提示——例如每周一次。 当审计服务器向客户端发送提示时，服务器会指定提示涵盖的证书颁发日期范围。 当客户想要审计 SCT 时，客户会检查其当前提示是否涵盖相关 SCT 的发布日期。 如果是这样，客户端会进行 PIR 查询以测试 SCT 的有效性。 如果没有，客户端会缓存 SCT 的哈希，以便在下次从审计服务器下载提示时测试此 SCT 的有效性。 这样，客户端最终会审计其 SCT 的全随机样本，但客户端只需要定期从审计服务器下载一个提示

服务器现在必须存储一些数据库副本（例如，每天一份），但服务器存储相对便宜。 在大规模部署中，通过让一个或多个物理服务器负责数据库的每个版本，很容易将所有这些数据库副本保存在内存中。


## 8 评估   

执行。 我们在 1000 行 Go 代码和 80 行 C 代码（用于矩阵乘法例程）中实现了 SimplePIR。 实现 DoublePIR 需要 170 行额外的 Go 代码。 我们的代码不依赖任何外部库，并根据 MIT 开源许可 [1] 发布。 SimplePIR 核心的代码清单出现在附录 G 中

我们将数据库以打包形式存储在内存中，并在运行中将其解压缩为 Z𝑝 元素，否则 Answer 例程受内存带宽限制。 在 DoublePIR 中，我们将数据库表示为矩形（而不是正方形）矩阵，因此第一级 PIR 主导计算。

我们使用单个执行线程在运行 Ubuntu 22.04 的 AWS c5n.metal 实例上运行所有实验。 为了收集表的吞吐量数字，我们将每个方案运行五次并报告平均值。 吞吐量的所有标准偏差均小于所测吞吐量的 5%。


### 8.1 Microbenchmarks微基准

吞吐量。 我们首先在最适合它的数据库维度上测量每个 PIR 方案的最大吞吐量。 在表 1 中，我们报告了针对每个 PIR 方案测量的吞吐量，该数据库由大约 2 33 位（或 1 GB）组成，其中我们将条目大小设为相应论文中报告的最高吞吐量 （或在相关论文中，如果没有明确说明）。 这些条目大小出现在表 9 中。我们通过在图 6 中测量每个方案在每个条目大小上的吞吐量来确认这些吞吐量确实是每个方案可实现的最佳值。

SimplePIR 和 DoublePIR 分别实现了 6.5 GB/s 和 5.2 GB/s 的吞吐量，这比之前为流设置 (SpiralStreamPack) 设计的最快的单服务器 PIR 方案好大约 5 倍，比之前最快的单服务器 PIR 方案好 18 倍 专为具有短条目（螺旋）的数据库设计的服务器 PIR 方案。 SimplePIR 和 DoublePIR 还实现了比之前的两服务器 PIR 方案更高的每服务器吞吐量1：来自 DPF 的两服务器 PIR 实现了每服务器 5.4 GB/s 的吞吐量。 最后，我们对在数据库的线性扫描中执行 XOR 的吞吐量进行基准测试，以提供线性工作、两台服务器 PIR 性能的硬上限。 该基准测试实现了每台服务器 6.1 GB/s 的吞吐量，也比 SimplePIR 慢。


沟通。 在图 6 中，我们给出了每个方案的总通信量，分摊了 100 多个查询，以增加条目大小。 在具有短条目的数据库上，DoublePIR 的摊销通信与最高效的通信方案（Spiral、SpiralPack、SealPIR 和 OnionPIR）相当。 随着条目的增加，DoublePIR 的摊销通信成本会增加，因为客户端必须下载许多提示。 与我们的吞吐量最接近的两种方案（SpiralStream 和 SpiralStreamPack）以及 FastPIR 在入口大小小于 1 kbit 时具有比 DoublePIR 和 SimplePIR 大得多的分摊通信。

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917153320.png)


图 5：吞吐量与每次查询通信，在总大小为 2 33 位（或 1 GiB）的数据库上。 对于每个 PIR 方案，我们显示了两种条目大小选择的通信和相应的吞吐量：一种使吞吐量最大化，另一种使通信最小化。 （对于只显示一个点的方案，两个条目大小相同。）给出的每次查询通信成本是总（即离线和在线）通信，摊销超过 100 个查询。



吞吐量与通信的权衡。 我们在图 5 中总结了这些发现，该图显示了每个 PIR 方案实现的吞吐量/通信权衡。 具体来说，我们在 2 33 位的数据库上运行每个方案，并增加条目大小（如图 6 所示）。 然后，对于每个方案，我们显示每个查询的通信（摊销超过 100 个查询）和两个条目大小选择的相应吞吐量：一个最大化吞吐量，另一个最小化通信。 图 5 展示了我们的新 PIR 方案在设计空间中实现了一个新点：SimplePIR 和 DoublePIR 具有比所有先前的单服务器 PIR 方案更高的吞吐量； DoublePIR 还具有每次查询的通信成本，与最具通信效率的方案相比具有竞争力。


在 2 个 33 × 1 位条目的数据库上进行比较。 在表 7 中，我们对每个方案在与我们的应用程序相关的数据库上的性能进行了细粒度比较，该数据库由 2 33 个 1 位条目组成。 在这个数据库上，SimplePIR 和 DoublePIR 再次实现了比所有其他方案高得多的吞吐量（分别为 6 GB/s 和 5 GB/s）。 SimplePIR 具有较高的离线下载，因此也具有客户端存储成本。 但是，DoublePIR 的离线下载与其他 PIR 方案的离线通信不相上下，其在线通信量为千字节量级。

对于每个方案，我们额外计算其每次查询的成本，当客户端进行 100 次数据库查询时，使用 AWS 的计算成本（每核每秒 1.5 美元·10−5 美元）和从 Amazon EC2 传出的数据（每 GB 0.09 美元）。 SimplePIR 的每次查询成本为 1 · 10−4 美元，而 DoublePIR 和相关工作中最便宜的方案 (SpiralStreamPack) 的每次查询成本为 2 · 10−5 美元。 然而，我们注意到 SpiralStreamPack 具有非常大的在线上传量（以兆字节为量级），这并未反映在其每次查询成本中，因为 AWS 仅对传出通信收费。

批处理查询。 最后，我们评估 SimplePIR 和 DoublePIR 的有效吞吐量在客户端一次对 𝑘 记录进行批量查询时如何扩展，假设客户端只需要恢复固定比例的 𝑘 记录。 对于增加的 𝑘 值，我们计算“成功”查询的预期数量（即，落入不同数据库块的预期查询数量，如 4.3 节所述），我们得出预期“成功”吞吐量，即 当服务器一次回答该数量的查询时测量的吞吐量，一次通过数据库。


图 8 显示，当客户端一次进行一批查询时，SimplePIR 和 DoublePIR 的吞吐量都会增加。 SimplePIR 的吞吐量线性扩展，在批量大小 𝑘 ≥ 32 上实现超过 100 GB/s 的值，在批量大小 𝑘 ≥ 256 上实现大约 1000 GB/s 的值。对于 𝑘 ≥ 64，DoublePIR 实现大约 50 GB/s 的吞吐量； 此时，吞吐量达到稳定水平，因为第二级 PIR 成为瓶颈。

![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917154142.png)
图 6：每个 PIR 方案的吞吐量和每次查询通信，在总大小为 2 33 位（或 1 GB）的数据库上，条目大小增加。 给出的每次查询通信成本是每次查询通信的总（即离线和在线），分摊超过 100 个查询。




![](https://raw.githubusercontent.com/JF-011101/Image_hosting_rep/main/20220917154213.png)


图 8：在由 2 个 33×1 位条目组成的数据库上，有效的 PIR 吞吐量（数据库大小 × 每秒查询数），随着批量大小的增加和固定大小的提示。 阴影显示标准偏差。




### 8.2 Certificate Transparency benchmark证书透明度基准


我们建议将 DoublePIR 用于 SCT 审计应用程序。 使用我们用于私有集成员的新数据结构，SCT 审计任务需要对具有 1 位条目的数据库进行单轮 PIR。 对于这样的数据库，我们在第 8.1 节中的评估表明，DoublePIR 实现了高服务器吞吐量和小型客户端存储和通信。 SCT 审计发生在后台，并不在 Web 浏览的关键路径上。 因此，虽然使用 PIR 可能会增加审计的延迟，但我们认为这是交换加密隐私的理想权衡，只要计算保持适度并且通信保持可比性。


为了在此应用程序上下文中对 DoublePIR 进行基准测试，我们在由 2 个 36 × 1 位条目组成的数据库上评估该方案，当我们用所有 5亿活跃的 SCT。 （在我们的评估中，每个条目都是一个随机位。）在这个数据库大小上，我们测量 DoublePIR 的“提示”大小为 16 MB，在线上传大小为 724 KB，在线下载大小为 32 KB。服务器可以在不到 1.9 个核心秒的时间内回答每个查询（并且这项工作是完全可并行化的）。由于我们的客户端必须每 500 个 TLS 连接审计一个，因此我们的 SCT 审计建议需要：(1) 每周 16 MB 的客户端存储和下载（以保留客户端提示），以及 (2) 每个 TLS 连接，摊销0.004 核心秒的服务器计算开销和 1.5 KB 的通信开销。使用 AWS 的计算成本（每核每秒 1.5 美元·10−5 美元）和数据传输（每传出 GB 0.09 美元），对于每个客户端，这相当于每周 0.001 美元的固定成本，以及每个 TLS 6 美元·10−8 美元联系。对于每周进行 104 次 TLS 连接的典型客户端 [3]，我们预计此成本约为每年 0.1 美元。由于（在对其 TLS 连接进行采样后）典型客户端使用每周的提示仅对审计服务器进行大约 20 次查询，因此我们可以使用附录 E.3 中的优化将客户端的存储空间减少到 400 KB 以下。


相比之下，谷歌浏览器当前的 SCT 审计方案每 1000 个 TLS 连接中就有一个客户端审计，并且仅提供 𝑘-匿名性（对于 𝑘 = 1000）[33]。 也就是说，服务器获悉客户端访问了一组 1000 个域中的一个。 审计会产生每个连接 240 B 通信的摊销开销 [33]、可忽略的服务器端计算和没有客户端存储（除非客户端缓存流行的 SCT）。 再次假设客户端每周进行 104 次 TLS 连接 [3]，我们预计此方案的成本约为 0.01 美元/客户端/年； 我们使用 DoublePIR 的方法只增加了 13 倍的通信量，并实现了加密隐私的目标。

## 9 Conclusion

我们展示了单服务器 PIR 的服务器端每核吞吐量可以接近机器的内存带宽。 我们的一个新方案 SimplePIR 比两台服务器 PIR 更快，没有两台服务器 PIR 的不良信任假设。 两个令人兴奋的方向仍然开放：一个是减少我们计划的沟通； 另一个是探索将我们的想法与亚线性时间 PIR [29, 30] 的想法相结合，以降低超出线性服务器时间障碍的计算成本。


致谢。我们感谢 Martin Albrecht 回答有关 LWE 硬度估计的问题，感谢 Vadim Lyubashevsky 就离散高斯采样提供建议，感谢 Adam Belay 和 Jinyuan Ruan 讨论 AVX 性能。我们感谢 Anish Athalye 和 Derek Leung 审阅了这项工作的草稿，并感谢 Dima Kogan、David Wu、Jean-Philippe Bossuat 和 Samir Menon 的有益对话和反馈。我们感谢 Sebastian Angel 对本工作早期版本中恶意安全性的讨论提出建设性意见，并就如何改进演示文稿提出建议。这项工作得到了美国国家科学基金会（CNS2054869 奖）、谷歌的礼物、Facebook 研究奖和麻省理工学院的 Fintech@CSAIL 倡议的部分支持。 Alexandra Henzinger 得到了美国国家科学基金会研究生研究奖学金的支持，资助号为 2141064 和 EECS 伟大的教育者奖学金。 Matthew M. Hong 由 NIH R01 HG010959 资助。 Vinod Vaikuntanathan 得到了 DARPA 根据协议号 HR00112020023、NSF CNS2154149、MIT-IBM Watson AI、Analog Devices、Microsoft 值得信赖的 AI 资助和 Thornton 家庭教师研究创新奖学金的支持。本材料中表达的任何意见、调查结果和结论或建议均为作者的观点，不一定反映美国政府或 DARPA 的观点。

























