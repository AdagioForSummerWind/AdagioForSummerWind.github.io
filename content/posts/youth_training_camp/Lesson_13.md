---
title: "Lesson_13"
date: 2022-06-02T10:59:33+08:00
lastmod:
tags: []
categories: []
slug:
draft: true
---
- [「HTTP框架修炼之道」第三届字节跳动青训营 - 后端专场](#http框架修炼之道第三届字节跳动青训营---后端专场)
- [HTTP框架修炼之道](#http框架修炼之道)
- [目录](#目录)
- [01 再谈HTTP协议](#01-再谈http协议)
- [1.1 HTTP协议是什么](#11-http协议是什么)
- [1.1 为什么需要协议](#11-为什么需要协议)
- [1.2 协议里有什么](#12-协议里有什么)
- [1.2 一个Demo](#12-一个demo)
- [1.3 请求流程](#13-请求流程)
- [1.4 不足与展望](#14-不足与展望)
- [02 HTTP框架的设计与实现](#02-http框架的设计与实现)
- [2.1分层设计](#21分层设计)
- [2.2 应用层设计](#22-应用层设计)
- [2.3 中间件设计](#23-中间件设计)
- [2.4 路由设计](#24-路由设计)
- [2.4 如何做设计](#24-如何做设计)
- [2.5 协议层设计](#25-协议层设计)
- [2.6 网络层设计](#26-网络层设计)
- [2.7 总结](#27-总结)
- [03 性能修炼之道](#03-性能修炼之道)
- [3.1 针对网络库的优化](#31-针对网络库的优化)
- [3.1不同网络库优势](#31不同网络库优势)
- [3.2 针对协议的优化-Headers解析](#32-针对协议的优化-headers解析)
- [3.3针对协议的优化-- Headers 解析](#33针对协议的优化---headers-解析)
- [3.4热点资源池化](#34热点资源池化)
- [04 企业实践](#04-企业实践)

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220528145846.jpg)

## 「HTTP框架修炼之道」第三届字节跳动青训营 - 后端专场

这是我参与「第三届青训营 -后端场」笔记创作活动的的第13篇笔记。同时这也是课表的第13天课程

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220528150043.png)



## HTTP框架修炼之道
讲师：尹旭然

**课程背景**

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220528150320.png)



1. 提到HTTP协议，大家都非常熟悉了。HTTP 协议是当今使用最为广泛的协议之一，HTTP是前(客户)端与服务端通信的基础协议，大家在学校课程中和大作业中应该或多或少都接触过。像这一张图就是一 个前后端分离的一一个流程图了，前后端之间通过HTTP请求进行通信。
2. 那HTTP框架负责的就是对HTTP请求的解析、根据对应的路由选择对应的后端逻辑了，也就是图上标出来的这些。除了在学校中的使用，HTTP 在企业实际业务场景中也使用广泛，目前字节跳动内部的HTTP服务达上万个。
3. 然而很多学校会简单讲一下 http协议是什么，并不会很深入的讲解，同学们考试稍微看一看就可以过了。 在大作业中也只是用到HTTP框架，保证本地可以演示出正确的case就OK了，对于HTTP框架的内部完全不了解，那这样在真是的工作场景万万不足够的。那这节课我希望能够带大家了解一下HTTP框架的设计与实现，知道HTTP框架为什么要这么做，之后呢能够更好的使用HTTP框架开发项目，甚至说对大家的其他项目也希望有所帮助。

## 目录

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220528151335.png)

## 01 再谈HTTP协议

1. HTTP协议是什么
2. 协议里有什么
3. 请求流程
4. 不足与展望

说到http协议的话，我们第一个大规模使用的 http协议版本，它其实是0.9，是从1991年开始的大规模使用。现在到今年的话已经30多年过去了。那这么这样一款30岁的一个协议，它依然能够这么生机盎然，持续地去迭代，甚至还有一些更新的版本。



## 1.1 HTTP协议是什么
HTTP：超文本传输协议(Hypertext Transfer Protocol)

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220528151620.png)

HTTP协议的话，那顾名思义，它就是hypertext transfer protocol，翻译过来就是超文本传输协议.

我们两台PC之间，想去互相去分享点什么东西。我们就把两台PC通过网线连起来，通过在网线上传输01把我们这个text进行一个交流和分享

然而有了网络之后，其实大家就发现text已经没有办法满足我们大家对于这个传输的一个需求了。逐渐地我们有了一些图片以及音乐以及视频， 甚至于还有一些超链接的这种需求。 

那这些资源其实他们就是针对我们text这种文本的类型资源的一个扩充，所以叫做hypertext然后传输这类资源的这种协议，我们就叫做hypertext transfer protocol。那非常简单，能很好理解这个协议的一个本质，它就是想传输这类超文本。那现在知道协议是什么了之后，我们可以来思考一下为啥需要协议。

## 1.1 为什么需要协议

比如我们说话，我们需要按照一定的语法， 按照定的主谓宾去造句 ，那这样的话对方才能够理解我们说的是啥，才能够表达清楚我们的意思，那协议其实也是这样。在网线上传输的都是一些01数据流，需要一定的规则才能让对方理解。那首先，我们需要协议给我们明确一一个信息的边界，我们需要明确的知道信息从什么时候开始以及到什么时候结束，我们不能一直接收对吧? 那这就是我们协议的第一个要素， 我们需要明确的边界。有了明确的边界之后，其实非常容易想到，我们需要用元数据进行消息的描述。我们描述这个消息它是什么类型的，包括我们刚刚看到的以图片对吧，音频视频以及超链接等等，就可以把它塞到这样的一个消息对应的地方，我们就进行一一个传输了， 这就是我们为什么需要协议。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220528152322.png)

>一个常见的POST 请求在协议层究竟做了什么?

## 1.2 协议里有什么

| ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529113217.png) | ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529113224.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

首先是一个请求行， 状态行，就是我们对应的first line然后之后就是一些元数据请求头响应头。 最后就是一个再再往后的话就是一个请求体响应体。 那针针对我们的请求行。其实刚刚我们也看到了，它是由方法名、URL 和协议版本组成，那方法名其实就比较多了，我们常见的方法名就get get就是我们http 0.9里面唯一的一个方法。然后之后我们在1.0里面扩充了header和post

然后1.1 里面又陆陆续续扩充了5个，然后从put开始到trace然后最终到一个patch。patch的话其实它是在1.1之后额外新增的一个方法名。 但是它因为使用得比较广泛，我们把它列在了这里patch的话其实它的语义跟我们的put其实是非常类似的。

patch和put有什么具体的区别吗?patch 的话就是我们的部分更新以及我们的put它的语义是完整地更新**(PUT是最等的，而PATCH不是幕等的)**。

然后接下来是我们的请求头响应头其实也是一个非常清晰的一个划分。 我们主要是分为协议约定的相关的。比如说我们刚刚看到的content就是我们指定我们的body有多少字节，然后以及业务相关的，那就是我们自己定义的需要传输传递的一些源数据了。

## 1.2 一个Demo

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529113910.png)

那我们把刚刚的那个demo用一个例子展示出来，大概是这样的一个场景。我们在地址栏输入小姐姐的URI和请求路径，选择好请求方法。 

之后呢将我们想说的话，也就是let's watch a movie together,填到body当中点发送就可以了。然后最后我们收到了一个小姐姐的response就是OK那一个简单的这样的一个回复。 那实现个这样的功能需要几行代码呢，我们一起来看一下。

```go
package main

import (
	"code.byted.org/middleware/hertz/pkg/app
	"code.byted.org/middleware/hertz/pkg/app/server
	"context"
)

func main() {
	h := server.New()
	h.POST("/sis",func(c context.Context, ctx *app.RequestContext) {
		ctx. Data(200,"text/plain; charset=utf-8", []byte( "OK" ))
	})
	h.Spin()
}
```
实现这样的一个功能仅仅需要5行代码， 核心呢就是三行。我们将对应的路由注册到server上， 选择对应的方法。接下来实现我们的业务逻辑，回复一个 OK。那这短短5行代码实现这样的一个功能， 其背后肯定隐含了大量的处理，那下面我就来说一下这背后经过了哪些的处理流程。

## 1.3 请求流程

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529114430.png)

那我们在讲完了协议里有什么之后，我们再来看一下那一次完整的请求发生了什么呢?

1. 首先在业务层，我们业务方的使用框架提供的API完成业务逻辑，也就是刚刚的那个小哥哥他想和小姐姐去看电影，那这个就是它的一个业务逻辑。那它的这个逻业务逻辑想要传递给小姐姐，其实还是有很多工作要去做的。

2. 完成了我们的业务逻辑之后，会进入到一些服务服务治理的逻辑。也就是大家经常说的比如熔断、限流等等。服务治理层，是依托于中间件层的。它对每个请求可以有一些先处理逻辑和后处理逻辑，是和请求级别绑定的。比如说我要打一个计时，在进入业务层之前，我记录一下当前的时间， 在业务层执行完毕之后，我们再记录一下业务执行完毕的时间， 那这样的话就可以记录整个的业务逻辑的耗时。
3. 对于client来说，之后就可以进入一个协议的编解码。协议的编解码层就是刚刚上文里说的协议里有什么编译成一个小姐姐能够看懂的一个协议，最后是通过传输层传输给小姐姐。之前王庆老师在《计算机网络基本概念与实际应用》讲了HTTP和TCP的关系，比如HTTP是第七层，TCP 是第四层，这里就不再重复说了。那小姐姐这边，她其实处理逻辑也大概如此，但是会多一个路由层， 它是根据 URI选择对应的执行的handler,比如说我这个好像比如说我这个地方有很多个小姐姐，那我要根据小姐姐的名字去选择我想要约的哪一个?

## 1.4 不足与展望

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529114923.png)

首先对于http1来说，因为它是基于TCP的，基于TCP的都会有一个这头阻塞的问题，后续的分片必须要等待前面的分片的到来才能继续发送后面的数据，否则的话会一直等待。 第二个是他的传输效率很低，就像刚刚我只想传输Let's watch a movie together但是这里面的无用的信息其实非常的多，存在很多重复的头部什么的。除此之外，http1也不支持多路复用，这个请求没结束之前是不能再发送其他请求的。

最后是他的明文传输不安全，也能看到刚刚我和小姐姐的沟通完全就是明文沟通，想隐藏也不行。HTTP2 呢解决了一部分， 但没有完全解决。比如说可以多路复用... 二进制协议解析起来更加高效。但是由于HTTP2 还是基于tcp的并没有解决对头阻塞的问题，而且握手的开销也没有优化。于是出现了QUIC在UDP就基础上解决得上刚刚才说的两个问题。

## 02 HTTP框架的设计与实现

## 2.1分层设计

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529120437.png)

王庆老师的那门课主要聚焦于OSI的第四层，而HTTP框架聚焦于第四层之上。分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。 想象一下，我写一个程序还要关心物理设备是否正常，关注网络是否堵塞，TCP是在否超时重传， 那这是一件多么痛苦的事情。而有了分层的设计，大家只需要使用下一层提供给上层的接口，专注特定层的开发就可以了，至于这个接口底层是如何实现的我是不用关心的。

分层架构可以让我们更容易做横向扩展。如果系统没有分层，那相关的扩展就会变得不太容易，比如某些Go的HTTP框架，到现在也没有支持h2,那肯定不是它不想支持。最后，分层之后可以做到很高的复用。比如，我们在设计模块A的时候，发现这一模块具有定的通用性，那么我们可以把它抽取独立出来，在设计系统B的时候使用起来，减少工作量。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529121113.png)

HTTP 框架的设计采用分层设计。在进行分层设计时，我们需要考虑一些点， 比如高内聚低耦合，复用性、扩展性等等。这个是我们进行的一个分层实践。这个架构的话其实从整体上来看的话，我们从上往下总共分为了五层，层与层之前使用接口解耦。

那我们从上开始的话就是我们的**应用层**，这一层的话其实就是跟用户直接打交道的一层，这一层会对请求进行一个抽象，包括像request response context等等。这一层也会提供一些丰富的易用的API。

然后下一层就是**中间件层**，可以对请求有一些预处理和后处理的逻辑， 像我们可以打一些access log,打一些耗时的点。其他中间件比如Reacovery 中间件用于捕获Panic。

之后是我们的**路由层**，路由层的话就是我们会有一个原生的路由实现来提供大家类似于跟注册、路由寻址的一些操作。这一块的话在我们下一部分会具体进行详细地展开。

然后再往下的话就是**协议层**。我们知道现在http1.1已经不能够满足我们所有的需求了，我们需要支持H2、Quic等等， 甚至是

在TLS握手之后的ALPN协商升级操作，那这些都需要能够很方便的支持。

最后一层的话就是我们的**网络层**， 不同的网络库使用的场景并不相同。那我们也需要一个灵活替换网络库的能力。 Common 层主要放一些公共逻辑，这一部分可能每一层都会使用。 那讲完了这些，这张图大家觉得是不是跟刚才“一次请求的完整流程 那张图很像，这里我再放一下。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529121555.png)

> 一个切实可行的复杂系统势必是从一个切实可行的简单系统发展而来的。从头开始设计的复杂系统根本不切实可行，无法修修补补让它切实可行。你必须由一个切实可行的简单系统重新开始。—- 盖尔定律

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529121816.png)

##  2.2 应用层设计

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529122033.png)

易用性首先是体现在我们要提供一些合理的 api。这里大概列了一些在设计 api时需要考虑的点。

- 可理解性：使用主流的概念，如ctx.Body(), ctx.GetBody()，不要用ctx.BodyA()
- 简单性：常用的API放到上层，误用/低频API放到下层，如ctx.Request.Header.Peek(key/ctx.GetHeader(key)
- 可见性：最小暴露原则，不需要暴露的API不暴露，可以抽象为接口。
- 冗余性：不需要冗余或能通过其他API组合得到的API。
- 兼容性：尽量避免break change,做好版本管理。

## 2.3 中间件设计

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529122255.png)

中间件需求：

- 配合Handler 实现一个完整的请求处理生命周期
- 拥有预处理逻辑与后处理逻辑
- 可以注册多中间件
- 对上层模块用户逻辑模块易用



![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529122531.png)

洋葱模型。 这个模型就是一个洋葱模型的一个示意图了，有请求过来。

首先我们先一层首先经过一个日志的日志中间件的预处理之后经过metrics中间件的预处理，在处理完了之后我们再进行执行一个真正的业务逻辑。那最后我们再退出业务逻辑之后，我们会有一个后处理。首先经过一个metric中间件的后处理，最后是经过一个日志中间件的后处理。 然后再将真正的响应再将一个完整的响应返回给用户。 那这个逻这这个的中间件的核心它是能够将核心逻辑与通用逻辑分离。那它的适用的场景包括说像**日志记录、性能统计、安全控制、事务处理、像异和异常处理**等等。可能还是有点抽象，那我们来举个具体点例子，比如说我们想打印出来每个请求的request和response那平时如果没有中间件，我们需要怎么办呢?

举个粒子：打印每个请求的request 和response

| ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529123414.png) | ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529123420.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

在每一个业务逻辑的代码当中去加上头和尾加上两句话去打印出来我们的一个request和response那我们有了中间件之后，我们只要在统一在上面的一个我们只需要给全局的路由注册一个中间件， 让这个中间件去执行一个打印的一个操作就可以了。 那可以看到这还只是一个中间件的一个是添加。 如果我们有多个中间件，那我们添加其他企业号就是费心费力，而且还容易添加出错。好，那我们刚刚看到了我们的中间件的一个需要时间的需求和一个大概的长什么样子之后，我们可以看一下说我们的中间件设计是怎么样的一个设计的流程。

1. 既然要实现预处理和后处理，那这个就很像调用了一个函数

   ```go
   func Middleware(some param) {
   	// some logic for pre-handle
   	...
       Next( )
   	nextMiddleware() / bizLogic()
   	// some logic after-handle
   	...
   }
   ```
2. 路由上可以注册多Middleware,同时也可以满足请求级别有效，只需要将Middleware设计为和业务和Handler相同即可。

3. 用户如果不主动调用下一个处理函数怎么办?

   ```go
   func Middleware(some param) {
   	// some logic
   }
   ```
   ```go
   func (ctx *RequestContext) Next() {
   	ctx.index++
   	for ctx.index < int8(len( ctx.handlers)) {
   		ctx.handlers [ctx.index]()
   		ctx.index++
   	}
   }
   ```
   核心：在任何场景下index保证递增

   

4. 出现异常想停止怎么办?

   ```go
   func (ctx *RequestContext) Abort() {
   	ctx.index = IndexMax
   }
   ```
如果用户只有预处理逻辑，没有后处理逻辑怎么办呢?比如只想完成一些初始化。考虑到用户真正希望执行的是业务逻辑，那我们可以主动帮用户调用一下之后的中间件。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529124849.png)

最后讲一下调用Next和不调用Next的适用场景。我们看一下这张图，这是次注册了ABC三个中间件和最后一个业务handler周用链图，其中B中间件中不调用next对，中间件C调用next。 那我们的调用顺序就是首先中间件A去调用中间件B,返回了之后中间件A去调用中间件C，然后中间件C去调用业务Handler,最后返回，也就是按照图上的标号调用。那我们可以想下， 这会不会有什么坑呢?

既然要实现预处理和后处理，那这个就很像调用了一 个函数。 路由上可以注册多Handler,同时也可以满足请求级别有效，只需要将Middleware设计为和业务和Handler相同即可。那这样是不是第5行的代码不就不用区分是中间件还是业务逻辑了，统一为直接调用下一一个处理函数。

## 2.4 路由设计

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529142622.png)

框架路由实际上就是为URL匹配对应的处理函数(Handlers)

- 静态路由： /a/b/c、/a/b/d
- 参数路由：/a/:id/c (/a/b/c, /a/d/c)、 /*all
- 路由修复： /a/b <-> /a/b/
- 冲突路由以及优先级： /a/b、 /:id/c
- 匹配HTTP方法
- 多处理函数：方便添加中间件

比如自定义路由：自定义路由: ANY + /*all,正则路由: NoRouteD在对上层易用方面，多处理函数。大家应该都学过数据结构，如果要是没有参数路由和路由修复，那直接一个 map处理就行。青铜段位: map。 白银段位:

**举个粒子：路由页面**

| ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529151652.png) | ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529151618.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

关于路由，可以给大家举一个直观一点的例子，比如我们在浏览器里输入不同的URI，那会弹出不同的页面，那这个就是路由。



| ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529151930.png) | ![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529151921.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

**如何匹配HTTP方法?**

![路由映射表](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529152020.png)外层Map：

根据method进行初步筛选

**如何实现添加多处理函数?**

在每个节点上使用一个list 存储handler

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529152204.png)

**思考：如何查找路由**

刚刚我们讲了路由树的构建规则，那同学们可以思考一下， 应该如何查找路由呢。查找路由的时候需要考虑到优先级匹配的问题，回溯的问题，因为静态路径已经走到一个子树，那怎么回溯到另一颗子树。再比如路由修正，/a/b-> /a/b/

## 2.4 如何做设计

1. 明确需求：考虑清楚要解决什么问题、有哪些需求
2. 业界调研：业界都有哪些解决方案可供参考
3. 方案权衡：思考不同方案的取舍
4. 方案评审：相关同学对不同方案做评审
5. 确定开发：确定最合适的方案进行开发

## 2.5 协议层设计

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529152417.png)

抽象出合适的接口：

```go
type Server interface {
	Serve(c context.Context,conn network.Conn) error
}
```
1. Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it . The Context should be the first par ameter.

2. 需要在连接上读写数据

第一个是对协议的扩展，对h1 h2 QUIC等等。首先他其实要实现一个server的一个接口。他这个server的接口他要传入一个标准的context 这也是和Golang的设计思想相吻合的。第二个，再一个是肯定要把连接传进来，因为我们要往连接上读

其他的应该是不再需要了。数据、 写数据对吧? 那其他的还有没有呢?那我们的返回值是一个 error,那也说只要是任何的一个协议，只要实现了这样的一个serve的接口，就可以注册到我们的框架当中来。https://pkg.go.dev/context

## 2.6 网络层设计

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529153636.png)

那有了epoll之后，C10K的问题就可以解决了吗?

我们在这里设想一个场景， 就比如说你打客服电话，然后比如说，我去打一个客服电话，客服跟我说问我身份证号是多少，那这时候我忘了身份证号多少，我就必须说你等一下， 我去找一下这个身份证，但我又没找着，那这个客服是不是占线，那占线的话他就什么都做不了，然后并在这里占住了，他等不下去了，就等到了超时。那这种编程模型在互联网界就叫block io,简称bio。

我们可以看下面这段代码，这段代码是go一个经典的connection处理，我们在一个go function里面维护一个listener那它listener每次accept获取一个连接之后，我们会开一个goroutine去单独处理它。这goroutine行为应该是先去读取数据，读取完之后然后处理业务逻辑，然后再把这个response写回去。这是一个比较经典的 go的写法，那它就是一种block io编程模型。因为假如说你在读数据的时候读到了一半，它就读在这里了，它啥也干不了。

那有没有解决这种办法的？方式也比较简单，我们在中间引入一种通知的机制，就是当他数据有一半的时候，我让客服小姐姐也去干别的事情。那当它后续把整个包都已经发完的时候，我们再去通知他去处理，这样的话就不会阻塞。是在互联网界就是non block IO的一种编程模式，它就是**非阻塞**的。我们可以看一下刚才那段伪代码改成这段伪代码之后是什么样子，就是上面我们在第一个go function里面还是维护这个连接，accept 但是每次我们拿到这个连接之后，我们把它加到一个监听器里面，比如说add这个链接，然后我们在另外一个部分里面去轮询这个monitor就是监听器，我们搜索可读的连接数。

因为这里monitor它已经知道有数据了，但我们这 个服务方式去执行的时候可能是read这时候就能拿到完整的数据并处理，然后再返回，这个时候整个流程是没有阻塞的。

**BI0**

```go
go func(){
	for {
		conn,_ := listener.Accept( )
		go func()
			conn.Read(request)
			handle...
			conn.Write(response)
		}()
	}
}()
```
**NIO**

```go
go func(){
	for {
		readableConns,... := Monitor(conns)
		for conn := range readableConns {
			go func() {
				conn.Read(request)
				handle...
				conn.Write(response)
			}( )
		}
	}
}()
```
---

go net “BIO” 用户管理buffer

```go
type Conn interface {
	Read(b [ ]byte) (n int, err error)
	Write(b [ ]byte) (n int,err error )
	...
}
```
在用户态来看。那go net呢是由用户管理的buffer,这两个接口都是传入buffer,进行读或者写，那它本身是不管理buffer的。

**netpoll是公司内部自研的网络库，目前已经开源**

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529161237.png)

**刚刚也提到了很多“抽象” 抽象是有开销的**

```go
type Conn interface {
	net.Conn
	Reader
	Writer
}
```
## 2.7 总结

API设计：可理解性、简单性.
中间件设计：洋葱模型
路由设计：前缀匹配树
协议层设计：抽象出合适的接口
网络层设计：网络模型

既然要实现预处理和后处理，那这个就很像调用了一个函数。 路由上可以注册多Handler,同时也可以满足请求级别有效，只需要将Middleware设计为和业务和Handler相同即可。

## 03 性能修炼之道

- 针对网络库的优化

- 针对协议的优化

## 3.1 针对网络库的优化



![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529190610.png)

1. 首先我们希望能够存下全部的header那如果要是说我们因为http它的头部它是没有length是不知道长度的，所以我们需要存下全部的header才能够进行一个解析。 

2. 第二个是我们希望能够减少系统调用的次数，系统调用户涉及到内核态和用户态的切换，这部分的开销还是比较大的。

3. 第三是我们希望能够复用内存，能也是提高一下资源的使用率。最后是我们希望能够多次读，这部分主要体现在对header的处理，对于一一个超大的header我可能第一次读不完，但是我并不知道这个header是不是完整的，所以说我们在那只有解析的时候发现解析失败了，那我们才知道说当前这个header是不足够的，那下一次我们希望说还能够从头地进行一个解析。

下面我给大家举两个例子， 一种是我header有100字节，整个request有150字节，那我一次把所有的数据全读了出来，那针对这种场景，对于body的50个字节，希望不需要将它拷贝到另一个buffer中; 第二个场景是我header超大，比如说100字节，那我希望接下来到来的数据不会再分配一个新的，大的buffer,然后将之前读的数据拷贝进去。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529191952.png)

那基于此，我们可以对勾在勾标准库的接口上面封装一层 buffer说也就是用一块用一个常用的一种优化手段。 就是绑定在这个连接上面，绑定一块缓冲区。 那根据我们在内部的一个调研，也发现大部分的包都是在4k以下的，所以我们可以绑定一块大小为4k左右的一个缓冲区，这样对内存的压力也不是很大。那这个还那我们再设计接那我们这个再设计接口。那首先需要一个我在读的时候让读指针不动， 我下次还能够在这里进行读，也就是Peek;以及说我们既然就能够让读指针不动，那我们就需要一个接口，让读指针进行一个移动，也就是Discard。最后呢我们还需要回收这块内存，希望下一次请求能够复用之前的空间，也就是Release接口。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529192505.png)

复复一下之前讲到的libuffer通过查找尾部(” /n/，判断Header的完整性对于netpoll我们是希望能够存下全部的header

那第二个我们是希望能够拷贝出完整的 body那对于netpoll这种网络库管理底层，由于netpoll为了减少锁的竞争，采用了一个链表的设计方式， 实现一个无所化。 那这样一个链表带来的问题就是它可能会存在一个跨节点的问题。

那比如说那比如说像下面的这张图，我们的header可能分布在两个节点当中，我们的body也可能分配在两个节点当中。那这样的话如果我们要进行一个使用， 我们效我们就需要再分配一块足够大的buffer

然后将两部分的header拼到一起，返回给框架来进行一个解析。 那既然如此，我们为什么不将这个足够大的buffer直接分配到下层的底层的节点当中呢?也就是像下面这样一种情况， 那我们可以根据D此请求当中的最大值来分配一个足够大的buffer来保证说所有的header和body都分配到同一个节点上。

```go
type Conn interface {
	net.Conn
	Reader
	Writer
}
```
## 3.1不同网络库优势

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529192554.png)

用户管理buffer,超大包友好;小包场景(4k)以下不涉及到内存分配与回收，性能高，中大包场景(4k以上)减少系统调用次数;时延低

## 3.2 针对协议的优化-Headers解析
![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529192850.png)

刚刚讲到了针对协议的所做的网络库的优化，那我们现在视线从底层移动到上层。刚刚也说了，http协议呢，我们需要找到边界才能够判断它是完整的。那我们现在来复习一下上一节课的知识，我们需要找到的一个边界就是\r\n,每个headerine的结束是v，如果连续两个\r\n \r\n的话就说明header读完了。那咱们的字符串匹配算法呢其实有很多种，像在学校里大家都学过kmp啊，bm啊。 这些算法可不可以用呢?那当然是可以了。快不快呢?当然不是最快了。这些算法针对的是任何两个字符串，没有其他条件了，至少需要进行一次预处理。 那我们来看一下针对我们的http协议， 他每次只需要匹配两个字符，并且都是\n的前面都是\r，杀鸡焉用宰牛刀，针对这种有特征的数据，那我们是不是就可以先找到\n，再去判断\r就OK了，起来这样的复杂度其实是只要扫一遍就ok了。具体的代码我也在下面写了出来。咱们现在思考一个问题， 这个找到边界能不能更快呢?可能有一些同学说， 那我这个算法再快，也要是on的吧。这个算法的复杂度，我是

没有想出来一个更好的解决办法。不过咱们上过一门课，叫计算机体系结构。这门课里面讲了simd。大家在刚听到这[ ]课中讲SMD的时候，反应跟我当时是一样的，一脸懵逼， 完全不知道有什么用。在这里，SIMD就可以派上用场。那个呃没
有上过这门课的同学也没有关系。我简单讲一下这个东西。SIMD (Single Instruction Multiple Data)指令集，指单指令多数据流技术，可用一组指令对多组数据通进行并行操作。对于咱们的这个场景之前，咱们之前来说是一个一 个进行相比。

那咱们这次呢咱们可以多个相比，比如每次比16个。那自然效率就高了。那可能有一些同学说， 那我不会写汇编，那怎么办呢?或者说这个汇编的难度太高了，那怎么办呢?不要急，咱们go语言呢，他官方已经为我们支持了SIMD技术，我们只要调用bytes.Index0函数，在满足条件的情况下，会自动使用SIMD指令集进行加速。这里有一个使用SIMD加速的json解析库sonic,有兴趣的话也可以了解一下，编解码速度已经能够达到和pb是同一个数量级的了。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529193327.png)

## 3.3针对协议的优化-- Headers 解析

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529193646.png)

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529193659.png)

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529193716.png)

然后这个这一块的话同样它也是有取舍的。那取的话其实我们非常非常清晰地可以看到我们是利用了一个空间换时间的方式， 我们把对应需要转换的这些字符我们能把它存起来了。然后通过这个带来些高效的转换效率。 然后对于原生的我们那Golang net hdp内部的实现，其实说它是针对于这种需求的话，它首先去判断是否是一个字母， 然后针对字母的话，它再去做一个额外的字母的一个转换。就是针对他在asci码表里面定义的一个是差值去进行加或者减这样差，这样完成它整个的一个规范化。

那我们相比它们规原生库的实现的话，我们这种取巧的方式我们带来了近40倍的提升。那同样我们的舍的话，其实刚刚也可以看到我们有一 些额外的内存开销。

那其实我们目前的一些部署的一 些场景的话， 我们的内存资源其实相对来说比较充足。针对刚刚的开销已经算是可以忽略不计了，所以这个也是舍得非常小。然后第二点的话就是我们舍掉了 一个我们叫做变更，我们没法去快速地去变更，因为我们每次要变更这个列表还是一个硬编码的列表， 然后我们得需要去改我们的框架代码。

## 3.4热点资源池化

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529194122.png)



对于我们的这个这种场景的话，我们有一个叫做 context request context池，我们把这个request放到池子里了。然后我们请求来的时候，我们池子里取出来一个， 我们做一些初始化， 然后把它进行一个 response的一个返回，之后我们处理完又把它放回去。按这个看起来是一个比较有意思的 一个做法，就是我们这大家就共用一个池子里的资源，那这样的话就可以明显地减少我们整个GC或者是一个 runtime的一个压力。

![](https://nateshao-blog.oss-cn-shenzhen.aliyuncs.com/img/20220529194206.png)

那其实取的话就非常明显，可以看到我们有了一些内存分配的一 个次数减少了，然后我们的复用能力也提高了，机制压力相应的就降低了，那性能就得到了提升。那舍掉的话其实就是我们再额外放回这个request刚才是到池子里之前的话，我们需要做一些复杂的reset操作，因为这个这块内存直接会被下一个请求去复用。那我们不做这类似reset初始化操作的话，那可能会有一些额外存在的值会对下一一个请求造成一些影响。 第二点的话说我们超出了-一个请求生命周期的这个request context它就变得不再可靠。那我们既然都把它放回池子里，那里面的数据不保证在一些请求生命周期之外也是可靠 了。

那等这两个问题的话其实带来的就是我们在一旦出现这种类似于数据不一致的问题的时候，我们的定位难度也非常的大，这就是我们在这个设计里面舍掉了一个东西。那其实针对这个问题的话，其实我们内部已经在做一些更优化的一些设计，来避免这种数据不一致造成的一些问题。包括我们刚刚提到的在我们的应用层有一个专门]的context模块，这一块的话这块设计的话之后也会有我们的一个更新之后，我们会以一个新的feature提供给大家。

## 04 企业实践

那我们首先第一个大家可能非常容易地想到我们刚刚做了那么多都是为了什么，都是为了性能，为了能够支持更多的 feature。这个也是和我刚进字节跳动的时候，包括说很多刚进字节跳动的想法，包括说跟可能跟很多同学的想法都是一样的，性能就是王道，性能高就是牛逼。

一个框架好不好完全就等于一个框架的性能好不好。确实性能是属于一个非常非常重要的。我在刚来的时候也做了一些关于性能优化方面的一些实践，当然现在也在做嗷。但是我后面慢慢地发现，除了追求性能之外，还有其他很多的工作也是要做的这部分工作的，这部分的一些优先级甚至要远大于提高性能方面的优先级。我们就来说一下进来之后的第二个在做的东西，就是我们要对一个框架要追求易用，减少误用这几个字。

就是我们在设计框架的时候，如果追求性能，因为往往性能和易用性它两个是一个矛盾的东西。我不能说我小孩子全做选择题，我全都要什么，性能又高，可扩展性又强，还非常的好用。那这个框架设计出来。确实非常有难度的。那所以说我们在设计当中就会有面临着非常多的取舍，那我们舍掉了就可能是一些追求好用的一些东西。

比如说我在刚刚讲到对于 header 的优化的时候，那我们其实就舍掉了一个非常好用的 map 的这样的一个结构。那再比如说我们刚刚对于 request context 进行池化的时候，那我们就抛弃我们就舍弃了它不能够在请求生命周期之外的一个不能再请求生命周期之外使用的这样的一个功能。那这样的话我们减少了应用性之后，我们发现很多业务，很多在使用方，很多做业务的同学在使用的时候就不能够正确地使用框架。

先别说性能怎么样，你可能说他连写出来正确的代码都是一件非常困难的一个事情。而且说因为你的问题，很多时候它并不是说不能通过编译这种简单地说我修一下语法错误，而很多的错误它都是一些在高并发或者说或者是并发问题，或者说数据不一致问题。那这样问题又非常非常的难查。那导致说我可能线上造成了一些很造成了一些很大影响之后我才发现说这个地方原来是有 bug 的，但是这个 bug 我还不知道是为啥。那所以说那再进来的。所以说之后我们又做了很多对于易用性和减少误用这两方面的一个工作，这两个看起来是亮点，其实就是一点，核心是说让业务方能够快速的去写出来正确的代码。那在这个前提之下我们再去做一些性能的优化。那下一步，第三个是我们打通内部的生态，其实一个框架好不好用？除了说刚刚的一些API ，还有一些相关的一些使用之外，还有框架毕竟是它只做了一部分，但像但是它像它的生态其实有很多，比如说我们内部的生态，比如说像我们的 log trace metrics mesh 等等，这部分逻辑是每个微服务体系下都需要的逻辑，但是接入起来又很麻烦。

如果要是说每一个业务的同学都去做这样的一套生态的话，那这样对于每个业务的同学肯定也是开销非常大了。而且最关键的就是很多同学他可能不太了解你内部，他也不知道他去他也不太了解实现。那这样的话打通内部生态对他来说其实也是不是很容易的一件事情。那除了内部生态，其实还有一些像外部生态，对于 HTTP 来说，常见的像 CORS，就是跨域，还有说像 session 那像这些基础的功能，一个 HTTP 框架也应该是有的。但是由于我们采用了为了追求性能的一些优化，那我们其实那我们就改变了它之前的我们就没有采用原生库的这样的一个数据结构，导致说现在开源社区的一些生态是不能够直接地使用的。那这样的话如果用户想要使用这些能力的话，那他就需要去自己实现这样一套能力。那对他来说肯定也是不太能够上手用的一些简单的中间件。还好比如说让大家写一个什么加密算法，针对你的数据结构写一个加密算法，那这个的开销可就太大了。所以说我们也在一段时间也在努力地打通内外部的种种生态。

那第四点就是关于文档建设和用户群建设，这部分主要还是为了说想尽量地减少一些双方的成本，我也不想让很多的业务同学都问一些很多重复的问题。我们可以让另外首先对于这些问题，如果每个人问如果每个人问一个，那 100 个人就问我 100 个，每天回复 100 个问题。那我也不是客服对吧，我还是有一些自己手上的开发的工作要做。那第二点就是我可能在某些时候也不会及时地回复消息，比如说我可能去开一些会或者什么的。那这个时候如果要是说没有一些良好的辅助的措施的话，让所有的用户阻塞在你这里肯定是不太好的。所以我们也在逐步地加强文档的建设，把常见的问题甚至说很多基础的用法都沟都进行了，一些文档都写到了文档当中。

甚至说我们在追求我的一个目标，就是把每一个成让每一个服务端开发工程师变成一个 CV 工程师，就是 ctrl C ctrl V 的工程师直接的代码从你的文档当中复制粘贴出来，代码就可以用的这样的一些工作。再有就是用户群的建设可能有一些同学，他的可能有一些用户他的那个找文档可能不太理解，或者说文档可能有一些没有覆盖到的点。

那用户群就是一个很好的反馈，很及时地反馈，说能够找到哪些点是他现在所欠缺的或者说不太清楚的。那这个时候他们这个时候我们在用户群里进行一个回复之后，一个是因为用户群有很多人，那其他的人也可以看到，也可以知道说我有没有这个问题，以及说我们后院加群的人，或者说之后我可以通过一个搜索聊天记录去搜索到一个对应的解决方案。这个是我们进来之后当然做了一些除了追求性能之外的很多的一些努力。

----

- 字节内部HTTP框架：Hertz
- 1万+服务3千万+QPS

那现在我们内部的 H 内部的 HTTP 框架叫做。那我我在做的内部的 HTTP 框架，它就叫做Hertz。目前它已经有上线，它已经有 1 万余个服务在使用，然后每天的峰值 QPS 是达到了 3000 余万。那这样的一个 HTTP 框架马上也要做开源，大概是在今年的 6 月份，所以大家也可以小小地期待一下。






